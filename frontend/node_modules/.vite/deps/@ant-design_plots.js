import {
  require_client
} from "./chunk-XGLDDBPM.js";
import {
  _asyncToGenerator,
  _callSuper,
  _classCallCheck,
  _createClass,
  _createForOfIteratorHelper,
  _defineProperty,
  _getPrototypeOf,
  _inherits,
  _objectSpread2,
  _objectWithoutProperties,
  _regeneratorRuntime,
  _slicedToArray,
  _toConsumableArray
} from "./chunk-QWF5HQLM.js";
import {
  require_react_dom
} from "./chunk-PJEEZAML.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice3 = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i2 = 0, len5 = args.length; i2 < len5; i2++) {
        var arg = args[i2];
        if (isArrayish(arg)) {
          results = concat.call(results, slice3.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty2 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name2 in colorNames) {
      if (hasOwnProperty2.call(colorNames, name2)) {
        reverseNames[colorNames[name2]] = name2;
      }
    }
    var name2;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex3 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba3 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb3 = [0, 0, 0, 1];
      var match;
      var i2;
      var hexAlpha;
      if (match = string.match(hex3)) {
        hexAlpha = match[2];
        match = match[1];
        for (i2 = 0; i2 < 3; i2++) {
          var i22 = i2 * 2;
          rgb3[i2] = parseInt(match.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb3[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i2 = 0; i2 < 3; i2++) {
          rgb3[i2] = parseInt(match[i2] + match[i2], 16);
        }
        if (hexAlpha) {
          rgb3[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba3)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb3[i2] = parseInt(match[i2 + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb3[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb3[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb3[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb3[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb3[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty2.call(colorNames, match[1])) {
          return null;
        }
        rgb3 = colorNames[match[1]];
        rgb3[3] = 1;
        return rgb3;
      } else {
        return null;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb3[i2] = clamp3(rgb3[i2], 0, 255);
      }
      rgb3[3] = clamp3(rgb3[3], 0, 1);
      return rgb3;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl4 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl4);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s4 = clamp3(parseFloat(match[2]), 0, 100);
        var l2 = clamp3(parseFloat(match[3]), 0, 100);
        var a5 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s4, l2, a5];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w2 = clamp3(parseFloat(match[2]), 0, 100);
        var b = clamp3(parseFloat(match[3]), 0, 100);
        var a5 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w2, b, a5];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba3 = swizzle(arguments);
      return "#" + hexDouble(rgba3[0]) + hexDouble(rgba3[1]) + hexDouble(rgba3[2]) + (rgba3[3] < 1 ? hexDouble(Math.round(rgba3[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba3 = swizzle(arguments);
      return rgba3.length < 4 || rgba3[3] === 1 ? "rgb(" + Math.round(rgba3[0]) + ", " + Math.round(rgba3[1]) + ", " + Math.round(rgba3[2]) + ")" : "rgba(" + Math.round(rgba3[0]) + ", " + Math.round(rgba3[1]) + ", " + Math.round(rgba3[2]) + ", " + rgba3[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba3 = swizzle(arguments);
      var r2 = Math.round(rgba3[0] / 255 * 100);
      var g = Math.round(rgba3[1] / 255 * 100);
      var b = Math.round(rgba3[2] / 255 * 100);
      return rgba3.length < 4 || rgba3[3] === 1 ? "rgb(" + r2 + "%, " + g + "%, " + b + "%)" : "rgba(" + r2 + "%, " + g + "%, " + b + "%, " + rgba3[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla3 = swizzle(arguments);
      return hsla3.length < 4 || hsla3[3] === 1 ? "hsl(" + hsla3[0] + ", " + hsla3[1] + "%, " + hsla3[2] + "%)" : "hsla(" + hsla3[0] + ", " + hsla3[1] + "%, " + hsla3[2] + "%, " + hsla3[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a5 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a5 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a5 + ")";
    };
    cs.to.keyword = function(rgb3) {
      return reverseNames[rgb3.slice(0, 3)];
    };
    function clamp3(num, min10, max11) {
      return Math.min(Math.max(min10, num), max11);
    }
    function hexDouble(num) {
      var str7 = Math.round(num).toString(16).toUpperCase();
      return str7.length < 2 ? "0" + str7 : str7;
    }
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a22, a32, a42, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len5 = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len5) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42, a5), true;
        }
        for (i2 = 1, args = new Array(len5 - 1); i2 < len5; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length5 = listeners.length, j;
        for (i2 = 0; i2 < length5; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len5) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a22);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a22, a32);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len5 - 1); j < len5; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length5 = listeners.length; i2 < length5; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/svg-path-parser/parser.js
var require_parser = __commonJS({
  "node_modules/svg-path-parser/parser.js"(exports, module) {
    "use strict";
    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        "class": function(expectation) {
          var escapedParts = "", i2;
          for (i2 = 0; i2 < expectation.parts.length; i2++) {
            escapedParts += expectation.parts[i2] instanceof Array ? classEscape(expectation.parts[i2][0]) + "-" + classEscape(expectation.parts[i2][1]) : classEscape(expectation.parts[i2]);
          }
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function(expectation) {
          return "any character";
        },
        end: function(expectation) {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex3(ch2) {
        return ch2.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s4) {
        return s4.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch2) {
          return "\\x0" + hex3(ch2);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch2) {
          return "\\x" + hex3(ch2);
        });
      }
      function classEscape(s4) {
        return s4.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch2) {
          return "\\x0" + hex3(ch2);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch2) {
          return "\\x" + hex3(ch2);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = new Array(expected2.length), i2, j;
        for (i2 = 0; i2 < expected2.length; i2++) {
          descriptions[i2] = describeExpectation(expected2[i2]);
        }
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i2 = 1, j = 1; i2 < descriptions.length; i2++) {
            if (descriptions[i2 - 1] !== descriptions[i2]) {
              descriptions[j] = descriptions[i2];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {}, peg$startRuleFunctions = { svg_path: peg$parsesvg_path }, peg$startRuleFunction = peg$parsesvg_path, peg$c0 = function(data2) {
        if (!data2) return [];
        for (var cmds2 = [], i2 = 0; i2 < data2.length; i2++) cmds2 = cmds2.concat.apply(cmds2, data2[i2]);
        var first3 = cmds2[0];
        if (first3 && first3.code == "m") {
          delete first3.relative;
          first3.code = "M";
        }
        return cmds2;
      }, peg$c1 = function(first3, more) {
        return merge2(first3, more);
      }, peg$c2 = /^[Mm]/, peg$c3 = peg$classExpectation(["M", "m"], false, false), peg$c4 = function(c6, first3, more) {
        var move = commands(c6, [first3]);
        if (more) move = move.concat(commands(c6 == "M" ? "L" : "l", more[1]));
        return move;
      }, peg$c5 = /^[Zz]/, peg$c6 = peg$classExpectation(["Z", "z"], false, false), peg$c7 = function() {
        return commands("Z");
      }, peg$c8 = /^[Ll]/, peg$c9 = peg$classExpectation(["L", "l"], false, false), peg$c10 = function(c6, args) {
        return commands(c6, args);
      }, peg$c11 = /^[Hh]/, peg$c12 = peg$classExpectation(["H", "h"], false, false), peg$c13 = function(c6, args) {
        return commands(c6, args.map(function(x3) {
          return { x: x3 };
        }));
      }, peg$c14 = /^[Vv]/, peg$c15 = peg$classExpectation(["V", "v"], false, false), peg$c16 = function(c6, args) {
        return commands(c6, args.map(function(y4) {
          return { y: y4 };
        }));
      }, peg$c17 = /^[Cc]/, peg$c18 = peg$classExpectation(["C", "c"], false, false), peg$c19 = function(a5, b, c6) {
        return { x1: a5.x, y1: a5.y, x2: b.x, y2: b.y, x: c6.x, y: c6.y };
      }, peg$c20 = /^[Ss]/, peg$c21 = peg$classExpectation(["S", "s"], false, false), peg$c22 = function(b, c6) {
        return { x2: b.x, y2: b.y, x: c6.x, y: c6.y };
      }, peg$c23 = /^[Qq]/, peg$c24 = peg$classExpectation(["Q", "q"], false, false), peg$c25 = function(a5, b) {
        return { x1: a5.x, y1: a5.y, x: b.x, y: b.y };
      }, peg$c26 = /^[Tt]/, peg$c27 = peg$classExpectation(["T", "t"], false, false), peg$c28 = /^[Aa]/, peg$c29 = peg$classExpectation(["A", "a"], false, false), peg$c30 = function(rx, ry, xrot, large, sweep, xy) {
        return { rx, ry, xAxisRotation: xrot, largeArc: large, sweep, x: xy.x, y: xy.y };
      }, peg$c31 = function(x3, y4) {
        return { x: x3, y: y4 };
      }, peg$c32 = function(n2) {
        return n2 * 1;
      }, peg$c33 = function(parts) {
        return parts.join("") * 1;
      }, peg$c34 = /^[01]/, peg$c35 = peg$classExpectation(["0", "1"], false, false), peg$c36 = function(bit) {
        return bit == "1";
      }, peg$c37 = function() {
        return "";
      }, peg$c38 = ",", peg$c39 = peg$literalExpectation(",", false), peg$c40 = function(parts) {
        return parts.join("");
      }, peg$c41 = ".", peg$c42 = peg$literalExpectation(".", false), peg$c43 = /^[eE]/, peg$c44 = peg$classExpectation(["e", "E"], false, false), peg$c45 = /^[+\-]/, peg$c46 = peg$classExpectation(["+", "-"], false, false), peg$c47 = /^[0-9]/, peg$c48 = peg$classExpectation([["0", "9"]], false, false), peg$c49 = function(digits) {
        return digits.join("");
      }, peg$c50 = /^[ \t\n\r]/, peg$c51 = peg$classExpectation([" ", "	", "\n", "\r"], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error3(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos], p3;
        if (details) {
          return details;
        } else {
          p3 = pos - 1;
          while (!peg$posDetailsCache[p3]) {
            p3--;
          }
          details = peg$posDetailsCache[p3];
          details = {
            line: details.line,
            column: details.column
          };
          while (p3 < pos) {
            if (input.charCodeAt(p3) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p3++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsesvg_path() {
        var s0, s1, s22, s32, s4;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewsp();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parsewsp();
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsemoveTo_drawTo_commandGroups();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parsewsp();
            }
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c0(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemoveTo_drawTo_commandGroups() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsemoveTo_drawTo_commandGroup();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsemoveTo_drawTo_commandGroup();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemoveTo_drawTo_commandGroup();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemoveTo_drawTo_commandGroup() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsemoveto();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = [];
          s5 = peg$parsewsp();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsewsp();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsedrawto_command();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = [];
            s5 = peg$parsewsp();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsewsp();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsedrawto_command();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedrawto_command() {
        var s0;
        s0 = peg$parseclosepath();
        if (s0 === peg$FAILED) {
          s0 = peg$parselineto();
          if (s0 === peg$FAILED) {
            s0 = peg$parsehorizontal_lineto();
            if (s0 === peg$FAILED) {
              s0 = peg$parsevertical_lineto();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecurveto();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsesmooth_curveto();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsequadratic_bezier_curveto();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsesmooth_quadratic_bezier_curveto();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseelliptical_arc();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsemoveto() {
        var s0, s1, s22, s32, s4, s5, s6;
        s0 = peg$currPos;
        if (peg$c2.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsecoordinate_pair();
            if (s32 !== peg$FAILED) {
              s4 = peg$currPos;
              s5 = peg$parsecomma_wsp();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parselineto_argument_sequence();
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c4(s1, s32, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclosepath() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c5.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c6);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c7();
        }
        s0 = s1;
        return s0;
      }
      function peg$parselineto() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (peg$c8.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parselineto_argument_sequence();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parselineto_argument_sequence() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecoordinate_pair();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecoordinate_pair();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehorizontal_lineto() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsecoordinate_sequence();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecoordinate_sequence() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsenumber();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenumber();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsevertical_lineto() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (peg$c14.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsecoordinate_sequence();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (peg$c17.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsecurveto_argument_sequence();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto_argument_sequence() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecurveto_argument();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecurveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecurveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecurveto_argument() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsecoordinate_pair();
            if (s32 !== peg$FAILED) {
              s4 = peg$parsecomma_wsp();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsecoordinate_pair();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c19(s1, s32, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (peg$c20.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsesmooth_curveto_argument_sequence();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto_argument_sequence() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsesmooth_curveto_argument();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsesmooth_curveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesmooth_curveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_curveto_argument() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsecoordinate_pair();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (peg$c23.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsequadratic_bezier_curveto_argument_sequence();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto_argument_sequence() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsequadratic_bezier_curveto_argument();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsequadratic_bezier_curveto_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsequadratic_bezier_curveto_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsequadratic_bezier_curveto_argument() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsecoordinate_pair();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c25(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_quadratic_bezier_curveto() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (peg$c26.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c27);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsecoordinate_pair();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecoordinate_pair();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecoordinate_pair();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        if (peg$c28.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parsewsp();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parsewsp();
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parseelliptical_arc_argument_sequence();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc_argument_sequence() {
        var s0, s1, s22, s32, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseelliptical_arc_argument();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$currPos;
          s4 = peg$parsecomma_wsp();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseelliptical_arc_argument();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$currPos;
            s4 = peg$parsecomma_wsp();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseelliptical_arc_argument();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s32 = s4;
              } else {
                peg$currPos = s32;
                s32 = peg$FAILED;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1, s22);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelliptical_arc_argument() {
        var s0, s1, s22, s32, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$parsenonnegative_number();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsenonnegative_number();
            if (s32 !== peg$FAILED) {
              s4 = peg$parsecomma_wsp();
              if (s4 === peg$FAILED) {
                s4 = null;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsecomma_wsp();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseflag();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsecomma_wsp();
                      if (s8 === peg$FAILED) {
                        s8 = null;
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseflag();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsecomma_wsp();
                          if (s10 === peg$FAILED) {
                            s10 = null;
                          }
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parsecoordinate_pair();
                            if (s11 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c30(s1, s32, s5, s7, s9, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecoordinate_pair() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma_wsp();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsenumber();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c31(s1, s32);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenonnegative_number() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsefloating_point_constant();
        if (s1 === peg$FAILED) {
          s1 = peg$parsedigit_sequence();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsenumber() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsesign();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$parsefloating_point_constant();
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parsesign();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parsedigit_sequence();
            if (s32 !== peg$FAILED) {
              s22 = [s22, s32];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseflag() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c34.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c36(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsecomma_wsp() {
        var s0, s1, s22, s32, s4;
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parsewsp();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsewsp();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parsecomma();
          if (s22 === peg$FAILED) {
            s22 = null;
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parsewsp();
            }
            if (s32 !== peg$FAILED) {
              s1 = [s1, s22, s32];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s22 = peg$parsecomma();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parsewsp();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parsewsp();
            }
            if (s32 !== peg$FAILED) {
              s22 = [s22, s32];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c37();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecomma() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 44) {
          s0 = peg$c38;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }
        return s0;
      }
      function peg$parsefloating_point_constant() {
        var s0, s1, s22, s32;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsefractional_constant();
        if (s22 !== peg$FAILED) {
          s32 = peg$parseexponent();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          if (s32 !== peg$FAILED) {
            s22 = [s22, s32];
            s1 = s22;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parsedigit_sequence();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseexponent();
            if (s32 !== peg$FAILED) {
              s22 = [s22, s32];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsefractional_constant() {
        var s0, s1, s22, s32, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parsedigit_sequence();
        if (s22 === peg$FAILED) {
          s22 = null;
        }
        if (s22 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s32 = peg$c41;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c42);
            }
          }
          if (s32 !== peg$FAILED) {
            s4 = peg$parsedigit_sequence();
            if (s4 !== peg$FAILED) {
              s22 = [s22, s32, s4];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          s22 = peg$parsedigit_sequence();
          if (s22 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s32 = peg$c41;
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }
            if (s32 !== peg$FAILED) {
              s22 = [s22, s32];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseexponent() {
        var s0, s1, s22, s32, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (peg$c43.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c44);
          }
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$parsesign();
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          if (s32 !== peg$FAILED) {
            s4 = peg$parsedigit_sequence();
            if (s4 !== peg$FAILED) {
              s22 = [s22, s32, s4];
              s1 = s22;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsesign() {
        var s0;
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }
        return s0;
      }
      function peg$parsedigit_sequence() {
        var s0, s1, s22;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c47.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$c47.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsewsp() {
        var s0, s1;
        s0 = peg$currPos;
        if (peg$c50.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c51);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c37();
        }
        s0 = s1;
        return s0;
      }
      function merge2(first3, more) {
        if (!more) return [first3];
        for (var a5 = [first3], i2 = 0, l2 = more.length; i2 < l2; i2++) a5[i2 + 1] = more[i2][1];
        return a5;
      }
      var cmds = { m: "moveto", l: "lineto", h: "horizontal lineto", v: "vertical lineto", c: "curveto", s: "smooth curveto", q: "quadratic curveto", t: "smooth quadratic curveto", a: "elliptical arc", z: "closepath" };
      for (var code in cmds) cmds[code.toUpperCase()] = cmds[code];
      function commands(code2, args) {
        if (!args) args = [{}];
        for (var i2 = args.length; i2--; ) {
          var cmd = { code: code2, command: cmds[code2] };
          if (code2 == code2.toLowerCase()) cmd.relative = true;
          for (var k2 in args[i2]) cmd[k2] = args[i2][k2];
          args[i2] = cmd;
        }
        return args;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    module.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});

// node_modules/svg-path-parser/index.js
var require_svg_path_parser = __commonJS({
  "node_modules/svg-path-parser/index.js"(exports, module) {
    var parserFunction = require_parser().parse;
    parserFunction.parseSVG = parserFunction;
    parserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;
    module.exports = parserFunction;
    function makeSVGPathCommandsAbsolute(commands) {
      var subpathStart, prevCmd = { x: 0, y: 0 };
      var attr2 = { x: "x0", y: "y0", x1: "x0", y1: "y0", x2: "x0", y2: "y0" };
      commands.forEach(function(cmd) {
        if (cmd.command === "moveto") subpathStart = cmd;
        cmd.x0 = prevCmd.x;
        cmd.y0 = prevCmd.y;
        for (var a5 in attr2) if (a5 in cmd) cmd[a5] += cmd.relative ? cmd[attr2[a5]] : 0;
        if (!("x" in cmd)) cmd.x = prevCmd.x;
        if (!("y" in cmd)) cmd.y = prevCmd.y;
        cmd.relative = false;
        cmd.code = cmd.code.toUpperCase();
        if (cmd.command == "closepath") {
          cmd.x = subpathStart.x;
          cmd.y = subpathStart.y;
        }
        prevCmd = cmd;
      });
      return commands;
    }
  }
});

// node_modules/pdfast/src/helper.js
var require_helper = __commonJS({
  "node_modules/pdfast/src/helper.js"(exports, module) {
    "use strict";
    var self2 = module.exports;
    module.exports.isNumber = function(x3) {
      return typeof x3 === "number";
    };
    module.exports.findMin = function(arr) {
      if (arr.length === 0) {
        return Infinity;
      }
      var curr = arr[0];
      for (var i2 = 1; i2 < arr.length; i2++) {
        curr = Math.min(curr, arr[i2]);
      }
      return curr;
    };
    module.exports.findMax = function(arr) {
      if (arr.length === 0) {
        return -Infinity;
      }
      var curr = arr[0];
      for (var i2 = 1; i2 < arr.length; i2++) {
        curr = Math.max(curr, arr[i2]);
      }
      return curr;
    };
    module.exports.findMinMulti = function(arr) {
      var curr = self2.findMin(arr[0]);
      for (var i2 = 1; i2 < arr.length; i2++) {
        curr = Math.min(curr, self2.findMin(arr[i2]));
      }
      return curr;
    };
    module.exports.findMaxMulti = function(arr) {
      var curr = self2.findMax(arr[0]);
      for (var i2 = 1; i2 < arr.length; i2++) {
        curr = Math.max(curr, self2.findMax(arr[i2]));
      }
      return curr;
    };
    module.exports.inside = function(min10, max11, x3) {
      return min10 <= x3 && x3 <= max11;
    };
  }
});

// node_modules/pdfast/src/index.js
var require_src = __commonJS({
  "node_modules/pdfast/src/index.js"(exports, module) {
    "use strict";
    var DEFAULT_SIZE = 50;
    var DEFAULT_WIDTH = 2;
    var LN_2 = Math.log(2);
    var self2 = module.exports;
    var helper = require_helper();
    function kernel(x3) {
      return 1 - Math.abs(x3);
    }
    module.exports.getUnifiedMinMax = function(arr, options) {
      return self2.getUnifiedMinMaxMulti([arr], options);
    };
    module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
      options = options || {};
      var relaxMin = false;
      var relaxMax = false;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var size3 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var min10 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
      var max11 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
      var range3 = max11 - min10;
      var step2 = range3 / (size3 - 1);
      if (relaxMin) {
        min10 = min10 - 2 * width * step2;
      }
      if (relaxMax) {
        max11 = max11 + 2 * width * step2;
      }
      return {
        min: min10,
        max: max11
      };
    };
    module.exports.create = function(arr, options) {
      options = options || {};
      if (!arr || arr.length === 0) {
        return [];
      }
      var size3 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
      var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
      var normalizedMinMax = self2.getUnifiedMinMax(arr, {
        size: size3,
        width,
        min: options.min,
        max: options.max
      });
      var min10 = normalizedMinMax.min;
      var max11 = normalizedMinMax.max;
      var range3 = max11 - min10;
      var step2 = range3 / (size3 - 1);
      if (range3 === 0) {
        return [{ x: min10, y: 1 }];
      }
      var buckets = [];
      for (var i2 = 0; i2 < size3; i2++) {
        buckets.push({
          x: min10 + i2 * step2,
          y: 0
        });
      }
      var xToBucket = function(x3) {
        return Math.floor((x3 - min10) / step2);
      };
      var partialArea = generatePartialAreas(kernel, width);
      var fullArea = partialArea[width];
      var c6 = partialArea[width - 1] - partialArea[width - 2];
      var initalValue = 0;
      arr.forEach(function(x3) {
        var bucket = xToBucket(x3);
        if (bucket + width < 0 || bucket - width >= buckets.length) {
          return;
        }
        var start = Math.max(bucket - width, 0);
        var mid2 = bucket;
        var end = Math.min(bucket + width, buckets.length - 1);
        var leftBlockCount = start - (bucket - width);
        var rightBlockCount = bucket + width - end;
        var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
        var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
        var weight2 = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
        if (leftBlockCount > 0) {
          initalValue += weight2 * (leftBlockCount - 1) * c6;
        }
        var startGradPos = Math.max(0, bucket - width + 1);
        if (helper.inside(0, buckets.length - 1, startGradPos)) {
          buckets[startGradPos].y += weight2 * 1 * c6;
        }
        if (helper.inside(0, buckets.length - 1, mid2 + 1)) {
          buckets[mid2 + 1].y -= weight2 * 2 * c6;
        }
        if (helper.inside(0, buckets.length - 1, end + 1)) {
          buckets[end + 1].y += weight2 * 1 * c6;
        }
      });
      var accumulator = initalValue;
      var gradAccumulator = 0;
      var area2 = 0;
      buckets.forEach(function(bucket) {
        gradAccumulator += bucket.y;
        accumulator += gradAccumulator;
        bucket.y = accumulator;
        area2 += accumulator;
      });
      if (area2 > 0) {
        buckets.forEach(function(bucket) {
          bucket.y /= area2;
        });
      }
      return buckets;
    };
    function generatePartialAreas(kernel2, width) {
      var partialAreas = {};
      var accumulator = 0;
      for (var i2 = -width; i2 <= width; i2++) {
        accumulator += kernel2(i2 / width);
        partialAreas[i2] = accumulator;
      }
      return partialAreas;
    }
    module.exports.getExpectedValueFromPdf = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var expected = 0;
      pdf2.forEach(function(obj) {
        expected += obj.x * obj.y;
      });
      return expected;
    };
    module.exports.getXWithLeftTailArea = function(pdf2, area2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var accumulator = 0;
      var last5 = 0;
      for (var i2 = 0; i2 < pdf2.length; i2++) {
        last5 = i2;
        accumulator += pdf2[i2].y;
        if (accumulator >= area2) {
          break;
        }
      }
      return pdf2[last5].x;
    };
    module.exports.getPerplexity = function(pdf2) {
      if (!pdf2 || pdf2.length === 0) {
        return void 0;
      }
      var entropy = 0;
      pdf2.forEach(function(obj) {
        var ln2 = Math.log(obj.y);
        if (isFinite(ln2)) {
          entropy += obj.y * ln2;
        }
      });
      entropy = -entropy / LN_2;
      return Math.pow(2, entropy);
    };
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        // Latin Extended-A block.
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e3) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          var value2 = array2[index3];
          setter(accumulator, value2, iteratee(value2), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          if (iteratee(array2[index3], index3, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length5 = array2 == null ? 0 : array2.length;
        while (length5--) {
          if (iteratee(array2[length5], length5, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          if (!predicate(array2[index3], index3, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index3 < length5) {
          var value2 = array2[index3];
          if (predicate(value2, index3, array2)) {
            result[resIndex++] = value2;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value2) {
        var length5 = array2 == null ? 0 : array2.length;
        return !!length5 && baseIndexOf(array2, value2, 0) > -1;
      }
      function arrayIncludesWith(array2, value2, comparator) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          if (comparator(value2, array2[index3])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length, result = Array(length5);
        while (++index3 < length5) {
          result[index3] = iteratee(array2[index3], index3, array2);
        }
        return result;
      }
      function arrayPush(array2, values4) {
        var index3 = -1, length5 = values4.length, offset2 = array2.length;
        while (++index3 < length5) {
          array2[offset2 + index3] = values4[index3];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        if (initAccum && length5) {
          accumulator = array2[++index3];
        }
        while (++index3 < length5) {
          accumulator = iteratee(accumulator, array2[index3], index3, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length5 = array2 == null ? 0 : array2.length;
        if (initAccum && length5) {
          accumulator = array2[--length5];
        }
        while (length5--) {
          accumulator = iteratee(accumulator, array2[length5], length5, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index3 = -1, length5 = array2 == null ? 0 : array2.length;
        while (++index3 < length5) {
          if (predicate(array2[index3], index3, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value2, key, collection2) {
          if (predicate(value2, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length5 = array2.length, index3 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index3-- : ++index3 < length5) {
          if (predicate(array2[index3], index3, array2)) {
            return index3;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value2, fromIndex) {
        return value2 === value2 ? strictIndexOf(array2, value2, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value2, fromIndex, comparator) {
        var index3 = fromIndex - 1, length5 = array2.length;
        while (++index3 < length5) {
          if (comparator(array2[index3], value2)) {
            return index3;
          }
        }
        return -1;
      }
      function baseIsNaN(value2) {
        return value2 !== value2;
      }
      function baseMean(array2, iteratee) {
        var length5 = array2 == null ? 0 : array2.length;
        return length5 ? baseSum(array2, iteratee) / length5 : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value2, index3, collection2) {
          accumulator = initAccum ? (initAccum = false, value2) : iteratee(accumulator, value2, index3, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length5 = array2.length;
        array2.sort(comparer);
        while (length5--) {
          array2[length5] = array2[length5].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index3 = -1, length5 = array2.length;
        while (++index3 < length5) {
          var current = iteratee(array2[index3]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index3 = -1, result = Array(n2);
        while (++index3 < n2) {
          result[index3] = iteratee(index3);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value2) {
          return func(value2);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index3 = -1, length5 = strSymbols.length;
        while (++index3 < length5 && baseIndexOf(chrSymbols, strSymbols[index3], 0) > -1) {
        }
        return index3;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index3 = strSymbols.length;
        while (index3-- && baseIndexOf(chrSymbols, strSymbols[index3], 0) > -1) {
        }
        return index3;
      }
      function countHolders(array2, placeholder) {
        var length5 = array2.length, result = 0;
        while (length5--) {
          if (array2[length5] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data2, result = [];
        while (!(data2 = iterator.next()).done) {
          result.push(data2.value);
        }
        return result;
      }
      function mapToArray(map5) {
        var index3 = -1, result = Array(map5.size);
        map5.forEach(function(value2, key) {
          result[++index3] = [key, value2];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array2, placeholder) {
        var index3 = -1, length5 = array2.length, resIndex = 0, result = [];
        while (++index3 < length5) {
          var value2 = array2[index3];
          if (value2 === placeholder || value2 === PLACEHOLDER) {
            array2[index3] = PLACEHOLDER;
            result[resIndex++] = index3;
          }
        }
        return result;
      }
      function setToArray(set10) {
        var index3 = -1, result = Array(set10.size);
        set10.forEach(function(value2) {
          result[++index3] = value2;
        });
        return result;
      }
      function setToPairs(set10) {
        var index3 = -1, result = Array(set10.size);
        set10.forEach(function(value2) {
          result[++index3] = [value2, value2];
        });
        return result;
      }
      function strictIndexOf(array2, value2, fromIndex) {
        var index3 = fromIndex - 1, length5 = array2.length;
        while (++index3 < length5) {
          if (array2[index3] === value2) {
            return index3;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value2, fromIndex) {
        var index3 = fromIndex + 1;
        while (index3--) {
          if (array2[index3] === value2) {
            return index3;
          }
        }
        return index3;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index3 = string.length;
        while (index3-- && reWhitespace.test(string.charAt(index3))) {
        }
        return index3;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto3 = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto3.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto3.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol3 = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto3.propertyIsEnumerable, splice6 = arrayProto.splice, spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined2, symIterator = Symbol3 ? Symbol3.iterator : undefined2, symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e3) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map3 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map3), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol3 ? Symbol3.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value2) {
          if (isObjectLike3(value2) && !isArray4(value2) && !(value2 instanceof LazyWrapper)) {
            if (value2 instanceof LodashWrapper) {
              return value2;
            }
            if (hasOwnProperty2.call(value2, "__wrapped__")) {
              return wrapperClone(value2);
            }
          }
          return new LodashWrapper(value2);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject6(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value2, chainAll) {
          this.__wrapped__ = value2;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value2) {
          this.__wrapped__ = value2;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray4(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length5 = end - start, index3 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length5, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length5 && takeCount == length5) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length5-- && resIndex < takeCount) {
              index3 += dir;
              var iterIndex = -1, value2 = array2[index3];
              while (++iterIndex < iterLength) {
                var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value2);
                if (type == LAZY_MAP_FLAG) {
                  value2 = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value2;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index3 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length5) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data2 = this.__data__;
          if (nativeCreate) {
            var result2 = data2[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data2, key) ? data2[key] : undefined2;
        }
        function hashHas(key) {
          var data2 = this.__data__;
          return nativeCreate ? data2[key] !== undefined2 : hasOwnProperty2.call(data2, key);
        }
        function hashSet(key, value2) {
          var data2 = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data2[key] = nativeCreate && value2 === undefined2 ? HASH_UNDEFINED : value2;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index3 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length5) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data2 = this.__data__, index3 = assocIndexOf(data2, key);
          if (index3 < 0) {
            return false;
          }
          var lastIndex = data2.length - 1;
          if (index3 == lastIndex) {
            data2.pop();
          } else {
            splice6.call(data2, index3, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data2 = this.__data__, index3 = assocIndexOf(data2, key);
          return index3 < 0 ? undefined2 : data2[index3][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value2) {
          var data2 = this.__data__, index3 = assocIndexOf(data2, key);
          if (index3 < 0) {
            ++this.size;
            data2.push([key, value2]);
          } else {
            data2[index3][1] = value2;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index3 = -1, length5 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length5) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map3 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value2) {
          var data2 = getMapData(this, key), size4 = data2.size;
          data2.set(key, value2);
          this.size += data2.size == size4 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values5) {
          var index3 = -1, length5 = values5 == null ? 0 : values5.length;
          this.__data__ = new MapCache();
          while (++index3 < length5) {
            this.add(values5[index3]);
          }
        }
        function setCacheAdd(value2) {
          this.__data__.set(value2, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value2) {
          return this.__data__.has(value2);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data2 = this.__data__ = new ListCache(entries);
          this.size = data2.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data2 = this.__data__, result2 = data2["delete"](key);
          this.size = data2.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value2) {
          var data2 = this.__data__;
          if (data2 instanceof ListCache) {
            var pairs2 = data2.__data__;
            if (!Map3 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
              pairs2.push([key, value2]);
              this.size = ++data2.size;
              return this;
            }
            data2 = this.__data__ = new MapCache(pairs2);
          }
          data2.set(key, value2);
          this.size = data2.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value2, inherited) {
          var isArr = isArray4(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType3 = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType3, result2 = skipIndexes ? baseTimes(value2.length, String2) : [], length5 = result2.length;
          for (var key in value2) {
            if ((inherited || hasOwnProperty2.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType3 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length5)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length5 = array2.length;
          return length5 ? array2[baseRandom(0, length5 - 1)] : undefined2;
        }
        function arraySampleSize(array2, n2) {
          return shuffleSelf(copyArray(array2), baseClamp(n2, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object, key, value2) {
          if (value2 !== undefined2 && !eq(object[key], value2) || value2 === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value2);
          }
        }
        function assignValue(object, key, value2) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value2)) || value2 === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value2);
          }
        }
        function assocIndexOf(array2, key) {
          var length5 = array2.length;
          while (length5--) {
            if (eq(array2[length5][0], key)) {
              return length5;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value2, key, collection2) {
            setter(accumulator, value2, iteratee2(value2), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys2(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value2) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value2,
              "writable": true
            });
          } else {
            object[key] = value2;
          }
        }
        function baseAt(object, paths) {
          var index3 = -1, length5 = paths.length, result2 = Array2(length5), skip = object == null;
          while (++index3 < length5) {
            result2[index3] = skip ? undefined2 : get4(object, paths[index3]);
          }
          return result2;
        }
        function baseClamp(number3, lower2, upper2) {
          if (number3 === number3) {
            if (upper2 !== undefined2) {
              number3 = number3 <= upper2 ? number3 : upper2;
            }
            if (lower2 !== undefined2) {
              number3 = number3 >= lower2 ? number3 : lower2;
            }
          }
          return number3;
        }
        function baseClone(value2, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value2, key, object, stack) : customizer(value2);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject6(value2)) {
            return value2;
          }
          var isArr = isArray4(value2);
          if (isArr) {
            result2 = initCloneArray(value2);
            if (!isDeep) {
              return copyArray(value2, result2);
            }
          } else {
            var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value2)) {
              return cloneBuffer(value2, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value2);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value2, baseAssignIn(result2, value2)) : copySymbols(value2, baseAssign(result2, value2));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value2 : {};
              }
              result2 = initCloneByTag(value2, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value2);
          if (stacked) {
            return stacked;
          }
          stack.set(value2, result2);
          if (isSet(value2)) {
            value2.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
            });
          } else if (isMap(value2)) {
            value2.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
          var props = isArr ? undefined2 : keysFunc(value2);
          arrayEach(props || value2, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value2[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length5 = props.length;
          if (object == null) {
            return !length5;
          }
          object = Object2(object);
          while (length5--) {
            var key = props[length5], predicate = source[key], value2 = object[key];
            if (value2 === undefined2 && !(key in object) || !predicate(value2)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array2, values5, iteratee2, comparator) {
          var index3 = -1, includes3 = arrayIncludes, isCommon = true, length5 = array2.length, result2 = [], valuesLength = values5.length;
          if (!length5) {
            return result2;
          }
          if (iteratee2) {
            values5 = arrayMap(values5, baseUnary(iteratee2));
          }
          if (comparator) {
            includes3 = arrayIncludesWith;
            isCommon = false;
          } else if (values5.length >= LARGE_ARRAY_SIZE) {
            includes3 = cacheHas;
            isCommon = false;
            values5 = new SetCache(values5);
          }
          outer:
            while (++index3 < length5) {
              var value2 = array2[index3], computed = iteratee2 == null ? value2 : iteratee2(value2);
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values5[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value2);
              } else if (!includes3(values5, computed, comparator)) {
                result2.push(value2);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value2, index3, collection2) {
            result2 = !!predicate(value2, index3, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index3 = -1, length5 = array2.length;
          while (++index3 < length5) {
            var value2 = array2[index3], current = iteratee2(value2);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value2;
            }
          }
          return result2;
        }
        function baseFill(array2, value2, start, end) {
          var length5 = array2.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length5 ? 0 : length5 + start;
          }
          end = end === undefined2 || end > length5 ? length5 : toInteger(end);
          if (end < 0) {
            end += length5;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array2[start++] = value2;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value2, index3, collection2) {
            if (predicate(value2, index3, collection2)) {
              result2.push(value2);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index3 = -1, length5 = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index3 < length5) {
            var value2 = array2[index3];
            if (depth > 0 && predicate(value2)) {
              if (depth > 1) {
                baseFlatten(value2, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value2);
              }
            } else if (!isStrict) {
              result2[result2.length] = value2;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys2);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys2);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction4(object[key]);
          });
        }
        function baseGet(object, path2) {
          path2 = castPath(path2, object);
          var index3 = 0, length5 = path2.length;
          while (object != null && index3 < length5) {
            object = object[toKey(path2[index3++])];
          }
          return index3 && index3 == length5 ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray4(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value2) {
          if (value2 == null) {
            return value2 === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value2) ? getRawTag(value2) : objectToString(value2);
        }
        function baseGt(value2, other) {
          return value2 > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number3, start, end) {
          return number3 >= nativeMin(start, end) && number3 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length5 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length5 >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
          }
          array2 = arrays[0];
          var index3 = -1, seen = caches[0];
          outer:
            while (++index3 < length5 && result2.length < maxLength) {
              var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (!(seen ? cacheHas(seen, computed) : includes3(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache2 = caches[othIndex];
                  if (!(cache2 ? cacheHas(cache2, computed) : includes3(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value2);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value2, key, object2) {
            setter(accumulator, iteratee2(value2), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path2, args) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          var func = object == null ? object : object[toKey(last5(path2))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == argsTag;
        }
        function baseIsArrayBuffer(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == arrayBufferTag;
        }
        function baseIsDate(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == dateTag;
        }
        function baseIsEqual(value2, other, bitmask, customizer, stack) {
          if (value2 === other) {
            return true;
          }
          if (value2 == null || other == null || !isObjectLike3(value2) && !isObjectLike3(other)) {
            return value2 !== value2 && other !== other;
          }
          return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray4(object), othIsArr = isArray4(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value2) {
          return isObjectLike3(value2) && getTag(value2) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index3 = matchData.length, length5 = index3, noCustomizer = !customizer;
          if (object == null) {
            return !length5;
          }
          object = Object2(object);
          while (index3--) {
            var data2 = matchData[index3];
            if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
              return false;
            }
          }
          while (++index3 < length5) {
            data2 = matchData[index3];
            var key = data2[0], objValue = object[key], srcValue = data2[1];
            if (noCustomizer && data2[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value2) {
          if (!isObject6(value2) || isMasked(value2)) {
            return false;
          }
          var pattern = isFunction4(value2) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value2));
        }
        function baseIsRegExp(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == regexpTag;
        }
        function baseIsSet(value2) {
          return isObjectLike3(value2) && getTag(value2) == setTag;
        }
        function baseIsTypedArray(value2) {
          return isObjectLike3(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
        }
        function baseIteratee(value2) {
          if (typeof value2 == "function") {
            return value2;
          }
          if (value2 == null) {
            return identity8;
          }
          if (typeof value2 == "object") {
            return isArray4(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
          }
          return property(value2);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject6(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value2, other) {
          return value2 < other;
        }
        function baseMap(collection, iteratee2) {
          var index3 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value2, key, collection2) {
            result2[++index3] = iteratee2(value2, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          if (isKey(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object) {
            var objValue = get4(object, path2);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject6(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray4(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray4(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject4(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject6(objValue) || isFunction4(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array2, n2) {
          var length5 = array2.length;
          if (!length5) {
            return;
          }
          n2 += n2 < 0 ? length5 : 0;
          return isIndex(n2, length5) ? array2[n2] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray4(iteratee2)) {
                return function(value2) {
                  return baseGet(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity8];
          }
          var index3 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value2, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value2);
            });
            return { "criteria": criteria, "index": ++index3, "value": value2 };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value2, path2) {
            return hasIn(object, path2);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index3 = -1, length5 = paths.length, result2 = {};
          while (++index3 < length5) {
            var path2 = paths[index3], value2 = baseGet(object, path2);
            if (predicate(value2, path2)) {
              baseSet(result2, castPath(path2, object), value2);
            }
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object) {
            return baseGet(object, path2);
          };
        }
        function basePullAll(array2, values5, iteratee2, comparator) {
          var indexOf6 = comparator ? baseIndexOfWith : baseIndexOf, index3 = -1, length5 = values5.length, seen = array2;
          if (array2 === values5) {
            values5 = copyArray(values5);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index3 < length5) {
            var fromIndex = 0, value2 = values5[index3], computed = iteratee2 ? iteratee2(value2) : value2;
            while ((fromIndex = indexOf6(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice6.call(seen, fromIndex, 1);
              }
              splice6.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes2) {
          var length5 = array2 ? indexes2.length : 0, lastIndex = length5 - 1;
          while (length5--) {
            var index3 = indexes2[length5];
            if (length5 == lastIndex || index3 !== previous) {
              var previous = index3;
              if (isIndex(index3)) {
                splice6.call(array2, index3, 1);
              } else {
                baseUnset(array2, index3);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower2, upper2) {
          return lower2 + nativeFloor(nativeRandom() * (upper2 - lower2 + 1));
        }
        function baseRange(start, end, step2, fromRight) {
          var index3 = -1, length5 = nativeMax(nativeCeil((end - start) / (step2 || 1)), 0), result2 = Array2(length5);
          while (length5--) {
            result2[fromRight ? length5 : ++index3] = start;
            start += step2;
          }
          return result2;
        }
        function baseRepeat(string, n2) {
          var result2 = "";
          if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string += string;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity8), func + "");
        }
        function baseSample(collection) {
          return arraySample(values4(collection));
        }
        function baseSampleSize(collection, n2) {
          var array2 = values4(collection);
          return shuffleSelf(array2, baseClamp(n2, 0, array2.length));
        }
        function baseSet(object, path2, value2, customizer) {
          if (!isObject6(object)) {
            return object;
          }
          path2 = castPath(path2, object);
          var index3 = -1, length5 = path2.length, lastIndex = length5 - 1, nested = object;
          while (nested != null && ++index3 < length5) {
            var key = toKey(path2[index3]), newValue = value2;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index3 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject6(objValue) ? objValue : isIndex(path2[index3 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity8 : function(func, data2) {
          metaMap.set(func, data2);
          return func;
        };
        var baseSetToString = !defineProperty ? identity8 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant4(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values4(collection));
        }
        function baseSlice(array2, start, end) {
          var index3 = -1, length5 = array2.length;
          if (start < 0) {
            start = -start > length5 ? 0 : length5 + start;
          }
          end = end > length5 ? length5 : end;
          if (end < 0) {
            end += length5;
          }
          length5 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length5);
          while (++index3 < length5) {
            result2[index3] = array2[index3 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value2, index3, collection2) {
            result2 = predicate(value2, index3, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value2, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid2 = low + high >>> 1, computed = array2[mid2];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value2 : computed < value2)) {
                low = mid2 + 1;
              } else {
                high = mid2;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value2, identity8, retHighest);
        }
        function baseSortedIndexBy(array2, value2, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value2 = iteratee2(value2);
          var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol(value2), valIsUndefined = value2 === undefined2;
          while (low < high) {
            var mid2 = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid2]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value2 : computed < value2;
            }
            if (setLow) {
              low = mid2 + 1;
            } else {
              high = mid2;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index3 = -1, length5 = array2.length, resIndex = 0, result2 = [];
          while (++index3 < length5) {
            var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
            if (!index3 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value2 === 0 ? 0 : value2;
            }
          }
          return result2;
        }
        function baseToNumber(value2) {
          if (typeof value2 == "number") {
            return value2;
          }
          if (isSymbol(value2)) {
            return NAN;
          }
          return +value2;
        }
        function baseToString(value2) {
          if (typeof value2 == "string") {
            return value2;
          }
          if (isArray4(value2)) {
            return arrayMap(value2, baseToString) + "";
          }
          if (isSymbol(value2)) {
            return symbolToString ? symbolToString.call(value2) : "";
          }
          var result2 = value2 + "";
          return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index3 = -1, includes3 = arrayIncludes, length5 = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes3 = arrayIncludesWith;
          } else if (length5 >= LARGE_ARRAY_SIZE) {
            var set11 = iteratee2 ? null : createSet(array2);
            if (set11) {
              return setToArray(set11);
            }
            isCommon = false;
            includes3 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index3 < length5) {
              var value2 = array2[index3], computed = iteratee2 ? iteratee2(value2) : value2;
              value2 = comparator || value2 !== 0 ? value2 : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value2);
              } else if (!includes3(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value2);
              }
            }
          return result2;
        }
        function baseUnset(object, path2) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          return object == null || delete object[toKey(last5(path2))];
        }
        function baseUpdate(object, path2, updater, customizer) {
          return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length5 = array2.length, index3 = fromRight ? length5 : -1;
          while ((fromRight ? index3-- : ++index3 < length5) && predicate(array2[index3], index3, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index3, fromRight ? index3 + 1 : length5) : baseSlice(array2, fromRight ? index3 + 1 : 0, fromRight ? length5 : index3);
        }
        function baseWrapperValue(value2, actions) {
          var result2 = value2;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length5 = arrays.length;
          if (length5 < 2) {
            return length5 ? baseUniq(arrays[0]) : [];
          }
          var index3 = -1, result2 = Array2(length5);
          while (++index3 < length5) {
            var array2 = arrays[index3], othIndex = -1;
            while (++othIndex < length5) {
              if (othIndex != index3) {
                result2[index3] = baseDifference(result2[index3] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values5, assignFunc) {
          var index3 = -1, length5 = props.length, valsLength = values5.length, result2 = {};
          while (++index3 < length5) {
            var value2 = index3 < valsLength ? values5[index3] : undefined2;
            assignFunc(result2, props[index3], value2);
          }
          return result2;
        }
        function castArrayLikeObject(value2) {
          return isArrayLikeObject(value2) ? value2 : [];
        }
        function castFunction(value2) {
          return typeof value2 == "function" ? value2 : identity8;
        }
        function castPath(value2, object) {
          if (isArray4(value2)) {
            return value2;
          }
          return isKey(value2, object) ? [value2] : stringToPath(toString5(value2));
        }
        var castRest = baseRest;
        function castSlice(array2, start, end) {
          var length5 = array2.length;
          end = end === undefined2 ? length5 : end;
          return !start && end >= length5 ? array2 : baseSlice(array2, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id4) {
          return root2.clearTimeout(id4);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length5 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length5) : new buffer.constructor(length5);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value2, other) {
          if (value2 !== other) {
            var valIsDefined = value2 !== undefined2, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol(value2);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index3 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length5 = objCriteria.length, ordersLength = orders.length;
          while (++index3 < length5) {
            var result2 = compareAscending(objCriteria[index3], othCriteria[index3]);
            if (result2) {
              if (index3 >= ordersLength) {
                return result2;
              }
              var order = orders[index3];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset2 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset2 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index3 = -1, length5 = source.length;
          array2 || (array2 = Array2(length5));
          while (++index3 < length5) {
            array2[index3] = source[index3];
          }
          return array2;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index3 = -1, length5 = props.length;
          while (++index3 < length5) {
            var key = props[index3];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray4(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index3 = -1, length5 = sources.length, customizer = length5 > 1 ? sources[length5 - 1] : undefined2, guard = length5 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length5--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length5 < 3 ? undefined2 : customizer;
              length5 = 1;
            }
            object = Object2(object);
            while (++index3 < length5) {
              var source = sources[index3];
              if (source) {
                assigner(object, source, index3, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike2(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length5 = collection.length, index3 = fromRight ? length5 : -1, iterable = Object2(collection);
            while (fromRight ? index3-- : ++index3 < length5) {
              if (iteratee2(iterable[index3], index3, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index3 = -1, iterable = Object2(object), props = keysFunc(object), length5 = props.length;
            while (length5--) {
              var key = props[fromRight ? length5 : ++index3];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString5(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject6(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length5 = arguments.length, args = Array2(length5), index3 = length5, placeholder = getHolder(wrapper);
            while (index3--) {
              args[index3] = arguments[index3];
            }
            var holders = length5 < 3 && args[0] !== placeholder && args[length5 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length5 -= holders.length;
            if (length5 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length5
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index3 = findIndexFunc(collection, predicate, fromIndex);
            return index3 > -1 ? iterable[iteratee2 ? collection[index3] : index3] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length5 = funcs.length, index3 = length5, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index3--) {
              var func = funcs[index3];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index3 = wrapper ? index3 : length5;
            while (++index3 < length5) {
              func = funcs[index3];
              var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData3(func) : undefined2;
              if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value2 = args[0];
              if (wrapper && args.length == 1 && isArray4(value2)) {
                return wrapper.plant(value2).value();
              }
              var index4 = 0, result2 = length5 ? funcs[index4].apply(this, args) : value2;
              while (++index4 < length5) {
                result2 = funcs[index4].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length5 = arguments.length, args = Array2(length5), index3 = length5;
            while (index3--) {
              args[index3] = arguments[index3];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length5 -= holdersCount;
            if (isCurried && length5 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length5
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length5 = args.length;
            if (argPos) {
              args = reorder2(args, argPos);
            } else if (isFlip && length5 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length5) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value2, other) {
            var result2;
            if (value2 === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value2 !== undefined2) {
              result2 = value2;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value2 == "string" || typeof other == "string") {
                value2 = baseToString(value2);
                other = baseToString(other);
              } else {
                value2 = baseToNumber(value2);
                other = baseToNumber(other);
              }
              result2 = operator(value2, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length5, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length5) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length5 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length5).join("") : result2.slice(0, length5);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step2) {
            if (step2 && typeof step2 != "number" && isIterateeCall(start, end, step2)) {
              end = step2 = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step2 = step2 === undefined2 ? start < end ? 1 : -1 : toFinite(step2);
            return baseRange(start, end, step2, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value2, other) {
            if (!(typeof value2 == "string" && typeof other == "string")) {
              value2 = toNumber(value2);
              other = toNumber(other);
            }
            return operator(value2, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData3(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number3, precision) {
            number3 = toNumber(number3);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number3)) {
              var pair = (toString5(number3) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString5(value2) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number3);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values5) {
          return new Set2(values5);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length5 = partials ? partials.length : 0;
          if (!length5) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length5 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data2 = isBindKey ? undefined2 : getData3(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data2) {
            mergeData2(newData, data2);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length5, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data2 ? baseSetData : setData3;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto3[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject6(objValue) && isObject6(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value2) {
          return isPlainObject4(value2) ? undefined2 : value2;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index3 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index3 < arrLength) {
            var arrValue = array2[index3], othValue = other[index3];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index3, other, array2, stack) : customizer(arrValue, othValue, index3, array2, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index3 = objLength;
          while (index3--) {
            var key = objProps[index3];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index3 < objLength) {
            key = objProps[index3];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten4), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys2, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData3 = !metaMap ? noop3 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array2 = realNames[result2], length5 = hasOwnProperty2.call(realNames, result2) ? array2.length : 0;
          while (length5--) {
            var data2 = array2[length5], otherFunc = data2.func;
            if (otherFunc == null || otherFunc == func) {
              return data2.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map6, key) {
          var data2 = map6.__data__;
          return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
        }
        function getMatchData(object) {
          var result2 = keys2(object), length5 = result2.length;
          while (length5--) {
            var key = result2[length5], value2 = object[key];
            result2[length5] = [key, value2, isStrictComparable(value2)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value2 = getValue(object, key);
          return baseIsNative(value2) ? value2 : undefined2;
        }
        function getRawTag(value2) {
          var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag = value2[symToStringTag];
          try {
            value2[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e3) {
          }
          var result2 = nativeObjectToString.call(value2);
          if (unmasked) {
            if (isOwn) {
              value2[symToStringTag] = tag;
            } else {
              delete value2[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map3 && getTag(new Map3()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value2) {
            var result2 = baseGetTag(value2), Ctor = result2 == objectTag ? value2.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index3 = -1, length5 = transforms.length;
          while (++index3 < length5) {
            var data2 = transforms[index3], size4 = data2.size;
            switch (data2.type) {
              case "drop":
                start += size4;
                break;
              case "dropRight":
                end -= size4;
                break;
              case "take":
                end = nativeMin(end, start + size4);
                break;
              case "takeRight":
                start = nativeMax(start, end - size4);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path2, hasFunc) {
          path2 = castPath(path2, object);
          var index3 = -1, length5 = path2.length, result2 = false;
          while (++index3 < length5) {
            var key = toKey(path2[index3]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index3 != length5) {
            return result2;
          }
          length5 = object == null ? 0 : object.length;
          return !!length5 && isLength(length5) && isIndex(key, length5) && (isArray4(object) || isArguments(object));
        }
        function initCloneArray(array2) {
          var length5 = array2.length, result2 = new array2.constructor(length5);
          if (length5 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length5 = details.length;
          if (!length5) {
            return source;
          }
          var lastIndex = length5 - 1;
          details[lastIndex] = (length5 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length5 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value2) {
          return isArray4(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
        }
        function isIndex(value2, length5) {
          var type = typeof value2;
          length5 = length5 == null ? MAX_SAFE_INTEGER : length5;
          return !!length5 && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length5);
        }
        function isIterateeCall(value2, index3, object) {
          if (!isObject6(object)) {
            return false;
          }
          var type = typeof index3;
          if (type == "number" ? isArrayLike2(object) && isIndex(index3, object.length) : type == "string" && index3 in object) {
            return eq(object[index3], value2);
          }
          return false;
        }
        function isKey(value2, object) {
          if (isArray4(value2)) {
            return false;
          }
          var type = typeof value2;
          if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol(value2)) {
            return true;
          }
          return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object2(object);
        }
        function isKeyable(value2) {
          var type = typeof value2;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data2 = getData3(other);
          return !!data2 && func === data2[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction4 : stubFalse;
        function isPrototype(value2) {
          var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto3;
          return value2 === proto;
        }
        function isStrictComparable(value2) {
          return value2 === value2 && !isObject6(value2);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize5(func, function(key) {
            if (cache2.size === MAX_MEMOIZE_SIZE) {
              cache2.clear();
            }
            return key;
          });
          var cache2 = result2.cache;
          return result2;
        }
        function mergeData2(data2, source) {
          var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data2;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data2[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value2 = source[3];
          if (value2) {
            var partials = data2[3];
            data2[3] = partials ? composeArgs(partials, value2, source[4]) : value2;
            data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
          }
          value2 = source[5];
          if (value2) {
            partials = data2[5];
            data2[5] = partials ? composeArgsRight(partials, value2, source[6]) : value2;
            data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
          }
          value2 = source[7];
          if (value2) {
            data2[7] = value2;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
          }
          if (data2[9] == null) {
            data2[9] = source[9];
          }
          data2[0] = source[0];
          data2[1] = newBitmask;
          return data2;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value2) {
          return nativeObjectToString.call(value2);
        }
        function overRest(func, start, transform3) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index3 = -1, length5 = nativeMax(args.length - start, 0), array2 = Array2(length5);
            while (++index3 < length5) {
              array2[index3] = args[start + index3];
            }
            index3 = -1;
            var otherArgs = Array2(start + 1);
            while (++index3 < start) {
              otherArgs[index3] = args[index3];
            }
            otherArgs[start] = transform3(array2);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path2) {
          return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
        }
        function reorder2(array2, indexes2) {
          var arrLength = array2.length, length5 = nativeMin(indexes2.length, arrLength), oldArray = copyArray(array2);
          while (length5--) {
            var index3 = indexes2[length5];
            array2[length5] = isIndex(index3, arrLength) ? oldArray[index3] : undefined2;
          }
          return array2;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData3 = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count4 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count4 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count4 = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array2, size4) {
          var index3 = -1, length5 = array2.length, lastIndex = length5 - 1;
          size4 = size4 === undefined2 ? length5 : size4;
          while (++index3 < size4) {
            var rand = baseRandom(index3, lastIndex), value2 = array2[rand];
            array2[rand] = array2[index3];
            array2[index3] = value2;
          }
          array2.length = size4;
          return array2;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number3, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
          });
          return result2;
        });
        function toKey(value2) {
          if (typeof value2 == "string" || isSymbol(value2)) {
            return value2;
          }
          var result2 = value2 + "";
          return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e3) {
            }
            try {
              return func + "";
            } catch (e3) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value2 = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value2)) {
              details.push(value2);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array2, size4, guard) {
          if (guard ? isIterateeCall(array2, size4, guard) : size4 === undefined2) {
            size4 = 1;
          } else {
            size4 = nativeMax(toInteger(size4), 0);
          }
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5 || size4 < 1) {
            return [];
          }
          var index3 = 0, resIndex = 0, result2 = Array2(nativeCeil(length5 / size4));
          while (index3 < length5) {
            result2[resIndex++] = baseSlice(array2, index3, index3 += size4);
          }
          return result2;
        }
        function compact(array2) {
          var index3 = -1, length5 = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index3 < length5) {
            var value2 = array2[index3];
            if (value2) {
              result2[resIndex++] = value2;
            }
          }
          return result2;
        }
        function concat() {
          var length5 = arguments.length;
          if (!length5) {
            return [];
          }
          var args = Array2(length5 - 1), array2 = arguments[0], index3 = length5;
          while (index3--) {
            args[index3 - 1] = arguments[index3];
          }
          return arrayPush(isArray4(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference2 = baseRest(function(array2, values5) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values5, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values5) {
          var iteratee2 = last5(values5);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values5, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values5) {
          var comparator = last5(values5);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values5, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array2, n2, guard) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array2, n2 < 0 ? 0 : n2, length5);
        }
        function dropRight(array2, n2, guard) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length5 - n2;
          return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value2, start, end) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array2, value2, start)) {
            start = 0;
            end = length5;
          }
          return baseFill(array2, value2, start, end);
        }
        function findIndex(array2, predicate, fromIndex) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return -1;
          }
          var index3 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index3 < 0) {
            index3 = nativeMax(length5 + index3, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index3);
        }
        function findLastIndex(array2, predicate, fromIndex) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return -1;
          }
          var index3 = length5 - 1;
          if (fromIndex !== undefined2) {
            index3 = toInteger(fromIndex);
            index3 = fromIndex < 0 ? nativeMax(length5 + index3, 0) : nativeMin(index3, length5 - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index3, true);
        }
        function flatten4(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? baseFlatten(array2, INFINITY) : [];
        }
        function flattenDepth(array2, depth) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs2) {
          var index3 = -1, length5 = pairs2 == null ? 0 : pairs2.length, result2 = {};
          while (++index3 < length5) {
            var pair = pairs2[index3];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head3(array2) {
          return array2 && array2.length ? array2[0] : undefined2;
        }
        function indexOf5(array2, value2, fromIndex) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return -1;
          }
          var index3 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index3 < 0) {
            index3 = nativeMax(length5 + index3, 0);
          }
          return baseIndexOf(array2, value2, index3);
        }
        function initial(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? baseSlice(array2, 0, -1) : [];
        }
        var intersection3 = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last5(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last5(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last5(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last5(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? array2[length5 - 1] : undefined2;
        }
        function lastIndexOf(array2, value2, fromIndex) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return -1;
          }
          var index3 = length5;
          if (fromIndex !== undefined2) {
            index3 = toInteger(fromIndex);
            index3 = index3 < 0 ? nativeMax(length5 + index3, 0) : nativeMin(index3, length5 - 1);
          }
          return value2 === value2 ? strictLastIndexOf(array2, value2, index3) : baseFindIndex(array2, baseIsNaN, index3, true);
        }
        function nth(array2, n2) {
          return array2 && array2.length ? baseNth(array2, toInteger(n2)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values5) {
          return array2 && array2.length && values5 && values5.length ? basePullAll(array2, values5) : array2;
        }
        function pullAllBy(array2, values5, iteratee2) {
          return array2 && array2.length && values5 && values5.length ? basePullAll(array2, values5, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values5, comparator) {
          return array2 && array2.length && values5 && values5.length ? basePullAll(array2, values5, undefined2, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes2) {
          var length5 = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes2);
          basePullAt(array2, arrayMap(indexes2, function(index3) {
            return isIndex(index3, length5) ? +index3 : index3;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index3 = -1, indexes2 = [], length5 = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index3 < length5) {
            var value2 = array2[index3];
            if (predicate(value2, index3, array2)) {
              result2.push(value2);
              indexes2.push(index3);
            }
          }
          basePullAt(array2, indexes2);
          return result2;
        }
        function reverse2(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice3(array2, start, end) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
            start = 0;
            end = length5;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length5 : toInteger(end);
          }
          return baseSlice(array2, start, end);
        }
        function sortedIndex2(array2, value2) {
          return baseSortedIndex(array2, value2);
        }
        function sortedIndexBy(array2, value2, iteratee2) {
          return baseSortedIndexBy(array2, value2, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value2) {
          var length5 = array2 == null ? 0 : array2.length;
          if (length5) {
            var index3 = baseSortedIndex(array2, value2);
            if (index3 < length5 && eq(array2[index3], value2)) {
              return index3;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value2) {
          return baseSortedIndex(array2, value2, true);
        }
        function sortedLastIndexBy(array2, value2, iteratee2) {
          return baseSortedIndexBy(array2, value2, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value2) {
          var length5 = array2 == null ? 0 : array2.length;
          if (length5) {
            var index3 = baseSortedIndex(array2, value2, true) - 1;
            if (eq(array2[index3], value2)) {
              return index3;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length5 = array2 == null ? 0 : array2.length;
          return length5 ? baseSlice(array2, 1, length5) : [];
        }
        function take(array2, n2, guard) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array2, n2, guard) {
          var length5 = array2 == null ? 0 : array2.length;
          if (!length5) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length5 - n2;
          return baseSlice(array2, n2 < 0 ? 0 : n2, length5);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last5(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last5(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq3(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy2(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
        }
        function unzip(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length5 = 0;
          array2 = arrayFilter(array2, function(group3) {
            if (isArrayLikeObject(group3)) {
              length5 = nativeMax(group3.length, length5);
              return true;
            }
          });
          return baseTimes(length5, function(index3) {
            return arrayMap(array2, baseProperty(index3));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group3) {
            return apply(iteratee2, undefined2, group3);
          });
        }
        var without = baseRest(function(array2, values5) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values5) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last5(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last5(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip2 = baseRest(unzip);
        function zipObject(props, values5) {
          return baseZipObject(props || [], values5 || [], assignValue);
        }
        function zipObjectDeep(props, values5) {
          return baseZipObject(props || [], values5 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length5 = arrays.length, iteratee2 = length5 > 1 ? arrays[length5 - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value2) {
          var result2 = lodash(value2);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value2, interceptor) {
          interceptor(value2);
          return value2;
        }
        function thru(value2, interceptor) {
          return interceptor(value2);
        }
        var wrapperAt = flatRest(function(paths) {
          var length5 = paths.length, start = length5 ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length5 > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value2 = value2.slice(start, +start + (length5 ? 1 : 0));
          value2.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value2, this.__chain__).thru(function(array2) {
            if (length5 && !array2.length) {
              array2.push(undefined2);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value2 = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value2 };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value2) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone9 = wrapperClone(parent2);
            clone9.__index__ = 0;
            clone9.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone9;
            } else {
              result2 = clone9;
            }
            var previous = clone9;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value2;
          return result2;
        }
        function wrapperReverse() {
          var value2 = this.__wrapped__;
          if (value2 instanceof LazyWrapper) {
            var wrapped = value2;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse2],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse2);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value2, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every2(collection, predicate, guard) {
          var func = isArray4(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter3(collection, predicate) {
          var func = isArray4(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find6 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map5(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map5(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map5(collection, iteratee2), depth);
        }
        function forEach4(collection, iteratee2) {
          var func = isArray4(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray4(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy3 = createAggregator(function(result2, value2, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value2);
          } else {
            baseAssignValue(result2, key, [value2]);
          }
        });
        function includes2(collection, value2, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values4(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length5 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length5 + fromIndex, 0);
          }
          return isString5(collection) ? fromIndex <= length5 && collection.indexOf(value2, fromIndex) > -1 : !!length5 && baseIndexOf(collection, value2, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index3 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value2) {
            result2[++index3] = isFunc ? apply(path2, value2, args) : baseInvoke(value2, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value2, key) {
          baseAssignValue(result2, key, value2);
        });
        function map5(collection, iteratee2) {
          var func = isArray4(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray4(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray4(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition2 = createAggregator(function(result2, value2, key) {
          result2[key ? 0 : 1].push(value2);
        }, function() {
          return [[], []];
        });
        function reduce4(collection, iteratee2, accumulator) {
          var func = isArray4(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray4(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray4(collection) ? arrayFilter : baseFilter;
          return func(collection, negate4(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray4(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray4(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle2(collection) {
          var func = isArray4(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size3(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike2(collection)) {
            return isString5(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some3(collection, predicate, guard) {
          var func = isArray4(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy2 = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length5 = iteratees.length;
          if (length5 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length5 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined2 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject6(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel2() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel2;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize5(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
            if (cache2.has(key)) {
              return cache2.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache2.set(key, result2) || cache2;
            return result2;
          };
          memoized.cache = new (memoize5.Cache || MapCache)();
          return memoized;
        }
        memoize5.Cache = MapCache;
        function negate4(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray4(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index3 = -1, length5 = nativeMin(args.length, funcsLength);
            while (++index3 < length5) {
              args[index3] = transforms[index3].call(this, args[index3]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes2) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes2);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array2 = args[start], otherArgs = castSlice(args, 0, start);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject6(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value2, wrapper) {
          return partial(castFunction(wrapper), value2);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value2 = arguments[0];
          return isArray4(value2) ? value2 : [value2];
        }
        function clone8(value2) {
          return baseClone(value2, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value2, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep2(value2) {
          return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys2(source));
        }
        function eq(value2, other) {
          return value2 === other || value2 !== value2 && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value2, other) {
          return value2 >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value2) {
          return isObjectLike3(value2) && hasOwnProperty2.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
        };
        var isArray4 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value2) {
          return value2 != null && isLength(value2.length) && !isFunction4(value2);
        }
        function isArrayLikeObject(value2) {
          return isObjectLike3(value2) && isArrayLike2(value2);
        }
        function isBoolean3(value2) {
          return value2 === true || value2 === false || isObjectLike3(value2) && baseGetTag(value2) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement4(value2) {
          return isObjectLike3(value2) && value2.nodeType === 1 && !isPlainObject4(value2);
        }
        function isEmpty3(value2) {
          if (value2 == null) {
            return true;
          }
          if (isArrayLike2(value2) && (isArray4(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer(value2) || isTypedArray(value2) || isArguments(value2))) {
            return !value2.length;
          }
          var tag = getTag(value2);
          if (tag == mapTag || tag == setTag) {
            return !value2.size;
          }
          if (isPrototype(value2)) {
            return !baseKeys(value2).length;
          }
          for (var key in value2) {
            if (hasOwnProperty2.call(value2, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual3(value2, other) {
          return baseIsEqual(value2, other);
        }
        function isEqualWith(value2, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value2, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value2, other, undefined2, customizer) : !!result2;
        }
        function isError(value2) {
          if (!isObjectLike3(value2)) {
            return false;
          }
          var tag = baseGetTag(value2);
          return tag == errorTag || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject4(value2);
        }
        function isFinite2(value2) {
          return typeof value2 == "number" && nativeIsFinite(value2);
        }
        function isFunction4(value2) {
          if (!isObject6(value2)) {
            return false;
          }
          var tag = baseGetTag(value2);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger3(value2) {
          return typeof value2 == "number" && value2 == toInteger(value2);
        }
        function isLength(value2) {
          return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
        }
        function isObject6(value2) {
          var type = typeof value2;
          return value2 != null && (type == "object" || type == "function");
        }
        function isObjectLike3(value2) {
          return value2 != null && typeof value2 == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch2(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value2) {
          return isNumber5(value2) && value2 != +value2;
        }
        function isNative(value2) {
          if (isMaskable(value2)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value2);
        }
        function isNull2(value2) {
          return value2 === null;
        }
        function isNil3(value2) {
          return value2 == null;
        }
        function isNumber5(value2) {
          return typeof value2 == "number" || isObjectLike3(value2) && baseGetTag(value2) == numberTag;
        }
        function isPlainObject4(value2) {
          if (!isObjectLike3(value2) || baseGetTag(value2) != objectTag) {
            return false;
          }
          var proto = getPrototype(value2);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value2) {
          return isInteger3(value2) && value2 >= -MAX_SAFE_INTEGER && value2 <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString5(value2) {
          return typeof value2 == "string" || !isArray4(value2) && isObjectLike3(value2) && baseGetTag(value2) == stringTag;
        }
        function isSymbol(value2) {
          return typeof value2 == "symbol" || isObjectLike3(value2) && baseGetTag(value2) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined3(value2) {
          return value2 === undefined2;
        }
        function isWeakMap(value2) {
          return isObjectLike3(value2) && getTag(value2) == weakMapTag;
        }
        function isWeakSet(value2) {
          return isObjectLike3(value2) && baseGetTag(value2) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value2, other) {
          return value2 <= other;
        });
        function toArray(value2) {
          if (!value2) {
            return [];
          }
          if (isArrayLike2(value2)) {
            return isString5(value2) ? stringToArray(value2) : copyArray(value2);
          }
          if (symIterator && value2[symIterator]) {
            return iteratorToArray(value2[symIterator]());
          }
          var tag = getTag(value2), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values4;
          return func(value2);
        }
        function toFinite(value2) {
          if (!value2) {
            return value2 === 0 ? value2 : 0;
          }
          value2 = toNumber(value2);
          if (value2 === INFINITY || value2 === -INFINITY) {
            var sign3 = value2 < 0 ? -1 : 1;
            return sign3 * MAX_INTEGER;
          }
          return value2 === value2 ? value2 : 0;
        }
        function toInteger(value2) {
          var result2 = toFinite(value2), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value2) {
          return value2 ? baseClamp(toInteger(value2), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value2) {
          if (typeof value2 == "number") {
            return value2;
          }
          if (isSymbol(value2)) {
            return NAN;
          }
          if (isObject6(value2)) {
            var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
            value2 = isObject6(other) ? other + "" : other;
          }
          if (typeof value2 != "string") {
            return value2 === 0 ? value2 : +value2;
          }
          value2 = baseTrim(value2);
          var isBinary = reIsBinary.test(value2);
          return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
        }
        function toPlainObject(value2) {
          return copyObject(value2, keysIn(value2));
        }
        function toSafeInteger(value2) {
          return value2 ? baseClamp(toInteger(value2), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value2 === 0 ? value2 : 0;
        }
        function toString5(value2) {
          return value2 == null ? "" : baseToString(value2);
        }
        var assign3 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike2(source)) {
            copyObject(source, keys2(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys2(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create8(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults4 = baseRest(function(object, sources) {
          object = Object2(object);
          var index3 = -1;
          var length5 = sources.length;
          var guard = length5 > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length5 = 1;
          }
          while (++index3 < length5) {
            var source = sources[index3];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value2 = object[key];
              if (value2 === undefined2 || eq(value2, objectProto3[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith2, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys2(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get4(object, path2, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path2);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        function hasIn(object, path2) {
          return object != null && hasPath(object, path2, baseHasIn);
        }
        var invert5 = createInverter(function(result2, value2, key) {
          if (value2 != null && typeof value2.toString != "function") {
            value2 = nativeObjectToString.call(value2);
          }
          result2[value2] = key;
        }, constant4(identity8));
        var invertBy = createInverter(function(result2, value2, key) {
          if (value2 != null && typeof value2.toString != "function") {
            value2 = nativeObjectToString.call(value2);
          }
          if (hasOwnProperty2.call(result2, value2)) {
            result2[value2].push(key);
          } else {
            result2[value2] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys2(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value2, key, object2) {
            baseAssignValue(result2, iteratee2(value2, key, object2), value2);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value2, key, object2) {
            baseAssignValue(result2, key, iteratee2(value2, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit3 = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path2) {
            path2 = castPath(path2, object);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length5 = paths.length;
          while (length5--) {
            baseUnset(result2, paths[length5]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate4(getIteratee(predicate)));
        }
        var pick3 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value2, path2) {
            return predicate(value2, path2[0]);
          });
        }
        function result(object, path2, defaultValue) {
          path2 = castPath(path2, object);
          var index3 = -1, length5 = path2.length;
          if (!length5) {
            length5 = 1;
            object = undefined2;
          }
          while (++index3 < length5) {
            var value2 = object == null ? undefined2 : object[toKey(path2[index3])];
            if (value2 === undefined2) {
              index3 = length5;
              value2 = defaultValue;
            }
            object = isFunction4(value2) ? value2.call(object) : value2;
          }
          return object;
        }
        function set10(object, path2, value2) {
          return object == null ? object : baseSet(object, path2, value2);
        }
        function setWith(object, path2, value2, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path2, value2, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object, iteratee2, accumulator) {
          var isArr = isArray4(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject6(object)) {
              accumulator = isFunction4(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value2, index3, object2) {
            return iteratee2(accumulator, value2, index3, object2);
          });
          return accumulator;
        }
        function unset(object, path2) {
          return object == null ? true : baseUnset(object, path2);
        }
        function update2(object, path2, updater) {
          return object == null ? object : baseUpdate(object, path2, castFunction(updater));
        }
        function updateWith(object, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
        }
        function values4(object) {
          return object == null ? [] : baseValues(object, keys2(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp3(number3, lower2, upper2) {
          if (upper2 === undefined2) {
            upper2 = lower2;
            lower2 = undefined2;
          }
          if (upper2 !== undefined2) {
            upper2 = toNumber(upper2);
            upper2 = upper2 === upper2 ? upper2 : 0;
          }
          if (lower2 !== undefined2) {
            lower2 = toNumber(lower2);
            lower2 = lower2 === lower2 ? lower2 : 0;
          }
          return baseClamp(toNumber(number3), lower2, upper2);
        }
        function inRange2(number3, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number3 = toNumber(number3);
          return baseInRange(number3, start, end);
        }
        function random5(lower2, upper2, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper2, floating)) {
            upper2 = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper2 == "boolean") {
              floating = upper2;
              upper2 = undefined2;
            } else if (typeof lower2 == "boolean") {
              floating = lower2;
              lower2 = undefined2;
            }
          }
          if (lower2 === undefined2 && upper2 === undefined2) {
            lower2 = 0;
            upper2 = 1;
          } else {
            lower2 = toFinite(lower2);
            if (upper2 === undefined2) {
              upper2 = lower2;
              lower2 = 0;
            } else {
              upper2 = toFinite(upper2);
            }
          }
          if (lower2 > upper2) {
            var temp = lower2;
            lower2 = upper2;
            upper2 = temp;
          }
          if (floating || lower2 % 1 || upper2 % 1) {
            var rand = nativeRandom();
            return nativeMin(lower2 + rand * (upper2 - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper2);
          }
          return baseRandom(lower2, upper2);
        }
        var camelCase2 = createCompounder(function(result2, word2, index3) {
          word2 = word2.toLowerCase();
          return result2 + (index3 ? capitalize(word2) : word2);
        });
        function capitalize(string) {
          return upperFirst2(toString5(string).toLowerCase());
        }
        function deburr(string) {
          string = toString5(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString5(string);
          target = baseToString(target);
          var length5 = string.length;
          position = position === undefined2 ? length5 : baseClamp(toInteger(position), 0, length5);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString5(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString5(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase2 = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? "-" : "") + word2.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? " " : "") + word2.toLowerCase();
        });
        var lowerFirst2 = createCaseFirst("toLowerCase");
        function pad3(string, length5, chars) {
          string = toString5(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          if (!length5 || strLength >= length5) {
            return string;
          }
          var mid2 = (length5 - strLength) / 2;
          return createPadding(nativeFloor(mid2), chars) + string + createPadding(nativeCeil(mid2), chars);
        }
        function padEnd(string, length5, chars) {
          string = toString5(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          return length5 && strLength < length5 ? string + createPadding(length5 - strLength, chars) : string;
        }
        function padStart(string, length5, chars) {
          string = toString5(string);
          length5 = toInteger(length5);
          var strLength = length5 ? stringSize(string) : 0;
          return length5 && strLength < length5 ? createPadding(length5 - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString5(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n2, guard) {
          if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString5(string), n2);
        }
        function replace() {
          var args = arguments, string = toString5(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? "_" : "") + word2.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString5(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? " " : "") + upperFirst2(word2);
        });
        function startsWith2(string, target, position) {
          string = toString5(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString5(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index3 = 0, interpolate4 = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate4.source + "|" + (interpolate4 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index3, offset2).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index3 = offset2 + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value2) {
          return toString5(value2).toLowerCase();
        }
        function toUpper(value2) {
          return toString5(value2).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString5(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString5(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString5(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length5 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject6(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length5 = "length" in options ? toInteger(options.length) : length5;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString5(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length5 >= strLength) {
            return string;
          }
          var end = length5 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString5(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index3 = result2.lastIndexOf(separator);
            if (index3 > -1) {
              result2 = result2.slice(0, index3);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString5(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word2, index3) {
          return result2 + (index3 ? " " : "") + word2.toUpperCase();
        });
        var upperFirst2 = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString5(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e3) {
            return isError(e3) ? e3 : new Error2(e3);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs2) {
          var length5 = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
          pairs2 = !length5 ? [] : arrayMap(pairs2, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index3 = -1;
            while (++index3 < length5) {
              var pair = pairs2[index3];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant4(value2) {
          return function() {
            return value2;
          };
        }
        function defaultTo(value2, defaultValue) {
          return value2 == null || value2 !== value2 ? defaultValue : value2;
        }
        var flow5 = createFlow();
        var flowRight = createFlow(true);
        function identity8(value2) {
          return value2;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object) {
            return baseInvoke(object, path2, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path2) {
            return baseInvoke(object, path2, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject6(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject6(options) && "chain" in options) || !!options.chain, isFunc = isFunction4(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop3() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object) {
          return function(path2) {
            return object == null ? undefined2 : baseGet(object, path2);
          };
        }
        var range3 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index3 = MAX_ARRAY_LENGTH, length5 = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length5, iteratee2);
          while (++index3 < n2) {
            iteratee2(index3);
          }
          return result2;
        }
        function toPath(value2) {
          if (isArray4(value2)) {
            return arrayMap(value2, toKey);
          }
          return isSymbol(value2) ? [value2] : copyArray(stringToPath(toString5(value2)));
        }
        function uniqueId3(prefix) {
          var id4 = ++idCounter;
          return toString5(prefix) + id4;
        }
        var add10 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil6 = createRound("ceil");
        var divide6 = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor4 = createRound("floor");
        function max11(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity8, baseGt) : undefined2;
        }
        function maxBy2(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean3(array2) {
          return baseMean(array2, identity8);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min10(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity8, baseLt) : undefined2;
        }
        function minBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply7 = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round6 = createRound("round");
        var subtract6 = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum4(array2) {
          return array2 && array2.length ? baseSum(array2, identity8) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign3;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant4;
        lodash.countBy = countBy;
        lodash.create = create8;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce2;
        lodash.defaults = defaults4;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference2;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter3;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten4;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow5;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy3;
        lodash.initial = initial;
        lodash.intersection = intersection3;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert5;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys2;
        lodash.keysIn = keysIn;
        lodash.map = map5;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize5;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith2;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate4;
        lodash.nthArg = nthArg;
        lodash.omit = omit3;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition2;
        lodash.pick = pick3;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range3;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove2;
        lodash.rest = rest;
        lodash.reverse = reverse2;
        lodash.sampleSize = sampleSize;
        lodash.set = set10;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle2;
        lodash.slice = slice3;
        lodash.sortBy = sortBy2;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform2;
        lodash.unary = unary;
        lodash.union = union2;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq3;
        lodash.uniqBy = uniqBy2;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values4;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip2;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add10;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase2;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil6;
        lodash.clamp = clamp3;
        lodash.clone = clone8;
        lodash.cloneDeep = cloneDeep2;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide6;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every2;
        lodash.find = find6;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor4;
        lodash.forEach = forEach4;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get4;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head3;
        lodash.identity = identity8;
        lodash.includes = includes2;
        lodash.indexOf = indexOf5;
        lodash.inRange = inRange2;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray4;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike2;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean3;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate2;
        lodash.isElement = isElement4;
        lodash.isEmpty = isEmpty3;
        lodash.isEqual = isEqual3;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction4;
        lodash.isInteger = isInteger3;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch2;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil3;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber5;
        lodash.isObject = isObject6;
        lodash.isObjectLike = isObjectLike3;
        lodash.isPlainObject = isPlainObject4;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString5;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined3;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase2;
        lodash.last = last5;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst2;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max11;
        lodash.maxBy = maxBy2;
        lodash.mean = mean3;
        lodash.meanBy = meanBy;
        lodash.min = min10;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply7;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop3;
        lodash.now = now2;
        lodash.pad = pad3;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random5;
        lodash.reduce = reduce4;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round6;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size3;
        lodash.snakeCase = snakeCase;
        lodash.some = some3;
        lodash.sortedIndex = sortedIndex2;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith2;
        lodash.subtract = subtract6;
        lodash.sum = sum4;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString5;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId3;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst2;
        lodash.each = forEach4;
        lodash.eachRight = forEachRight;
        lodash.first = head3;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index3) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index3 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index3) {
          var type = index3 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index3) {
          var takeName = "take" + (index3 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index3) {
          var dropName = "drop" + (index3 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity8);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value2) {
            return baseInvoke(value2, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate4(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray4(value2);
            var interceptor = function(value3) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value3], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value2 = onlyLazy ? value2 : new LazyWrapper(this);
              var result2 = func.apply(value2, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value2 = this.value();
              return func.apply(isArray4(value2) ? value2 : [], args);
            }
            return this[chainName](function(value3) {
              return func.apply(isArray4(value3) ? value3 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root2._ = _2;
      }
    }).call(exports);
  }
});

// node_modules/@antv/g2/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AREA_CLASS_NAME: () => AREA_CLASS_NAME,
  Academy: () => Academy,
  Bin: () => Bin,
  BinX: () => BinX,
  COMPONENT_CLASS_NAME: () => COMPONENT_CLASS_NAME,
  Chart: () => Chart2,
  ChartEvent: () => ChartEvent,
  Classic: () => Classic,
  ClassicDark: () => ClassicDark,
  Dark: () => Dark,
  DiffY: () => DiffY,
  DodgeX: () => DodgeX,
  ELEMENT_CLASS_NAME: () => ELEMENT_CLASS_NAME,
  Filter: () => Filter,
  FlexX: () => FlexX,
  Group: () => Group,
  GroupColor: () => GroupColor,
  GroupX: () => GroupX,
  GroupY: () => GroupY,
  Jitter: () => Jitter,
  JitterX: () => JitterX,
  JitterY: () => JitterY,
  LABEL_CLASS_NAME: () => LABEL_CLASS_NAME,
  LABEL_LAYER_CLASS_NAME: () => LABEL_LAYER_CLASS_NAME,
  Light: () => Light,
  LinearAxis: () => LinearAxis,
  MAIN_LAYER_CLASS_NAME: () => MAIN_LAYER_CLASS_NAME,
  MASK_CLASS_NAME: () => MASK_CLASS_NAME,
  MaybeDefaultX: () => MaybeDefaultX,
  MaybeDefaultY: () => MaybeDefaultY,
  MaybeFunctionAttribute: () => MaybeFunctionAttribute,
  MaybeGradient: () => MaybeGradient,
  MaybeIdentityX: () => MaybeIdentityX,
  MaybeIdentityY: () => MaybeIdentityY,
  MaybeKey: () => MaybeKey,
  MaybeSeries: () => MaybeSeries,
  MaybeSize: () => MaybeSize,
  MaybeStackY: () => MaybeStackY,
  MaybeTitle: () => MaybeTitle,
  MaybeTooltip: () => MaybeTooltip,
  MaybeTuple: () => MaybeTuple,
  MaybeTupleX: () => MaybeTupleX,
  MaybeTupleY: () => MaybeTupleY,
  MaybeVisualPosition: () => MaybeVisualPosition,
  MaybeZeroPadding: () => MaybeZeroPadding,
  MaybeZeroX: () => MaybeZeroX,
  MaybeZeroY: () => MaybeZeroY,
  MaybeZeroY1: () => MaybeZeroY1,
  MaybeZeroZ: () => MaybeZeroZ,
  NormalizeY: () => NormalizeY,
  PLOT_CLASS_NAME: () => PLOT_CLASS_NAME,
  Pack: () => Pack,
  Runtime: () => Runtime,
  Sample: () => Sample,
  Select: () => Select,
  SelectX: () => SelectX,
  SelectY: () => SelectY,
  Selection: () => Selection,
  SortColor: () => SortColor,
  SortX: () => SortX,
  SortY: () => SortY,
  StackEnter: () => StackEnter,
  StackY: () => StackY,
  SymmetryY: () => SymmetryY,
  VIEW_CLASS_NAME: () => VIEW_CLASS_NAME,
  corelib: () => corelib,
  dataOf: () => dataOf,
  extend: () => extend5,
  geolib: () => geolib,
  graphlib: () => graphlib,
  litelib: () => litelib,
  plotlib: () => plotlib,
  register: () => register,
  render: () => render,
  renderToMountedElement: () => renderToMountedElement,
  select: () => select,
  selectG2Elements: () => selectG2Elements,
  selectPlotArea: () => selectPlotArea,
  seriesOf: () => seriesOf,
  stdlib: () => stdlib
});

// node_modules/@antv/g2/esm/coordinate/cartesian.js
var Cartesian = () => [["cartesian"]];
Cartesian.props = {};

// node_modules/@antv/g2/esm/utils/angle.js
function convertAngles(startAngle, endAngle) {
  startAngle = startAngle % (2 * Math.PI);
  endAngle = endAngle % (2 * Math.PI);
  if (startAngle < 0) {
    startAngle = 2 * Math.PI + startAngle;
  }
  if (endAngle < 0) {
    endAngle = 2 * Math.PI + endAngle;
  }
  if (startAngle >= endAngle) {
    endAngle = endAngle + 2 * Math.PI;
  }
  return {
    startAngle,
    endAngle
  };
}

// node_modules/@antv/g2/esm/coordinate/polar.js
var getPolarOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  const polarOption = Object.assign(Object.assign({}, defaultOptions), options);
  return Object.assign(Object.assign({}, polarOption), convertAngles(polarOption.startAngle, polarOption.endAngle));
};
var Polar = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getPolarOptions(options);
  return [
    ["translate", 0, 0.5],
    ["reflect.y"],
    ["translate", 0, -0.5],
    ["polar", startAngle, endAngle, innerRadius, outerRadius]
  ];
};
Polar.props = {};

// node_modules/@antv/g2/esm/coordinate/helix.js
var Helix = ({ startAngle = 0, endAngle = Math.PI * 6, innerRadius = 0, outerRadius = 1 }) => [
  ["translate", 0.5, 0.5],
  ["reflect.y"],
  ["translate", -0.5, -0.5],
  ["helix", startAngle, endAngle, innerRadius, outerRadius]
];
Helix.props = {};

// node_modules/@antv/g2/esm/coordinate/transpose.js
var Transpose = () => [
  ["transpose"],
  ["translate", 0.5, 0.5],
  ["reflect.x"],
  ["translate", -0.5, -0.5]
];
Transpose.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/theta.js
var getThetaOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Theta = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getThetaOptions(options);
  return [
    ...Transpose(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Theta.props = {};

// node_modules/@antv/g2/esm/coordinate/radial.js
var getRadialOptions = (options = {}) => {
  const defaultOptions = {
    startAngle: -Math.PI / 2,
    endAngle: Math.PI * 3 / 2,
    innerRadius: 0,
    outerRadius: 1
  };
  return Object.assign(Object.assign({}, defaultOptions), options);
};
var Radial = (options) => {
  const { startAngle, endAngle, innerRadius, outerRadius } = getRadialOptions(options);
  return [
    ["transpose"],
    ["translate", 0.5, 0.5],
    ["reflect"],
    ["translate", -0.5, -0.5],
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radial.props = {};

// node_modules/@antv/g2/esm/coordinate/parallel.js
var Parallel = () => [["parallel", 0, 1, 0, 1]];
Parallel.props = {};

// node_modules/@antv/g2/esm/coordinate/fisheye.js
var Fisheye = ({ focusX = 0, focusY = 0, distortionX = 2, distortionY = 2, visual = false }) => [["fisheye", focusX, focusY, distortionX, distortionY, visual]];
Fisheye.props = { transform: true };

// node_modules/@antv/g2/esm/coordinate/radar.js
var Radar = (options) => {
  const { startAngle = -Math.PI / 2, endAngle = Math.PI * 3 / 2, innerRadius = 0, outerRadius = 1 } = options;
  return [
    ...Parallel(),
    ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
  ];
};
Radar.props = {};

// node_modules/@antv/g2/esm/encode/constant.js
var Constant = ({ value: value2 }) => {
  return (data2) => data2.map(() => value2);
};
Constant.props = {};

// node_modules/@antv/g2/esm/encode/transform.js
var Transform = ({ value: value2 }) => {
  return (data2) => data2.map(value2);
};
Transform.props = {};

// node_modules/@antv/g2/esm/encode/field.js
var Field = ({ value: value2 }) => {
  return (data2) => data2.map((d4) => d4[value2]);
};
Field.props = {};

// node_modules/@antv/g2/esm/encode/column.js
var Column = ({ value: value2 }) => {
  return () => value2;
};
Column.props = {};

// node_modules/@antv/util/esm/color/arr2rgb.js
function toHex(value2) {
  var x16Value = Math.round(value2).toString(16);
  return x16Value.length === 1 ? "0".concat(x16Value) : x16Value;
}
function arr2rgb(arr) {
  return "#".concat(toHex(arr[0])).concat(toHex(arr[1])).concat(toHex(arr[2]));
}

// node_modules/@antv/util/esm/lodash/is-array-like.js
var isArrayLike = function(value2) {
  return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
};
var is_array_like_default = isArrayLike;

// node_modules/@antv/util/esm/lodash/filter.js
var filter = function(arr, func) {
  if (!is_array_like_default(arr)) {
    return arr;
  }
  var result = [];
  for (var index3 = 0; index3 < arr.length; index3++) {
    var value2 = arr[index3];
    if (func(value2, index3)) {
      result.push(value2);
    }
  }
  return result;
};
var filter_default = filter;

// node_modules/@antv/util/esm/lodash/is-function.js
function isFunction(value2) {
  return typeof value2 === "function";
}

// node_modules/@antv/util/esm/lodash/is-nil.js
function isNil(value2) {
  return value2 === null || value2 === void 0;
}

// node_modules/@antv/util/esm/lodash/is-array.js
function isArray(value2) {
  return Array.isArray(value2);
}

// node_modules/@antv/util/esm/lodash/is-object.js
var is_object_default = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/util/esm/lodash/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray(elements)) {
    for (var i2 = 0, len5 = elements.length; i2 < len5; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// node_modules/@antv/util/esm/lodash/keys.js
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result = [];
  each_default(obj, function(value2, key) {
    if (!(isFunction(obj) && key === "prototype")) {
      result.push(key);
    }
  });
  return result;
};
var keys_default = keys;

// node_modules/@antv/util/esm/lodash/is-match.js
function isMatch(obj, attrs) {
  var _keys = keys_default(attrs);
  var length5 = _keys.length;
  if (isNil(obj))
    return !length5;
  for (var i2 = 0; i2 < length5; i2 += 1) {
    var key = _keys[i2];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default = isMatch;

// node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default = isObjectLike;

// node_modules/@antv/util/esm/lodash/is-type.js
var toString = {}.toString;
var isType = function(value2, type) {
  return toString.call(value2) === "[object " + type + "]";
};
var is_type_default = isType;

// node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject = function(value2) {
  if (!is_object_like_default(value2) || !is_type_default(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default = isPlainObject;

// node_modules/@antv/util/esm/lodash/find.js
function find(arr, predicate) {
  if (!isArray(arr))
    return null;
  var _predicate;
  if (isFunction(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default(predicate)) {
    _predicate = function(a5) {
      return is_match_default(a5, predicate);
    };
  }
  if (_predicate) {
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      if (_predicate(arr[i2])) {
        return arr[i2];
      }
    }
  }
  return null;
}
var find_default = find;

// node_modules/@antv/util/esm/lodash/flatten.js
var flatten = function(arr) {
  if (!isArray(arr)) {
    return [];
  }
  var rst = [];
  for (var i2 = 0; i2 < arr.length; i2++) {
    rst = rst.concat(arr[i2]);
  }
  return rst;
};
var flatten_default = flatten;

// node_modules/@antv/util/esm/lodash/max.js
function max(arr) {
  if (!Array.isArray(arr))
    return -Infinity;
  var length5 = arr.length;
  if (!length5)
    return -Infinity;
  var max11 = arr[0];
  for (var i2 = 1; i2 < length5; i2++) {
    max11 = Math.max(max11, arr[i2]);
  }
  return max11;
}

// node_modules/@antv/util/esm/lodash/min.js
var min_default = function(arr) {
  if (!isArray(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};

// node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/@antv/util/esm/lodash/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/@antv/util/esm/lodash/reduce.js
var reduce = function(arr, fn, init) {
  if (!isArray(arr) && !is_plain_object_default(arr)) {
    return arr;
  }
  var result = init;
  each_default(arr, function(data2, i2) {
    result = fn(result, data2, i2);
  });
  return result;
};
var reduce_default = reduce;

// node_modules/@antv/util/esm/lodash/is-string.js
function isString(value2) {
  return typeof value2 === "string";
}

// node_modules/@antv/util/esm/lodash/last.js
function last(o2) {
  if (is_array_like_default(o2)) {
    var arr = o2;
    return arr[arr.length - 1];
  }
  return void 0;
}

// node_modules/@antv/util/esm/lodash/clamp.js
var clamp = function(a5, min10, max11) {
  if (a5 < min10) {
    return min10;
  } else if (a5 > max11) {
    return max11;
  }
  return a5;
};
var clamp_default = clamp;

// node_modules/@antv/util/esm/lodash/is-number.js
function isNumber(value2) {
  return typeof value2 === "number";
}

// node_modules/@antv/util/esm/lodash/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a5, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return a5 === b || Math.abs(a5 - b) < precision;
}

// node_modules/@antv/util/esm/lodash/max-by.js
var max_by_default = function(arr, fn) {
  if (!isArray(arr)) {
    return void 0;
  }
  var maxItem;
  var max11 = -Infinity;
  for (var i2 = 0; i2 < arr.length; i2++) {
    var item = arr[i2];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v > max11) {
      maxItem = item;
      max11 = v;
    }
  }
  return maxItem;
};

// node_modules/@antv/util/esm/lodash/min-by.js
var min_by_default = function(arr, fn) {
  if (!isArray(arr)) {
    return void 0;
  }
  var minItem;
  var min10 = Infinity;
  for (var i2 = 0; i2 < arr.length; i2++) {
    var item = arr[i2];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v < min10) {
      minItem = item;
      min10 = v;
    }
  }
  return minItem;
};

// node_modules/@antv/util/esm/lodash/mod.js
var mod = function(n2, m3) {
  return (n2 % m3 + m3) % m3;
};
var mod_default = mod;

// node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/@antv/util/esm/lodash/to-string.js
var to_string_default = function(value2) {
  if (isNil(value2))
    return "";
  return value2.toString();
};

// node_modules/@antv/util/esm/lodash/lower-first.js
var lowerFirst = function(value2) {
  var str7 = to_string_default(value2);
  return str7.charAt(0).toLowerCase() + str7.substring(1);
};
var lower_first_default = lowerFirst;

// node_modules/@antv/util/esm/lodash/substitute.js
function substitute(str7, o2) {
  if (!str7 || !o2) {
    return str7;
  }
  return str7.replace(/\\?\{([^{}]+)\}/g, function(match, name2) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o2[name2] === void 0 ? "" : o2[name2];
  });
}
var substitute_default = substitute;

// node_modules/@antv/util/esm/lodash/upper-first.js
var upperFirst = function(value2) {
  var str7 = to_string_default(value2);
  return str7.charAt(0).toUpperCase() + str7.substring(1);
};
var upper_first_default = upperFirst;

// node_modules/@antv/util/esm/lodash/get-type.js
var toString2 = {}.toString;

// node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean = function(value2) {
  return is_type_default(value2, "Boolean");
};
var is_boolean_default = isBoolean;

// node_modules/@antv/util/esm/lodash/is-null.js
function isNull(value2) {
  return value2 === null;
}

// node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto = Object.prototype;

// node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined = function(value2) {
  return value2 === void 0;
};
var is_undefined_default = isUndefined;

// node_modules/@antv/util/esm/lodash/is-element.js
function isElement(value2) {
  return value2 instanceof Element || value2 instanceof Document;
}

// node_modules/@antv/util/esm/lodash/mix.js
function _mix(dist5, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist5[key] = obj[key];
    }
  }
}
function mix(dist5, src1, src2, src3) {
  if (src1)
    _mix(dist5, src1);
  if (src2)
    _mix(dist5, src2);
  if (src3)
    _mix(dist5, src3);
  return dist5;
}

// node_modules/@antv/util/esm/lodash/clone.js
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (isArray(obj)) {
    rst = [];
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (typeof obj[i2] === "object" && obj[i2] != null) {
        rst[i2] = clone(obj[i2]);
      } else {
        rst[i2] = obj[i2];
      }
    }
  } else {
    rst = {};
    for (var k2 in obj) {
      if (typeof obj[k2] === "object" && obj[k2] != null) {
        rst[k2] = clone(obj[k2]);
      } else {
        rst[k2] = obj[k2];
      }
    }
  }
  return rst;
};
var clone_default = clone;

// node_modules/@antv/util/esm/lodash/debounce.js
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default = debounce;

// node_modules/@antv/util/esm/lodash/memoize.js
function flru(max11) {
  var num, curr, prev;
  var limit = max11 || 1;
  function keep(key, value2) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value2;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value2) {
      if (curr[key] !== void 0) {
        curr[key] = value2;
      } else {
        keep(key, value2);
      }
    }
  };
}
var CacheMap = /* @__PURE__ */ new Map();
function memoize(fn, resolver, maxSize) {
  if (maxSize === void 0) {
    maxSize = 128;
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    if (!CacheMap.has(fn))
      CacheMap.set(fn, flru(maxSize));
    var cache2 = CacheMap.get(fn);
    if (cache2.has(key))
      return cache2.get(key);
    var result = fn.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  return memoized;
}

// node_modules/@antv/util/esm/lodash/deep-mix.js
var MAX_MIX_LEVEL = 5;
function hasOwn(object, property) {
  if (Object.hasOwn) {
    return Object.hasOwn(object, property);
  }
  if (object == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
}
function _deepMix(dist5, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (hasOwn(src, key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default(value2)) {
        if (!is_plain_object_default(dist5[key])) {
          dist5[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist5[key], value2, level + 1, maxLevel);
        } else {
          dist5[key] = src[key];
        }
      } else if (isArray(value2)) {
        dist5[key] = [];
        dist5[key] = dist5[key].concat(value2);
      } else if (value2 !== void 0) {
        dist5[key] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    _deepMix(rst, args[i2]);
  }
  return rst;
};
var deep_mix_default = deepMix;

// node_modules/@antv/util/esm/lodash/index-of.js
var indexOf2 = function(arr, obj) {
  if (!is_array_like_default(arr)) {
    return -1;
  }
  var m3 = Array.prototype.indexOf;
  if (m3) {
    return m3.call(arr, obj);
  }
  var index3 = -1;
  for (var i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2] === obj) {
      index3 = i2;
      break;
    }
  }
  return index3;
};
var index_of_default = indexOf2;

// node_modules/@antv/util/esm/lodash/is-equal.js
var isEqual = function(value2, other) {
  if (value2 === other) {
    return true;
  }
  if (!value2 || !other) {
    return false;
  }
  if (isString(value2) || isString(other)) {
    return false;
  }
  if (is_array_like_default(value2) || is_array_like_default(other)) {
    if (value2.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i2 = 0; i2 < value2.length; i2++) {
      rst = isEqual(value2[i2], other[i2]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (is_object_like_default(value2) || is_object_like_default(other)) {
    var valueKeys = Object.keys(value2);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i2 = 0; i2 < valueKeys.length; i2++) {
      rst = isEqual(value2[valueKeys[i2]], other[valueKeys[i2]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var is_equal_default = isEqual;

// node_modules/@antv/util/esm/lodash/map-values.js
var identity = function(v) {
  return v;
};
var map_values_default = function(object, func) {
  if (func === void 0) {
    func = identity;
  }
  var r2 = {};
  if (is_object_default(object) && !isNil(object)) {
    Object.keys(object).forEach(function(key) {
      r2[key] = func(object[key], key);
    });
  }
  return r2;
};

// node_modules/@antv/util/esm/lodash/get.js
var get_default = function(obj, key, defaultValue) {
  var p3 = 0;
  var keyArr = isString(key) ? key.split(".") : key;
  while (obj && p3 < keyArr.length) {
    obj = obj[keyArr[p3++]];
  }
  return obj === void 0 || p3 < keyArr.length ? defaultValue : obj;
};

// node_modules/@antv/util/esm/lodash/set.js
var set_default = function(obj, path2, value2) {
  var o2 = obj;
  var keyArr = isString(path2) ? path2.split(".") : path2;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!is_object_default(o2[key])) {
        o2[key] = isNumber(keyArr[idx + 1]) ? [] : {};
      }
      o2 = o2[key];
    } else {
      o2[key] = value2;
    }
  });
  return obj;
};

// node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var pick_default = function(object, keys2) {
  if (object === null || !is_plain_object_default(object)) {
    return {};
  }
  var result = {};
  each_default(keys2, function(key) {
    if (hasOwnProperty.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};

// node_modules/@antv/util/esm/lodash/omit.js
var omit_default = function(obj, keys2) {
  return reduce_default(obj, function(r2, curr, key) {
    if (!keys2.includes(key)) {
      r2[key] = curr;
    }
    return r2;
  }, {});
};

// node_modules/@antv/util/esm/lodash/throttle.js
var throttle_default = function(func, wait, options) {
  var timeout2, context, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func.apply(context, args);
    if (!timeout2)
      context = args = null;
  };
  var throttled = function() {
    var now2 = Date.now();
    if (!previous && options.leading === false)
      previous = now2;
    var remaining = wait - (now2 - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now2;
      result = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context = args = null;
  };
  return throttled;
};

// node_modules/@antv/util/esm/lodash/noop.js
var noop_default = function() {
};

// node_modules/@antv/util/esm/lodash/identity.js
var identity_default = function(v) {
  return v;
};

// node_modules/@antv/util/esm/lodash/size.js
function size(o2) {
  if (isNil(o2)) {
    return 0;
  }
  if (is_array_like_default(o2)) {
    return o2.length;
  }
  return Object.keys(o2).length;
}

// node_modules/@antv/util/esm/lodash/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_13() {
      this.map = {};
    }
    default_13.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_13.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_13.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_13.prototype.clear = function() {
      this.map = {};
    };
    default_13.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_13.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_13;
  }()
);

// node_modules/@antv/util/esm/color/torgb.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
function getTmp() {
  var i2 = document.getElementById("antv-web-colour-picker");
  if (i2) {
    return i2;
  }
  i2 = document.createElement("i");
  i2.id = "antv-web-colour-picker";
  i2.title = "Web Colour Picker";
  i2.style.display = "none";
  document.body.appendChild(i2);
  return i2;
}
function toRGBString(color3) {
  if (color3[0] === "#" && color3.length === 7) {
    return color3;
  }
  var iEl = getTmp();
  iEl.style.color = color3;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s4) {
    return Number(s4);
  });
  rst = arr2rgb(cArray);
  return rst;
}
var toRGB = memoize(toRGBString, function(color3) {
  return color3;
}, 256);

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var ANGLE_ORDER = "zyx";
function round(a5) {
  if (a5 >= 0) return Math.round(a5);
  return a5 % 0.5 === 0 ? Math.floor(a5) : Math.round(a5);
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity2,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a5) {
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  out[3] = a5[4];
  out[4] = a5[5];
  out[5] = a5[6];
  out[6] = a5[8];
  out[7] = a5[9];
  out[8] = a5[10];
  return out;
}
function clone2(a5) {
  var out = new ARRAY_TYPE(9);
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  out[3] = a5[3];
  out[4] = a5[4];
  out[5] = a5[5];
  out[6] = a5[6];
  out[7] = a5[7];
  out[8] = a5[8];
  return out;
}
function copy(out, a5) {
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  out[3] = a5[3];
  out[4] = a5[4];
  out[5] = a5[5];
  out[6] = a5[6];
  out[7] = a5[7];
  out[8] = a5[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a5) {
  if (out === a5) {
    var a01 = a5[1], a02 = a5[2], a12 = a5[5];
    out[1] = a5[3];
    out[2] = a5[6];
    out[3] = a01;
    out[5] = a5[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a5[0];
    out[1] = a5[3];
    out[2] = a5[6];
    out[3] = a5[1];
    out[4] = a5[4];
    out[5] = a5[7];
    out[6] = a5[2];
    out[7] = a5[5];
    out[8] = a5[8];
  }
  return out;
}
function invert(out, a5) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2];
  var a10 = a5[3], a11 = a5[4], a12 = a5[5];
  var a20 = a5[6], a21 = a5[7], a22 = a5[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a5) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2];
  var a10 = a5[3], a11 = a5[4], a12 = a5[5];
  var a20 = a5[6], a21 = a5[7], a22 = a5[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a5) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2];
  var a10 = a5[3], a11 = a5[4], a12 = a5[5];
  var a20 = a5[6], a21 = a5[7], a22 = a5[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a5, b) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2];
  var a10 = a5[3], a11 = a5[4], a12 = a5[5];
  var a20 = a5[6], a21 = a5[7], a22 = a5[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a5, v) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2], a10 = a5[3], a11 = a5[4], a12 = a5[5], a20 = a5[6], a21 = a5[7], a22 = a5[8], x3 = v[0], y4 = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x3 * a00 + y4 * a10 + a20;
  out[7] = x3 * a01 + y4 * a11 + a21;
  out[8] = x3 * a02 + y4 * a12 + a22;
  return out;
}
function rotate(out, a5, rad2) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2], a10 = a5[3], a11 = a5[4], a12 = a5[5], a20 = a5[6], a21 = a5[7], a22 = a5[8], s4 = Math.sin(rad2), c6 = Math.cos(rad2);
  out[0] = c6 * a00 + s4 * a10;
  out[1] = c6 * a01 + s4 * a11;
  out[2] = c6 * a02 + s4 * a12;
  out[3] = c6 * a10 - s4 * a00;
  out[4] = c6 * a11 - s4 * a01;
  out[5] = c6 * a12 - s4 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a5, v) {
  var x3 = v[0], y4 = v[1];
  out[0] = x3 * a5[0];
  out[1] = x3 * a5[1];
  out[2] = x3 * a5[2];
  out[3] = y4 * a5[3];
  out[4] = y4 * a5[4];
  out[5] = y4 * a5[5];
  out[6] = a5[6];
  out[7] = a5[7];
  out[8] = a5[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad2) {
  var s4 = Math.sin(rad2), c6 = Math.cos(rad2);
  out[0] = c6;
  out[1] = s4;
  out[2] = 0;
  out[3] = -s4;
  out[4] = c6;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a5) {
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = 0;
  out[3] = a5[2];
  out[4] = a5[3];
  out[5] = 0;
  out[6] = a5[4];
  out[7] = a5[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x3 = q[0], y4 = q[1], z = q[2], w2 = q[3];
  var x22 = x3 + x3;
  var y22 = y4 + y4;
  var z2 = z + z;
  var xx = x3 * x22;
  var yx = y4 * x22;
  var yy = y4 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a5) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2], a03 = a5[3];
  var a10 = a5[4], a11 = a5[5], a12 = a5[6], a13 = a5[7];
  var a20 = a5[8], a21 = a5[9], a22 = a5[10], a23 = a5[11];
  var a30 = a5[12], a31 = a5[13], a32 = a5[14], a33 = a5[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a5) {
  return "mat3(" + a5[0] + ", " + a5[1] + ", " + a5[2] + ", " + a5[3] + ", " + a5[4] + ", " + a5[5] + ", " + a5[6] + ", " + a5[7] + ", " + a5[8] + ")";
}
function frob(a5) {
  return Math.sqrt(a5[0] * a5[0] + a5[1] * a5[1] + a5[2] * a5[2] + a5[3] * a5[3] + a5[4] * a5[4] + a5[5] * a5[5] + a5[6] * a5[6] + a5[7] * a5[7] + a5[8] * a5[8]);
}
function add(out, a5, b) {
  out[0] = a5[0] + b[0];
  out[1] = a5[1] + b[1];
  out[2] = a5[2] + b[2];
  out[3] = a5[3] + b[3];
  out[4] = a5[4] + b[4];
  out[5] = a5[5] + b[5];
  out[6] = a5[6] + b[6];
  out[7] = a5[7] + b[7];
  out[8] = a5[8] + b[8];
  return out;
}
function subtract(out, a5, b) {
  out[0] = a5[0] - b[0];
  out[1] = a5[1] - b[1];
  out[2] = a5[2] - b[2];
  out[3] = a5[3] - b[3];
  out[4] = a5[4] - b[4];
  out[5] = a5[5] - b[5];
  out[6] = a5[6] - b[6];
  out[7] = a5[7] - b[7];
  out[8] = a5[8] - b[8];
  return out;
}
function multiplyScalar(out, a5, b) {
  out[0] = a5[0] * b;
  out[1] = a5[1] * b;
  out[2] = a5[2] * b;
  out[3] = a5[3] * b;
  out[4] = a5[4] * b;
  out[5] = a5[5] * b;
  out[6] = a5[6] * b;
  out[7] = a5[7] * b;
  out[8] = a5[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a5, b, scale12) {
  out[0] = a5[0] + b[0] * scale12;
  out[1] = a5[1] + b[1] * scale12;
  out[2] = a5[2] + b[2] * scale12;
  out[3] = a5[3] + b[3] * scale12;
  out[4] = a5[4] + b[4] * scale12;
  out[5] = a5[5] + b[5] * scale12;
  out[6] = a5[6] + b[6] * scale12;
  out[7] = a5[7] + b[7] * scale12;
  out[8] = a5[8] + b[8] * scale12;
  return out;
}
function exactEquals(a5, b) {
  return a5[0] === b[0] && a5[1] === b[1] && a5[2] === b[2] && a5[3] === b[3] && a5[4] === b[4] && a5[5] === b[5] && a5[6] === b[6] && a5[7] === b[7] && a5[8] === b[8];
}
function equals(a5, b) {
  var a0 = a5[0], a1 = a5[1], a22 = a5[2], a32 = a5[3], a42 = a5[4], a52 = a5[5], a6 = a5[6], a7 = a5[7], a8 = a5[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a42 - b4) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a52 - b5) <= EPSILON * Math.max(1, Math.abs(a52), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  decompose: () => decompose,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity3,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone3(a5) {
  var out = new ARRAY_TYPE(16);
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  out[3] = a5[3];
  out[4] = a5[4];
  out[5] = a5[5];
  out[6] = a5[6];
  out[7] = a5[7];
  out[8] = a5[8];
  out[9] = a5[9];
  out[10] = a5[10];
  out[11] = a5[11];
  out[12] = a5[12];
  out[13] = a5[13];
  out[14] = a5[14];
  out[15] = a5[15];
  return out;
}
function copy2(out, a5) {
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  out[3] = a5[3];
  out[4] = a5[4];
  out[5] = a5[5];
  out[6] = a5[6];
  out[7] = a5[7];
  out[8] = a5[8];
  out[9] = a5[9];
  out[10] = a5[10];
  out[11] = a5[11];
  out[12] = a5[12];
  out[13] = a5[13];
  out[14] = a5[14];
  out[15] = a5[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a5) {
  if (out === a5) {
    var a01 = a5[1], a02 = a5[2], a03 = a5[3];
    var a12 = a5[6], a13 = a5[7];
    var a23 = a5[11];
    out[1] = a5[4];
    out[2] = a5[8];
    out[3] = a5[12];
    out[4] = a01;
    out[6] = a5[9];
    out[7] = a5[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a5[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a5[0];
    out[1] = a5[4];
    out[2] = a5[8];
    out[3] = a5[12];
    out[4] = a5[1];
    out[5] = a5[5];
    out[6] = a5[9];
    out[7] = a5[13];
    out[8] = a5[2];
    out[9] = a5[6];
    out[10] = a5[10];
    out[11] = a5[14];
    out[12] = a5[3];
    out[13] = a5[7];
    out[14] = a5[11];
    out[15] = a5[15];
  }
  return out;
}
function invert2(out, a5) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2], a03 = a5[3];
  var a10 = a5[4], a11 = a5[5], a12 = a5[6], a13 = a5[7];
  var a20 = a5[8], a21 = a5[9], a22 = a5[10], a23 = a5[11];
  var a30 = a5[12], a31 = a5[13], a32 = a5[14], a33 = a5[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a5) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2], a03 = a5[3];
  var a10 = a5[4], a11 = a5[5], a12 = a5[6], a13 = a5[7];
  var a20 = a5[8], a21 = a5[9], a22 = a5[10], a23 = a5[11];
  var a30 = a5[12], a31 = a5[13], a32 = a5[14], a33 = a5[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
  return out;
}
function determinant2(a5) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2], a03 = a5[3];
  var a10 = a5[4], a11 = a5[5], a12 = a5[6], a13 = a5[7];
  var a20 = a5[8], a21 = a5[9], a22 = a5[10], a23 = a5[11];
  var a30 = a5[12], a31 = a5[13], a32 = a5[14], a33 = a5[15];
  var b0 = a00 * a11 - a01 * a10;
  var b1 = a00 * a12 - a02 * a10;
  var b2 = a01 * a12 - a02 * a11;
  var b3 = a20 * a31 - a21 * a30;
  var b4 = a20 * a32 - a22 * a30;
  var b5 = a21 * a32 - a22 * a31;
  var b6 = a00 * b5 - a01 * b4 + a02 * b3;
  var b7 = a10 * b5 - a11 * b4 + a12 * b3;
  var b8 = a20 * b2 - a21 * b1 + a22 * b0;
  var b9 = a30 * b2 - a31 * b1 + a32 * b0;
  return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
}
function multiply2(out, a5, b) {
  var a00 = a5[0], a01 = a5[1], a02 = a5[2], a03 = a5[3];
  var a10 = a5[4], a11 = a5[5], a12 = a5[6], a13 = a5[7];
  var a20 = a5[8], a21 = a5[9], a22 = a5[10], a23 = a5[11];
  var a30 = a5[12], a31 = a5[13], a32 = a5[14], a33 = a5[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a5, v) {
  var x3 = v[0], y4 = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a5 === out) {
    out[12] = a5[0] * x3 + a5[4] * y4 + a5[8] * z + a5[12];
    out[13] = a5[1] * x3 + a5[5] * y4 + a5[9] * z + a5[13];
    out[14] = a5[2] * x3 + a5[6] * y4 + a5[10] * z + a5[14];
    out[15] = a5[3] * x3 + a5[7] * y4 + a5[11] * z + a5[15];
  } else {
    a00 = a5[0];
    a01 = a5[1];
    a02 = a5[2];
    a03 = a5[3];
    a10 = a5[4];
    a11 = a5[5];
    a12 = a5[6];
    a13 = a5[7];
    a20 = a5[8];
    a21 = a5[9];
    a22 = a5[10];
    a23 = a5[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x3 + a10 * y4 + a20 * z + a5[12];
    out[13] = a01 * x3 + a11 * y4 + a21 * z + a5[13];
    out[14] = a02 * x3 + a12 * y4 + a22 * z + a5[14];
    out[15] = a03 * x3 + a13 * y4 + a23 * z + a5[15];
  }
  return out;
}
function scale2(out, a5, v) {
  var x3 = v[0], y4 = v[1], z = v[2];
  out[0] = a5[0] * x3;
  out[1] = a5[1] * x3;
  out[2] = a5[2] * x3;
  out[3] = a5[3] * x3;
  out[4] = a5[4] * y4;
  out[5] = a5[5] * y4;
  out[6] = a5[6] * y4;
  out[7] = a5[7] * y4;
  out[8] = a5[8] * z;
  out[9] = a5[9] * z;
  out[10] = a5[10] * z;
  out[11] = a5[11] * z;
  out[12] = a5[12];
  out[13] = a5[13];
  out[14] = a5[14];
  out[15] = a5[15];
  return out;
}
function rotate2(out, a5, rad2, axis) {
  var x3 = axis[0], y4 = axis[1], z = axis[2];
  var len5 = Math.sqrt(x3 * x3 + y4 * y4 + z * z);
  var s4, c6, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x3 *= len5;
  y4 *= len5;
  z *= len5;
  s4 = Math.sin(rad2);
  c6 = Math.cos(rad2);
  t = 1 - c6;
  a00 = a5[0];
  a01 = a5[1];
  a02 = a5[2];
  a03 = a5[3];
  a10 = a5[4];
  a11 = a5[5];
  a12 = a5[6];
  a13 = a5[7];
  a20 = a5[8];
  a21 = a5[9];
  a22 = a5[10];
  a23 = a5[11];
  b00 = x3 * x3 * t + c6;
  b01 = y4 * x3 * t + z * s4;
  b02 = z * x3 * t - y4 * s4;
  b10 = x3 * y4 * t - z * s4;
  b11 = y4 * y4 * t + c6;
  b12 = z * y4 * t + x3 * s4;
  b20 = x3 * z * t + y4 * s4;
  b21 = y4 * z * t - x3 * s4;
  b22 = z * z * t + c6;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a5 !== out) {
    out[12] = a5[12];
    out[13] = a5[13];
    out[14] = a5[14];
    out[15] = a5[15];
  }
  return out;
}
function rotateX(out, a5, rad2) {
  var s4 = Math.sin(rad2);
  var c6 = Math.cos(rad2);
  var a10 = a5[4];
  var a11 = a5[5];
  var a12 = a5[6];
  var a13 = a5[7];
  var a20 = a5[8];
  var a21 = a5[9];
  var a22 = a5[10];
  var a23 = a5[11];
  if (a5 !== out) {
    out[0] = a5[0];
    out[1] = a5[1];
    out[2] = a5[2];
    out[3] = a5[3];
    out[12] = a5[12];
    out[13] = a5[13];
    out[14] = a5[14];
    out[15] = a5[15];
  }
  out[4] = a10 * c6 + a20 * s4;
  out[5] = a11 * c6 + a21 * s4;
  out[6] = a12 * c6 + a22 * s4;
  out[7] = a13 * c6 + a23 * s4;
  out[8] = a20 * c6 - a10 * s4;
  out[9] = a21 * c6 - a11 * s4;
  out[10] = a22 * c6 - a12 * s4;
  out[11] = a23 * c6 - a13 * s4;
  return out;
}
function rotateY(out, a5, rad2) {
  var s4 = Math.sin(rad2);
  var c6 = Math.cos(rad2);
  var a00 = a5[0];
  var a01 = a5[1];
  var a02 = a5[2];
  var a03 = a5[3];
  var a20 = a5[8];
  var a21 = a5[9];
  var a22 = a5[10];
  var a23 = a5[11];
  if (a5 !== out) {
    out[4] = a5[4];
    out[5] = a5[5];
    out[6] = a5[6];
    out[7] = a5[7];
    out[12] = a5[12];
    out[13] = a5[13];
    out[14] = a5[14];
    out[15] = a5[15];
  }
  out[0] = a00 * c6 - a20 * s4;
  out[1] = a01 * c6 - a21 * s4;
  out[2] = a02 * c6 - a22 * s4;
  out[3] = a03 * c6 - a23 * s4;
  out[8] = a00 * s4 + a20 * c6;
  out[9] = a01 * s4 + a21 * c6;
  out[10] = a02 * s4 + a22 * c6;
  out[11] = a03 * s4 + a23 * c6;
  return out;
}
function rotateZ(out, a5, rad2) {
  var s4 = Math.sin(rad2);
  var c6 = Math.cos(rad2);
  var a00 = a5[0];
  var a01 = a5[1];
  var a02 = a5[2];
  var a03 = a5[3];
  var a10 = a5[4];
  var a11 = a5[5];
  var a12 = a5[6];
  var a13 = a5[7];
  if (a5 !== out) {
    out[8] = a5[8];
    out[9] = a5[9];
    out[10] = a5[10];
    out[11] = a5[11];
    out[12] = a5[12];
    out[13] = a5[13];
    out[14] = a5[14];
    out[15] = a5[15];
  }
  out[0] = a00 * c6 + a10 * s4;
  out[1] = a01 * c6 + a11 * s4;
  out[2] = a02 * c6 + a12 * s4;
  out[3] = a03 * c6 + a13 * s4;
  out[4] = a10 * c6 - a00 * s4;
  out[5] = a11 * c6 - a01 * s4;
  out[6] = a12 * c6 - a02 * s4;
  out[7] = a13 * c6 - a03 * s4;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad2, axis) {
  var x3 = axis[0], y4 = axis[1], z = axis[2];
  var len5 = Math.sqrt(x3 * x3 + y4 * y4 + z * z);
  var s4, c6, t;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x3 *= len5;
  y4 *= len5;
  z *= len5;
  s4 = Math.sin(rad2);
  c6 = Math.cos(rad2);
  t = 1 - c6;
  out[0] = x3 * x3 * t + c6;
  out[1] = y4 * x3 * t + z * s4;
  out[2] = z * x3 * t - y4 * s4;
  out[3] = 0;
  out[4] = x3 * y4 * t - z * s4;
  out[5] = y4 * y4 * t + c6;
  out[6] = z * y4 * t + x3 * s4;
  out[7] = 0;
  out[8] = x3 * z * t + y4 * s4;
  out[9] = y4 * z * t - x3 * s4;
  out[10] = z * z * t + c6;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad2) {
  var s4 = Math.sin(rad2);
  var c6 = Math.cos(rad2);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c6;
  out[6] = s4;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s4;
  out[10] = c6;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad2) {
  var s4 = Math.sin(rad2);
  var c6 = Math.cos(rad2);
  out[0] = c6;
  out[1] = 0;
  out[2] = -s4;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s4;
  out[9] = 0;
  out[10] = c6;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad2) {
  var s4 = Math.sin(rad2);
  var c6 = Math.cos(rad2);
  out[0] = c6;
  out[1] = s4;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s4;
  out[5] = c6;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x3 = q[0], y4 = q[1], z = q[2], w2 = q[3];
  var x22 = x3 + x3;
  var y22 = y4 + y4;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y4 * y22;
  var yz = y4 * z2;
  var zz = z * z2;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a5) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a5[0], by = -a5[1], bz = -a5[2], bw = a5[3], ax = a5[4], ay = a5[5], az = a5[6], aw = a5[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a5, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function decompose(out_r, out_t, out_s, mat) {
  out_t[0] = mat[12];
  out_t[1] = mat[13];
  out_t[2] = mat[14];
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  var is1 = 1 / out_s[0];
  var is2 = 1 / out_s[1];
  var is3 = 1 / out_s[2];
  var sm11 = m11 * is1;
  var sm12 = m12 * is2;
  var sm13 = m13 * is3;
  var sm21 = m21 * is1;
  var sm22 = m22 * is2;
  var sm23 = m23 * is3;
  var sm31 = m31 * is1;
  var sm32 = m32 * is2;
  var sm33 = m33 * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out_r[3] = 0.25 * S;
    out_r[0] = (sm23 - sm32) / S;
    out_r[1] = (sm31 - sm13) / S;
    out_r[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out_r[3] = (sm23 - sm32) / S;
    out_r[0] = 0.25 * S;
    out_r[1] = (sm12 + sm21) / S;
    out_r[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out_r[3] = (sm31 - sm13) / S;
    out_r[0] = (sm12 + sm21) / S;
    out_r[1] = 0.25 * S;
    out_r[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out_r[3] = (sm12 - sm21) / S;
    out_r[0] = (sm31 + sm13) / S;
    out_r[1] = (sm23 + sm32) / S;
    out_r[2] = 0.25 * S;
  }
  return out_r;
}
function fromRotationTranslationScale(out, q, v, s4) {
  var x3 = q[0], y4 = q[1], z = q[2], w2 = q[3];
  var x22 = x3 + x3;
  var y22 = y4 + y4;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y4 * y22;
  var yz = y4 * z2;
  var zz = z * z2;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z2;
  var sx = s4[0];
  var sy = s4[1];
  var sz = s4[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s4, o2) {
  var x3 = q[0], y4 = q[1], z = q[2], w2 = q[3];
  var x22 = x3 + x3;
  var y22 = y4 + y4;
  var z2 = z + z;
  var xx = x3 * x22;
  var xy = x3 * y22;
  var xz = x3 * z2;
  var yy = y4 * y22;
  var yz = y4 * z2;
  var zz = z * z2;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z2;
  var sx = s4[0];
  var sy = s4[1];
  var sz = s4[2];
  var ox = o2[0];
  var oy = o2[1];
  var oz = o2[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x3 = q[0], y4 = q[1], z = q[2], w2 = q[3];
  var x22 = x3 + x3;
  var y22 = y4 + y4;
  var z2 = z + z;
  var xx = x3 * x22;
  var yx = y4 * x22;
  var yy = y4 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left2, right2, bottom, top, near, far) {
  var rl = 1 / (right2 - left2);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right2 + left2) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2);
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    var nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left2, right2, bottom, top, near, far) {
  var lr = 1 / (left2 - right2);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left2 + right2) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left2, right2, bottom, top, near, far) {
  var lr = 1 / (left2 - right2);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left2 + right2) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center2, up) {
  var x05, x12, x22, y05, y12, y22, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center2[0];
  var centery = center2[1];
  var centerz = center2[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity3(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x05 = upy * z2 - upz * z1;
  x12 = upz * z0 - upx * z2;
  x22 = upx * z1 - upy * z0;
  len5 = Math.sqrt(x05 * x05 + x12 * x12 + x22 * x22);
  if (!len5) {
    x05 = 0;
    x12 = 0;
    x22 = 0;
  } else {
    len5 = 1 / len5;
    x05 *= len5;
    x12 *= len5;
    x22 *= len5;
  }
  y05 = z1 * x22 - z2 * x12;
  y12 = z2 * x05 - z0 * x22;
  y22 = z0 * x12 - z1 * x05;
  len5 = Math.sqrt(y05 * y05 + y12 * y12 + y22 * y22);
  if (!len5) {
    y05 = 0;
    y12 = 0;
    y22 = 0;
  } else {
    len5 = 1 / len5;
    y05 *= len5;
    y12 *= len5;
    y22 *= len5;
  }
  out[0] = x05;
  out[1] = y05;
  out[2] = z0;
  out[3] = 0;
  out[4] = x12;
  out[5] = y12;
  out[6] = z1;
  out[7] = 0;
  out[8] = x22;
  out[9] = y22;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x05 * eyex + x12 * eyey + x22 * eyez);
  out[13] = -(y05 * eyex + y12 * eyey + y22 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x05 = upy * z2 - upz * z1, x12 = upz * z0 - upx * z2, x22 = upx * z1 - upy * z0;
  len5 = x05 * x05 + x12 * x12 + x22 * x22;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x05 *= len5;
    x12 *= len5;
    x22 *= len5;
  }
  out[0] = x05;
  out[1] = x12;
  out[2] = x22;
  out[3] = 0;
  out[4] = z1 * x22 - z2 * x12;
  out[5] = z2 * x05 - z0 * x22;
  out[6] = z0 * x12 - z1 * x05;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a5) {
  return "mat4(" + a5[0] + ", " + a5[1] + ", " + a5[2] + ", " + a5[3] + ", " + a5[4] + ", " + a5[5] + ", " + a5[6] + ", " + a5[7] + ", " + a5[8] + ", " + a5[9] + ", " + a5[10] + ", " + a5[11] + ", " + a5[12] + ", " + a5[13] + ", " + a5[14] + ", " + a5[15] + ")";
}
function frob2(a5) {
  return Math.sqrt(a5[0] * a5[0] + a5[1] * a5[1] + a5[2] * a5[2] + a5[3] * a5[3] + a5[4] * a5[4] + a5[5] * a5[5] + a5[6] * a5[6] + a5[7] * a5[7] + a5[8] * a5[8] + a5[9] * a5[9] + a5[10] * a5[10] + a5[11] * a5[11] + a5[12] * a5[12] + a5[13] * a5[13] + a5[14] * a5[14] + a5[15] * a5[15]);
}
function add2(out, a5, b) {
  out[0] = a5[0] + b[0];
  out[1] = a5[1] + b[1];
  out[2] = a5[2] + b[2];
  out[3] = a5[3] + b[3];
  out[4] = a5[4] + b[4];
  out[5] = a5[5] + b[5];
  out[6] = a5[6] + b[6];
  out[7] = a5[7] + b[7];
  out[8] = a5[8] + b[8];
  out[9] = a5[9] + b[9];
  out[10] = a5[10] + b[10];
  out[11] = a5[11] + b[11];
  out[12] = a5[12] + b[12];
  out[13] = a5[13] + b[13];
  out[14] = a5[14] + b[14];
  out[15] = a5[15] + b[15];
  return out;
}
function subtract2(out, a5, b) {
  out[0] = a5[0] - b[0];
  out[1] = a5[1] - b[1];
  out[2] = a5[2] - b[2];
  out[3] = a5[3] - b[3];
  out[4] = a5[4] - b[4];
  out[5] = a5[5] - b[5];
  out[6] = a5[6] - b[6];
  out[7] = a5[7] - b[7];
  out[8] = a5[8] - b[8];
  out[9] = a5[9] - b[9];
  out[10] = a5[10] - b[10];
  out[11] = a5[11] - b[11];
  out[12] = a5[12] - b[12];
  out[13] = a5[13] - b[13];
  out[14] = a5[14] - b[14];
  out[15] = a5[15] - b[15];
  return out;
}
function multiplyScalar2(out, a5, b) {
  out[0] = a5[0] * b;
  out[1] = a5[1] * b;
  out[2] = a5[2] * b;
  out[3] = a5[3] * b;
  out[4] = a5[4] * b;
  out[5] = a5[5] * b;
  out[6] = a5[6] * b;
  out[7] = a5[7] * b;
  out[8] = a5[8] * b;
  out[9] = a5[9] * b;
  out[10] = a5[10] * b;
  out[11] = a5[11] * b;
  out[12] = a5[12] * b;
  out[13] = a5[13] * b;
  out[14] = a5[14] * b;
  out[15] = a5[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a5, b, scale12) {
  out[0] = a5[0] + b[0] * scale12;
  out[1] = a5[1] + b[1] * scale12;
  out[2] = a5[2] + b[2] * scale12;
  out[3] = a5[3] + b[3] * scale12;
  out[4] = a5[4] + b[4] * scale12;
  out[5] = a5[5] + b[5] * scale12;
  out[6] = a5[6] + b[6] * scale12;
  out[7] = a5[7] + b[7] * scale12;
  out[8] = a5[8] + b[8] * scale12;
  out[9] = a5[9] + b[9] * scale12;
  out[10] = a5[10] + b[10] * scale12;
  out[11] = a5[11] + b[11] * scale12;
  out[12] = a5[12] + b[12] * scale12;
  out[13] = a5[13] + b[13] * scale12;
  out[14] = a5[14] + b[14] * scale12;
  out[15] = a5[15] + b[15] * scale12;
  return out;
}
function exactEquals2(a5, b) {
  return a5[0] === b[0] && a5[1] === b[1] && a5[2] === b[2] && a5[3] === b[3] && a5[4] === b[4] && a5[5] === b[5] && a5[6] === b[6] && a5[7] === b[7] && a5[8] === b[8] && a5[9] === b[9] && a5[10] === b[10] && a5[11] === b[11] && a5[12] === b[12] && a5[13] === b[13] && a5[14] === b[14] && a5[15] === b[15];
}
function equals2(a5, b) {
  var a0 = a5[0], a1 = a5[1], a22 = a5[2], a32 = a5[3];
  var a42 = a5[4], a52 = a5[5], a6 = a5[6], a7 = a5[7];
  var a8 = a5[8], a9 = a5[9], a10 = a5[10], a11 = a5[11];
  var a12 = a5[12], a13 = a5[13], a14 = a5[14], a15 = a5[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a42 - b4) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b4)) && Math.abs(a52 - b5) <= EPSILON * Math.max(1, Math.abs(a52), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone6,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity4,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp2,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone4,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max2,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round2,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  slerp: () => slerp,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone4(a5) {
  var out = new ARRAY_TYPE(3);
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  return out;
}
function length(a5) {
  var x3 = a5[0];
  var y4 = a5[1];
  var z = a5[2];
  return Math.sqrt(x3 * x3 + y4 * y4 + z * z);
}
function fromValues3(x3, y4, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x3;
  out[1] = y4;
  out[2] = z;
  return out;
}
function copy3(out, a5) {
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  return out;
}
function set3(out, x3, y4, z) {
  out[0] = x3;
  out[1] = y4;
  out[2] = z;
  return out;
}
function add3(out, a5, b) {
  out[0] = a5[0] + b[0];
  out[1] = a5[1] + b[1];
  out[2] = a5[2] + b[2];
  return out;
}
function subtract3(out, a5, b) {
  out[0] = a5[0] - b[0];
  out[1] = a5[1] - b[1];
  out[2] = a5[2] - b[2];
  return out;
}
function multiply3(out, a5, b) {
  out[0] = a5[0] * b[0];
  out[1] = a5[1] * b[1];
  out[2] = a5[2] * b[2];
  return out;
}
function divide(out, a5, b) {
  out[0] = a5[0] / b[0];
  out[1] = a5[1] / b[1];
  out[2] = a5[2] / b[2];
  return out;
}
function ceil(out, a5) {
  out[0] = Math.ceil(a5[0]);
  out[1] = Math.ceil(a5[1]);
  out[2] = Math.ceil(a5[2]);
  return out;
}
function floor(out, a5) {
  out[0] = Math.floor(a5[0]);
  out[1] = Math.floor(a5[1]);
  out[2] = Math.floor(a5[2]);
  return out;
}
function min(out, a5, b) {
  out[0] = Math.min(a5[0], b[0]);
  out[1] = Math.min(a5[1], b[1]);
  out[2] = Math.min(a5[2], b[2]);
  return out;
}
function max2(out, a5, b) {
  out[0] = Math.max(a5[0], b[0]);
  out[1] = Math.max(a5[1], b[1]);
  out[2] = Math.max(a5[2], b[2]);
  return out;
}
function round2(out, a5) {
  out[0] = round(a5[0]);
  out[1] = round(a5[1]);
  out[2] = round(a5[2]);
  return out;
}
function scale3(out, a5, b) {
  out[0] = a5[0] * b;
  out[1] = a5[1] * b;
  out[2] = a5[2] * b;
  return out;
}
function scaleAndAdd(out, a5, b, scale12) {
  out[0] = a5[0] + b[0] * scale12;
  out[1] = a5[1] + b[1] * scale12;
  out[2] = a5[2] + b[2] * scale12;
  return out;
}
function distance(a5, b) {
  var x3 = b[0] - a5[0];
  var y4 = b[1] - a5[1];
  var z = b[2] - a5[2];
  return Math.sqrt(x3 * x3 + y4 * y4 + z * z);
}
function squaredDistance(a5, b) {
  var x3 = b[0] - a5[0];
  var y4 = b[1] - a5[1];
  var z = b[2] - a5[2];
  return x3 * x3 + y4 * y4 + z * z;
}
function squaredLength(a5) {
  var x3 = a5[0];
  var y4 = a5[1];
  var z = a5[2];
  return x3 * x3 + y4 * y4 + z * z;
}
function negate(out, a5) {
  out[0] = -a5[0];
  out[1] = -a5[1];
  out[2] = -a5[2];
  return out;
}
function inverse(out, a5) {
  out[0] = 1 / a5[0];
  out[1] = 1 / a5[1];
  out[2] = 1 / a5[2];
  return out;
}
function normalize(out, a5) {
  var x3 = a5[0];
  var y4 = a5[1];
  var z = a5[2];
  var len5 = x3 * x3 + y4 * y4 + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a5[0] * len5;
  out[1] = a5[1] * len5;
  out[2] = a5[2] * len5;
  return out;
}
function dot(a5, b) {
  return a5[0] * b[0] + a5[1] * b[1] + a5[2] * b[2];
}
function cross(out, a5, b) {
  var ax = a5[0], ay = a5[1], az = a5[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a5, b, t) {
  var ax = a5[0];
  var ay = a5[1];
  var az = a5[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function slerp(out, a5, b, t) {
  var angle4 = Math.acos(Math.min(Math.max(dot(a5, b), -1), 1));
  var sinTotal = Math.sin(angle4);
  var ratioA = Math.sin((1 - t) * angle4) / sinTotal;
  var ratioB = Math.sin(t * angle4) / sinTotal;
  out[0] = ratioA * a5[0] + ratioB * b[0];
  out[1] = ratioA * a5[1] + ratioB * b[1];
  out[2] = ratioA * a5[2] + ratioB * b[2];
  return out;
}
function hermite(out, a5, b, c6, d4, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a5[0] * factor1 + b[0] * factor2 + c6[0] * factor3 + d4[0] * factor4;
  out[1] = a5[1] * factor1 + b[1] * factor2 + c6[1] * factor3 + d4[1] * factor4;
  out[2] = a5[2] * factor1 + b[2] * factor2 + c6[2] * factor3 + d4[2] * factor4;
  return out;
}
function bezier(out, a5, b, c6, d4, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a5[0] * factor1 + b[0] * factor2 + c6[0] * factor3 + d4[0] * factor4;
  out[1] = a5[1] * factor1 + b[1] * factor2 + c6[1] * factor3 + d4[1] * factor4;
  out[2] = a5[2] * factor1 + b[2] * factor2 + c6[2] * factor3 + d4[2] * factor4;
  return out;
}
function random(out, scale12) {
  scale12 = scale12 === void 0 ? 1 : scale12;
  var r2 = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale12;
  out[0] = Math.cos(r2) * zScale;
  out[1] = Math.sin(r2) * zScale;
  out[2] = z * scale12;
  return out;
}
function transformMat4(out, a5, m3) {
  var x3 = a5[0], y4 = a5[1], z = a5[2];
  var w2 = m3[3] * x3 + m3[7] * y4 + m3[11] * z + m3[15];
  w2 = w2 || 1;
  out[0] = (m3[0] * x3 + m3[4] * y4 + m3[8] * z + m3[12]) / w2;
  out[1] = (m3[1] * x3 + m3[5] * y4 + m3[9] * z + m3[13]) / w2;
  out[2] = (m3[2] * x3 + m3[6] * y4 + m3[10] * z + m3[14]) / w2;
  return out;
}
function transformMat3(out, a5, m3) {
  var x3 = a5[0], y4 = a5[1], z = a5[2];
  out[0] = x3 * m3[0] + y4 * m3[3] + z * m3[6];
  out[1] = x3 * m3[1] + y4 * m3[4] + z * m3[7];
  out[2] = x3 * m3[2] + y4 * m3[5] + z * m3[8];
  return out;
}
function transformQuat(out, a5, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var vx = a5[0], vy = a5[1], vz = a5[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}
function rotateX2(out, a5, b, rad2) {
  var p3 = [], r2 = [];
  p3[0] = a5[0] - b[0];
  p3[1] = a5[1] - b[1];
  p3[2] = a5[2] - b[2];
  r2[0] = p3[0];
  r2[1] = p3[1] * Math.cos(rad2) - p3[2] * Math.sin(rad2);
  r2[2] = p3[1] * Math.sin(rad2) + p3[2] * Math.cos(rad2);
  out[0] = r2[0] + b[0];
  out[1] = r2[1] + b[1];
  out[2] = r2[2] + b[2];
  return out;
}
function rotateY2(out, a5, b, rad2) {
  var p3 = [], r2 = [];
  p3[0] = a5[0] - b[0];
  p3[1] = a5[1] - b[1];
  p3[2] = a5[2] - b[2];
  r2[0] = p3[2] * Math.sin(rad2) + p3[0] * Math.cos(rad2);
  r2[1] = p3[1];
  r2[2] = p3[2] * Math.cos(rad2) - p3[0] * Math.sin(rad2);
  out[0] = r2[0] + b[0];
  out[1] = r2[1] + b[1];
  out[2] = r2[2] + b[2];
  return out;
}
function rotateZ2(out, a5, b, rad2) {
  var p3 = [], r2 = [];
  p3[0] = a5[0] - b[0];
  p3[1] = a5[1] - b[1];
  p3[2] = a5[2] - b[2];
  r2[0] = p3[0] * Math.cos(rad2) - p3[1] * Math.sin(rad2);
  r2[1] = p3[0] * Math.sin(rad2) + p3[1] * Math.cos(rad2);
  r2[2] = p3[2];
  out[0] = r2[0] + b[0];
  out[1] = r2[1] + b[1];
  out[2] = r2[2] + b[2];
  return out;
}
function angle(a5, b) {
  var ax = a5[0], ay = a5[1], az = a5[2], bx = b[0], by = b[1], bz = b[2], mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)), cosine = mag && dot(a5, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a5) {
  return "vec3(" + a5[0] + ", " + a5[1] + ", " + a5[2] + ")";
}
function exactEquals3(a5, b) {
  return a5[0] === b[0] && a5[1] === b[1] && a5[2] === b[2];
}
function equals3(a5, b) {
  var a0 = a5[0], a1 = a5[1], a22 = a5[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a5, stride, offset2, count4, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 3;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l2 = Math.min(count4 * stride + offset2, a5.length);
    } else {
      l2 = a5.length;
    }
    for (i2 = offset2; i2 < l2; i2 += stride) {
      vec[0] = a5[i2];
      vec[1] = a5[i2 + 1];
      vec[2] = a5[i2 + 2];
      fn(vec, vec, arg);
      a5[i2] = vec[0];
      a5[i2 + 1] = vec[1];
      a5[i2 + 2] = vec[2];
    }
    return a5;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max3,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round3,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone5(a5) {
  var out = new ARRAY_TYPE(4);
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  out[3] = a5[3];
  return out;
}
function fromValues4(x3, y4, z, w2) {
  var out = new ARRAY_TYPE(4);
  out[0] = x3;
  out[1] = y4;
  out[2] = z;
  out[3] = w2;
  return out;
}
function copy4(out, a5) {
  out[0] = a5[0];
  out[1] = a5[1];
  out[2] = a5[2];
  out[3] = a5[3];
  return out;
}
function set4(out, x3, y4, z, w2) {
  out[0] = x3;
  out[1] = y4;
  out[2] = z;
  out[3] = w2;
  return out;
}
function add4(out, a5, b) {
  out[0] = a5[0] + b[0];
  out[1] = a5[1] + b[1];
  out[2] = a5[2] + b[2];
  out[3] = a5[3] + b[3];
  return out;
}
function subtract4(out, a5, b) {
  out[0] = a5[0] - b[0];
  out[1] = a5[1] - b[1];
  out[2] = a5[2] - b[2];
  out[3] = a5[3] - b[3];
  return out;
}
function multiply4(out, a5, b) {
  out[0] = a5[0] * b[0];
  out[1] = a5[1] * b[1];
  out[2] = a5[2] * b[2];
  out[3] = a5[3] * b[3];
  return out;
}
function divide2(out, a5, b) {
  out[0] = a5[0] / b[0];
  out[1] = a5[1] / b[1];
  out[2] = a5[2] / b[2];
  out[3] = a5[3] / b[3];
  return out;
}
function ceil2(out, a5) {
  out[0] = Math.ceil(a5[0]);
  out[1] = Math.ceil(a5[1]);
  out[2] = Math.ceil(a5[2]);
  out[3] = Math.ceil(a5[3]);
  return out;
}
function floor2(out, a5) {
  out[0] = Math.floor(a5[0]);
  out[1] = Math.floor(a5[1]);
  out[2] = Math.floor(a5[2]);
  out[3] = Math.floor(a5[3]);
  return out;
}
function min2(out, a5, b) {
  out[0] = Math.min(a5[0], b[0]);
  out[1] = Math.min(a5[1], b[1]);
  out[2] = Math.min(a5[2], b[2]);
  out[3] = Math.min(a5[3], b[3]);
  return out;
}
function max3(out, a5, b) {
  out[0] = Math.max(a5[0], b[0]);
  out[1] = Math.max(a5[1], b[1]);
  out[2] = Math.max(a5[2], b[2]);
  out[3] = Math.max(a5[3], b[3]);
  return out;
}
function round3(out, a5) {
  out[0] = round(a5[0]);
  out[1] = round(a5[1]);
  out[2] = round(a5[2]);
  out[3] = round(a5[3]);
  return out;
}
function scale4(out, a5, b) {
  out[0] = a5[0] * b;
  out[1] = a5[1] * b;
  out[2] = a5[2] * b;
  out[3] = a5[3] * b;
  return out;
}
function scaleAndAdd2(out, a5, b, scale12) {
  out[0] = a5[0] + b[0] * scale12;
  out[1] = a5[1] + b[1] * scale12;
  out[2] = a5[2] + b[2] * scale12;
  out[3] = a5[3] + b[3] * scale12;
  return out;
}
function distance2(a5, b) {
  var x3 = b[0] - a5[0];
  var y4 = b[1] - a5[1];
  var z = b[2] - a5[2];
  var w2 = b[3] - a5[3];
  return Math.sqrt(x3 * x3 + y4 * y4 + z * z + w2 * w2);
}
function squaredDistance2(a5, b) {
  var x3 = b[0] - a5[0];
  var y4 = b[1] - a5[1];
  var z = b[2] - a5[2];
  var w2 = b[3] - a5[3];
  return x3 * x3 + y4 * y4 + z * z + w2 * w2;
}
function length2(a5) {
  var x3 = a5[0];
  var y4 = a5[1];
  var z = a5[2];
  var w2 = a5[3];
  return Math.sqrt(x3 * x3 + y4 * y4 + z * z + w2 * w2);
}
function squaredLength2(a5) {
  var x3 = a5[0];
  var y4 = a5[1];
  var z = a5[2];
  var w2 = a5[3];
  return x3 * x3 + y4 * y4 + z * z + w2 * w2;
}
function negate2(out, a5) {
  out[0] = -a5[0];
  out[1] = -a5[1];
  out[2] = -a5[2];
  out[3] = -a5[3];
  return out;
}
function inverse2(out, a5) {
  out[0] = 1 / a5[0];
  out[1] = 1 / a5[1];
  out[2] = 1 / a5[2];
  out[3] = 1 / a5[3];
  return out;
}
function normalize2(out, a5) {
  var x3 = a5[0];
  var y4 = a5[1];
  var z = a5[2];
  var w2 = a5[3];
  var len5 = x3 * x3 + y4 * y4 + z * z + w2 * w2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x3 * len5;
  out[1] = y4 * len5;
  out[2] = z * len5;
  out[3] = w2 * len5;
  return out;
}
function dot2(a5, b) {
  return a5[0] * b[0] + a5[1] * b[1] + a5[2] * b[2] + a5[3] * b[3];
}
function cross2(out, u2, v, w2) {
  var A6 = v[0] * w2[1] - v[1] * w2[0], B4 = v[0] * w2[2] - v[2] * w2[0], C4 = v[0] * w2[3] - v[3] * w2[0], D2 = v[1] * w2[2] - v[2] * w2[1], E3 = v[1] * w2[3] - v[3] * w2[1], F = v[2] * w2[3] - v[3] * w2[2];
  var G = u2[0];
  var H = u2[1];
  var I = u2[2];
  var J = u2[3];
  out[0] = H * F - I * E3 + J * D2;
  out[1] = -(G * F) + I * C4 - J * B4;
  out[2] = G * E3 - H * C4 + J * A6;
  out[3] = -(G * D2) + H * B4 - I * A6;
  return out;
}
function lerp2(out, a5, b, t) {
  var ax = a5[0];
  var ay = a5[1];
  var az = a5[2];
  var aw = a5[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale12) {
  scale12 = scale12 === void 0 ? 1 : scale12;
  var v1, v2, v3, v4;
  var s1, s22;
  var rand;
  rand = RANDOM();
  v1 = rand * 2 - 1;
  v2 = (4 * RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s1 = v1 * v1 + v2 * v2;
  rand = RANDOM();
  v3 = rand * 2 - 1;
  v4 = (4 * RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
  s22 = v3 * v3 + v4 * v4;
  var d4 = Math.sqrt((1 - s1) / s22);
  out[0] = scale12 * v1;
  out[1] = scale12 * v2;
  out[2] = scale12 * v3 * d4;
  out[3] = scale12 * v4 * d4;
  return out;
}
function transformMat42(out, a5, m3) {
  var x3 = a5[0], y4 = a5[1], z = a5[2], w2 = a5[3];
  out[0] = m3[0] * x3 + m3[4] * y4 + m3[8] * z + m3[12] * w2;
  out[1] = m3[1] * x3 + m3[5] * y4 + m3[9] * z + m3[13] * w2;
  out[2] = m3[2] * x3 + m3[6] * y4 + m3[10] * z + m3[14] * w2;
  out[3] = m3[3] * x3 + m3[7] * y4 + m3[11] * z + m3[15] * w2;
  return out;
}
function transformQuat2(out, a5, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var vx = a5[0], vy = a5[1], vz = a5[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  out[3] = a5[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a5) {
  return "vec4(" + a5[0] + ", " + a5[1] + ", " + a5[2] + ", " + a5[3] + ")";
}
function exactEquals4(a5, b) {
  return a5[0] === b[0] && a5[1] === b[1] && a5[2] === b[2] && a5[3] === b[3];
}
function equals4(a5, b) {
  var a0 = a5[0], a1 = a5[1], a22 = a5[2], a32 = a5[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a5, stride, offset2, count4, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 4;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l2 = Math.min(count4 * stride + offset2, a5.length);
    } else {
      l2 = a5.length;
    }
    for (i2 = offset2; i2 < l2; i2 += stride) {
      vec[0] = a5[i2];
      vec[1] = a5[i2 + 1];
      vec[2] = a5[i2 + 2];
      vec[3] = a5[i2 + 3];
      fn(vec, vec, arg);
      a5[i2] = vec[0];
      a5[i2 + 1] = vec[1];
      a5[i2 + 2] = vec[2];
      a5[i2 + 3] = vec[3];
    }
    return a5;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity4(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad2) {
  rad2 = rad2 * 0.5;
  var s4 = Math.sin(rad2);
  out[0] = s4 * axis[0];
  out[1] = s4 * axis[1];
  out[2] = s4 * axis[2];
  out[3] = Math.cos(rad2);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad2 = Math.acos(q[3]) * 2;
  var s4 = Math.sin(rad2 / 2);
  if (s4 > EPSILON) {
    out_axis[0] = q[0] / s4;
    out_axis[1] = q[1] / s4;
    out_axis[2] = q[2] / s4;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad2;
}
function getAngle(a5, b) {
  var dotproduct = dot3(a5, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a5, b) {
  var ax = a5[0], ay = a5[1], az = a5[2], aw = a5[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a5, rad2) {
  rad2 *= 0.5;
  var ax = a5[0], ay = a5[1], az = a5[2], aw = a5[3];
  var bx = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a5, rad2) {
  rad2 *= 0.5;
  var ax = a5[0], ay = a5[1], az = a5[2], aw = a5[3];
  var by = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a5, rad2) {
  rad2 *= 0.5;
  var ax = a5[0], ay = a5[1], az = a5[2], aw = a5[3];
  var bz = Math.sin(rad2), bw = Math.cos(rad2);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a5) {
  var x3 = a5[0], y4 = a5[1], z = a5[2];
  out[0] = x3;
  out[1] = y4;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y4 * y4 - z * z));
  return out;
}
function exp(out, a5) {
  var x3 = a5[0], y4 = a5[1], z = a5[2], w2 = a5[3];
  var r2 = Math.sqrt(x3 * x3 + y4 * y4 + z * z);
  var et = Math.exp(w2);
  var s4 = r2 > 0 ? et * Math.sin(r2) / r2 : 0;
  out[0] = x3 * s4;
  out[1] = y4 * s4;
  out[2] = z * s4;
  out[3] = et * Math.cos(r2);
  return out;
}
function ln(out, a5) {
  var x3 = a5[0], y4 = a5[1], z = a5[2], w2 = a5[3];
  var r2 = Math.sqrt(x3 * x3 + y4 * y4 + z * z);
  var t = r2 > 0 ? Math.atan2(r2, w2) / r2 : 0;
  out[0] = x3 * t;
  out[1] = y4 * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x3 * x3 + y4 * y4 + z * z + w2 * w2);
  return out;
}
function pow(out, a5, b) {
  ln(out, a5);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp2(out, a5, b, t) {
  var ax = a5[0], ay = a5[1], az = a5[2], aw = a5[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a5) {
  var a0 = a5[0], a1 = a5[1], a22 = a5[2], a32 = a5[3];
  var dot9 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
  var invDot = dot9 ? 1 / dot9 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a32 * invDot;
  return out;
}
function conjugate(out, a5) {
  out[0] = -a5[0];
  out[1] = -a5[1];
  out[2] = -a5[2];
  out[3] = a5[3];
  return out;
}
function fromMat3(out, m3) {
  var fTrace = m3[0] + m3[4] + m3[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m3[5] - m3[7]) * fRoot;
    out[1] = (m3[6] - m3[2]) * fRoot;
    out[2] = (m3[1] - m3[3]) * fRoot;
  } else {
    var i2 = 0;
    if (m3[4] > m3[0]) i2 = 1;
    if (m3[8] > m3[i2 * 3 + i2]) i2 = 2;
    var j = (i2 + 1) % 3;
    var k2 = (i2 + 2) % 3;
    fRoot = Math.sqrt(m3[i2 * 3 + i2] - m3[j * 3 + j] - m3[k2 * 3 + k2] + 1);
    out[i2] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m3[j * 3 + k2] - m3[k2 * 3 + j]) * fRoot;
    out[j] = (m3[j * 3 + i2] + m3[i2 * 3 + j]) * fRoot;
    out[k2] = (m3[k2 * 3 + i2] + m3[i2 * 3 + k2]) * fRoot;
  }
  return out;
}
function fromEuler(out, x3, y4, z) {
  var order = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ANGLE_ORDER;
  var halfToRad = Math.PI / 360;
  x3 *= halfToRad;
  z *= halfToRad;
  y4 *= halfToRad;
  var sx = Math.sin(x3);
  var cx = Math.cos(x3);
  var sy = Math.sin(y4);
  var cy = Math.cos(y4);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  switch (order) {
    case "xyz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "xzy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yxz":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    case "yzx":
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zxy":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
      break;
    case "zyx":
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
      break;
    default:
      throw new Error("Unknown angle order " + order);
  }
  return out;
}
function str5(a5) {
  return "quat(" + a5[0] + ", " + a5[1] + ", " + a5[2] + ", " + a5[3] + ")";
}
var clone6 = clone5;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
function equals5(a5, b) {
  return Math.abs(dot2(a5, b)) >= 1 - EPSILON;
}
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a5, b) {
    var dot9 = dot(a5, b);
    if (dot9 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a5);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a5);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot9 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a5, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot9;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a5, b, c6, d4, t) {
    slerp2(temp1, a5, d4, t);
    slerp2(temp2, b, c6, t);
    slerp2(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right2, up) {
    matr[0] = right2[0];
    matr[3] = right2[1];
    matr[6] = right2[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add6,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone7,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues6,
  inverse: () => inverse3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max4,
  min: () => min3,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize4,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round4,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set6,
  signedAngle: () => signedAngle,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str6,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone7(a5) {
  var out = new ARRAY_TYPE(2);
  out[0] = a5[0];
  out[1] = a5[1];
  return out;
}
function fromValues6(x3, y4) {
  var out = new ARRAY_TYPE(2);
  out[0] = x3;
  out[1] = y4;
  return out;
}
function copy6(out, a5) {
  out[0] = a5[0];
  out[1] = a5[1];
  return out;
}
function set6(out, x3, y4) {
  out[0] = x3;
  out[1] = y4;
  return out;
}
function add6(out, a5, b) {
  out[0] = a5[0] + b[0];
  out[1] = a5[1] + b[1];
  return out;
}
function subtract5(out, a5, b) {
  out[0] = a5[0] - b[0];
  out[1] = a5[1] - b[1];
  return out;
}
function multiply6(out, a5, b) {
  out[0] = a5[0] * b[0];
  out[1] = a5[1] * b[1];
  return out;
}
function divide3(out, a5, b) {
  out[0] = a5[0] / b[0];
  out[1] = a5[1] / b[1];
  return out;
}
function ceil3(out, a5) {
  out[0] = Math.ceil(a5[0]);
  out[1] = Math.ceil(a5[1]);
  return out;
}
function floor3(out, a5) {
  out[0] = Math.floor(a5[0]);
  out[1] = Math.floor(a5[1]);
  return out;
}
function min3(out, a5, b) {
  out[0] = Math.min(a5[0], b[0]);
  out[1] = Math.min(a5[1], b[1]);
  return out;
}
function max4(out, a5, b) {
  out[0] = Math.max(a5[0], b[0]);
  out[1] = Math.max(a5[1], b[1]);
  return out;
}
function round4(out, a5) {
  out[0] = round(a5[0]);
  out[1] = round(a5[1]);
  return out;
}
function scale6(out, a5, b) {
  out[0] = a5[0] * b;
  out[1] = a5[1] * b;
  return out;
}
function scaleAndAdd3(out, a5, b, scale12) {
  out[0] = a5[0] + b[0] * scale12;
  out[1] = a5[1] + b[1] * scale12;
  return out;
}
function distance3(a5, b) {
  var x3 = b[0] - a5[0], y4 = b[1] - a5[1];
  return Math.sqrt(x3 * x3 + y4 * y4);
}
function squaredDistance3(a5, b) {
  var x3 = b[0] - a5[0], y4 = b[1] - a5[1];
  return x3 * x3 + y4 * y4;
}
function length4(a5) {
  var x3 = a5[0], y4 = a5[1];
  return Math.sqrt(x3 * x3 + y4 * y4);
}
function squaredLength4(a5) {
  var x3 = a5[0], y4 = a5[1];
  return x3 * x3 + y4 * y4;
}
function negate3(out, a5) {
  out[0] = -a5[0];
  out[1] = -a5[1];
  return out;
}
function inverse3(out, a5) {
  out[0] = 1 / a5[0];
  out[1] = 1 / a5[1];
  return out;
}
function normalize4(out, a5) {
  var x3 = a5[0], y4 = a5[1];
  var len5 = x3 * x3 + y4 * y4;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a5[0] * len5;
  out[1] = a5[1] * len5;
  return out;
}
function dot4(a5, b) {
  return a5[0] * b[0] + a5[1] * b[1];
}
function cross3(out, a5, b) {
  var z = a5[0] * b[1] - a5[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a5, b, t) {
  var ax = a5[0], ay = a5[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale12) {
  scale12 = scale12 === void 0 ? 1 : scale12;
  var r2 = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r2) * scale12;
  out[1] = Math.sin(r2) * scale12;
  return out;
}
function transformMat2(out, a5, m3) {
  var x3 = a5[0], y4 = a5[1];
  out[0] = m3[0] * x3 + m3[2] * y4;
  out[1] = m3[1] * x3 + m3[3] * y4;
  return out;
}
function transformMat2d(out, a5, m3) {
  var x3 = a5[0], y4 = a5[1];
  out[0] = m3[0] * x3 + m3[2] * y4 + m3[4];
  out[1] = m3[1] * x3 + m3[3] * y4 + m3[5];
  return out;
}
function transformMat32(out, a5, m3) {
  var x3 = a5[0], y4 = a5[1];
  out[0] = m3[0] * x3 + m3[3] * y4 + m3[6];
  out[1] = m3[1] * x3 + m3[4] * y4 + m3[7];
  return out;
}
function transformMat43(out, a5, m3) {
  var x3 = a5[0];
  var y4 = a5[1];
  out[0] = m3[0] * x3 + m3[4] * y4 + m3[12];
  out[1] = m3[1] * x3 + m3[5] * y4 + m3[13];
  return out;
}
function rotate3(out, a5, b, rad2) {
  var p0 = a5[0] - b[0], p1 = a5[1] - b[1], sinC = Math.sin(rad2), cosC = Math.cos(rad2);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a5, b) {
  var ax = a5[0], ay = a5[1], bx = b[0], by = b[1];
  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));
}
function signedAngle(a5, b) {
  var ax = a5[0], ay = a5[1], bx = b[0], by = b[1];
  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a5) {
  return "vec2(" + a5[0] + ", " + a5[1] + ")";
}
function exactEquals6(a5, b) {
  return a5[0] === b[0] && a5[1] === b[1];
}
function equals6(a5, b) {
  var a0 = a5[0], a1 = a5[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len4 = length4;
var sub5 = subtract5;
var mul6 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen4 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a5, stride, offset2, count4, fn, arg) {
    var i2, l2;
    if (!stride) {
      stride = 2;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count4) {
      l2 = Math.min(count4 * stride + offset2, a5.length);
    } else {
      l2 = a5.length;
    }
    for (i2 = offset2; i2 < l2; i2 += stride) {
      vec[0] = a5[i2];
      vec[1] = a5[i2 + 1];
      fn(vec, vec, arg);
      a5[i2] = vec[0];
      a5[i2 + 1] = vec[1];
    }
    return a5;
  };
}();

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d4, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
    d5.__proto__ = b2;
  } || function(d5, b2) {
    for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
  };
  return extendStatics(d4, b);
};
function __extends(d4, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d4, b);
  function __() {
    this.constructor = d4;
  }
  d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign25(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3)) t[p3] = s4[p3];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
}
function __values(o2) {
  var s4 = typeof Symbol === "function" && Symbol.iterator, m3 = s4 && o2[s4], i2 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
}
function __spreadArrays() {
  for (var s4 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s4 += arguments[i2].length;
  for (var r2 = Array(s4), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a5 = arguments[i2], j = 0, jl = a5.length; j < jl; j++, k2++)
      r2[k2] = a5[j];
  return r2;
}
function __spreadArray(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}

// node_modules/@antv/util/esm/path/parser/params-parser.js
var paramsParser = {
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  x: 0,
  y: 0,
  qx: null,
  qy: null
};

// node_modules/@antv/util/esm/path/process/fix-arc.js
function fixArc(pathArray, allPathCommands, i2) {
  if (pathArray[i2].length > 7) {
    pathArray[i2].shift();
    var pi4 = pathArray[i2];
    var ni = i2;
    while (pi4.length) {
      allPathCommands[i2] = "A";
      pathArray.splice(ni += 1, 0, ["C"].concat(pi4.splice(0, 6)));
    }
    pathArray.splice(i2, 1);
  }
}

// node_modules/@antv/util/esm/path/parser/params-count.js
var paramsCount = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  r: 4,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};

// node_modules/@antv/util/esm/path/util/is-path-array.js
function isPathArray(path2) {
  return Array.isArray(path2) && path2.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}

// node_modules/@antv/util/esm/path/util/is-absolute-array.js
function isAbsoluteArray(path2) {
  return isPathArray(path2) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path2.every(function(_a2) {
    var x3 = _a2[0];
    return x3 === x3.toUpperCase();
  });
}

// node_modules/@antv/util/esm/path/util/is-normalized-array.js
function isNormalizedArray(path2) {
  return isAbsoluteArray(path2) && path2.every(function(_a2) {
    var pc = _a2[0];
    return "ACLMQZ".includes(pc);
  });
}

// node_modules/@antv/util/esm/path/parser/finalize-segment.js
function finalizeSegment(path2) {
  var pathCommand = path2.pathValue[path2.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data2 = path2.data;
  while (data2.length >= paramsCount[LK]) {
    if (LK === "m" && data2.length > 2) {
      path2.segments.push([pathCommand].concat(data2.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path2.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}

// node_modules/@antv/util/esm/path/parser/scan-flag.js
function scanFlag(path2) {
  var index3 = path2.index, pathValue = path2.pathValue;
  var code = pathValue.charCodeAt(index3);
  if (code === 48) {
    path2.param = 0;
    path2.index += 1;
    return;
  }
  if (code === 49) {
    path2.param = 1;
    path2.index += 1;
    return;
  }
  path2.err = '[path-util]: invalid Arc flag "'.concat(pathValue[index3], '", expecting 0 or 1 at index ').concat(index3);
}

// node_modules/@antv/util/esm/path/parser/is-digit-start.js
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}

// node_modules/@antv/util/esm/path/parser/scan-param.js
function scanParam(path2) {
  var max11 = path2.max, pathValue = path2.pathValue, start = path2.index;
  var index3 = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch2;
  if (index3 >= max11) {
    path2.err = "[path-util]: Invalid path value at index ".concat(index3, ', "pathValue" is missing param');
    return;
  }
  ch2 = pathValue.charCodeAt(index3);
  if (ch2 === 43 || ch2 === 45) {
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
  }
  if (!isDigit(ch2) && ch2 !== 46) {
    path2.err = "[path-util]: Invalid path value at index ".concat(index3, ', "').concat(pathValue[index3], '" is not a number');
    return;
  }
  if (ch2 !== 46) {
    zeroFirst = ch2 === 48;
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
    if (zeroFirst && index3 < max11) {
      if (ch2 && isDigit(ch2)) {
        path2.err = "[path-util]: Invalid path value at index ".concat(start, ', "').concat(pathValue[start], '" illegal number');
        return;
      }
    }
    while (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
      index3 += 1;
      hasCeiling = true;
    }
    ch2 = pathValue.charCodeAt(index3);
  }
  if (ch2 === 46) {
    hasDot = true;
    index3 += 1;
    while (isDigit(pathValue.charCodeAt(index3))) {
      index3 += 1;
      hasDecimal = true;
    }
    ch2 = pathValue.charCodeAt(index3);
  }
  if (ch2 === 101 || ch2 === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path2.err = "[path-util]: Invalid path value at index ".concat(index3, ', "').concat(pathValue[index3], '" invalid float exponent');
      return;
    }
    index3 += 1;
    ch2 = pathValue.charCodeAt(index3);
    if (ch2 === 43 || ch2 === 45) {
      index3 += 1;
    }
    if (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
      while (index3 < max11 && isDigit(pathValue.charCodeAt(index3))) {
        index3 += 1;
      }
    } else {
      path2.err = "[path-util]: Invalid path value at index ".concat(index3, ', "').concat(pathValue[index3], '" invalid integer exponent');
      return;
    }
  }
  path2.index = index3;
  path2.param = +path2.pathValue.slice(start, index3);
}

// node_modules/@antv/util/esm/path/parser/is-space.js
function isSpace(ch2) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233 || // Line terminators
  // White spaces
  ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && specialSpaces.includes(ch2);
}

// node_modules/@antv/util/esm/path/parser/skip-spaces.js
function skipSpaces(path2) {
  var pathValue = path2.pathValue, max11 = path2.max;
  while (path2.index < max11 && isSpace(pathValue.charCodeAt(path2.index))) {
    path2.index += 1;
  }
}

// node_modules/@antv/util/esm/path/parser/is-path-command.js
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}

// node_modules/@antv/util/esm/path/parser/is-arc-command.js
function isArcCommand(code) {
  return (code | 32) === 97;
}

// node_modules/@antv/util/esm/path/parser/scan-segment.js
function scanSegment(path2) {
  var max11 = path2.max, pathValue = path2.pathValue, index3 = path2.index;
  var cmdCode = pathValue.charCodeAt(index3);
  var reqParams = paramsCount[pathValue[index3].toLowerCase()];
  path2.segmentStart = index3;
  if (!isPathCommand(cmdCode)) {
    path2.err = '[path-util]: Invalid path value "'.concat(pathValue[index3], '" is not a path command');
    return;
  }
  path2.index += 1;
  skipSpaces(path2);
  path2.data = [];
  if (!reqParams) {
    finalizeSegment(path2);
    return;
  }
  for (; ; ) {
    for (var i2 = reqParams; i2 > 0; i2 -= 1) {
      if (isArcCommand(cmdCode) && (i2 === 3 || i2 === 4))
        scanFlag(path2);
      else
        scanParam(path2);
      if (path2.err.length) {
        return;
      }
      path2.data.push(path2.param);
      skipSpaces(path2);
      if (path2.index < max11 && pathValue.charCodeAt(path2.index) === 44) {
        path2.index += 1;
        skipSpaces(path2);
      }
    }
    if (path2.index >= path2.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path2.index))) {
      break;
    }
  }
  finalizeSegment(path2);
}

// node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser = (
  /** @class */
  /* @__PURE__ */ function() {
    function PathParser2(pathString) {
      this.pathValue = pathString;
      this.segments = [];
      this.max = pathString.length;
      this.index = 0;
      this.param = 0;
      this.segmentStart = 0;
      this.data = [];
      this.err = "";
    }
    return PathParser2;
  }()
);

// node_modules/@antv/util/esm/path/parser/parse-path-string.js
function parsePathString(pathInput) {
  if (isPathArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = new PathParser(pathInput);
  skipSpaces(path2);
  while (path2.index < path2.max && !path2.err.length) {
    scanSegment(path2);
  }
  return path2.err ? path2.err : path2.segments;
}

// node_modules/@antv/util/esm/path/convert/path-2-absolute.js
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = parsePathString(pathInput);
  var x3 = 0;
  var y4 = 0;
  var mx = 0;
  var my = 0;
  return path2.map(function(segment) {
    var values4 = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x3 = values4[0], y4 = values4[1];
      mx = x3;
      my = y4;
      return ["M", x3, y4];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values4[0],
            values4[1],
            values4[2],
            values4[3],
            values4[4],
            values4[5] + x3,
            values4[6] + y4
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values4[0] + y4];
          break;
        case "H":
          absoluteSegment = [absCommand, values4[0] + x3];
          break;
        default: {
          var absValues = values4.map(function(n2, j) {
            return n2 + (j % 2 ? y4 : x3);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values4);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x3 = mx;
        y4 = my;
        break;
      case "H":
        x3 = absoluteSegment[1];
        break;
      case "V":
        y4 = absoluteSegment[1];
        break;
      default:
        x3 = absoluteSegment[segLength - 2];
        y4 = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x3;
          my = y4;
        }
    }
    return absoluteSegment;
  });
}

// node_modules/@antv/util/esm/path/process/normalize-segment.js
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values4 = segment.slice(1).map(Number);
  var result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x12 = px1 * 2 - px2;
    var y12 = py1 * 2 - py2;
    params.x1 = x12;
    params.y1 = y12;
    result = ["C", x12, y12].concat(values4);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy].concat(values4);
  } else if (pathCommand === "Q") {
    var nqx = values4[0], nqy = values4[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}

// node_modules/@antv/util/esm/path/process/normalize-path.js
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path2 = path2Absolute(pathInput);
  var params = __assign({}, paramsParser);
  for (var i2 = 0; i2 < path2.length; i2 += 1) {
    path2[i2] = normalizeSegment(path2[i2], params);
    var segment = path2[i2];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path2;
}

// node_modules/@antv/util/esm/path/util/is-curve-array.js
function isCurveArray(path2) {
  return isNormalizedArray(path2) && path2.every(function(_a2) {
    var pc = _a2[0];
    return "MC".includes(pc);
  });
}

// node_modules/@antv/util/esm/path/util/rotate-vector.js
function rotateVector(x3, y4, rad2) {
  var X = x3 * Math.cos(rad2) - y4 * Math.sin(rad2);
  var Y = x3 * Math.sin(rad2) + y4 * Math.cos(rad2);
  return { x: X, y: Y };
}

// node_modules/@antv/util/esm/path/process/arc-2-cubic.js
function arcToCubic(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, recursive) {
  var x12 = X12;
  var y12 = Y12;
  var rx = RX;
  var ry = RY;
  var x22 = X22;
  var y22 = Y22;
  var d120 = Math.PI * 120 / 180;
  var rad2 = Math.PI / 180 * (+angle4 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x12, y12, -rad2);
    x12 = xy.x;
    y12 = xy.y;
    xy = rotateVector(x22, y22, -rad2);
    x22 = xy.x;
    y22 = xy.y;
    var x3 = (x12 - x22) / 2;
    var y4 = (y12 - y22) / 2;
    var h2 = x3 * x3 / (rx * rx) + y4 * y4 / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx *= h2;
      ry *= h2;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k2 = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y4 * y4 - ry2 * x3 * x3) / (rx2 * y4 * y4 + ry2 * x3 * x3)));
    cx = k2 * rx * y4 / ry + (x12 + x22) / 2;
    cy = k2 * -ry * x3 / rx + (y12 + y22) / 2;
    f1 = Math.asin(((y12 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x12 < cx ? Math.PI - f1 : f1;
    f2 = x22 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x22;
    var y2old = y22;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x22 = cx + rx * Math.cos(f2);
    y22 = cy + ry * Math.sin(f2);
    res = arcToCubic(x22, y22, rx, ry, angle4, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c22 = Math.cos(f2);
  var s22 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x12, y12];
  var m22 = [x12 + hx * s1, y12 - hy * c1];
  var m3 = [x22 + hx * s22, y22 - hy * c22];
  var m4 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return m22.concat(m3, m4, res);
  }
  res = m22.concat(m3, m4, res);
  var newres = [];
  for (var i2 = 0, ii = res.length; i2 < ii; i2 += 1) {
    newres[i2] = i2 % 2 ? rotateVector(res[i2 - 1], res[i2], rad2).y : rotateVector(res[i2], res[i2 + 1], rad2).x;
  }
  return newres;
}

// node_modules/@antv/util/esm/path/process/quad-2-cubic.js
function quadToCubic(x12, y12, qx, qy, x22, y22) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x12 + r23 * qx,
    // cpx1
    r13 * y12 + r23 * qy,
    // cpy1
    r13 * x22 + r23 * qx,
    // cpx2
    r13 * y22 + r23 * qy,
    // cpy2
    x22,
    y22
    // x,y
  ];
}

// node_modules/@antv/util/esm/path/util/mid-point.js
function midPoint(a5, b, t) {
  var ax = a5[0];
  var ay = a5[1];
  var bx = b[0];
  var by = b[1];
  return [ax + (bx - ax) * t, ay + (by - ay) * t];
}

// node_modules/@antv/util/esm/path/process/line-2-cubic.js
var lineToCubic = function(x12, y12, x22, y22) {
  var t = 0.5;
  var mid2 = midPoint([x12, y12], [x22, y22], t);
  return __spreadArray(__spreadArray([], mid2, true), [x22, y22, x22, y22], false);
};

// node_modules/@antv/util/esm/path/process/segment-2-cubic.js
function segmentToCubic(segment, params) {
  var pathCommand = segment[0];
  var values4 = segment.slice(1).map(Number);
  var x3 = values4[0], y4 = values4[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px2 = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x3;
      params.y = y4;
      return segment;
    case "A":
      args = [px1, py1].concat(values4);
      return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x3;
      params.qy = y4;
      args = [px1, py1].concat(values4);
      return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic(px1, py1, x3, y4));
    case "Z":
      if (px1 === px2 && py1 === py) {
        return ["C", px1, py1, px2, py, px2, py];
      }
      return ["C"].concat(lineToCubic(px1, py1, px2, py));
    default:
  }
  return segment;
}

// node_modules/@antv/util/esm/path/convert/path-2-curve.js
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = [].concat(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path2 = normalizePath(pathInput);
  var params = __assign({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii = path2.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i2 = 0; i2 < ii; i2 += 1) {
    if (path2[i2])
      pathCommand = path2[i2][0];
    allPathCommands[i2] = pathCommand;
    var curveSegment = segmentToCubic(path2[i2], params);
    path2[i2] = curveSegment;
    fixArc(path2, allPathCommands, i2);
    ii = path2.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i2);
    }
    segment = path2[i2];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path2, zCommandIndexes];
  } else {
    return path2;
  }
}

// node_modules/@antv/util/esm/path/process/clone-path.js
function clonePath(path2) {
  return path2.map(function(x3) {
    return Array.isArray(x3) ? [].concat(x3) : x3;
  });
}

// node_modules/@antv/util/esm/path/process/reverse-curve.js
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x3, i2, curveOnly) {
    return !i2 ? pathArray[0].slice(1).concat(x3.slice(1)) : curveOnly[i2 - 1].slice(-2).concat(x3.slice(1));
  }).map(function(x3) {
    return x3.map(function(y4, i2) {
      return x3[x3.length - i2 - 2 * (1 - i2 % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x3) {
    return ["C"].concat(x3.slice(2));
  }));
}

// node_modules/@antv/util/esm/path/util/distance-square-root.js
function distanceSquareRoot(a5, b) {
  return Math.sqrt((a5[0] - b[0]) * (a5[0] - b[0]) + (a5[1] - b[1]) * (a5[1] - b[1]));
}

// node_modules/@antv/util/esm/path/util/segment-line-factory.js
function segmentLineFactory(x12, y12, x22, y22, distance7) {
  var length5 = distanceSquareRoot([x12, y12], [x22, y22]);
  var point7 = { x: 0, y: 0 };
  if (typeof distance7 === "number") {
    if (distance7 <= 0) {
      point7 = { x: x12, y: y12 };
    } else if (distance7 >= length5) {
      point7 = { x: x22, y: y22 };
    } else {
      var _a2 = midPoint([x12, y12], [x22, y22], distance7 / length5), x3 = _a2[0], y4 = _a2[1];
      point7 = { x: x3, y: y4 };
    }
  }
  return {
    length: length5,
    point: point7,
    min: {
      x: Math.min(x12, x22),
      y: Math.min(y12, y22)
    },
    max: {
      x: Math.max(x12, x22),
      y: Math.max(y12, y22)
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-arc-factory.js
function angleBetween(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p3 = v0x * v1x + v0y * v1y;
  var n2 = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign3 = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle4 = sign3 * Math.acos(p3 / n2);
  return angle4;
}
function getPointAtArcSegmentLength(x12, y12, RX, RY, angle4, LAF, SF, x3, y4, t) {
  var abs3 = Math.abs, sin3 = Math.sin, cos3 = Math.cos, sqrt4 = Math.sqrt, PI = Math.PI;
  var rx = abs3(RX);
  var ry = abs3(RY);
  var xRot = (angle4 % 360 + 360) % 360;
  var xRotRad = xRot * (PI / 180);
  if (x12 === x3 && y12 === y4) {
    return { x: x12, y: y12 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x12, y12, x3, y4, t).point;
  }
  var dx = (x12 - x3) / 2;
  var dy = (y12 - y4) / 2;
  var transformedPoint = {
    x: cos3(xRotRad) * dx + sin3(xRotRad) * dy,
    y: -sin3(xRotRad) * dx + cos3(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt4(radiiCheck);
    ry *= sqrt4(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt4(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center2 = {
    x: cos3(xRotRad) * transformedCenter.x - sin3(xRotRad) * transformedCenter.y + (x12 + x3) / 2,
    y: sin3(xRotRad) * transformedCenter.x + cos3(xRotRad) * transformedCenter.y + (y12 + y4) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI;
  }
  sweepAngle %= 2 * PI;
  var alpha = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * cos3(alpha);
  var ellipseComponentY = ry * sin3(alpha);
  var point7 = {
    x: cos3(xRotRad) * ellipseComponentX - sin3(xRotRad) * ellipseComponentY + center2.x,
    y: sin3(xRotRad) * ellipseComponentX + cos3(xRotRad) * ellipseComponentY + center2.y
  };
  return point7;
}
function segmentArcFactory(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = X12;
  var y4 = Y12;
  var LENGTH = 0;
  var prev = [x3, y4, LENGTH];
  var cur = [x3, y4];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y4 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y4 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtArcSegmentLength(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, t), x3 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y4 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y4]);
    }
    cur = [x3, y4];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y4, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: X22, y: Y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
function getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 3) * x12 + 3 * Math.pow(t12, 2) * t * c1x + 3 * t12 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x22,
    y: Math.pow(t12, 3) * y12 + 3 * Math.pow(t12, 2) * t * c1y + 3 * t12 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y22
  };
}
function segmentCubicFactory(x12, y12, c1x, c1y, c2x, c2y, x22, y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = x12;
  var y4 = y12;
  var LENGTH = 0;
  var prev = [x3, y4, LENGTH];
  var cur = [x3, y4];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y4 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y4 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t), x3 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y4 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y4]);
    }
    cur = [x3, y4];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y4, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/segment-quad-factory.js
function getPointAtQuadSegmentLength(x12, y12, cx, cy, x22, y22, t) {
  var t12 = 1 - t;
  return {
    x: Math.pow(t12, 2) * x12 + 2 * t12 * t * cx + Math.pow(t, 2) * x22,
    y: Math.pow(t12, 2) * y12 + 2 * t12 * t * cy + Math.pow(t, 2) * y22
  };
}
function segmentQuadFactory(x12, y12, qx, qy, x22, y22, distance7, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance7 === "number";
  var x3 = x12;
  var y4 = y12;
  var LENGTH = 0;
  var prev = [x3, y4, LENGTH];
  var cur = [x3, y4];
  var t = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x3, y: y4 }];
  if (distanceIsNumber && distance7 <= 0) {
    POINT = { x: x3, y: y4 };
  }
  for (var j = 0; j <= sampleSize; j += 1) {
    t = j / sampleSize;
    _a2 = getPointAtQuadSegmentLength(x12, y12, qx, qy, x22, y22, t), x3 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x3, y: y4 });
    }
    if (length5) {
      LENGTH += distanceSquareRoot(cur, [x3, y4]);
    }
    cur = [x3, y4];
    if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
      var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x3, y4, LENGTH];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/path-length-factory.js
function pathLengthFactory(pathInput, distance7, options) {
  var _a2, _b, _c, _d, _e, _f;
  var path2 = normalizePath(pathInput);
  var distanceIsNumber = typeof distance7 === "number";
  var isM;
  var data2 = [];
  var pathCommand;
  var x3 = 0;
  var y4 = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length5 = 0;
  var min10 = { x: 0, y: 0 };
  var max11 = min10;
  var point7 = min10;
  var POINT = min10;
  var LENGTH = 0;
  for (var i2 = 0, ll = path2.length; i2 < ll; i2 += 1) {
    seg = path2[i2];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data2 = !isM ? [x3, y4].concat(seg.slice(1)) : data2;
    if (isM) {
      mx = seg[1], my = seg[2];
      min10 = { x: mx, y: my };
      max11 = min10;
      length5 = 0;
      if (distanceIsNumber && distance7 < 1e-3) {
        POINT = min10;
      }
    } else if (pathCommand === "L") {
      _a2 = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance7 || 0) - LENGTH), length5 = _a2.length, min10 = _a2.min, max11 = _a2.max, point7 = _a2.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance7 || 0) - LENGTH, options || {}), length5 = _b.length, min10 = _b.min, max11 = _b.max, point7 = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance7 || 0) - LENGTH, options || {}), length5 = _c.length, min10 = _c.min, max11 = _c.max, point7 = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance7 || 0) - LENGTH, options || {}), length5 = _d.length, min10 = _d.min, max11 = _d.max, point7 = _d.point;
    } else if (pathCommand === "Z") {
      data2 = [x3, y4, mx, my];
      _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance7 || 0) - LENGTH), length5 = _e.length, min10 = _e.min, max11 = _e.max, point7 = _e.point;
    }
    if (distanceIsNumber && LENGTH < distance7 && LENGTH + length5 >= distance7) {
      POINT = point7;
    }
    MAX.push(max11);
    MIN.push(min10);
    LENGTH += length5;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x3 = _f[0], y4 = _f[1];
  }
  if (distanceIsNumber && distance7 >= LENGTH) {
    POINT = { x: x3, y: y4 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n2) {
        return n2.y;
      }))
    }
  };
}

// node_modules/@antv/util/esm/path/util/get-total-length.js
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
}

// node_modules/@antv/util/esm/path/util/get-rotated-curve.js
function getRotations(a5) {
  var segCount = a5.length;
  var pointCount = segCount - 1;
  return a5.map(function(f2, idx) {
    return a5.map(function(p3, i2) {
      var oldSegIdx = idx + i2;
      var seg;
      if (i2 === 0 || a5[oldSegIdx] && a5[oldSegIdx][0] === "M") {
        seg = a5[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a5[oldSegIdx];
    });
  });
}
function getRotatedCurve(a5, b) {
  var segCount = a5.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a5);
  rotations.forEach(function(r2, i2) {
    a5.slice(1).forEach(function(s4, j) {
      sumLensSqrd += distanceSquareRoot(a5[(i2 + j) % segCount].slice(-2), b[j % segCount].slice(-2));
    });
    lineLengths[i2] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}

// node_modules/@antv/util/esm/path/util/get-path-area.js
function getCubicSegArea(x12, y12, c1x, c1y, c2x, c2y, x22, y22) {
  return 3 * ((y22 - y12) * (c1x + c2x) - (x22 - x12) * (c1y + c2y) + c1y * (x12 - c2x) - c1x * (y12 - c2y) + y22 * (c2x + x12 / 3) - x22 * (c2y + y12 / 3)) / 20;
}
function getPathArea(path2) {
  var x3 = 0;
  var y4 = 0;
  var len5 = 0;
  return path2Curve(path2).map(function(seg) {
    var _a2;
    switch (seg[0]) {
      case "M":
        x3 = seg[1], y4 = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
        len5 = getCubicSegArea(x3, y4, c1x, c1y, c2x, c2y, x22, y22);
        _a2 = seg.slice(-2), x3 = _a2[0], y4 = _a2[1];
        return len5;
    }
  }).reduce(function(a5, b) {
    return a5 + b;
  }, 0);
}

// node_modules/@antv/util/esm/path/util/get-draw-direction.js
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}

// node_modules/@antv/util/esm/path/util/get-point-at-length.js
function getPointAtLength(pathInput, distance7, options) {
  return pathLengthFactory(pathInput, distance7, __assign(__assign({}, options), { bbox: false, length: true })).point;
}

// node_modules/@antv/util/esm/path/util/equalize-segments.js
var MAX_RECURSION_DEPTH = 50;
function splitCubic(pts, t) {
  if (t === void 0) {
    t = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p22 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t);
  var p5 = midPoint(p1, p22, t);
  var p6 = midPoint(p22, p3, t);
  var p7 = midPoint(p4, p5, t);
  var p8 = midPoint(p5, p6, t);
  var p9 = midPoint(p7, p8, t);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i2, pathArray) {
    var segmentData = i2 && pathArray[i2 - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i2 ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i2) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL, depth) {
  if (depth === void 0) {
    depth = 0;
  }
  if (depth > MAX_RECURSION_DEPTH) {
    console.warn("Maximum recursion depth reached in equalizeSegments");
    return [path1, path2];
  }
  var c1 = getCurveArray(path1);
  var c22 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c22.length;
  var l1 = c1.filter(function(x3) {
    return x3.l;
  }).length;
  var l2 = c22.filter(function(x3) {
    return x3.l;
  }).length;
  var m1 = c1.filter(function(x3) {
    return x3.l;
  }).reduce(function(a5, _a2) {
    var l3 = _a2.l;
    return a5 + l3;
  }, 0) / l1 || 0;
  var m22 = c22.filter(function(x3) {
    return x3.l;
  }).reduce(function(a5, _a2) {
    var l3 = _a2.l;
    return a5 + l3;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m22];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c22].map(function(x3, i2) {
    return x3.l === tl ? x3.map(function(y4) {
      return y4.s;
    }) : x3.map(function(y4, j) {
      canSplit = j && dif[i2] && y4.l >= mm[i2];
      dif[i2] -= canSplit ? 1 : 0;
      return canSplit ? y4.ss : [y4.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl, depth + 1);
}

// node_modules/@antv/util/esm/dom/create-dom.js
function createDOM(str7) {
  var container = document.createElement("div");
  container.innerHTML = str7;
  var dom2 = container.childNodes[0];
  if (dom2 && container.contains(dom2)) {
    container.removeChild(dom2);
  }
  return dom2;
}

// node_modules/@antv/g2/esm/transform/utils/helper.js
function column(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3 };
}
function inferredColumn(value2, field3) {
  const c6 = column(value2, field3);
  return Object.assign(Object.assign({}, c6), { inferred: true });
}
function visualColumn(value2, field3) {
  if (value2 === null)
    return void 0;
  return { type: "column", value: value2, field: field3, visual: true };
}
function nonConstantColumn(value2, field3) {
  const c6 = column(value2, field3);
  return Object.assign(Object.assign({}, c6), { constant: false });
}
function constant(I, value2) {
  const array2 = [];
  for (const i2 of I)
    array2[i2] = value2;
  return array2;
}
function columnOf(encode, key) {
  const channel = encode[key];
  if (!channel)
    return [null, null];
  const { value: value2, field: field3 = null } = channel;
  return [value2, field3];
}
function maybeColumnOf(encode, ...K2) {
  for (const key of K2) {
    if (typeof key === "string") {
      const [KV, fv] = columnOf(encode, key);
      if (KV !== null)
        return [KV, fv];
    } else {
      return [key, null];
    }
  }
  return [null, null];
}
function isObject(d4) {
  if (d4 instanceof Date)
    return false;
  return typeof d4 === "object";
}

// node_modules/@antv/g2/esm/transform/maybeZeroY1.js
var MaybeZeroY1 = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y1: inferredColumn(constant(I, 0)) }
      })
    ];
  };
};
MaybeZeroY1.props = {};

// node_modules/d3-array/src/ascending.js
function ascending(a5, b) {
  return a5 == null || b == null ? NaN : a5 < b ? -1 : a5 > b ? 1 : a5 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a5, b) {
  return a5 == null || b == null ? NaN : b < a5 ? -1 : b > a5 ? 1 : b >= a5 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d4, x3) => ascending(f2(d4), x3);
    delta = (d4, x3) => f2(d4) - x3;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero4;
    compare2 = f2;
    delta = f2;
  }
  function left2(a5, x3, lo = 0, hi = a5.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0) return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a5[mid2], x3) < 0) lo = mid2 + 1;
        else hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a5, x3, lo = 0, hi = a5.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0) return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a5[mid2], x3) <= 0) lo = mid2 + 1;
        else hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a5, x3, lo = 0, hi = a5.length) {
    const i2 = left2(a5, x3, lo, hi - 1);
    return i2 > lo && delta(a5[i2 - 1], x3) > -delta(a5[i2], x3) ? i2 - 1 : i2;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero4() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x3) {
  return x3 === null ? NaN : +x3;
}
function* numbers(values4, valueof2) {
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data2, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values4, width, height } = data2;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values4.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data2;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values4.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values4, width, height);
      blurh(blurx, values4, temp, width, height);
      blurh(blurx, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
      blurv(blury, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values4, temp, width, height);
      blurh(blurx, temp, values4, width, height);
      blurh(blurx, values4, temp, width, height);
    } else if (blury) {
      blurv(blury, values4, temp, width, height);
      blurv(blury, temp, values4, width, height);
      blurv(blury, values4, temp, width, height);
    }
    return data2;
  };
}
function blurh(blur3, T2, S, w2, h2) {
  for (let y4 = 0, n2 = w2 * h2; y4 < n2; ) {
    blur3(T2, S, y4, y4 += w2, 1);
  }
}
function blurv(blur3, T2, S, w2, h2) {
  for (let x3 = 0, n2 = w2 * h2; x3 < w2; ++x3) {
    blur3(T2, S, x3, x3 + n2, w2);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T2, S, start, stop, step2) => {
    start <<= 2, stop <<= 2, step2 <<= 2;
    blur3(T2, S, start + 0, stop + 0, step2);
    blur3(T2, S, start + 1, stop + 1, step2);
    blur3(T2, S, start + 2, stop + 2, step2);
    blur3(T2, S, start + 3, stop + 3, step2);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w2 = 2 * radius + 1;
  return (T2, S, start, stop, step2) => {
    if (!((stop -= step2) >= start)) return;
    let sum4 = radius0 * S[start];
    const s0 = step2 * radius0;
    const s1 = s0 + step2;
    for (let i2 = start, j = start + s0; i2 < j; i2 += step2) {
      sum4 += S[Math.min(stop, i2)];
    }
    for (let i2 = start, j = stop; i2 <= j; i2 += step2) {
      sum4 += S[Math.min(stop, i2 + s0)];
      T2[i2] = (sum4 + t * (S[Math.max(start, i2 - s1)] + S[Math.min(stop, i2 + s1)])) / w2;
      sum4 -= S[Math.max(start, i2 - s0)];
    }
  };
}
function bluri(radius) {
  const w2 = 2 * radius + 1;
  return (T2, S, start, stop, step2) => {
    if (!((stop -= step2) >= start)) return;
    let sum4 = radius * S[start];
    const s4 = step2 * radius;
    for (let i2 = start, j = start + s4; i2 < j; i2 += step2) {
      sum4 += S[Math.min(stop, i2)];
    }
    for (let i2 = start, j = stop; i2 <= j; i2 += step2) {
      sum4 += S[Math.min(stop, i2 + s4)];
      T2[i2] = sum4 / w2;
      sum4 -= S[Math.max(start, i2 - s4)];
    }
  };
}

// node_modules/d3-array/src/count.js
function count(values4, valueof2) {
  let count4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        ++count4;
      }
    }
  }
  return count4;
}

// node_modules/d3-array/src/variance.js
function variance(values4, valueof2) {
  let count4 = 0;
  let delta;
  let mean3 = 0;
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        delta = value2 - mean3;
        mean3 += delta / ++count4;
        sum4 += delta * (value2 - mean3);
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        delta = value2 - mean3;
        mean3 += delta / ++count4;
        sum4 += delta * (value2 - mean3);
      }
    }
  }
  if (count4 > 1) return sum4 / (count4 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values4, valueof2) {
  const v = variance(values4, valueof2);
  return v ? Math.sqrt(v) : v;
}

// node_modules/d3-array/src/extent.js
function extent(values4, valueof2) {
  let min10;
  let max11;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null) {
        if (min10 === void 0) {
          if (value2 >= value2) min10 = max11 = value2;
        } else {
          if (min10 > value2) min10 = value2;
          if (max11 < value2) max11 = value2;
        }
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null) {
        if (min10 === void 0) {
          if (value2 >= value2) min10 = max11 = value2;
        } else {
          if (min10 > value2) min10 = value2;
          if (max11 < value2) max11 = value2;
        }
      }
    }
  }
  return [min10, max11];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x3) {
    const p3 = this._partials;
    let i2 = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y4 = p3[j], hi = x3 + y4, lo = Math.abs(x3) < Math.abs(y4) ? x3 - (hi - y4) : y4 - (hi - x3);
      if (lo) p3[i2++] = lo;
      x3 = hi;
    }
    p3[i2] = x3;
    this._n = i2 + 1;
    return this;
  }
  valueOf() {
    const p3 = this._partials;
    let n2 = this._n, x3, y4, lo, hi = 0;
    if (n2 > 0) {
      hi = p3[--n2];
      while (n2 > 0) {
        x3 = hi;
        y4 = p3[--n2];
        hi = x3 + y4;
        lo = y4 - (hi - x3);
        if (lo) break;
      }
      if (n2 > 0 && (lo < 0 && p3[n2 - 1] < 0 || lo > 0 && p3[n2 - 1] > 0)) {
        y4 = lo * 2;
        x3 = hi + y4;
        if (y4 == x3 - hi) hi = x3;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value2] of entries) this.set(key2, value2);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value2) {
    return super.set(intern_set(this, key), value2);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value2) {
  const key = _key(value2);
  return _intern.has(key) ? _intern.get(key) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key = _key(value2);
  if (_intern.has(key)) {
    value2 = _intern.get(key);
    _intern.delete(key);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}

// node_modules/d3-array/src/identity.js
function identity5(x3) {
  return x3;
}

// node_modules/d3-array/src/group.js
function group(values4, ...keys2) {
  return nest(values4, identity5, identity5, keys2);
}
function groups(values4, ...keys2) {
  return nest(values4, Array.from, identity5, keys2);
}
function rollup(values4, reduce4, ...keys2) {
  return nest(values4, identity5, reduce4, keys2);
}
function rollups(values4, reduce4, ...keys2) {
  return nest(values4, Array.from, reduce4, keys2);
}
function nest(values4, map5, reduce4, keys2) {
  return function regroup(values5, i2) {
    if (i2 >= keys2.length) return reduce4(values5);
    const groups2 = new InternMap();
    const keyof3 = keys2[i2++];
    let index3 = -1;
    for (const value2 of values5) {
      const key = keyof3(value2, ++index3, values5);
      const group3 = groups2.get(key);
      if (group3) group3.push(value2);
      else groups2.set(key, [value2]);
    }
    for (const [key, values6] of groups2) {
      groups2.set(key, regroup(values6, i2));
    }
    return map5(groups2);
  }(values4, 0);
}

// node_modules/d3-array/src/permute.js
function permute(source, keys2) {
  return Array.from(keys2, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort(values4, ...F) {
  if (typeof values4[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values4 = Array.from(values4);
  let [f2] = F;
  if (f2 && f2.length !== 2 || F.length > 1) {
    const index3 = Uint32Array.from(values4, (d4, i2) => i2);
    if (F.length > 1) {
      F = F.map((f3) => values4.map(f3));
      index3.sort((i2, j) => {
        for (const f3 of F) {
          const c6 = ascendingDefined(f3[i2], f3[j]);
          if (c6) return c6;
        }
      });
    } else {
      f2 = values4.map(f2);
      index3.sort((i2, j) => ascendingDefined(f2[i2], f2[j]));
    }
    return permute(values4, index3);
  }
  return values4.sort(compareDefined(f2));
}
function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a5, b) => {
    const x3 = compare(a5, b);
    if (x3 || x3 === 0) return x3;
    return (compare(b, b) === 0) - (compare(a5, a5) === 0);
  };
}
function ascendingDefined(a5, b) {
  return (a5 == null || !(a5 >= a5)) - (b == null || !(b >= b)) || (a5 < b ? -1 : a5 > b ? 1 : 0);
}

// node_modules/d3-array/src/groupSort.js
function groupSort(values4, reduce4, key) {
  return (reduce4.length !== 2 ? sort(rollup(values4, reduce4, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values4, key), ([ak, av], [bk, bv]) => reduce4(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/constant.js
function constant2(x3) {
  return () => x3;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count4) {
  const step2 = (stop - start) / Math.max(0, count4), power = Math.floor(Math.log10(step2)), error3 = step2 / Math.pow(10, power), factor = error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count4 && count4 < 2) return tickSpec(start, stop, count4 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  if (!(count4 > 0)) return [];
  if (start === stop) return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count4) : tickSpec(start, stop, count4);
  if (!(i2 >= i1)) return [];
  const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
  if (reverse2) {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) * inc;
  } else {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count4) {
  stop = +stop, start = +start, count4 = +count4;
  return tickSpec(start, stop, count4)[2];
}

// node_modules/d3-array/src/nice.js
function nice(start, stop, count4) {
  let prestep;
  while (true) {
    const step2 = tickIncrement(start, stop, count4);
    if (step2 === prestep || step2 === 0 || !isFinite(step2)) {
      return [start, stop];
    } else if (step2 > 0) {
      start = Math.floor(start / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
    } else if (step2 < 0) {
      start = Math.ceil(start * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
    }
    prestep = step2;
  }
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values4) {
  return Math.max(1, Math.ceil(Math.log(count(values4)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/bin.js
function bin() {
  var value2 = identity5, domain = extent, threshold = thresholdSturges;
  function histogram(data2) {
    if (!Array.isArray(data2)) data2 = Array.from(data2);
    var i2, n2 = data2.length, x3, step2, values4 = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      values4[i2] = value2(data2[i2], i2, data2);
    }
    var xz = domain(values4), x05 = xz[0], x12 = xz[1], tz = threshold(values4, x05, x12);
    if (!Array.isArray(tz)) {
      const max11 = x12, tn = +tz;
      if (domain === extent) [x05, x12] = nice(x05, x12, tn);
      tz = ticks(x05, x12, tn);
      if (tz[0] <= x05) step2 = tickIncrement(x05, x12, tn);
      if (tz[tz.length - 1] >= x12) {
        if (max11 >= x12 && domain === extent) {
          const step3 = tickIncrement(x05, x12, tn);
          if (isFinite(step3)) {
            if (step3 > 0) {
              x12 = (Math.floor(x12 / step3) + 1) * step3;
            } else if (step3 < 0) {
              x12 = (Math.ceil(x12 * -step3) + 1) / -step3;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m3 = tz.length, a5 = 0, b = m3;
    while (tz[a5] <= x05) ++a5;
    while (tz[b - 1] > x12) --b;
    if (a5 || b < m3) tz = tz.slice(a5, b), m3 = b - a5;
    var bins = new Array(m3 + 1), bin2;
    for (i2 = 0; i2 <= m3; ++i2) {
      bin2 = bins[i2] = [];
      bin2.x0 = i2 > 0 ? tz[i2 - 1] : x05;
      bin2.x1 = i2 < m3 ? tz[i2] : x12;
    }
    if (isFinite(step2)) {
      if (step2 > 0) {
        for (i2 = 0; i2 < n2; ++i2) {
          if ((x3 = values4[i2]) != null && x05 <= x3 && x3 <= x12) {
            bins[Math.min(m3, Math.floor((x3 - x05) / step2))].push(data2[i2]);
          }
        }
      } else if (step2 < 0) {
        for (i2 = 0; i2 < n2; ++i2) {
          if ((x3 = values4[i2]) != null && x05 <= x3 && x3 <= x12) {
            const j = Math.floor((x05 - x3) * step2);
            bins[Math.min(m3, j + (tz[j] <= x3))].push(data2[i2]);
          }
        }
      }
    } else {
      for (i2 = 0; i2 < n2; ++i2) {
        if ((x3 = values4[i2]) != null && x05 <= x3 && x3 <= x12) {
          bins[bisect_default(tz, x3, 0, m3)].push(data2[i2]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_2) {
    return arguments.length ? (value2 = typeof _2 === "function" ? _2 : constant2(_2), histogram) : value2;
  };
  histogram.domain = function(_2) {
    return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant2([_2[0], _2[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_2) {
    return arguments.length ? (threshold = typeof _2 === "function" ? _2 : constant2(Array.isArray(_2) ? slice.call(_2) : _2), histogram) : threshold;
  };
  return histogram;
}

// node_modules/d3-array/src/max.js
function max5(values4, valueof2) {
  let max11;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2;
      }
    }
  }
  return max11;
}

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values4, valueof2) {
  let max11;
  let maxIndex2 = -1;
  let index3 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      ++index3;
      if (value2 != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2, maxIndex2 = index3;
      }
    }
  } else {
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
        max11 = value2, maxIndex2 = index3;
      }
    }
  }
  return maxIndex2;
}

// node_modules/d3-array/src/min.js
function min4(values4, valueof2) {
  let min10;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      if (value2 != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
        min10 = value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
        min10 = value2;
      }
    }
  }
  return min10;
}

// node_modules/d3-array/src/minIndex.js
function minIndex(values4, valueof2) {
  let min10;
  let minIndex2 = -1;
  let index3 = -1;
  if (valueof2 === void 0) {
    for (const value2 of values4) {
      ++index3;
      if (value2 != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
        min10 = value2, minIndex2 = index3;
      }
    }
  } else {
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
        min10 = value2, minIndex2 = index3;
      }
    }
  }
  return minIndex2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left2 = 0, right2 = Infinity, compare) {
  k2 = Math.floor(k2);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k2 && k2 <= right2)) return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n2 = right2 - left2 + 1;
      const m3 = k2 - left2 + 1;
      const z = Math.log(n2);
      const s4 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s4 * (n2 - s4) / n2) * (m3 - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k2 - m3 * s4 / n2 + sd));
      const newRight = Math.min(right2, Math.floor(k2 + (n2 - m3) * s4 / n2 + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i2 = left2;
    let j = right2;
    swap(array2, left2, k2);
    if (compare(array2[right2], t) > 0) swap(array2, left2, right2);
    while (i2 < j) {
      swap(array2, i2, j), ++i2, --j;
      while (compare(array2[i2], t) < 0) ++i2;
      while (compare(array2[j], t) > 0) --j;
    }
    if (compare(array2[left2], t) === 0) swap(array2, left2, j);
    else ++j, swap(array2, j, right2);
    if (j <= k2) left2 = j + 1;
    if (k2 <= j) right2 = j - 1;
  }
  return array2;
}
function swap(array2, i2, j) {
  const t = array2[i2];
  array2[i2] = array2[j];
  array2[j] = t;
}

// node_modules/d3-array/src/greatest.js
function greatest(values4, compare = ascending) {
  let max11;
  let defined4 = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values4) {
      const value2 = compare(element);
      if (defined4 ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
        max11 = element;
        maxValue = value2;
        defined4 = true;
      }
    }
  } else {
    for (const value2 of values4) {
      if (defined4 ? compare(value2, max11) > 0 : compare(value2, value2) === 0) {
        max11 = value2;
        defined4 = true;
      }
    }
  }
  return max11;
}

// node_modules/d3-array/src/quantile.js
function quantile(values4, p3, valueof2) {
  values4 = Float64Array.from(numbers(values4, valueof2));
  if (!(n2 = values4.length) || isNaN(p3 = +p3)) return;
  if (p3 <= 0 || n2 < 2) return min4(values4);
  if (p3 >= 1) return max5(values4);
  var n2, i2 = (n2 - 1) * p3, i0 = Math.floor(i2), value0 = max5(quickselect(values4, i0).subarray(0, i0 + 1)), value1 = min4(values4.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i2 - i0);
}
function quantileIndex(values4, p3, valueof2 = number) {
  if (isNaN(p3 = +p3)) return;
  numbers2 = Float64Array.from(values4, (_2, i3) => number(valueof2(values4[i3], i3, values4)));
  if (p3 <= 0) return minIndex(numbers2);
  if (p3 >= 1) return maxIndex(numbers2);
  var numbers2, index3 = Uint32Array.from(values4, (_2, i3) => i3), j = numbers2.length - 1, i2 = Math.floor(j * p3);
  quickselect(index3, i2, 0, j, (i3, j2) => ascendingDefined(numbers2[i3], numbers2[j2]));
  i2 = greatest(index3.subarray(0, i2 + 1), (i3) => numbers2[i3]);
  return i2 >= 0 ? i2 : -1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values4, min10, max11) {
  const c6 = count(values4), d4 = deviation(values4);
  return c6 && d4 ? Math.ceil((max11 - min10) * Math.cbrt(c6) / (3.49 * d4)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values4, valueof2) {
  let count4 = 0;
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count4, sum4 += value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if ((value2 = valueof2(value2, ++index3, values4)) != null && (value2 = +value2) >= value2) {
        ++count4, sum4 += value2;
      }
    }
  }
  if (count4) return sum4 / count4;
}

// node_modules/d3-array/src/median.js
function median(values4, valueof2) {
  return quantile(values4, 0.5, valueof2);
}
function medianIndex(values4, valueof2) {
  return quantileIndex(values4, 0.5, valueof2);
}

// node_modules/d3-array/src/merge.js
function* flatten2(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge(arrays) {
  return Array.from(flatten2(arrays));
}

// node_modules/d3-array/src/range.js
function range(start, stop, step2) {
  start = +start, stop = +stop, step2 = (n2 = arguments.length) < 2 ? (stop = start, start = 0, 1) : n2 < 3 ? 1 : +step2;
  var i2 = -1, n2 = Math.max(0, Math.ceil((stop - start) / step2)) | 0, range3 = new Array(n2);
  while (++i2 < n2) {
    range3[i2] = start + i2 * step2;
  }
  return range3;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random5) {
  return function shuffle2(array2, i0 = 0, i1 = array2.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i2 = random5() * m3-- | 0, t = array2[m3 + i0];
      array2[m3 + i0] = array2[i2 + i0];
      array2[i2 + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values4, valueof2) {
  let sum4 = 0;
  if (valueof2 === void 0) {
    for (let value2 of values4) {
      if (value2 = +value2) {
        sum4 += value2;
      }
    }
  } else {
    let index3 = -1;
    for (let value2 of values4) {
      if (value2 = +valueof2(value2, ++index3, values4)) {
        sum4 += value2;
      }
    }
  }
  return sum4;
}

// node_modules/@antv/scale/esm/utils/compose.js
function compose(fn, ...rest) {
  return rest.reduce((pre, cur) => (x3) => pre(cur(x3)), fn);
}

// node_modules/@antv/scale/esm/utils/normalize.js
function createNormalize(a5, b) {
  return b - a5 ? (t) => (t - a5) / (b - a5) : (_2) => 0.5;
}

// node_modules/@antv/scale/esm/utils/clamp.js
function createClamp(a5, b) {
  const lo = b < a5 ? b : a5;
  const hi = a5 > b ? a5 : b;
  return (x3) => Math.min(Math.max(lo, x3), hi);
}

// node_modules/@antv/scale/esm/utils/bisect.js
function bisect(array2, x3, lo, hi, getter) {
  let i2 = lo || 0;
  let j = hi || array2.length;
  const get4 = getter || ((x4) => x4);
  while (i2 < j) {
    const mid2 = Math.floor((i2 + j) / 2);
    if (get4(array2[mid2]) > x3) {
      j = mid2;
    } else {
      i2 = mid2 + 1;
    }
  }
  return i2;
}

// node_modules/@antv/scale/esm/utils/ticks.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickIncrement2(start, stop, count4) {
  const step2 = (stop - start) / Math.max(0, count4);
  const power = Math.floor(Math.log(step2) / Math.LN10);
  const error3 = step2 / 10 ** power;
  if (power >= 0) {
    return (error3 >= e102 ? 10 : error3 >= e52 ? 5 : error3 >= e22 ? 2 : 1) * 10 ** power;
  }
  return -(10 ** -power) / (error3 >= e102 ? 10 : error3 >= e52 ? 5 : error3 >= e22 ? 2 : 1);
}
function tickStep2(start, stop, count4) {
  const step0 = Math.abs(stop - start) / Math.max(0, count4);
  let step1 = 10 ** Math.floor(Math.log(step0) / Math.LN10);
  const error3 = step0 / step1;
  if (error3 >= e102)
    step1 *= 10;
  else if (error3 >= e52)
    step1 *= 5;
  else if (error3 >= e22)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}

// node_modules/@antv/scale/esm/utils/d3-linear-nice.js
var d3LinearNice = (min10, max11, count4 = 5) => {
  const d4 = [min10, max11];
  let i0 = 0;
  let i1 = d4.length - 1;
  let start = d4[i0];
  let stop = d4[i1];
  let step2;
  if (stop < start) {
    [start, stop] = [stop, start];
    [i0, i1] = [i1, i0];
  }
  step2 = tickIncrement2(start, stop, count4);
  if (step2 > 0) {
    start = Math.floor(start / step2) * step2;
    stop = Math.ceil(stop / step2) * step2;
    step2 = tickIncrement2(start, stop, count4);
  } else if (step2 < 0) {
    start = Math.ceil(start * step2) / step2;
    stop = Math.floor(stop * step2) / step2;
    step2 = tickIncrement2(start, stop, count4);
  }
  if (step2 > 0) {
    d4[i0] = Math.floor(start / step2) * step2;
    d4[i1] = Math.ceil(stop / step2) * step2;
  } else if (step2 < 0) {
    d4[i0] = Math.ceil(start * step2) / step2;
    d4[i1] = Math.floor(stop * step2) / step2;
  }
  return d4;
};

// node_modules/@antv/scale/esm/utils/time-interval.js
var DURATION_SECOND = 1e3;
var DURATION_MINUTE = DURATION_SECOND * 60;
var DURATION_HOUR = DURATION_MINUTE * 60;
var DURATION_DAY = DURATION_HOUR * 24;
var DURATION_WEEK = DURATION_DAY * 7;
var DURATION_MONTH = DURATION_DAY * 30;
var DURATION_YEAR = DURATION_DAY * 365;
function createInterval(duration, floorish, offseti, field3) {
  const adjust2 = (date, step2) => {
    const test = (date2) => field3(date2) % step2 === 0;
    let i2 = step2;
    while (i2 && !test(date)) {
      offseti(date, -1);
      i2 -= 1;
    }
    return date;
  };
  const floori = (date, step2) => {
    if (step2)
      adjust2(date, step2);
    floorish(date);
  };
  const floor4 = (date, step2) => {
    const d4 = /* @__PURE__ */ new Date(+date);
    floori(d4, step2);
    return d4;
  };
  const ceil6 = (date, step2) => {
    const d4 = new Date(+date - 1);
    floori(d4, step2);
    offseti(d4, step2);
    floori(d4);
    return d4;
  };
  const range3 = (start, stop, step2, shouldAdjust) => {
    const ticks2 = [];
    const roundStep = Math.floor(step2);
    const t = shouldAdjust ? ceil6(start, step2) : ceil6(start);
    for (let i2 = t; i2 < stop; offseti(i2, roundStep), floori(i2)) {
      ticks2.push(/* @__PURE__ */ new Date(+i2));
    }
    return ticks2;
  };
  return {
    ceil: ceil6,
    floor: floor4,
    range: range3,
    duration
  };
}
var millisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
  date.setTime(+date + step2);
}, (date) => date.getTime());
var second = createInterval(DURATION_SECOND, (date) => {
  date.setMilliseconds(0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_SECOND * step2);
}, (date) => date.getSeconds());
var minute = createInterval(DURATION_MINUTE, (date) => {
  date.setSeconds(0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_MINUTE * step2);
}, (date) => date.getMinutes());
var hour = createInterval(DURATION_HOUR, (date) => {
  date.setMinutes(0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_HOUR * step2);
}, (date) => date.getHours());
var day = createInterval(DURATION_DAY, (date) => {
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_DAY * step2);
}, (date) => date.getDate() - 1);
var month = createInterval(DURATION_MONTH, (date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const month2 = date.getMonth();
  date.setMonth(month2 + step2);
}, (date) => date.getMonth());
var week = createInterval(DURATION_WEEK, (date) => {
  date.setDate(date.getDate() - date.getDay() % 7);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setDate(date.getDate() + 7 * step2);
}, (date) => {
  const start = month.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var year = createInterval(DURATION_YEAR, (date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const year2 = date.getFullYear();
  date.setFullYear(year2 + step2);
}, (date) => date.getFullYear());
var localIntervalMap = {
  millisecond,
  second,
  minute,
  hour,
  day,
  week,
  month,
  year
};

// node_modules/@antv/scale/esm/utils/utc-interval.js
var utcMillisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
  date.setTime(+date + step2);
}, (date) => date.getTime());
var utcSecond = createInterval(DURATION_SECOND, (date) => {
  date.setUTCMilliseconds(0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_SECOND * step2);
}, (date) => date.getUTCSeconds());
var utcMinute = createInterval(DURATION_MINUTE, (date) => {
  date.setUTCSeconds(0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_MINUTE * step2);
}, (date) => date.getUTCMinutes());
var utcHour = createInterval(DURATION_HOUR, (date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_HOUR * step2);
}, (date) => date.getUTCHours());
var utcDay = createInterval(DURATION_DAY, (date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_DAY * step2);
}, (date) => date.getUTCDate() - 1);
var utcMonth = createInterval(DURATION_MONTH, (date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const month2 = date.getUTCMonth();
  date.setUTCMonth(month2 + step2);
}, (date) => date.getUTCMonth());
var utcWeek = createInterval(DURATION_WEEK, (date) => {
  date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7) % 7);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  date.setTime(+date + DURATION_WEEK * step2);
}, (date) => {
  const start = utcMonth.floor(date);
  const end = /* @__PURE__ */ new Date(+date);
  return Math.floor((+end - +start) / DURATION_WEEK);
});
var utcYear = createInterval(DURATION_YEAR, (date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step2 = 1) => {
  const year2 = date.getUTCFullYear();
  date.setUTCFullYear(year2 + step2);
}, (date) => date.getUTCFullYear());
var utcIntervalMap = {
  millisecond: utcMillisecond,
  second: utcSecond,
  minute: utcMinute,
  hour: utcHour,
  day: utcDay,
  week: utcWeek,
  month: utcMonth,
  year: utcYear
};

// node_modules/@antv/scale/esm/utils/find-tick-interval.js
function chooseTickIntervals(utc) {
  const intervalMap = utc ? utcIntervalMap : localIntervalMap;
  const { year: year2, month: month2, week: week2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 } = intervalMap;
  const tickIntervals = [
    [second2, 1],
    [second2, 5],
    [second2, 15],
    [second2, 30],
    [minute2, 1],
    [minute2, 5],
    [minute2, 15],
    [minute2, 30],
    [hour2, 1],
    [hour2, 3],
    [hour2, 6],
    [hour2, 12],
    [day2, 1],
    [day2, 2],
    [week2, 1],
    [month2, 1],
    [month2, 3],
    [year2, 1]
  ];
  return {
    tickIntervals,
    year: year2,
    millisecond: millisecond2
  };
}
function findTickInterval(start, stop, count4, interval2, utc) {
  const lo = +start;
  const hi = +stop;
  const { tickIntervals, year: year2, millisecond: millisecond2 } = chooseTickIntervals(utc);
  const getter = ([interval3, count5]) => interval3.duration * count5;
  const targetCount = interval2 ? (hi - lo) / interval2 : count4 || 5;
  const targetInterval = interval2 || (hi - lo) / targetCount;
  const len5 = tickIntervals.length;
  const i2 = bisect(tickIntervals, targetInterval, 0, len5, getter);
  let matchInterval;
  if (i2 === len5) {
    const step2 = tickStep2(lo / year2.duration, hi / year2.duration, targetCount);
    matchInterval = [year2, step2];
  } else if (i2) {
    const closeToLow = targetInterval / getter(tickIntervals[i2 - 1]) < getter(tickIntervals[i2]) / targetInterval;
    const [timeInterval, targetStep] = closeToLow ? tickIntervals[i2 - 1] : tickIntervals[i2];
    const step2 = interval2 ? Math.ceil(interval2 / timeInterval.duration) : targetStep;
    matchInterval = [timeInterval, step2];
  } else {
    const step2 = Math.max(tickStep2(lo, hi, targetCount), 1);
    matchInterval = [millisecond2, step2];
  }
  return matchInterval;
}

// node_modules/@antv/scale/esm/utils/d3-time-nice.js
var d3TimeNice = (min10, max11, count4, interval2, utc) => {
  const r2 = min10 > max11;
  const lo = r2 ? max11 : min10;
  const hi = r2 ? min10 : max11;
  const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
  const domain = [tickInterval.floor(lo, step2), tickInterval.ceil(hi, step2)];
  return r2 ? domain.reverse() : domain;
};

// node_modules/@antv/scale/esm/utils/is-valid.js
function isValid(x3) {
  return !is_undefined_default(x3) && !isNull(x3) && !Number.isNaN(x3);
}

// node_modules/@antv/scale/esm/utils/log.js
var reflect = (f2) => {
  return (x3) => -f2(-x3);
};
var logs = (base, shouldReflect) => {
  const baseCache = Math.log(base);
  const log2 = base === Math.E ? Math.log : base === 10 ? Math.log10 : base === 2 ? Math.log2 : (x3) => Math.log(x3) / baseCache;
  return shouldReflect ? reflect(log2) : log2;
};
var pows = (base, shouldReflect) => {
  const pow3 = base === Math.E ? Math.exp : (x3) => base ** x3;
  return shouldReflect ? reflect(pow3) : pow3;
};

// node_modules/@antv/scale/esm/utils/d3-log-nice.js
var d3LogNice = (a5, b, _2, base) => {
  const shouldReflect = a5 < 0;
  const log2 = logs(base, shouldReflect);
  const pow3 = pows(base, shouldReflect);
  const r2 = a5 > b;
  const min10 = r2 ? b : a5;
  const max11 = r2 ? a5 : b;
  const niceDomain = [pow3(Math.floor(log2(min10))), pow3(Math.ceil(log2(max11)))];
  return r2 ? niceDomain.reverse() : niceDomain;
};

// node_modules/@antv/scale/esm/utils/interpolatize.js
var createInterpolatorRound = (interpolator) => {
  return (t) => {
    const res = interpolator(t);
    return isNumber(res) ? Math.round(res) : res;
  };
};
function interpolatize(rangeOf5, normalizeDomain3) {
  return (Scale) => {
    Scale.prototype.rescale = function() {
      this.initRange();
      this.nice();
      const [transform2] = this.chooseTransforms();
      this.composeOutput(transform2, this.chooseClamp(transform2));
    };
    Scale.prototype.initRange = function() {
      const { interpolator } = this.options;
      this.options.range = rangeOf5(interpolator);
    };
    Scale.prototype.composeOutput = function(transform2, clamp3) {
      const { domain, interpolator, round: round6 } = this.getOptions();
      const normalize10 = normalizeDomain3(domain.map(transform2));
      const interpolate4 = round6 ? createInterpolatorRound(interpolator) : interpolator;
      this.output = compose(interpolate4, normalize10, clamp3, transform2);
    };
    Scale.prototype.invert = void 0;
  };
}

// node_modules/@antv/scale/esm/utils/color.js
var import_color_string = __toESM(require_color_string());
function hue2rgb(p3, q, m3) {
  let t = m3;
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p3 + (q - p3) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p3 + (q - p3) * (2 / 3 - t) * 6;
  return p3;
}
function hsl2rbg(hsl4) {
  const h2 = hsl4[0] / 360;
  const s4 = hsl4[1] / 100;
  const l2 = hsl4[2] / 100;
  const a5 = hsl4[3];
  if (s4 === 0)
    return [l2 * 255, l2 * 255, l2 * 255, a5];
  const q = l2 < 0.5 ? l2 * (1 + s4) : l2 + s4 - l2 * s4;
  const p3 = 2 * l2 - q;
  const r2 = hue2rgb(p3, q, h2 + 1 / 3);
  const g = hue2rgb(p3, q, h2);
  const b = hue2rgb(p3, q, h2 - 1 / 3);
  return [r2 * 255, g * 255, b * 255, a5];
}
function string2rbg(s4) {
  const color3 = import_color_string.default.get(s4);
  if (!color3)
    return null;
  const { model, value: value2 } = color3;
  if (model === "rgb")
    return value2;
  if (model === "hsl")
    return hsl2rbg(value2);
  return null;
}

// node_modules/@antv/scale/esm/utils/interpolate.js
var createInterpolateNumber = (a5, b) => {
  return (t) => a5 * (1 - t) + b * t;
};
var createInterpolateColor = (a5, b) => {
  const c1 = string2rbg(a5);
  const c22 = string2rbg(b);
  if (c1 === null || c22 === null)
    return c1 ? () => a5 : () => b;
  return (t) => {
    const values4 = new Array(4);
    for (let i2 = 0; i2 < 4; i2 += 1) {
      const from = c1[i2];
      const to = c22[i2];
      values4[i2] = from * (1 - t) + to * t;
    }
    const [r2, g, b2, a6] = values4;
    return `rgba(${Math.round(r2)}, ${Math.round(g)}, ${Math.round(b2)}, ${a6})`;
  };
};
var createInterpolateValue = (a5, b) => {
  if (typeof a5 === "number" && typeof b === "number")
    return createInterpolateNumber(a5, b);
  if (typeof a5 === "string" && typeof b === "string")
    return createInterpolateColor(a5, b);
  return () => a5;
};
var createInterpolateRound = (a5, b) => {
  const interpolateNumber = createInterpolateNumber(a5, b);
  return (t) => Math.round(interpolateNumber(t));
};

// node_modules/@antv/scale/esm/utils/choose-mask.js
function chooseNiceTimeMask(date, intervalMap) {
  const { second: second2, minute: minute2, hour: hour2, day: day2, week: week2, month: month2, year: year2 } = intervalMap;
  if (second2.floor(date) < date)
    return ".SSS";
  if (minute2.floor(date) < date)
    return ":ss";
  if (hour2.floor(date) < date)
    return "hh:mm";
  if (day2.floor(date) < date)
    return "hh A";
  if (month2.floor(date) < date) {
    if (week2.floor(date) < date)
      return "MMM DD";
    return "ddd DD";
  }
  if (year2.floor(date) < date)
    return "MMMM";
  return "YYYY";
}

// node_modules/@antv/scale/esm/utils/internMap.js
function internGet({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  return map5.has(key) ? map5.get(key) : value2;
}
function internSet({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key))
    return map5.get(key);
  map5.set(key, value2);
  return value2;
}
function internDelete({ map: map5, initKey }, value2) {
  const key = initKey(value2);
  if (map5.has(key)) {
    value2 = map5.get(key);
    map5.delete(key);
  }
  return value2;
}
function keyof2(value2) {
  return typeof value2 === "object" ? value2.valueOf() : value2;
}
var InternMap2 = class extends Map {
  constructor(entries) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.initKey = keyof2;
    if (entries !== null) {
      for (const [key, value2] of entries) {
        this.set(key, value2);
      }
    }
  }
  get(key) {
    return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  has(key) {
    return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
  }
  set(key, value2) {
    return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value2);
  }
  delete(key) {
    return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
  }
};

// node_modules/@antv/scale/esm/scales/base.js
var Base = class {
  /**
   * 
   * @param options 
   */
  constructor(options) {
    this.options = deep_mix_default({}, this.getDefaultOptions());
    this.update(options);
  }
  /**
   * 
   * @returns 
   */
  getOptions() {
    return this.options;
  }
  /**
   * 
   * @param updateOptions 
   */
  update(updateOptions = {}) {
    this.options = deep_mix_default({}, this.options, updateOptions);
    this.rescale(updateOptions);
  }
  /**
   *  options  options  scale 
   *  this.options  options
   * @param options  options
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rescale(options) {
  }
};

// node_modules/@antv/scale/esm/scales/ordinal.js
var defaultUnknown = Symbol("defaultUnknown");
function updateIndexMap(target, arr, key) {
  for (let i2 = 0; i2 < arr.length; i2 += 1) {
    if (!target.has(arr[i2])) {
      target.set(key(arr[i2]), i2);
    }
  }
}
function mapBetweenArrByMapIndex(options) {
  const { value: value2, from, to, mapper, notFoundReturn } = options;
  let mappedIndex = mapper.get(value2);
  if (mappedIndex === void 0) {
    if (notFoundReturn !== defaultUnknown) {
      return notFoundReturn;
    }
    mappedIndex = from.push(value2) - 1;
    mapper.set(value2, mappedIndex);
  }
  return to[mappedIndex % to.length];
}
function createKey(d4) {
  if (d4 instanceof Date)
    return (d5) => `${d5}`;
  if (typeof d4 === "object")
    return (d5) => JSON.stringify(d5);
  return (d5) => d5;
}
var Ordinal = class _Ordinal extends Base {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      unknown: defaultUnknown
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  map(x3) {
    if (this.domainIndexMap.size === 0) {
      updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.domainKey(x3),
      mapper: this.domainIndexMap,
      from: this.getDomain(),
      to: this.getRange(),
      notFoundReturn: this.options.unknown
    });
  }
  invert(y4) {
    if (this.rangeIndexMap.size === 0) {
      updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
    }
    return mapBetweenArrByMapIndex({
      value: this.rangeKey(y4),
      mapper: this.rangeIndexMap,
      from: this.getRange(),
      to: this.getDomain(),
      notFoundReturn: this.options.unknown
    });
  }
  //  ordinal 
  rescale(options) {
    const [d4] = this.options.domain;
    const [r2] = this.options.range;
    this.domainKey = createKey(d4);
    this.rangeKey = createKey(r2);
    if (!this.rangeIndexMap) {
      this.rangeIndexMap = /* @__PURE__ */ new Map();
      this.domainIndexMap = /* @__PURE__ */ new Map();
      return;
    }
    if (!options || options.range) {
      this.rangeIndexMap.clear();
    }
    if (!options || options.domain || options.compare) {
      this.domainIndexMap.clear();
      this.sortedDomain = void 0;
    }
  }
  clone() {
    return new _Ordinal(this.options);
  }
  getRange() {
    return this.options.range;
  }
  getDomain() {
    if (this.sortedDomain)
      return this.sortedDomain;
    const { domain, compare } = this.options;
    this.sortedDomain = compare ? [...domain].sort(compare) : domain;
    return this.sortedDomain;
  }
};

// node_modules/@antv/scale/esm/scales/band.js
function normalize5(array2) {
  const min10 = Math.min(...array2);
  return array2.map((d4) => d4 / min10);
}
function splice3(array2, n2) {
  const sn = array2.length;
  const diff = n2 - sn;
  return diff > 0 ? [...array2, ...new Array(diff).fill(1)] : diff < 0 ? array2.slice(0, n2) : array2;
}
function pretty(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function computeFlexBandState(options) {
  const { domain, range: range3, paddingOuter, paddingInner, flex: F, round: round6, align } = options;
  const n2 = domain.length;
  const flex2 = splice3(F, n2);
  const [start, end] = range3;
  const width = end - start;
  const ratio = 2 / n2 * paddingOuter + 1 - 1 / n2 * paddingInner;
  const stepSum = width / ratio;
  const PI = stepSum * paddingInner / n2;
  const bandWidthSum = stepSum - n2 * PI;
  const normalizedFlex = normalize5(flex2);
  const flexSum = normalizedFlex.reduce((sum4, value2) => sum4 + value2);
  const minBandWidth = bandWidthSum / flexSum;
  const valueBandWidth = new InternMap2(domain.map((d4, i2) => {
    const bandWidth3 = normalizedFlex[i2] * minBandWidth;
    return [d4, round6 ? Math.floor(bandWidth3) : bandWidth3];
  }));
  const valueStep = new InternMap2(domain.map((d4, i2) => {
    const bandWidth3 = normalizedFlex[i2] * minBandWidth;
    const step2 = bandWidth3 + PI;
    return [d4, round6 ? Math.floor(step2) : step2];
  }));
  const finalStepSum = Array.from(valueStep.values()).reduce((sum4, value2) => sum4 + value2);
  const outerPaddingSum = width - (finalStepSum - finalStepSum / n2 * paddingInner);
  const offset2 = outerPaddingSum * align;
  const bandStart = start + offset2;
  let prev = round6 ? Math.round(bandStart) : bandStart;
  const adjustedRange = new Array(n2);
  for (let i2 = 0; i2 < n2; i2 += 1) {
    adjustedRange[i2] = pretty(prev);
    const value2 = domain[i2];
    prev += valueStep.get(value2);
  }
  return {
    valueBandWidth,
    valueStep,
    adjustedRange
  };
}
function computeBandState(options) {
  var _a2;
  const { domain } = options;
  const n2 = domain.length;
  if (n2 === 0) {
    return {
      valueBandWidth: void 0,
      valueStep: void 0,
      adjustedRange: []
    };
  }
  const hasFlex = !!((_a2 = options.flex) === null || _a2 === void 0 ? void 0 : _a2.length);
  if (hasFlex) {
    return computeFlexBandState(options);
  }
  const { range: range3, paddingOuter, paddingInner, round: round6, align } = options;
  let step2;
  let bandWidth3;
  let rangeStart = range3[0];
  const rangeEnd = range3[1];
  const deltaRange = rangeEnd - rangeStart;
  const outerTotal = paddingOuter * 2;
  const innerTotal = n2 - paddingInner;
  step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
  if (round6) {
    step2 = Math.floor(step2);
  }
  rangeStart += (deltaRange - step2 * (n2 - paddingInner)) * align;
  bandWidth3 = step2 * (1 - paddingInner);
  if (round6) {
    rangeStart = Math.round(rangeStart);
    bandWidth3 = Math.round(bandWidth3);
  }
  const adjustedRange = new Array(n2).fill(0).map((_2, i2) => rangeStart + i2 * step2);
  return {
    valueStep: step2,
    valueBandWidth: bandWidth3,
    adjustedRange
  };
}
var Band = class _Band extends Ordinal {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      paddingInner: 0,
      paddingOuter: 0,
      padding: 0,
      unknown: defaultUnknown,
      flex: []
    };
  }
  //  options  OrdinalOptions O 
  constructor(options) {
    super(options);
  }
  clone() {
    return new _Band(this.options);
  }
  getStep(x3) {
    if (this.valueStep === void 0)
      return 1;
    if (typeof this.valueStep === "number") {
      return this.valueStep;
    }
    if (x3 === void 0)
      return Array.from(this.valueStep.values())[0];
    return this.valueStep.get(x3);
  }
  getBandWidth(x3) {
    if (this.valueBandWidth === void 0)
      return 1;
    if (typeof this.valueBandWidth === "number") {
      return this.valueBandWidth;
    }
    if (x3 === void 0)
      return Array.from(this.valueBandWidth.values())[0];
    return this.valueBandWidth.get(x3);
  }
  getRange() {
    return this.adjustedRange;
  }
  getPaddingInner() {
    const { padding, paddingInner } = this.options;
    return padding > 0 ? padding : paddingInner;
  }
  getPaddingOuter() {
    const { padding, paddingOuter } = this.options;
    return padding > 0 ? padding : paddingOuter;
  }
  rescale() {
    super.rescale();
    const { align, domain, range: range3, round: round6, flex: flex2 } = this.options;
    const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
      align,
      range: range3,
      round: round6,
      flex: flex2,
      paddingInner: this.getPaddingInner(),
      paddingOuter: this.getPaddingOuter(),
      domain
    });
    this.valueStep = valueStep;
    this.valueBandWidth = valueBandWidth;
    this.adjustedRange = adjustedRange;
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
var d3Ticks = (begin, end, count4) => {
  let n2;
  let ticks2;
  let start = begin;
  let stop = end;
  if (start === stop && count4 > 0) {
    return [start];
  }
  let step2 = tickIncrement2(start, stop, count4);
  if (step2 === 0 || !Number.isFinite(step2)) {
    return [];
  }
  if (step2 > 0) {
    start = Math.ceil(start / step2);
    stop = Math.floor(stop / step2);
    ticks2 = new Array(n2 = Math.ceil(stop - start + 1));
    for (let i2 = 0; i2 < n2; i2 += 1) {
      ticks2[i2] = (start + i2) * step2;
    }
  } else {
    step2 = -step2;
    start = Math.ceil(start * step2);
    stop = Math.floor(stop * step2);
    ticks2 = new Array(n2 = Math.ceil(stop - start + 1));
    for (let i2 = 0; i2 < n2; i2 += 1) {
      ticks2[i2] = (start + i2) / step2;
    }
  }
  return ticks2;
};

// node_modules/@antv/scale/esm/scales/constant.js
var Constant2 = class _Constant extends Base {
  /**
   * 
   * @returns 
   */
  getDefaultOptions() {
    return {
      range: [0],
      domain: [0, 1],
      unknown: void 0,
      tickCount: 5,
      tickMethod: d3Ticks
    };
  }
  /**
   * y = b b  options.range 
   * @param _ 
   * @returns 
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_2) {
    const [v] = this.options.range;
    return v !== void 0 ? v : this.options.unknown;
  }
  /**
   *  x x === b []
   * @param x  (
   * @returns 
   */
  invert(x3) {
    const [v] = this.options.range;
    return x3 === v && v !== void 0 ? this.options.domain : [];
  }
  getTicks() {
    const { tickMethod, domain, tickCount } = this.options;
    const [a5, b] = domain;
    if (!isNumber(a5) || !isNumber(b))
      return [];
    return tickMethod(a5, b, tickCount);
  }
  /**
   *  Constant Scale
   * @returns  Constant Scale
   */
  clone() {
    return new _Constant(this.options);
  }
};

// node_modules/@antv/scale/esm/utils/pretty-number.js
function prettyNumber(n2) {
  return Math.abs(n2) < 1e-14 ? n2 : parseFloat(n2.toFixed(14));
}

// node_modules/@antv/scale/esm/tick-methods/wilkinson-extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod2(n2, m3) {
  return (n2 % m3 + m3) % m3;
}
function round5(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  const n2 = size(Q);
  const i2 = index_of_default(Q, q);
  let v = 0;
  const m3 = mod2(lmin, lstep);
  if ((m3 < eps || lstep - m3 < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i2 / (n2 - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  const n2 = size(Q);
  const i2 = index_of_default(Q, q);
  const v = 1;
  return 1 - i2 / (n2 - 1) - j + v;
}
function density(k2, m3, dMin, dMax, lMin, lMax) {
  const r2 = (k2 - 1) / (lMax - lMin);
  const rt = (m3 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r2 / rt, rt / r2);
}
function densityMax(k2, m3) {
  if (k2 >= m3) {
    return 2 - (k2 - 1) / (m3 - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  const range3 = dMax - dMin;
  return 1 - 0.5 * ((dMax - lMax) ** 2 + (dMin - lMin) ** 2) / (0.1 * range3) ** 2;
}
function coverageMax(dMin, dMax, span) {
  const range3 = dMax - dMin;
  if (span > range3) {
    const half = (span - range3) / 2;
    return 1 - half ** 2 / (0.1 * range3) ** 2;
  }
  return 1;
}
function legibility() {
  return 1;
}
var wilkinsonExtended = (dMin, dMax, n2 = 5, onlyLoose = true, Q = DEFAULT_Q, w2 = [0.25, 0.2, 0.5, 0.05]) => {
  const m3 = n2 < 0 ? 0 : Math.round(n2);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m3) {
    return [];
  }
  if (dMax - dMin < 1e-15 || m3 === 1) {
    return [dMin];
  }
  const best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  let j = 1;
  while (j < Infinity) {
    for (let i2 = 0; i2 < Q.length; i2 += 1) {
      const q = Q[i2];
      const sm = simplicityMax(q, Q, j);
      if (w2[0] * sm + w2[1] + w2[2] + w2[3] < best.score) {
        j = Infinity;
        break;
      }
      let k2 = 2;
      while (k2 < Infinity) {
        const dm = densityMax(k2, m3);
        if (w2[0] * sm + w2[1] + w2[2] * dm + w2[3] < best.score) {
          break;
        }
        const delta = (dMax - dMin) / (k2 + 1) / j / q;
        let z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          const step2 = j * q * 10 ** z;
          const cm = coverageMax(dMin, dMax, step2 * (k2 - 1));
          if (w2[0] * sm + w2[1] * cm + w2[2] * dm + w2[3] < best.score) {
            break;
          }
          const minStart = Math.floor(dMax / step2) * j - (k2 - 1) * j;
          const maxStart = Math.ceil(dMin / step2) * j;
          if (minStart <= maxStart) {
            const count4 = maxStart - minStart;
            for (let i3 = 0; i3 <= count4; i3 += 1) {
              const start = minStart + i3;
              const lMin = start * (step2 / j);
              const lMax = lMin + step2 * (k2 - 1);
              const lStep = step2;
              const s4 = simplicity(q, Q, j, lMin, lMax, lStep);
              const c6 = coverage(dMin, dMax, lMin, lMax);
              const g = density(k2, m3, dMin, dMax, lMin, lMax);
              const l2 = legibility();
              const score2 = w2[0] * s4 + w2[1] * c6 + w2[2] * g + w2[3] * l2;
              if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score2;
              }
            }
          }
          z += 1;
        }
        k2 += 1;
      }
    }
    j += 1;
  }
  const lmax = prettyNumber(best.lmax);
  const lmin = prettyNumber(best.lmin);
  const lstep = prettyNumber(best.lstep);
  const tickCount = Math.floor(round5((lmax - lmin) / lstep)) + 1;
  const ticks2 = new Array(tickCount);
  ticks2[0] = prettyNumber(lmin);
  for (let i2 = 1; i2 < tickCount; i2 += 1) {
    ticks2[i2] = prettyNumber(ticks2[i2 - 1] + lstep);
  }
  return ticks2;
};

// node_modules/@antv/scale/esm/scales/identity.js
var Identity = class _Identity extends Base {
  /**
   * 
   * @returns 
   */
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      tickCount: 5,
      unknown: void 0,
      tickMethod: wilkinsonExtended
    };
  }
  /**
   * y = x
   * @param x 
   * @returns 
   */
  map(x3) {
    return isValid(x3) ? x3 : this.options.unknown;
  }
  /**
   * map x = y map 
   * @param x 
   * @returns 
   */
  invert(x3) {
    return this.map(x3);
  }
  /**
   *  Identity Scale
   * @returns  Identity Scale
   */
  clone() {
    return new _Identity(this.options);
  }
  /**
   *  ticks ticks 
   * @returns  ticks 
   */
  getTicks() {
    const { domain, tickCount, tickMethod } = this.options;
    const [min10, max11] = domain;
    if (!isNumber(min10) || !isNumber(max11))
      return [];
    return tickMethod(min10, max11, tickCount);
  }
};

// node_modules/@antv/scale/esm/scales/continuous.js
var createBiMap = (domain, range3, createInterpolate) => {
  const [d0, d1] = domain;
  const [r0, r1] = range3;
  let normalize10;
  let interpolate4;
  if (d0 < d1) {
    normalize10 = createNormalize(d0, d1);
    interpolate4 = createInterpolate(r0, r1);
  } else {
    normalize10 = createNormalize(d1, d0);
    interpolate4 = createInterpolate(r1, r0);
  }
  return compose(interpolate4, normalize10);
};
var createPolyMap = (domain, range3, createInterpolate) => {
  const len5 = Math.min(domain.length, range3.length) - 1;
  const normalizeList = new Array(len5);
  const interpolateList = new Array(len5);
  const reverse2 = domain[0] > domain[len5];
  const ascendingDomain = reverse2 ? [...domain].reverse() : domain;
  const ascendingRange = reverse2 ? [...range3].reverse() : range3;
  for (let i2 = 0; i2 < len5; i2 += 1) {
    normalizeList[i2] = createNormalize(ascendingDomain[i2], ascendingDomain[i2 + 1]);
    interpolateList[i2] = createInterpolate(ascendingRange[i2], ascendingRange[i2 + 1]);
  }
  return (x3) => {
    const i2 = bisect(domain, x3, 1, len5) - 1;
    const normalize10 = normalizeList[i2];
    const interpolate4 = interpolateList[i2];
    return compose(interpolate4, normalize10)(x3);
  };
};
var choosePiecewise = (domain, range3, interpolate4, shouldRound) => {
  const n2 = Math.min(domain.length, range3.length);
  const createPiecewise = n2 > 2 ? createPolyMap : createBiMap;
  const createInterpolate = shouldRound ? createInterpolateRound : interpolate4;
  return createPiecewise(domain, range3, createInterpolate);
};
var Continuous = class extends Base {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateNumber,
      tickCount: 5
    };
  }
  /**
   * y = interpolate(normalize(clamp(transform(x))))
   */
  map(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    return this.output(x3);
  }
  /**
   * x = transform(clamp(interpolate(normalize(y))))
   */
  invert(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    return this.input(x3);
  }
  nice() {
    if (!this.options.nice)
      return;
    const [min10, max11, tickCount, ...rest] = this.getTickMethodOptions();
    this.options.domain = this.chooseNice()(min10, max11, tickCount, ...rest);
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min10, max11, tickCount, ...rest] = this.getTickMethodOptions();
    return tickMethod(min10, max11, tickCount, ...rest);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min10 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min10, max11, tickCount];
  }
  chooseNice() {
    return d3LinearNice;
  }
  rescale() {
    this.nice();
    const [transform2, untransform] = this.chooseTransforms();
    this.composeOutput(transform2, this.chooseClamp(transform2));
    this.composeInput(transform2, untransform, this.chooseClamp(untransform));
  }
  chooseClamp(transform2) {
    const { clamp: shouldClamp, range: range3 } = this.options;
    const domain = this.options.domain.map(transform2);
    const n2 = Math.min(domain.length, range3.length);
    return shouldClamp ? createClamp(domain[0], domain[n2 - 1]) : identity_default;
  }
  composeOutput(transform2, clamp3) {
    const { domain, range: range3, round: round6, interpolate: interpolate4 } = this.options;
    const piecewise2 = choosePiecewise(domain.map(transform2), range3, interpolate4, round6);
    this.output = compose(piecewise2, clamp3, transform2);
  }
  composeInput(transform2, untransform, clamp3) {
    const { domain, range: range3 } = this.options;
    const piecewise2 = choosePiecewise(range3, domain.map(transform2), createInterpolateNumber);
    this.input = compose(untransform, clamp3, piecewise2);
  }
};

// node_modules/@antv/scale/esm/scales/linear.js
var Linear = class _Linear extends Continuous {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  chooseTransforms() {
    return [identity_default, identity_default];
  }
  clone() {
    return new _Linear(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/point.js
var Point = class _Point extends Band {
  // 
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: false,
      padding: 0,
      unknown: defaultUnknown,
      paddingInner: 1,
      paddingOuter: 0
    };
  }
  //  PointOptions paddingInner 
  constructor(options) {
    super(options);
  }
  // Point  paddingInner 1
  getPaddingInner() {
    return 1;
  }
  clone() {
    return new _Point(this.options);
  }
  update(options) {
    super.update(options);
  }
  getPaddingOuter() {
    return this.options.padding;
  }
};

// node_modules/@antv/scale/esm/scales/pow.js
var transformPow = (exponent) => {
  return (x3) => {
    return x3 < 0 ? -((-x3) ** exponent) : x3 ** exponent;
  };
};
var transformPowInvert = (exponent) => {
  return (x3) => {
    return x3 < 0 ? -((-x3) ** (1 / exponent)) : x3 ** (1 / exponent);
  };
};
var transformSqrt = (x3) => {
  return x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
};
var Pow = class _Pow extends Continuous {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      exponent: 2,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  //  options  PowOptions O 
  constructor(options) {
    super(options);
  }
  chooseTransforms() {
    const { exponent } = this.options;
    if (exponent === 1)
      return [identity_default, identity_default];
    const transform2 = exponent === 0.5 ? transformSqrt : transformPow(exponent);
    const untransform = transformPowInvert(exponent);
    return [transform2, untransform];
  }
  clone() {
    return new _Pow(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/sqrt.js
var Sqrt = class _Sqrt extends Pow {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0, 1],
      nice: false,
      clamp: false,
      round: false,
      interpolate: createInterpolateValue,
      tickMethod: d3Ticks,
      tickCount: 5,
      exponent: 0.5
    };
  }
  constructor(options) {
    super(options);
  }
  update(options) {
    super.update(options);
  }
  clone() {
    return new _Sqrt(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/threshold.js
var Threshold = class _Threshold extends Base {
  getDefaultOptions() {
    return {
      domain: [0.5],
      range: [0, 1]
    };
  }
  constructor(options) {
    super(options);
  }
  /**
   * 
   */
  map(x3) {
    if (!isValid(x3))
      return this.options.unknown;
    const index3 = bisect(this.thresholds, x3, 0, this.n);
    return this.options.range[index3];
  }
  /**
   * 
   */
  invert(y4) {
    const { range: range3 } = this.options;
    const index3 = range3.indexOf(y4);
    const domain = this.thresholds;
    return [domain[index3 - 1], domain[index3]];
  }
  clone() {
    return new _Threshold(this.options);
  }
  rescale() {
    const { domain, range: range3 } = this.options;
    this.n = Math.min(domain.length, range3.length - 1);
    this.thresholds = domain;
  }
};

// node_modules/@antv/scale/esm/tick-methods/d3-log.js
var d3Log = (a5, b, n2, base = 10) => {
  const shouldReflect = a5 < 0;
  const pow3 = pows(base, shouldReflect);
  const log2 = logs(base, shouldReflect);
  const r2 = b < a5;
  const min10 = r2 ? b : a5;
  const max11 = r2 ? a5 : b;
  let i2 = log2(min10);
  let j = log2(max11);
  let ticks2 = [];
  if (!(base % 1) && j - i2 < n2) {
    i2 = Math.floor(i2);
    j = Math.ceil(j);
    if (shouldReflect) {
      for (; i2 <= j; i2 += 1) {
        const p3 = pow3(i2);
        for (let k2 = base - 1; k2 >= 1; k2 -= 1) {
          const t = p3 * k2;
          if (t > max11)
            break;
          if (t >= min10)
            ticks2.push(t);
        }
      }
    } else {
      for (; i2 <= j; i2 += 1) {
        const p3 = pow3(i2);
        for (let k2 = 1; k2 < base; k2 += 1) {
          const t = p3 * k2;
          if (t > max11)
            break;
          if (t >= min10)
            ticks2.push(t);
        }
      }
    }
    if (ticks2.length * 2 < n2)
      ticks2 = d3Ticks(min10, max11, n2);
  } else {
    const count4 = n2 === -1 ? j - i2 : Math.min(j - i2, n2);
    ticks2 = d3Ticks(i2, j, count4).map(pow3);
  }
  return r2 ? ticks2.reverse() : ticks2;
};

// node_modules/@antv/scale/esm/scales/log.js
var Log = class _Log extends Continuous {
  getDefaultOptions() {
    return {
      domain: [1, 10],
      range: [0, 1],
      base: 10,
      interpolate: createInterpolateValue,
      tickMethod: d3Log,
      tickCount: 5
    };
  }
  chooseNice() {
    return d3LogNice;
  }
  getTickMethodOptions() {
    const { domain, tickCount, base } = this.options;
    const min10 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min10, max11, tickCount, base];
  }
  chooseTransforms() {
    const { base, domain } = this.options;
    const shouldReflect = domain[0] < 0;
    return [logs(base, shouldReflect), pows(base, shouldReflect)];
  }
  clone() {
    return new _Log(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/quantize.js
var Quantize = class _Quantize extends Threshold {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      range: [0.5],
      nice: false,
      tickCount: 5,
      tickMethod: wilkinsonExtended
    };
  }
  constructor(options) {
    super(options);
  }
  nice() {
    const { nice: nice2 } = this.options;
    if (nice2) {
      const [min10, max11, tickCount] = this.getTickMethodOptions();
      this.options.domain = d3LinearNice(min10, max11, tickCount);
    }
  }
  getTicks() {
    const { tickMethod } = this.options;
    const [min10, max11, tickCount] = this.getTickMethodOptions();
    return tickMethod(min10, max11, tickCount);
  }
  getTickMethodOptions() {
    const { domain, tickCount } = this.options;
    const min10 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min10, max11, tickCount];
  }
  rescale() {
    this.nice();
    const { range: range3, domain } = this.options;
    const [x05, x12] = domain;
    this.n = range3.length - 1;
    this.thresholds = new Array(this.n);
    for (let i2 = 0; i2 < this.n; i2 += 1) {
      this.thresholds[i2] = ((i2 + 1) * x12 - (i2 - this.n) * x05) / (this.n + 1);
    }
  }
  /**
   * 
   */
  invert(y4) {
    const [a5, b] = super.invert(y4);
    const [x05, x12] = this.options.domain;
    return a5 === void 0 && b === void 0 ? [a5, b] : [a5 || x05, b || x12];
  }
  getThresholds() {
    return this.thresholds;
  }
  clone() {
    return new _Quantize(this.options);
  }
};

// node_modules/@antv/scale/esm/utils/create-quartile.js
function quantileSorted2(arr, percentage) {
  const len5 = arr.length;
  if (!len5) {
    return void 0;
  }
  if (len5 < 2) {
    return arr[len5 - 1];
  }
  const i2 = (len5 - 1) * percentage;
  const i0 = Math.floor(i2);
  const v0 = arr[i0];
  const v1 = arr[i0 + 1];
  return v0 + (v1 - v0) * (i2 - i0);
}
function createQuartile(arr, n2, isSorted = false) {
  const numberArr = arr;
  if (!isSorted) {
    numberArr.sort((a5, b) => a5 - b);
  }
  const tmp2 = [];
  for (let i2 = 1; i2 < n2; i2 += 1) {
    tmp2.push(quantileSorted2(numberArr, i2 / n2));
  }
  return tmp2;
}

// node_modules/@antv/scale/esm/scales/quantile.js
var Quantile = class _Quantile extends Threshold {
  getDefaultOptions() {
    return {
      domain: [],
      range: [],
      tickCount: 5,
      unknown: void 0,
      tickMethod: wilkinsonExtended
    };
  }
  constructor(options) {
    super(options);
  }
  rescale() {
    const { domain, range: range3 } = this.options;
    this.n = range3.length - 1;
    this.thresholds = createQuartile(domain, this.n + 1, false);
  }
  /**
   * 
   */
  invert(y4) {
    const [a5, b] = super.invert(y4);
    const { domain } = this.options;
    const dMin = domain[0];
    const dMax = domain[domain.length - 1];
    return a5 === void 0 && b === void 0 ? [a5, b] : [a5 || dMin, b || dMax];
  }
  getThresholds() {
    return this.thresholds;
  }
  clone() {
    return new _Quantile(this.options);
  }
  getTicks() {
    const { tickCount, domain, tickMethod } = this.options;
    const lastIndex = domain.length - 1;
    const min10 = domain[0];
    const max11 = domain[lastIndex];
    return tickMethod(min10, max11, tickCount);
  }
};

// node_modules/fecha/lib/fecha.js
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i2 = 0, len5 = arr.length; i2 < len5; i2++) {
    newArr.push(arr[i2].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v2) {
      return v2.toLowerCase();
    });
    var index3 = lowerCaseArr.indexOf(v.toLowerCase());
    if (index3 > -1) {
      return index3;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var pad = function(val, len5) {
  if (len5 === void 0) {
    len5 = 2;
  }
  val = String(val);
  while (val.length < len5) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset2 = dateObj.getTimezoneOffset();
    return (offset2 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset2) / 60) * 100 + Math.abs(offset2) % 60, 4);
  },
  Z: function(dateObj) {
    var offset2 = dateObj.getTimezoneOffset();
    return (offset2 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset2) / 60), 2) + ":" + pad(Math.abs(offset2) % 60, 2);
  }
};
var monthParse = function(v) {
  return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v) {
    var parts = (v + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v) {
      var now2 = /* @__PURE__ */ new Date();
      var cent = +("" + now2.getFullYear()).substr(0, 2);
      return +("" + (+v > 68 ? cent - 1 : cent) + v);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function(v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};

// node_modules/@antv/scale/esm/tick-methods/d3-time.js
var d3Time = (min10, max11, count4, interval2, utc) => {
  const r2 = min10 > max11;
  const lo = r2 ? max11 : min10;
  const hi = r2 ? min10 : max11;
  const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
  const ticks2 = tickInterval.range(lo, /* @__PURE__ */ new Date(+hi + 1), step2, true);
  return r2 ? ticks2.reverse() : ticks2;
};

// node_modules/@antv/scale/esm/scales/time.js
function offset(date) {
  const minuteOffset = date.getTimezoneOffset();
  const d4 = new Date(date);
  d4.setMinutes(d4.getMinutes() + minuteOffset, d4.getSeconds(), d4.getMilliseconds());
  return d4;
}
var Time = class _Time extends Continuous {
  getDefaultOptions() {
    return {
      domain: [new Date(2e3, 0, 1), new Date(2e3, 0, 2)],
      range: [0, 1],
      nice: false,
      tickCount: 5,
      tickInterval: void 0,
      unknown: void 0,
      clamp: false,
      tickMethod: d3Time,
      interpolate: createInterpolateNumber,
      mask: void 0,
      utc: false
    };
  }
  chooseTransforms() {
    const transform2 = (x3) => +x3;
    const untransform = (x3) => new Date(x3);
    return [transform2, untransform];
  }
  chooseNice() {
    return d3TimeNice;
  }
  getTickMethodOptions() {
    const { domain, tickCount, tickInterval, utc } = this.options;
    const min10 = domain[0];
    const max11 = domain[domain.length - 1];
    return [min10, max11, tickCount, tickInterval, utc];
  }
  getFormatter() {
    const { mask, utc } = this.options;
    const maskMap = utc ? utcIntervalMap : localIntervalMap;
    const time = utc ? offset : identity_default;
    return (d4) => format(time(d4), mask || chooseNiceTimeMask(d4, maskMap));
  }
  clone() {
    return new _Time(this.options);
  }
};

// node_modules/@antv/scale/esm/scales/sequential.js
var __decorate = function(decorators, target, key, desc) {
  var c6 = arguments.length, r2 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d4 = decorators[i2]) r2 = (c6 < 3 ? d4(r2) : c6 > 3 ? d4(target, key, r2) : d4(target, key)) || r2;
  return c6 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var Sequential_1;
function rangeOf(interpolator) {
  return [interpolator(0), interpolator(1)];
}
var normalizeDomain = (domain) => {
  const [d0, d1] = domain;
  const normalize10 = compose(createInterpolateNumber(0, 1), createNormalize(d0, d1));
  return normalize10;
};
var Sequential = Sequential_1 = class Sequential2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Sequential_1(this.options);
  }
};
Sequential = Sequential_1 = __decorate([
  interpolatize(rangeOf, normalizeDomain)
], Sequential);

// node_modules/@antv/scale/esm/scales/diverging.js
var __decorate2 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r2 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d4 = decorators[i2]) r2 = (c6 < 3 ? d4(r2) : c6 > 3 ? d4(target, key, r2) : d4(target, key)) || r2;
  return c6 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var Diverging_1;
function rangeOf2(interpolator) {
  return [interpolator(0), interpolator(0.5), interpolator(1)];
}
var normalizeDomain2 = (domain) => {
  const [d0, d1, d22] = domain;
  const normalizeLeft = compose(createInterpolateNumber(0, 0.5), createNormalize(d0, d1));
  const normalizeRight = compose(createInterpolateNumber(0.5, 1), createNormalize(d1, d22));
  return (x3) => {
    if (d0 > d22) {
      return x3 < d1 ? normalizeRight(x3) : normalizeLeft(x3);
    } else {
      return x3 < d1 ? normalizeLeft(x3) : normalizeRight(x3);
    }
  };
};
var Diverging = Diverging_1 = class Diverging2 extends Linear {
  getDefaultOptions() {
    return {
      domain: [0, 0.5, 1],
      unknown: void 0,
      nice: false,
      clamp: false,
      round: false,
      interpolator: identity_default,
      tickMethod: d3Ticks,
      tickCount: 5
    };
  }
  constructor(options) {
    super(options);
  }
  clone() {
    return new Diverging_1(this.options);
  }
};
Diverging = Diverging_1 = __decorate2([
  interpolatize(rangeOf2, normalizeDomain2)
], Diverging);

// node_modules/@antv/g2/esm/utils/helper.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getViewFromElement(element) {
  var _a2;
  let current = element;
  while (current) {
    if (((_a2 = current.attributes) === null || _a2 === void 0 ? void 0 : _a2.class) === "view")
      return current;
    current = current.parentNode;
  }
  return null;
}
function isHeatmap(element) {
  const { markType, nodeName } = element;
  return markType === "heatmap" && nodeName === "image";
}
function dataOf(element, viewData) {
  const view = viewData !== null && viewData !== void 0 ? viewData : getViewFromElement(element).__data__;
  const datum = element.__data__;
  const { markKey, index: index3, seriesIndex, normalized = { x: 0 } } = datum;
  const { markState } = view;
  const selectedMark = Array.from(markState.keys()).find((mark2) => mark2.key === markKey);
  if (!selectedMark)
    return;
  if (seriesIndex) {
    return seriesIndex.map((i2) => selectedMark.data[i2]);
  }
  return isHeatmap(element) ? selectedMark.data[Math.round(selectedMark.data.length * normalized.x)] : selectedMark.data[index3];
}
function seriesOf(elemenet) {
  const viewData = getViewFromElement(elemenet).__data__;
  const { scale: scale12 } = viewData;
  return groupNameOf(scale12, elemenet.__data__);
}
function groupNameOf(scale12, datum) {
  const { color: scaleColor, series: scaleSeries, facet = false } = scale12;
  const { color: color3, series } = datum;
  const invertAble = (scale13) => {
    return scale13 && scale13.invert && !(scale13 instanceof Band) && !(scale13 instanceof Constant2);
  };
  if (invertAble(scaleSeries)) {
    const cloned = scaleSeries.clone();
    return cloned.invert(series);
  }
  if (series && scaleSeries instanceof Band && scaleSeries.invert(series) !== color3 && !facet) {
    return scaleSeries.invert(series);
  }
  if (invertAble(scaleColor)) {
    const name2 = scaleColor.invert(color3);
    if (Array.isArray(name2))
      return null;
    return name2;
  }
  return null;
}
function identity6(x3) {
  return x3;
}
function compose2(fns) {
  return fns.reduce((composed, fn) => (x3, ...args) => fn(composed(x3, ...args), ...args), identity6);
}
function composeAsync(fns) {
  return fns.reduce((composed, fn) => (x3) => __awaiter(this, void 0, void 0, function* () {
    const value2 = yield composed(x3);
    return fn(value2);
  }), identity6);
}
function capitalizeFirst(str7) {
  return str7.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
}
function error(message = "") {
  throw new Error(message);
}
function copyAttributes(target, source) {
  const { attributes } = source;
  const exclude2 = /* @__PURE__ */ new Set(["id", "className"]);
  for (const [key, value2] of Object.entries(attributes)) {
    if (!exclude2.has(key)) {
      target.attr(key, value2);
    }
  }
}
function defined(x3) {
  return x3 !== void 0 && x3 !== null && !Number.isNaN(x3);
}
function useMemo(compute2) {
  const map5 = /* @__PURE__ */ new Map();
  return (key) => {
    if (map5.has(key))
      return map5.get(key);
    const value2 = compute2(key);
    map5.set(key, value2);
    return value2;
  };
}
function appendTransform(node, transform2) {
  const { transform: preTransform } = node.style;
  const unset = (d4) => d4 === "none" || d4 === void 0;
  const prefix = unset(preTransform) ? "" : preTransform;
  node.style.transform = `${prefix} ${transform2}`.trimStart();
}
function subObject(obj, prefix) {
  return maybeSubObject(obj, prefix) || {};
}
function maybeSubObject(obj, prefix) {
  const entries = Object.entries(obj || {}).filter(([key]) => key.startsWith(prefix)).map(([key, value2]) => [lower_first_default(key.replace(prefix, "").trim()), value2]).filter(([key]) => !!key);
  return entries.length === 0 ? null : Object.fromEntries(entries);
}
function filterPrefixObject(obj, prefix) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p3) => key.startsWith(p3))));
}
function omitPrefixObject(obj, ...prefixes2) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes2.every((prefix) => !key.startsWith(prefix))));
}
function maybePercentage(x3, size3) {
  if (x3 === void 0)
    return null;
  if (typeof x3 === "number")
    return x3;
  const px2 = +x3.replace("%", "");
  return Number.isNaN(px2) ? null : px2 / 100 * size3;
}
function isStrictObject(d4) {
  return typeof d4 === "object" && !(d4 instanceof Date) && d4 !== null && !Array.isArray(d4);
}
function isUnset(value2) {
  return value2 === null || value2 === false;
}
function deepAssign(dist5, src, maxLevel = 5, level = 0) {
  if (level >= maxLevel)
    return;
  for (const key of Object.keys(src)) {
    const value2 = src[key];
    if (!is_plain_object_default(value2) || !is_plain_object_default(dist5[key])) {
      dist5[key] = value2;
    } else {
      deepAssign(dist5[key], value2, maxLevel, level + 1);
    }
  }
  return dist5;
}

// node_modules/@antv/g2/esm/utils/array.js
function mapObject(object, callbackfn) {
  return Object.entries(object).reduce((obj, [key, value2]) => {
    obj[key] = callbackfn(value2, key, object);
    return obj;
  }, {});
}
function indexOf3(array2) {
  return array2.map((_2, i2) => i2);
}
function firstOf(array2) {
  return array2[0];
}
function lastOf(array2) {
  return array2[array2.length - 1];
}
function unique(array2) {
  return Array.from(new Set(array2));
}
function divide4(array2, callbackfn) {
  const result = [[], []];
  array2.forEach((item) => {
    result[callbackfn(item) ? 0 : 1].push(item);
  });
  return result;
}
function comb(array2, len5 = array2.length) {
  if (len5 === 1)
    return array2.map((item) => [item]);
  const result = [];
  for (let i2 = 0; i2 < array2.length; i2++) {
    const rest = array2.slice(i2 + 1);
    const restComb = comb(rest, len5 - 1);
    restComb.forEach((comb2) => {
      result.push([array2[i2], ...comb2]);
    });
  }
  return result;
}
function combine(array2) {
  if (array2.length === 1)
    return [array2];
  const result = [];
  for (let i2 = 1; i2 <= array2.length; i2++) {
    result.push(...comb(array2, i2));
  }
  return result;
}

// node_modules/@antv/g2/esm/transform/utils/order.js
function createGroups(groupBy3, I, mark2) {
  const { encode } = mark2;
  if (groupBy3 === null)
    return [I];
  const G = normalizeGroupBy(groupBy3).map((k2) => {
    var _a2;
    return [k2, (_a2 = columnOf(encode, k2)) === null || _a2 === void 0 ? void 0 : _a2[0]];
  }).filter(([, column2]) => defined(column2));
  const key = (i2) => G.map(([, V]) => V[i2]).join("-");
  return Array.from(group(I, key).values());
}
function normalizeComparator(order) {
  if (Array.isArray(order))
    return createFieldsOrder(order);
  if (typeof order === "function")
    return createFunctionOrder(order);
  if (order === "series")
    return createSeriesOrder;
  if (order === "value")
    return createValueOrder;
  if (order === "sum")
    return createSumOrder;
  if (order === "maxIndex")
    return createMaxIndexOrder;
  return null;
}
function applyOrder(groups2, comparator) {
  for (const group3 of groups2) {
    group3.sort(comparator);
  }
}
function domainOf(value2, scale12) {
  return (scale12 === null || scale12 === void 0 ? void 0 : scale12.domain) || Array.from(new Set(value2));
}
function normalizeGroupBy(groupBy3) {
  if (Array.isArray(groupBy3))
    return groupBy3;
  return [groupBy3];
}
function createSeriesOrder(data2, Y, S) {
  return ascendingComparator((i2) => S[i2]);
}
function createFunctionOrder(order) {
  return (data2, Y, S) => {
    return ascendingComparator((i2) => order(data2[i2]));
  };
}
function createFieldsOrder(order) {
  return (data2, Y, S) => {
    return (i2, j) => order.reduce((eq, f2) => eq !== 0 ? eq : ascending(data2[i2][f2], data2[j][f2]), 0);
  };
}
function createValueOrder(data2, Y, S) {
  return ascendingComparator((i2) => Y[i2]);
}
function createSumOrder(data2, Y, S) {
  const I = indexOf3(data2);
  const groups2 = Array.from(group(I, (i2) => S[+i2]).entries());
  const seriesSum = new Map(groups2.map(([k2, GI]) => [k2, GI.reduce((s4, i2) => s4 + +Y[i2])]));
  return ascendingComparator((i2) => seriesSum.get(S[i2]));
}
function createMaxIndexOrder(data2, Y, S) {
  const I = indexOf3(data2);
  const groups2 = Array.from(group(I, (i2) => S[+i2]).entries());
  const seriesMaxIndex = new Map(groups2.map(([k2, GI]) => [k2, maxIndex(GI, (i2) => Y[i2])]));
  return ascendingComparator((i2) => seriesMaxIndex.get(S[i2]));
}
function ascendingComparator(order) {
  return (i2, j) => ascending(order(i2), order(j));
}

// node_modules/@antv/g2/esm/transform/stackY.js
var StackY = (options = {}) => {
  const { groupBy: groupBy3 = "x", orderBy = null, reverse: reverse2 = false, y: fromY = "y", y1: fromY1 = "y1", series = true } = options;
  return (I, mark2) => {
    var _a2;
    const { data: data2, encode, style = {} } = mark2;
    const [Y, fy] = columnOf(encode, "y");
    const [Y12, fy1] = columnOf(encode, "y1");
    const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
    const groups2 = createGroups(groupBy3, I, mark2);
    const createComparator = (_a2 = normalizeComparator(orderBy)) !== null && _a2 !== void 0 ? _a2 : () => null;
    const comparator = createComparator(data2, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newY = new Array(I.length);
    const newY1 = new Array(I.length);
    const TY = new Array(I.length);
    const F = [];
    const L = [];
    for (const G of groups2) {
      if (reverse2)
        G.reverse();
      const start = Y12 ? +Y12[G[0]] : 0;
      const PG = [];
      const NG = [];
      for (const i3 of G) {
        const y4 = TY[i3] = +Y[i3] - start;
        if (y4 < 0)
          NG.push(i3);
        else if (y4 >= 0)
          PG.push(i3);
      }
      const FG = PG.length > 0 ? PG : NG;
      const LG = NG.length > 0 ? NG : PG;
      let i2 = PG.length - 1;
      let j = 0;
      while (i2 > 0 && Y[FG[i2]] === 0)
        i2--;
      while (j < LG.length - 1 && Y[LG[j]] === 0)
        j++;
      F.push(FG[i2]);
      L.push(LG[j]);
      let ny = start;
      for (const i3 of NG.reverse()) {
        const y4 = TY[i3];
        ny = newY[i3] = (newY1[i3] = ny) + y4;
      }
      let py = start;
      for (const i3 of PG) {
        const y4 = TY[i3];
        if (y4 > 0)
          py = newY[i3] = (newY1[i3] = py) + y4;
        else
          newY[i3] = newY1[i3] = py;
      }
    }
    const FS = new Set(F);
    const LS = new Set(L);
    const V = fromY === "y" ? newY : newY1;
    const V1 = fromY1 === "y" ? newY : newY1;
    let newEncode;
    if (mark2.type === "point") {
      newEncode = {
        y0: inferredColumn(Y, fy),
        y: column(V, fy)
      };
    } else {
      newEncode = {
        y0: inferredColumn(Y, fy),
        y: column(V, fy),
        y1: column(V1, fy1)
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.assign({}, newEncode),
        style: Object.assign({ first: (_2, i2) => FS.has(i2), last: (_2, i2) => LS.has(i2) }, style)
      })
    ];
  };
};
StackY.props = {};

// node_modules/@antv/g2/esm/transform/maybeStackY.js
function exclude(transform2) {
  const { type } = transform2;
  const excludes = ["stackY", "dodgeX", "groupX"];
  return typeof type === "string" && excludes.includes(type);
}
var MaybeStackY = (options) => {
  return (I, mark2, context) => {
    const { encode, transform: transform2 = [] } = mark2;
    if (transform2.some(exclude))
      return [I, mark2];
    const { x: x3, y: y4 } = encode;
    if (x3 === void 0 || y4 === void 0)
      return [I, mark2];
    const { series } = options;
    const groupBy3 = series ? ["x", "series"] : "x";
    return StackY({ groupBy: groupBy3 })(I, mark2, context);
  };
};
MaybeStackY.props = {};

// node_modules/@antv/g2/esm/utils/dateFormat.js
function fillZero(digit) {
  if (Math.abs(digit) > 10)
    return String(digit);
  return digit.toString().padStart(2, "0");
}
function dynamicFormatDateTime(date) {
  const year2 = date.getFullYear();
  const month2 = fillZero(date.getMonth() + 1);
  const day2 = fillZero(date.getDate());
  const yyyyMMDD = `${year2}-${month2}-${day2}`;
  const hour2 = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  if (hour2 || minutes || seconds)
    return `${yyyyMMDD} ${fillZero(hour2)}:${fillZero(minutes)}:${fillZero(seconds)}`;
  return yyyyMMDD;
}

// node_modules/@antv/g2/esm/transform/maybeTitle.js
var MaybeTitle = (options = {}) => {
  const { channel = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { title } = tooltip2;
    if (title !== void 0)
      return [I, mark2];
    const titles = Object.keys(encode).filter((key) => key.startsWith(channel)).filter((key) => !encode[key].inferred).map((key) => columnOf(encode, key)).filter(([T3]) => T3).map((d4) => d4[0]);
    if (titles.length === 0)
      return [I, mark2];
    const T2 = [];
    for (const i2 of I) {
      T2[i2] = {
        value: titles.map((t) => t[i2] instanceof Date ? dynamicFormatDateTime(t[i2]) : t[i2]).join(", ")
      };
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        tooltip: {
          title: T2
        }
      })
    ];
  };
};
MaybeTitle.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroX.js
var MaybeZeroX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x3 } = encode;
    if (x3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { x: inferredColumn(constant(I, 0)) },
        scale: { x: { guide: null } }
      })
    ];
  };
};
MaybeZeroX.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroY.js
var MaybeZeroY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y4 } = encode;
    if (y4 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { y: inferredColumn(constant(I, 0)) },
        scale: { y: { guide: null } }
      })
    ];
  };
};
MaybeZeroY.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroZ.js
var MaybeZeroZ = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { z } = encode;
    if (z !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: { z: inferredColumn(constant(I, 0)) },
        scale: { z: { guide: null } }
      })
    ];
  };
};
MaybeZeroZ.props = {};

// node_modules/@antv/g2/esm/transform/maybeSize.js
var MaybeSize = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { size: size3 } = encode;
    if (size3 !== void 0)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, { encode: { size: visualColumn(constant(I, 3)) } })
    ];
  };
};
MaybeSize.props = {};

// node_modules/@antv/g2/esm/transform/maybeKey.js
var __rest2 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var MaybeKey = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { key } = encode, rest = __rest2(encode, ["key"]);
    if (key !== void 0)
      return [I, mark2];
    const values4 = Object.values(rest).map(({ value: value2 }) => value2);
    const K2 = I.map((i2) => values4.filter(Array.isArray).map((V) => V[i2]).join("-"));
    return [I, deep_mix_default({}, mark2, { encode: { key: column(K2) } })];
  };
};
MaybeKey.props = {};

// node_modules/@antv/g2/esm/transform/maybeSeries.js
var MaybeSeries = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { series, color: color3 } = encode;
    if (series !== void 0 || color3 === void 0)
      return [I, mark2];
    const [C4, fc] = columnOf(encode, "color");
    return [I, deep_mix_default({}, mark2, { encode: { series: column(C4, fc) } })];
  };
};
MaybeSeries.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleY.js
var MaybeTupleY = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { y: column(data2) } })];
  };
};
MaybeTupleY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTupleX.js
var MaybeTupleX = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    return [I, deep_mix_default({}, mark2, { encode: { x: column(data2) } })];
  };
};
MaybeTupleX.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityY.js
var MaybeIdentityY = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y1: y12 } = encode;
    if (y12)
      return [I, mark2];
    const [Y] = columnOf(encode, "y");
    return [I, deep_mix_default({}, mark2, { encode: { y1: column([...Y]) } })];
  };
};
MaybeIdentityY.props = {};

// node_modules/@antv/g2/esm/transform/maybeIdentityX.js
var MaybeIdentityX = () => {
  return (I, mark2) => {
    const { encode } = mark2;
    const { x1: x12 } = encode;
    if (x12)
      return [I, mark2];
    const [X] = columnOf(encode, "x");
    return [I, deep_mix_default({}, mark2, { encode: { x1: column([...X]) } })];
  };
};
MaybeIdentityX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultX.js
var MaybeDefaultX = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
      const extractX = (data3, index3) => Array.isArray(data3[0]) ? data3.map((item) => item[index3]) : [data3[index3]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            x: column(extractX(data2, 0)),
            x1: column(extractX(data2, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultX.props = {};

// node_modules/@antv/g2/esm/transform/maybeDefaultY.js
var MaybeDefaultY = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
      const extractY = (data3, index3) => Array.isArray(data3[0]) ? data3.map((item) => item[index3]) : [data3[index3]];
      return [
        I,
        deep_mix_default({}, mark2, {
          encode: {
            y: column(extractY(data2, 0)),
            y1: column(extractY(data2, 1))
          }
        })
      ];
    }
    return [I, mark2];
  };
};
MaybeDefaultY.props = {};

// node_modules/@antv/g2/esm/transform/maybeTooltip.js
var MaybeTooltip = (options) => {
  const { channel } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    if (isUnset(tooltip2))
      return [I, mark2];
    const { items = [] } = tooltip2;
    if (!items || items.length > 0)
      return [I, mark2];
    const channels = Array.isArray(channel) ? channel : [channel];
    const newItems = channels.flatMap((channel2) => Object.keys(encode).filter((key) => key.startsWith(channel2)).map((key) => {
      const { field: field3, value: value2, inferred = false, aggregate } = encode[key];
      if (inferred)
        return null;
      if (aggregate && value2)
        return { channel: key };
      if (field3)
        return { field: field3 };
      if (value2)
        return { channel: key };
      return null;
    }).filter((d4) => d4 !== null));
    return [I, deep_mix_default({}, mark2, { tooltip: { items: newItems } })];
  };
};
MaybeTooltip.props = {};

// node_modules/@antv/g2/esm/transform/maybeZeroPadding.js
var MaybeZeroPadding = () => {
  return (I, mark2) => {
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, mark2)
    ];
  };
};
MaybeZeroPadding.props = {};

// node_modules/@antv/g2/esm/transform/maybeVisualPosition.js
var __rest3 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var MaybeVisualPosition = () => {
  return (I, mark2) => {
    const { data: data2, style = {} } = mark2, restMark = __rest3(mark2, ["data", "style"]);
    const { x: x05, y: y05 } = style, rest = __rest3(style, ["x", "y"]);
    if (x05 == void 0 || y05 == void 0)
      return [I, mark2];
    const x3 = x05 || 0;
    const y4 = y05 || 0;
    return [
      [0],
      deep_mix_default({}, restMark, {
        data: [0],
        cartesian: true,
        encode: {
          x: column([x3]),
          y: column([y4])
        },
        scale: {
          x: { type: "identity", independent: true, guide: null },
          y: { type: "identity", independent: true, guide: null }
          // hide axis
        },
        style: rest
      })
    ];
  };
};
MaybeVisualPosition.props = {};

// node_modules/@antv/g2/esm/transform/maybeFunctionAttribute.js
var MaybeFunctionAttribute = () => {
  return (I, mark2) => {
    const { style = {} } = mark2;
    return [
      I,
      deep_mix_default({}, mark2, {
        style: Object.assign(Object.assign({}, style), Object.fromEntries(Object.entries(style).filter(([, v]) => typeof v === "function").map(([k2, v]) => [k2, () => v])))
      })
    ];
  };
};
MaybeFunctionAttribute.props = {};

// node_modules/@antv/g2/esm/transform/maybeTuple.js
var MaybeTuple = () => {
  return (I, mark2) => {
    const { data: data2 } = mark2;
    if (!Array.isArray(data2) || data2.some(isObject))
      return [I, mark2];
    const position = Array.isArray(data2[0]) ? data2 : [data2];
    const X = position.map((d4) => d4[0]);
    const Y = position.map((d4) => d4[1]);
    return [I, deep_mix_default({}, mark2, { encode: { x: column(X), y: column(Y) } })];
  };
};
MaybeTuple.props = {};

// node_modules/@antv/g2/esm/transform/maybeGradient.js
var MaybeGradient = () => {
  return (I, mark2) => {
    const { style = {}, encode } = mark2;
    const { series } = encode;
    const { gradient: gradient2 } = style;
    if (!gradient2 || series)
      return [I, mark2];
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          series: visualColumn(constant(I, void 0))
        }
      })
    ];
  };
};
MaybeGradient.props = {};

// node_modules/@antv/g2/esm/transform/dodgeX.js
var __rest4 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var DodgeX = (options = {}) => {
  const { groupBy: groupBy3 = "x", reverse: reverse2 = false, orderBy, padding } = options, rest = __rest4(options, ["groupBy", "reverse", "orderBy", "padding"]);
  return (I, mark2) => {
    const { data: data2, encode, scale: scale12 } = mark2;
    const { series: scaleSeries } = scale12;
    const [Y] = columnOf(encode, "y");
    const [S] = maybeColumnOf(encode, "series", "color");
    const domainSeries = domainOf(S, scaleSeries);
    const newMark = deep_mix_default({}, mark2, {
      scale: {
        series: {
          domain: domainSeries,
          paddingInner: padding
        }
      }
    });
    const groups2 = createGroups(groupBy3, I, mark2);
    const createComparator = normalizeComparator(orderBy);
    if (!createComparator) {
      return [I, deep_mix_default(newMark, { encode: { series: column(S) } })];
    }
    const comparator = createComparator(data2, Y, S);
    if (comparator)
      applyOrder(groups2, comparator);
    const newS = new Array(I.length);
    for (const G of groups2) {
      if (reverse2)
        G.reverse();
      for (let i2 = 0; i2 < G.length; i2++) {
        newS[G[i2]] = domainSeries[i2];
      }
    }
    return [
      I,
      deep_mix_default(newMark, {
        encode: {
          series: column(orderBy ? newS : S)
        }
      })
    ];
  };
};
DodgeX.props = {};

// node_modules/@antv/g2/esm/transform/stackEnter.js
var StackEnter = (options) => {
  const { groupBy: groupBy3 = ["x"], reducer = (I, V) => V[I[0]], orderBy = null, reverse: reverse2 = false, duration } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const by = Array.isArray(groupBy3) ? groupBy3 : [groupBy3];
    const groupEntries = by.map((k2) => [k2, columnOf(encode, k2)[0]]);
    if (groupEntries.length === 0)
      return [I, mark2];
    let groups2 = [I];
    for (const [, V] of groupEntries) {
      const newGroups = [];
      for (const I2 of groups2) {
        const G = Array.from(group(I2, (i2) => V[i2]).values());
        newGroups.push(...G);
      }
      groups2 = newGroups;
    }
    if (orderBy) {
      const [V] = columnOf(encode, orderBy);
      if (V)
        groups2.sort((I2, J) => reducer(I2, V) - reducer(J, V));
      if (reverse2)
        groups2.reverse();
    }
    const t = (duration || 3e3) / groups2.length;
    const [ED2] = duration ? [constant(I, t)] : maybeColumnOf(encode, "enterDuration", constant(I, t));
    const [EDL] = maybeColumnOf(encode, "enterDelay", constant(I, 0));
    const newEnterDelay = new Array(I.length);
    for (let i2 = 0, pd = 0; i2 < groups2.length; i2++) {
      const I2 = groups2[i2];
      const maxDuration = max5(I2, (i3) => +ED2[i3]);
      for (const j of I2)
        newEnterDelay[j] = +EDL[j] + pd;
      pd += maxDuration;
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          enterDuration: visualColumn(ED2),
          enterDelay: visualColumn(newEnterDelay)
        }
      })
    ];
  };
};
StackEnter.props = {};

// node_modules/@antv/g2/esm/transform/normalizeY.js
var __rest5 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function normalizeBasis(basis2) {
  if (typeof basis2 === "function")
    return basis2;
  const registry = {
    min: (I, Y) => min4(I, (i2) => Y[+i2]),
    max: (I, Y) => max5(I, (i2) => Y[+i2]),
    first: (I, Y) => Y[I[0]],
    last: (I, Y) => Y[I[I.length - 1]],
    mean: (I, Y) => mean(I, (i2) => Y[+i2]),
    median: (I, Y) => median(I, (i2) => Y[+i2]),
    sum: (I, Y) => sum(I, (i2) => Y[+i2]),
    deviation: (I, Y) => deviation(I, (i2) => Y[+i2])
  };
  return registry[basis2] || max5;
}
var NormalizeY = (options = {}) => {
  const { groupBy: groupBy3 = "x", basis: basis2 = "max" } = options;
  return (I, mark2) => {
    const { encode, tooltip: tooltip2 } = mark2;
    const { x: x3 } = encode, rest = __rest5(encode, ["x"]);
    const Yn2 = Object.entries(rest).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const [, Y] = Yn2.find(([k2]) => k2 === "y");
    const newYn = Yn2.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy3, I, mark2);
    const basisFunction = normalizeBasis(basis2);
    for (const I2 of groups2) {
      const basisValue = basisFunction(I2, Y);
      for (const i2 of I2) {
        for (let j = 0; j < Yn2.length; j++) {
          const [, V] = Yn2[j];
          const [, newV] = newYn[j];
          newV[i2] = +V[i2] / basisValue;
        }
      }
    }
    const specifiedTooltip = isUnset(tooltip2) || (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items) && (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items.length) !== 0;
    return [
      I,
      deep_mix_default({}, mark2, Object.assign({ encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])])) }, !specifiedTooltip && encode.y0 && {
        tooltip: { items: [{ channel: "y0" }] }
      }))
    ];
  };
};
NormalizeY.props = {};

// node_modules/@antv/g2/esm/transform/jitter.js
function rangeOf3(value2, scaleOptions, padding) {
  if (value2 === null)
    return [-0.5, 0.5];
  const domain = domainOf(value2, scaleOptions);
  const scale12 = new Band({ domain, range: [0, 1], padding });
  const step2 = scale12.getBandWidth();
  return [-step2 / 2, step2 / 2];
}
function interpolate(t, a5, b) {
  return a5 * (1 - t) + b * t;
}
var Jitter = (options = {}) => {
  const { padding = 0, paddingX = padding, paddingY = padding, random: random5 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale12 } = mark2;
    const { x: scaleX2, y: scaleY2 } = scale12;
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    const rangeX = rangeOf3(X, scaleX2, paddingX);
    const rangeY = rangeOf3(Y, scaleY2, paddingY);
    const DY = I.map(() => interpolate(random5(), ...rangeY));
    const DX = I.map(() => interpolate(random5(), ...rangeX));
    return [
      I,
      deep_mix_default({
        scale: {
          x: { padding: 0.5 },
          y: { padding: 0.5 }
        }
      }, mark2, {
        encode: { dy: column(DY), dx: column(DX) }
      })
    ];
  };
};
Jitter.props = {};

// node_modules/@antv/g2/esm/transform/jitterX.js
var JitterX = (options = {}) => {
  const { padding = 0, random: random5 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale12 } = mark2;
    const { x: scaleX2 } = scale12;
    const [X] = columnOf(encode, "x");
    const rangeX = rangeOf3(X, scaleX2, padding);
    const DX = I.map(() => interpolate(random5(), ...rangeX));
    return [
      I,
      deep_mix_default({ scale: { x: { padding: 0.5 } } }, mark2, {
        encode: { dx: column(DX) }
      })
    ];
  };
};
JitterX.props = {};

// node_modules/@antv/g2/esm/transform/jitterY.js
var JitterY = (options = {}) => {
  const { padding = 0, random: random5 = Math.random } = options;
  return (I, mark2) => {
    const { encode, scale: scale12 } = mark2;
    const { y: scaleY2 } = scale12;
    const [Y] = columnOf(encode, "y");
    const rangeY = rangeOf3(Y, scaleY2, padding);
    const DY = I.map(() => interpolate(random5(), ...rangeY));
    return [
      I,
      deep_mix_default({ scale: { y: { padding: 0.5 } } }, mark2, {
        encode: { dy: column(DY) }
      })
    ];
  };
};
JitterY.props = {};

// node_modules/@antv/g2/esm/transform/symmetryY.js
var __rest6 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var SymmetryY = (options = {}) => {
  const { groupBy: groupBy3 = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const { x: x3 } = encode, rest = __rest6(encode, ["x"]);
    const Yn2 = Object.entries(rest).filter(([k2]) => k2.startsWith("y")).map(([k2]) => [k2, columnOf(encode, k2)[0]]);
    const newYn = Yn2.map(([k2]) => [k2, new Array(I.length)]);
    const groups2 = createGroups(groupBy3, I, mark2);
    const MY = new Array(groups2.length);
    for (let i2 = 0; i2 < groups2.length; i2++) {
      const I2 = groups2[i2];
      const Y = I2.flatMap((i3) => Yn2.map(([, V]) => +V[i3]));
      const [minY, maxY2] = extent(Y);
      MY[i2] = (minY + maxY2) / 2;
    }
    const maxMiddleY = Math.max(...MY);
    for (let m3 = 0; m3 < groups2.length; m3++) {
      const offset2 = maxMiddleY - MY[m3];
      const I2 = groups2[m3];
      for (const i2 of I2) {
        for (let j = 0; j < Yn2.length; j++) {
          const [, V] = Yn2[j];
          const [, newV] = newYn[j];
          newV[i2] = +V[i2] + offset2;
        }
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newYn.map(([k2, v]) => [k2, column(v, columnOf(encode, k2)[1])]))
      })
    ];
  };
};
SymmetryY.props = {};

// node_modules/@antv/g2/esm/transform/diffY.js
var DiffY = (options = {}) => {
  const { groupBy: groupBy3 = "x" } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const [Y] = columnOf(encode, "y");
    const [_2, fy1] = columnOf(encode, "y1");
    const groups2 = createGroups(groupBy3, I, mark2);
    const newY1 = new Array(I.length);
    for (const G of groups2) {
      const YG = G.map((i2) => +Y[i2]);
      for (let idx = 0; idx < G.length; idx++) {
        const i2 = G[idx];
        const max11 = Math.max(...YG.filter((_3, _i) => _i !== idx));
        newY1[i2] = +Y[i2] > max11 ? max11 : Y[i2];
      }
    }
    return [
      I,
      deep_mix_default({}, mark2, {
        encode: {
          y1: column(newY1, fy1)
        }
      })
    ];
  };
};
DiffY.props = {};

// node_modules/@antv/g2/esm/transform/select.js
function first(I, V) {
  return [I[0]];
}
function last2(I, V) {
  const i2 = I.length - 1;
  return [I[i2]];
}
function max6(I, V) {
  const i2 = maxIndex(I, (i3) => V[i3]);
  return [I[i2]];
}
function min5(I, V) {
  const i2 = minIndex(I, (i3) => V[i3]);
  return [I[i2]];
}
function normalizeSelector(selector) {
  if (typeof selector === "function")
    return selector;
  const registry = { first, last: last2, max: max6, min: min5 };
  return registry[selector] || first;
}
var Select = (options = {}) => {
  const { groupBy: groupBy3 = "series", channel, selector } = options;
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy3, I, mark2);
    const [V] = columnOf(encode, channel);
    const selectFunction = normalizeSelector(selector);
    return [groups2.flatMap((GI) => selectFunction(GI, V)), mark2];
  };
};
Select.props = {};

// node_modules/@antv/g2/esm/transform/selectX.js
var __rest7 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var SelectX = (options = {}) => {
  const { selector } = options, rest = __rest7(options, ["selector"]);
  return Select(Object.assign({ channel: "x", selector }, rest));
};
SelectX.props = {};

// node_modules/@antv/g2/esm/transform/selectY.js
var __rest8 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var SelectY = (options = {}) => {
  const { selector } = options, rest = __rest8(options, ["selector"]);
  return Select(Object.assign({ channel: "y", selector }, rest));
};
SelectY.props = {};

// node_modules/@antv/g2/esm/transform/groupN.js
var __rest9 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function builtinFormatter(summary) {
  return (d4) => d4 === null ? summary : `${summary} of ${d4}`;
}
function normalizeReducer(reducer) {
  if (typeof reducer === "function")
    return [reducer, null];
  const registry = { mean: mean2, max: max7, count: count2, first: first2, last: last3, sum: sum2, min: min6, median: median2 };
  const reducerFunction = registry[reducer];
  if (!reducerFunction)
    throw new Error(`Unknown reducer: ${reducer}.`);
  return reducerFunction();
}
function mean2() {
  const reducer = (I, V) => mean(I, (i2) => +V[i2]);
  const formatter2 = builtinFormatter("mean");
  return [reducer, formatter2];
}
function median2() {
  const reducer = (I, V) => median(I, (i2) => +V[i2]);
  const formatter2 = builtinFormatter("median");
  return [reducer, formatter2];
}
function max7() {
  const reducer = (I, V) => max5(I, (i2) => +V[i2]);
  const formatter2 = builtinFormatter("max");
  return [reducer, formatter2];
}
function min6() {
  const reducer = (I, V) => min4(I, (i2) => +V[i2]);
  const formatter2 = builtinFormatter("min");
  return [reducer, formatter2];
}
function count2() {
  const reducer = (I, V) => I.length;
  const formatter2 = builtinFormatter("count");
  return [reducer, formatter2];
}
function sum2() {
  const reducer = (I, V) => sum(I, (i2) => +V[i2]);
  const formatter2 = builtinFormatter("sum");
  return [reducer, formatter2];
}
function first2() {
  const reducer = (I, V) => V[I[0]];
  const formatter2 = builtinFormatter("first");
  return [reducer, formatter2];
}
function last3() {
  const reducer = (I, V) => V[I[I.length - 1]];
  const formatter2 = builtinFormatter("last");
  return [reducer, formatter2];
}
var GroupN = (options = {}) => {
  const { groupBy: groupBy3 } = options, rest = __rest9(options, ["groupBy"]);
  return (I, mark2) => {
    const { data: data2, encode } = mark2;
    const groups2 = groupBy3(I, mark2);
    if (!groups2)
      return [I, mark2];
    const maybeFrom = (field3, reducer) => {
      if (field3)
        return field3;
      const { from } = reducer;
      if (!from)
        return field3;
      const [, field1] = columnOf(encode, from);
      return field1;
    };
    const outputs = Object.entries(rest).map(([channel, reducer]) => {
      const [reducerFunction, formatter2] = normalizeReducer(reducer);
      const [V, field3] = columnOf(encode, channel);
      const field1 = maybeFrom(field3, reducer);
      const RV = groups2.map((I2) => reducerFunction(I2, V !== null && V !== void 0 ? V : data2));
      return [
        channel,
        Object.assign(Object.assign({}, nonConstantColumn(RV, (formatter2 === null || formatter2 === void 0 ? void 0 : formatter2(field1)) || field1)), { aggregate: true })
      ];
    });
    const reducedColumns = Object.keys(encode).map((key) => {
      const [V, fv] = columnOf(encode, key);
      const GV = groups2.map((I2) => V[I2[0]]);
      return [key, column(GV, fv)];
    });
    const GD = groups2.map((I2) => data2[I2[0]]);
    const GI = indexOf3(groups2);
    return [
      GI,
      deep_mix_default({}, mark2, {
        data: GD,
        encode: Object.fromEntries([...reducedColumns, ...outputs])
      })
    ];
  };
};
GroupN.props = {};

// node_modules/@antv/g2/esm/transform/group.js
var __rest10 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Group = (options = {}) => {
  const { channels = ["x", "y"] } = options, rest = __rest10(options, ["channels"]);
  const groupBy3 = (I, mark2) => createGroups(channels, I, mark2);
  return GroupN(Object.assign(Object.assign({}, rest), { groupBy: groupBy3 }));
};
Group.props = {};

// node_modules/@antv/g2/esm/transform/groupX.js
var GroupX = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["x", "color", "series"] }));
};
GroupX.props = {};

// node_modules/@antv/g2/esm/transform/groupY.js
var GroupY = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["y", "color", "series"] }));
};
GroupY.props = {};

// node_modules/@antv/g2/esm/transform/groupColor.js
var GroupColor = (options = {}) => {
  return Group(Object.assign(Object.assign({}, options), { channels: ["color"] }));
};
GroupColor.props = {};

// node_modules/@antv/g2/esm/transform/sort.js
function createReducer(channel, options, encode) {
  const { by = channel, reducer = "max" } = options;
  const [V] = columnOf(encode, by);
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "max")
    return (GI) => max5(GI, (i2) => +V[i2]);
  if (reducer === "min")
    return (GI) => min4(GI, (i2) => +V[i2]);
  if (reducer === "sum")
    return (GI) => sum(GI, (i2) => +V[i2]);
  if (reducer === "median")
    return (GI) => median(GI, (i2) => +V[i2]);
  if (reducer === "mean")
    return (GI) => mean(GI, (i2) => +V[i2]);
  if (reducer === "first")
    return (GI) => V[GI[0]];
  if (reducer === "last")
    return (GI) => V[GI[GI.length - 1]];
  throw new Error(`Unknown reducer: ${reducer}`);
}
function filterIndex(I, values4, specifiedDomain) {
  if (!Array.isArray(specifiedDomain))
    return I;
  const domain = new Set(specifiedDomain);
  return I.filter((i2) => domain.has(values4[i2]));
}
var Sort = (options = {}) => {
  return (I, mark2) => {
    const { reverse: reverse2, slice: slice3, channel, by, ordinal = true, reducer } = options;
    const { encode, scale: scale12 = {} } = mark2;
    const domain = scale12[channel].domain;
    const [V] = columnOf(encode, by !== null && by !== void 0 ? by : channel);
    const [T2] = columnOf(encode, channel);
    const normalizeReducer2 = createReducer(channel, { by, reducer }, encode);
    const SI = filterIndex(I, T2, domain);
    const sortedDomain = groupSort(SI, normalizeReducer2, (i2) => T2[i2]);
    const sortedI = !ordinal ? sort(I, (i2) => V[i2]) : I;
    if (reverse2) {
      !ordinal && sortedI.reverse();
      sortedDomain.reverse();
    }
    const s4 = typeof slice3 === "number" ? [0, slice3] : slice3;
    const slicedDomain = slice3 ? sortedDomain.slice(...s4) : sortedDomain;
    return [
      sortedI,
      deep_mix_default(mark2, { scale: { [channel]: { domain: slicedDomain } } })
    ];
  };
};
Sort.props = {};

// node_modules/@antv/g2/esm/transform/sortX.js
var SortX = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "x" }));
};
SortX.props = {};

// node_modules/@antv/g2/esm/transform/sortColor.js
var SortColor = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "color" }));
};
SortColor.props = {};

// node_modules/@antv/g2/esm/transform/sortY.js
var SortY = (options = {}) => {
  return Sort(Object.assign(Object.assign({}, options), { channel: "y" }));
};
SortY.props = {};

// node_modules/@antv/g2/esm/transform/flexX.js
function valueOf(data2, field3) {
  if (typeof field3 === "string")
    return data2.map((d4) => d4[field3]);
  return data2.map(field3);
}
function createReducer2(reducer, V) {
  if (typeof reducer === "function")
    return (GI) => reducer(GI, V);
  if (reducer === "sum")
    return (GI) => sum(GI, (i2) => +V[i2]);
  throw new Error(`Unknown reducer: ${reducer}`);
}
var FlexX = (options = {}) => {
  const { field: field3, channel = "y", reducer = "sum" } = options;
  return (I, mark2) => {
    const { data: data2, encode } = mark2;
    const [x3] = columnOf(encode, "x");
    const V = field3 ? valueOf(data2, field3) : columnOf(encode, channel)[0];
    const reducerFunction = createReducer2(reducer, V);
    const flex2 = rollups(I, reducerFunction, (i2) => x3[i2]).map((d4) => d4[1]);
    return [I, deep_mix_default({}, mark2, { scale: { x: { flex: flex2 } } })];
  };
};
FlexX.props = {};

// node_modules/@antv/g2/esm/utils/vector.js
function sub6([x12, y12], [x22, y22]) {
  return [x12 - x22, y12 - y22];
}
function add7([x12, y12], [x22, y22]) {
  return [x12 + x22, y12 + y22];
}
function dist4([x05, y05], [x12, y12]) {
  return Math.sqrt(Math.pow(x05 - x12, 2) + Math.pow(y05 - y12, 2));
}
function angle3([x3, y4]) {
  return Math.atan2(y4, x3);
}
function angleWithQuadrant([x3, y4]) {
  return angle3([x3, y4]) + Math.PI / 2;
}
function angleBetween2(v0, v1) {
  const a0 = angle3(v0);
  const a1 = angle3(v1);
  if (a0 < a1)
    return a1 - a0;
  return Math.PI * 2 - (a0 - a1);
}
function calcBBox(points) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY2 = -Infinity;
  for (const [x3, y4] of points) {
    minX = Math.min(x3, minX);
    maxX = Math.max(x3, maxX);
    minY = Math.min(y4, minY);
    maxY2 = Math.max(y4, maxY2);
  }
  const width = maxX - minX;
  const height = maxY2 - minY;
  return [minX, minY, width, height];
}
function mid([x12, y12], [x22, y22]) {
  return [(x12 + x22) / 2, (y12 + y22) / 2];
}

// node_modules/@antv/g2/esm/transform/pack.js
function pack(options) {
  const { padding = 0, direction: direction3 = "col" } = options;
  return (P, count4, layout) => {
    const pcount = P.length;
    if (pcount === 0)
      return [];
    const { innerWidth, innerHeight } = layout;
    const aspect = innerHeight / innerWidth;
    let col = Math.ceil(Math.sqrt(count4 / aspect));
    let size3 = innerWidth / col;
    let row2 = Math.ceil(count4 / col);
    let h0 = row2 * size3;
    while (h0 > innerHeight) {
      col = col + 1;
      size3 = innerWidth / col;
      row2 = Math.ceil(count4 / col);
      h0 = row2 * size3;
    }
    const space = innerHeight - row2 * size3;
    const intervalY = row2 <= 1 ? 0 : space / (row2 - 1);
    const [offsetX, offsetY] = row2 <= 1 ? [
      (innerWidth - pcount * size3) / (pcount - 1),
      (innerHeight - size3) / 2
    ] : [0, 0];
    return P.map((points, m3) => {
      const [x3, y4, width, height] = calcBBox(points);
      const i2 = direction3 === "col" ? m3 % col : Math.floor(m3 / row2);
      const j = direction3 === "col" ? Math.floor(m3 / col) : m3 % row2;
      const newX = i2 * size3;
      const newY = (row2 - j - 1) * size3 + space;
      const sx = (size3 - padding) / width;
      const sy = (size3 - padding) / height;
      const tx = newX - x3 + offsetX * i2 + 1 / 2 * padding;
      const ty = newY - y4 - intervalY * j - offsetY + 1 / 2 * padding;
      return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;
    });
  };
}
var Pack = (options) => {
  return (I, mark2) => {
    return [I, deep_mix_default({}, mark2, { modifier: pack(options), axis: false })];
  };
};
Pack.props = {};

// node_modules/@antv/g2/esm/transform/bin.js
var __rest11 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var THRESHOLD = "thresholds";
function thresholdAuto(values4) {
  const [min10, max11] = extent(values4);
  return Math.min(200, thresholdScott(values4, min10, max11));
}
var Bin = (options = {}) => {
  const { groupChannels = ["color"], binChannels = ["x", "y"] } = options, rest = __rest11(options, ["groupChannels", "binChannels"]);
  const channelIndexKey = {};
  const groupBy3 = (I, mark2) => {
    const { encode } = mark2;
    const binValues = binChannels.map((channel) => {
      const [V] = columnOf(encode, channel);
      return V;
    });
    const thresholds = subObject(rest, THRESHOLD);
    const DI = I.filter((i2) => binValues.every((V) => defined(V[i2])));
    const groupKeys = [
      // For discrete channels, use value as group key.
      ...groupChannels.map((d4) => {
        const [V] = columnOf(encode, d4);
        return V;
      }).filter(defined).map((V) => (i2) => V[i2]),
      // For quantitative channels, use extent of bin as group key.
      ...binChannels.map((d4, i2) => {
        const V = binValues[i2];
        const t = thresholds[d4] || thresholdAuto(V);
        const bins = bin().thresholds(t).value((i3) => +V[i3])(DI);
        const indexKey = new Map(bins.flatMap((bin2) => {
          const { x0: x05, x1: x12 } = bin2;
          const key2 = `${x05},${x12}`;
          return bin2.map((i3) => [i3, key2]);
        }));
        channelIndexKey[d4] = indexKey;
        return (i3) => indexKey.get(i3);
      })
    ];
    const key = (i2) => groupKeys.map((key2) => key2(i2)).join("-");
    return Array.from(group(DI, key).values());
  };
  return GroupN(Object.assign(Object.assign(Object.assign({}, Object.fromEntries(Object.entries(rest).filter(([k2]) => !k2.startsWith(THRESHOLD)))), Object.fromEntries(binChannels.flatMap((channel) => {
    const start = ([i2]) => +channelIndexKey[channel].get(i2).split(",")[0];
    const end = ([i2]) => +channelIndexKey[channel].get(i2).split(",")[1];
    end.from = channel;
    return [
      [channel, start],
      [`${channel}1`, end]
    ];
  }))), { groupBy: groupBy3 }));
};
Bin.props = {};

// node_modules/@antv/g2/esm/transform/binX.js
var BinX = (options = {}) => {
  const { thresholds } = options;
  return Bin(Object.assign(Object.assign({}, options), { thresholdsX: thresholds, groupChannels: ["color"], binChannels: ["x"] }));
};
BinX.props = {};

// node_modules/@antv/g2/esm/transform/utils/lttb.js
function lttb(I, X, Y, thresholds) {
  const length5 = I.length;
  if (thresholds >= length5 || thresholds === 0) {
    return I;
  }
  const x3 = (i2) => X[I[i2]] * 1;
  const y4 = (i2) => Y[I[i2]] * 1;
  const sampled = [];
  const every2 = (length5 - 2) / (thresholds - 2);
  let a5 = 0;
  let maxArea;
  let area2;
  let nextA;
  sampled.push(a5);
  for (let i2 = 0; i2 < thresholds - 2; i2++) {
    let avgX = 0;
    let avgY = 0;
    let start = Math.floor((i2 + 1) * every2) + 1;
    let end = Math.floor((i2 + 2) * every2) + 1;
    end = Math.min(end, length5);
    const size3 = end - start;
    for (; start < end; start++) {
      avgX += x3(start);
      avgY += y4(start);
    }
    avgX /= size3;
    avgY /= size3;
    let frameStart = Math.floor((i2 + 0) * every2) + 1;
    const frameEnd = Math.floor((i2 + 1) * every2) + 1;
    const pointA = [x3(a5), y4(a5)];
    maxArea = area2 = -1;
    for (; frameStart < frameEnd; frameStart++) {
      area2 = Math.abs((pointA[0] - avgX) * (x3(frameStart) - pointA[1]) - (pointA[0] - y4(frameStart)) * (avgY - pointA[0])) * 0.5;
      if (area2 > maxArea) {
        maxArea = area2;
        nextA = frameStart;
      }
    }
    sampled.push(nextA);
    a5 = nextA;
  }
  sampled.push(length5 - 1);
  return sampled.map((a6) => I[a6]);
}

// node_modules/@antv/g2/esm/transform/sample.js
function normalizeSample(strategy) {
  if (typeof strategy === "function")
    return strategy;
  if (strategy === "lttb")
    return lttb;
  const strategies = {
    first: (f2) => [f2[0]],
    last: (f2) => [f2[f2.length - 1]],
    min: (f2, X, Y) => [
      f2[minIndex(f2, (i2) => Y[i2])]
    ],
    max: (f2, X, Y) => [
      f2[maxIndex(f2, (i2) => Y[i2])]
    ],
    median: (f2, X, Y) => [
      f2[medianIndex(f2, (i2) => Y[i2])]
    ]
  };
  const sampleFunction = strategies[strategy] || strategies.median;
  return (I, X, Y, thresholds) => {
    const frameSize = Math.max(1, Math.floor(I.length / thresholds));
    const frames = getFrames(I, frameSize);
    return frames.flatMap((frame2) => sampleFunction(frame2, X, Y));
  };
}
function getFrames(I, frameSize) {
  const size3 = I.length;
  const frames = [];
  let i2 = 0;
  while (i2 < size3) {
    frames.push(I.slice(i2, i2 += frameSize));
  }
  return frames;
}
var Sample = (options = {}) => {
  const { strategy = "median", thresholds = 2e3, groupBy: groupBy3 = ["series", "color"] } = options;
  const sampleFunction = normalizeSample(strategy);
  return (I, mark2) => {
    const { encode } = mark2;
    const groups2 = createGroups(groupBy3, I, mark2);
    const [X] = columnOf(encode, "x");
    const [Y] = columnOf(encode, "y");
    return [
      groups2.flatMap((g) => sampleFunction(g, X, Y, thresholds)),
      mark2
    ];
  };
};
Sample.props = {};

// node_modules/@antv/g2/esm/transform/filter.js
function normalizeValue(value2) {
  if (typeof value2 === "object")
    return [value2.value, value2.ordinal];
  else
    return [value2, true];
}
function filterWhenNoElements(mark2) {
  var _a2;
  const { encode } = mark2;
  const noElementMark = Object.assign(Object.assign({}, mark2), { encode: Object.assign(Object.assign({}, mark2.encode), { y: Object.assign(Object.assign({}, mark2.encode.y), { value: [] }) }) });
  const targetField = (_a2 = encode === null || encode === void 0 ? void 0 : encode.color) === null || _a2 === void 0 ? void 0 : _a2.field;
  if (!encode || !targetField) {
    return noElementMark;
  }
  let filterObject;
  for (const [key, v] of Object.entries(encode)) {
    if ((key === "x" || key === "y") && v.field === targetField) {
      filterObject = Object.assign(Object.assign({}, filterObject), { [key]: Object.assign(Object.assign({}, v), { value: [] }) });
    }
  }
  if (!filterObject) {
    return noElementMark;
  }
  return Object.assign(Object.assign({}, mark2), { encode: Object.assign(Object.assign({}, mark2.encode), filterObject) });
}
var Filter = (options = {}) => {
  return (I, mark2) => {
    const { encode, data: data2 } = mark2;
    const filters = Object.entries(options).map(([key, v]) => {
      const [V] = columnOf(encode, key);
      if (!V)
        return null;
      const [value2, ordinal = true] = normalizeValue(v);
      if (typeof value2 === "function")
        return (i2) => value2(V[i2]);
      if (ordinal) {
        const expectedValues = Array.isArray(value2) ? value2 : [value2];
        if (expectedValues.length === 0)
          return null;
        return (i2) => expectedValues.includes(V[i2]);
      } else {
        const [start, end] = value2;
        return (i2) => V[i2] >= start && V[i2] <= end;
      }
    }).filter(defined);
    const totalFilter = (i2) => filters.every((f2) => f2(i2));
    const FI = I.filter(totalFilter);
    const newIndex = FI.map((_2, i2) => i2);
    if (filters.length === 0) {
      const targetMark = filterWhenNoElements(mark2);
      return [I, targetMark];
    }
    const newEncodes = Object.entries(encode).map(([key, encode2]) => {
      return [
        key,
        Object.assign(Object.assign({}, encode2), { value: newIndex.map((i2) => encode2.value[FI[i2]]).filter((v) => v !== void 0) })
      ];
    });
    return [
      newIndex,
      deep_mix_default({}, mark2, {
        encode: Object.fromEntries(newEncodes),
        // Filter data for tooltip item.
        data: FI.map((i2) => data2[i2])
      })
    ];
  };
};
Filter.props = {};

// node_modules/d3-shape/src/constant.js
function constant_default(x3) {
  return function constant4() {
    return x3;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max8 = Math.max;
var min7 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
}
function asin(x3) {
  return x3 >= 1 ? halfPi : x3 <= -1 ? -halfPi : Math.asin(x3);
}

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon2 = 1e-6;
var tauEpsilon = tau2 - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
    this._ += arguments[i2] + strings[i2];
  }
}
function appendRound(digits) {
  let d4 = Math.floor(digits);
  if (!(d4 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d4 > 15) return append;
  const k2 = 10 ** d4;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
      this._ += Math.round(arguments[i2] * k2) / k2 + strings[i2];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x3, y4) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x3, y4) {
    this._append`L${this._x1 = +x3},${this._y1 = +y4}`;
  }
  quadraticCurveTo(x12, y12, x3, y4) {
    this._append`Q${+x12},${+y12},${this._x1 = +x3},${this._y1 = +y4}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x3, y4) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x3},${this._y1 = +y4}`;
  }
  arcTo(x12, y12, x22, y22, r2) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r2 = +r2;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x05 = this._x1, y05 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r2) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x3, y4, r2, a0, a1, ccw) {
    x3 = +x3, y4 = +y4, r2 = +r2, ccw = !!ccw;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x05 = x3 + dx, y05 = y4 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x05},${y05}`;
    } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
      this._append`L${x05},${y05}`;
    }
    if (!r2) return;
    if (da < 0) da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw2},${x3 - dx},${y4 - dy}A${r2},${r2},0,1,${cw2},${this._x1 = x05},${this._y1 = y05}`;
    } else if (da > epsilon2) {
      this._append`A${r2},${r2},0,${+(da >= pi2)},${cw2},${this._x1 = x3 + r2 * Math.cos(a1)},${this._y1 = y4 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x3, y4, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y4}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape23) {
  let digits = 3;
  shape23.digits = function(_2) {
    if (!arguments.length) return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d4 = Math.floor(_2);
      if (!(d4 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
      digits = d4;
    }
    return shape23;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d4) {
  return d4.innerRadius;
}
function arcOuterRadius(d4) {
  return d4.outerRadius;
}
function arcStartAngle(d4) {
  return d4.startAngle;
}
function arcEndAngle(d4) {
  return d4.endAngle;
}
function arcPadAngle(d4) {
  return d4 && d4.padAngle;
}
function intersect(x05, y05, x12, y12, x22, y22, x3, y32) {
  var x10 = x12 - x05, y10 = y12 - y05, x32 = x3 - x22, y322 = y32 - y22, t = y322 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y05 - y22) - y322 * (x05 - x22)) / t;
  return [x05 + t * x10, y05 + t * y10];
}
function cornerTangents(x05, y05, x12, y12, r1, rc, cw2) {
  var x01 = x05 - x12, y01 = y05 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x05 + ox, y11 = y05 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d22 = dx * dx + dy * dy, r2 = r1 - rc, D2 = x11 * y10 - x10 * y11, d4 = (dy < 0 ? -1 : 1) * sqrt(max8(0, r2 * r2 * d22 - D2 * D2)), cx0 = (D2 * dy - dx * d4) / d22, cy0 = (-D2 * dx - dy * d4) / d22, cx1 = (D2 * dy + dx * d4) / d22, cy1 = (-D2 * dx + dy * d4) / d22, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
    if (!context) context = buffer = path2();
    if (r1 < r0) r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min7(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min7(rc, (r0 - lc) / (kc - 1));
            rc1 = min7(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t02 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc) context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw2);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t12 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc) context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw2);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else context.arc(0, 0, r0, a10, a00, cw2);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a5 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a5) * r2, sin(a5) * r2];
  };
  arc.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : innerRadius;
  };
  arc.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : outerRadius;
  };
  arc.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : cornerRadius;
  };
  arc.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padRadius;
  };
  arc.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : startAngle;
  };
  arc.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : endAngle;
  };
  arc.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padAngle;
  };
  arc.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear2(context) {
  this._context = context;
}
Linear2.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y4) : this._context.moveTo(x3, y4);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x3, y4);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear2(context);
}

// node_modules/d3-shape/src/point.js
function x(p3) {
  return p3[0];
}
function y(p3) {
  return p3[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x3, y4) {
  var defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line4);
  x3 = typeof x3 === "function" ? x3 : x3 === void 0 ? x : constant_default(x3);
  y4 = typeof y4 === "function" ? y4 : y4 === void 0 ? y : constant_default(y4);
  function line4(data2) {
    var i2, n2 = (data2 = array_default(data2)).length, d4, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path2());
    for (i2 = 0; i2 <= n2; ++i2) {
      if (!(i2 < n2 && defined4(d4 = data2[i2], i2, data2)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x3(d4, i2, data2), +y4(d4, i2, data2));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line4.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : x3;
  };
  line4.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : y4;
  };
  line4.defined = function(_2) {
    return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), line4) : defined4;
  };
  line4.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line4) : curve;
  };
  line4.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line4) : context;
  };
  return line4;
}

// node_modules/d3-shape/src/area.js
function area_default(x05, y05, y12) {
  var x12 = null, defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
  x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x : constant_default(+x05);
  y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default(0) : constant_default(+y05);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
  function area2(data2) {
    var i2, j, k2, n2 = (data2 = array_default(data2)).length, d4, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
    if (context == null) output = curve(buffer = path2());
    for (i2 = 0; i2 <= n2; ++i2) {
      if (!(i2 < n2 && defined4(d4 = data2[i2], i2, data2)) === defined0) {
        if (defined0 = !defined0) {
          j = i2;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i2 - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i2] = +x05(d4, i2, data2), y0z[i2] = +y05(d4, i2, data2);
        output.point(x12 ? +x12(d4, i2, data2) : x0z[i2], y12 ? +y12(d4, i2, data2) : y0z[i2]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined4).curve(curve).context(context);
  }
  area2.x = function(_2) {
    return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), x12 = null, area2) : x05;
  };
  area2.x0 = function(_2) {
    return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x05;
  };
  area2.x1 = function(_2) {
    return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x12;
  };
  area2.y = function(_2) {
    return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), y12 = null, area2) : y05;
  };
  area2.y0 = function(_2) {
    return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y05;
  };
  area2.y1 = function(_2) {
    return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x05).y(y05);
  };
  area2.lineY1 = function() {
    return arealine().x(x05).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y05);
  };
  area2.defined = function(_2) {
    return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), area2) : defined4;
  };
  area2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
  };
  return area2;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial2(curve) {
  this._curve = curve;
}
Radial2.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a5, r2) {
    this._curve.point(r2 * Math.sin(a5), r2 * -Math.cos(a5));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial2(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l2) {
  var c6 = l2.curve;
  l2.angle = l2.x, delete l2.x;
  l2.radius = l2.y, delete l2.y;
  l2.curve = function(_2) {
    return arguments.length ? c6(curveRadial(_2)) : c6()._curve;
  };
  return l2;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/areaRadial.js
function areaRadial_default() {
  var a5 = area_default().curve(curveRadialLinear), c6 = a5.curve, x05 = a5.lineX0, x12 = a5.lineX1, y05 = a5.lineY0, y12 = a5.lineY1;
  a5.angle = a5.x, delete a5.x;
  a5.startAngle = a5.x0, delete a5.x0;
  a5.endAngle = a5.x1, delete a5.x1;
  a5.radius = a5.y, delete a5.y;
  a5.innerRadius = a5.y0, delete a5.y0;
  a5.outerRadius = a5.y1, delete a5.y1;
  a5.lineStartAngle = function() {
    return lineRadial(x05());
  }, delete a5.lineX0;
  a5.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a5.lineX1;
  a5.lineInnerRadius = function() {
    return lineRadial(y05());
  }, delete a5.lineY0;
  a5.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a5.lineY1;
  a5.curve = function(_2) {
    return arguments.length ? c6(curveRadial(_2)) : c6()._curve;
  };
  return a5;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt(3);

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default2() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x3, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x3) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y4) : this._context.moveTo(x3, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x3, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x3, this._y2 = y4;
        break;
      case 1:
        this._point = 2;
        this._x3 = x3, this._y3 = y4;
        break;
      case 2:
        this._point = 3;
        this._x4 = x3, this._y4 = y4;
        this._context.moveTo((this._x0 + 4 * this._x1 + x3) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
        break;
      default:
        point(this, x3, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x05 = (this._x0 + 4 * this._x1 + x3) / 6, y05 = (this._y0 + 4 * this._y1 + y4) / 6;
        this._line ? this._context.lineTo(x05, y05) : this._context.moveTo(x05, y05);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x3, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x3 = this._x, y4 = this._y, j = x3.length - 1;
    if (j > 0) {
      var x05 = x3[0], y05 = y4[0], dx = x3[j] - x05, dy = y4[j] - y05, i2 = -1, t;
      while (++i2 <= j) {
        t = i2 / j;
        this._basis.point(
          this._beta * x3[i2] + (1 - this._beta) * (x05 + t * dx),
          this._beta * y4[i2] + (1 - this._beta) * (y05 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x3, y4) {
    this._x.push(+x3);
    this._y.push(+y4);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x3, y4) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x3),
    that._y2 + that._k * (that._y1 - y4),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y4) : this._context.moveTo(x3, y4);
        break;
      case 1:
        this._point = 2;
        this._x1 = x3, this._y1 = y4;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x3, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y4;
        break;
      default:
        point2(this, x3, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x3, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x3, y4) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a5 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a5 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
    y12 = (y12 * a5 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x3 * that._l12_2a) / m3;
    y22 = (y22 * b + that._y1 * that._l23_2a - y4 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y4) : this._context.moveTo(x3, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x3, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y4;
        break;
      default:
        point3(this, x3, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x3, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    if (this._point) this._context.lineTo(x3, y4);
    else this._point = 1, this._context.moveTo(x3, y4);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x3) {
  return x3 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p3 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p3)) || 0;
}
function slope2(that, t) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t) / 2 : t;
}
function point4(that, t02, t12) {
  var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
  that._context.bezierCurveTo(x05 + dx, y05 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    var t12 = NaN;
    x3 = +x3, y4 = +y4;
    if (x3 === this._x1 && y4 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y4) : this._context.moveTo(x3, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t12 = slope3(this, x3, y4)), t12);
        break;
      default:
        point4(this, this._t0, t12 = slope3(this, x3, y4));
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y4;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x3, y4) {
  MonotoneX.prototype.point.call(this, y4, x3);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x3, y4) {
    this._context.moveTo(y4, x3);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x3, y4) {
    this._context.lineTo(y4, x3);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x3, y4) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x3 = this._x, y4 = this._y, n2 = x3.length;
    if (n2) {
      this._line ? this._context.lineTo(x3[0], y4[0]) : this._context.moveTo(x3[0], y4[0]);
      if (n2 === 2) {
        this._context.lineTo(x3[1], y4[1]);
      } else {
        var px2 = controlPoints(x3), py = controlPoints(y4);
        for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
          this._context.bezierCurveTo(px2[0][i0], py[0][i0], px2[1][i0], py[1][i0], x3[i1], y4[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n2 === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x3, y4) {
    this._x.push(+x3);
    this._y.push(+y4);
  }
};
function controlPoints(x3) {
  var i2, n2 = x3.length - 1, m3, a5 = new Array(n2), b = new Array(n2), r2 = new Array(n2);
  a5[0] = 0, b[0] = 2, r2[0] = x3[0] + 2 * x3[1];
  for (i2 = 1; i2 < n2 - 1; ++i2) a5[i2] = 1, b[i2] = 4, r2[i2] = 4 * x3[i2] + 2 * x3[i2 + 1];
  a5[n2 - 1] = 2, b[n2 - 1] = 7, r2[n2 - 1] = 8 * x3[n2 - 1] + x3[n2];
  for (i2 = 1; i2 < n2; ++i2) m3 = a5[i2] / b[i2 - 1], b[i2] -= m3, r2[i2] -= m3 * r2[i2 - 1];
  a5[n2 - 1] = r2[n2 - 1] / b[n2 - 1];
  for (i2 = n2 - 2; i2 >= 0; --i2) a5[i2] = (r2[i2] - a5[i2 + 1]) / b[i2];
  b[n2 - 1] = (x3[n2] + a5[n2 - 1]) / 2;
  for (i2 = 0; i2 < n2 - 1; ++i2) b[i2] = 2 * x3[i2 + 1] - a5[i2 + 1];
  return [a5, b];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x3, y4) {
    x3 = +x3, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y4) : this._context.moveTo(x3, y4);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y4);
          this._context.lineTo(x3, y4);
        } else {
          var x12 = this._x * (1 - this._t) + x3 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y4);
        }
        break;
      }
    }
    this._x = x3, this._y = y4;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/@antv/g2/esm/utils/coordinate.js
function isTranspose(coordinate) {
  const { transformations } = coordinate.getOptions();
  const transposes = transformations.map(([type]) => type).filter((type) => type === "transpose");
  return transposes.length % 2 !== 0;
}
function isPolar(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "polar");
}
function isRadial(coordinate) {
  const { transformations } = coordinate.getOptions();
  return (
    // distinguish radial from theta.
    transformations.some(([type]) => type === "reflect") && transformations.some(([type]) => type.startsWith("transpose"))
  );
}
function isHelix(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "helix");
}
function isParallel(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "parallel");
}
function isFisheye(coordinate) {
  const { transformations } = coordinate.getOptions();
  return transformations.some(([type]) => type === "fisheye");
}
function isRadar(coordinate) {
  return isParallel(coordinate) && isPolar(coordinate);
}
function isCircular(coordinate) {
  return isHelix(coordinate) || isPolar(coordinate);
}
function isTheta(coordinate) {
  return isPolar(coordinate) && isTranspose(coordinate);
}
function getRadius(coordinate) {
  if (isCircular(coordinate)) {
    const [width, height] = coordinate.getSize();
    const polar2 = coordinate.getOptions().transformations.find((t) => t[0] === "polar");
    if (polar2)
      return Math.max(width, height) / 2 * polar2[4];
  }
  return 0;
}
function radiusOf(coordinate) {
  const { transformations } = coordinate.getOptions();
  const [, , , innerRadius, outerRadius] = transformations.find((d4) => d4[0] === "polar");
  return [+innerRadius, +outerRadius];
}
function angleOf(coordinate, isRadius = true) {
  const { transformations } = coordinate.getOptions();
  const [, startAngle, endAngle] = transformations.find((d4) => d4[0] === "polar");
  return isRadius ? [+startAngle * 180 / Math.PI, +endAngle * 180 / Math.PI] : [startAngle, endAngle];
}
function getTransformOptions(coordinate, type) {
  const { transformations } = coordinate.getOptions();
  const [, ...args] = transformations.find((d4) => d4[0] === type);
  return args;
}

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(t, o2) {
  for (; !{}.hasOwnProperty.call(t, o2) && null !== (t = _getPrototypeOf(t)); ) ;
  return t;
}

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e3, t, r2) {
    var p3 = _superPropBase(e3, t);
    if (p3) {
      var n2 = Object.getOwnPropertyDescriptor(p3, t);
      return n2.get ? n2.get.call(arguments.length < 3 ? e3 : r2) : n2.value;
    }
  }, _get.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/superPropGet.js
function _superPropGet(t, o2, e3, r2) {
  var p3 = _get(_getPrototypeOf(1 & r2 ? t.prototype : t), o2, e3);
  return 2 & r2 && "function" == typeof p3 ? function(t4) {
    return p3.apply(e3, t4);
  } : p3;
}

// node_modules/@antv/g-math/dist/index.esm.js
function distance4(x12, y12, x22, y22) {
  var dx = x12 - x22;
  var dy = y12 - y22;
  return Math.sqrt(dx * dx + dy * dy);
}
function getBBoxByArray(xArr, yArr) {
  var minX = Math.min.apply(Math, _toConsumableArray(xArr));
  var minY = Math.min.apply(Math, _toConsumableArray(yArr));
  var maxX = Math.max.apply(Math, _toConsumableArray(xArr));
  var maxY2 = Math.max.apply(Math, _toConsumableArray(yArr));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle4) {
  return rx * Math.cos(xRotation) * Math.cos(angle4) - ry * Math.sin(xRotation) * Math.sin(angle4) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle4) {
  return rx * Math.sin(xRotation) * Math.cos(angle4) + ry * Math.cos(xRotation) * Math.sin(angle4) + cy;
}
function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  var xDim = xExtrema(rx, ry, xRotation);
  var minX = Infinity;
  var maxX = -Infinity;
  var xs = [startAngle, endAngle];
  for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
    var xAngle = xDim + i2;
    if (startAngle < endAngle) {
      if (startAngle < xAngle && xAngle < endAngle) {
        xs.push(xAngle);
      }
    } else if (endAngle < xAngle && xAngle < startAngle) {
      xs.push(xAngle);
    }
  }
  for (var _i = 0; _i < xs.length; _i++) {
    var x3 = xAt(cx, cy, rx, ry, xRotation, xs[_i]);
    if (x3 < minX) {
      minX = x3;
    }
    if (x3 > maxX) {
      maxX = x3;
    }
  }
  var yDim = yExtrema(rx, ry, xRotation);
  var minY = Infinity;
  var maxY2 = -Infinity;
  var ys = [startAngle, endAngle];
  for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {
    var yAngle = yDim + _i2;
    if (startAngle < endAngle) {
      if (startAngle < yAngle && yAngle < endAngle) {
        ys.push(yAngle);
      }
    } else if (endAngle < yAngle && yAngle < startAngle) {
      ys.push(yAngle);
    }
  }
  for (var _i3 = 0; _i3 < ys.length; _i3++) {
    var y4 = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);
    if (y4 < minY) {
      minY = y4;
    }
    if (y4 > maxY2) {
      maxY2 = y4;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
var EPSILON2 = 1e-4;
function nearestPoint$2(xArr, yArr, x3, y4, tCallback, length5) {
  var t = -1;
  var d4 = Infinity;
  var v0 = [x3, y4];
  var segNum = 20;
  if (length5 && length5 > 200) {
    segNum = length5 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i2 = 0; i2 <= segNum; i2++) {
    var _t = i2 * increaseRate;
    var v1 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([_t]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([_t])))];
    var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d4) {
      t = _t;
      d4 = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count4 = xArr.length;
    return {
      x: xArr[count4 - 1],
      y: yArr[count4 - 1]
    };
  }
  d4 = Infinity;
  for (var _i = 0; _i < 32; _i++) {
    if (interval2 < EPSILON2) {
      break;
    }
    var prev = t - interval2;
    var next = t + interval2;
    var _v = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([prev]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([prev])))];
    var _d = distance4(v0[0], v0[1], _v[0], _v[1]);
    if (prev >= 0 && _d < d4) {
      t = prev;
      d4 = _d;
    } else {
      var v2 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([next]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([next])))];
      var d22 = distance4(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d4) {
        t = next;
        d4 = d22;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(void 0, _toConsumableArray(xArr.concat([t]))),
    y: tCallback.apply(void 0, _toConsumableArray(yArr.concat([t])))
  };
}
function length$4(x12, y12, x22, y22) {
  return distance4(x12, y12, x22, y22);
}
function pointAt$3(x12, y12, x22, y22, t) {
  return {
    x: (1 - t) * x12 + t * x22,
    y: (1 - t) * y12 + t * y22
  };
}
function pointToLine(x12, y12, x22, y22, x3, y4) {
  var d4 = [x22 - x12, y22 - y12];
  if (vec2_exports.exactEquals(d4, [0, 0])) {
    return Math.sqrt((x3 - x12) * (x3 - x12) + (y4 - y12) * (y4 - y12));
  }
  var u2 = [-d4[1], d4[0]];
  vec2_exports.normalize(u2, u2);
  var a5 = [x3 - x12, y4 - y12];
  return Math.abs(vec2_exports.dot(a5, u2));
}
function cubicAt(p0, p1, p22, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p22 * t * t * onet + p3 * t * t * t;
}
function extrema$1(p0, p1, p22, p3) {
  var a5 = -3 * p0 + 9 * p1 - 9 * p22 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p22;
  var c6 = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual(a5, 0)) {
    if (!isNumberEqual(b, 0)) {
      t12 = -c6 / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a5 * c6;
    if (isNumberEqual(disc, 0)) {
      extremas.push(-b / (2 * a5));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a5);
      t22 = (-b - discSqrt) / (2 * a5);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function box$3(x12, y12, x22, y22, x3, y32, x4, y4) {
  var xArr = [x12, x4];
  var yArr = [y12, y4];
  var xExtrema2 = extrema$1(x12, x22, x3, x4);
  var yExtrema2 = extrema$1(y12, y22, y32, y4);
  for (var i2 = 0; i2 < xExtrema2.length; i2++) {
    xArr.push(cubicAt(x12, x22, x3, x4, xExtrema2[i2]));
  }
  for (var _i = 0; _i < yExtrema2.length; _i++) {
    yArr.push(cubicAt(y12, y22, y32, y4, yExtrema2[_i]));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint$1(x12, y12, x22, y22, x3, y32, x4, y4, x05, y05, length5) {
  return nearestPoint$2([x12, x22, x3, x4], [y12, y22, y32, y4], x05, y05, cubicAt, length5);
}
function pointDistance$3(x12, y12, x22, y22, x3, y32, x4, y4, x05, y05, length5) {
  var point7 = nearestPoint$1(x12, y12, x22, y22, x3, y32, x4, y4, x05, y05, length5);
  return distance4(point7.x, point7.y, x05, y05);
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var from = points[i2];
    var to = points[i2 + 1];
    totalLength += distance4(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function length$2(points) {
  return lengthOfSegment(points);
}
function quadraticAt(p0, p1, p22, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p22;
}
function extrema(p0, p1, p22) {
  var a5 = p0 + p22 - 2 * p1;
  if (isNumberEqual(a5, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a5;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function box(x12, y12, x22, y22, x3, y32) {
  var xExtrema2 = extrema(x12, x22, x3)[0];
  var yExtrema2 = extrema(y12, y22, y32)[0];
  var xArr = [x12, x3];
  var yArr = [y12, y32];
  if (xExtrema2 !== void 0) {
    xArr.push(quadraticAt(x12, x22, x3, xExtrema2));
  }
  if (yExtrema2 !== void 0) {
    yArr.push(quadraticAt(y12, y22, y32, yExtrema2));
  }
  return getBBoxByArray(xArr, yArr);
}
function nearestPoint(x12, y12, x22, y22, x3, y32, x05, y05) {
  return nearestPoint$2([x12, x22, x3], [y12, y22, y32], x05, y05, quadraticAt);
}
function pointDistance(x12, y12, x22, y22, x3, y32, x05, y05) {
  var point7 = nearestPoint(x12, y12, x22, y22, x3, y32, x05, y05);
  return distance4(point7.x, point7.y, x05, y05);
}

// node_modules/@antv/g-lite/dist/index.esm.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var rbush = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function quickselect2(arr, k2, left2, right2, compare) {
      quickselectStep(arr, k2, left2 || 0, right2 || arr.length - 1, compare || defaultCompare);
    }
    function quickselectStep(arr, k2, left2, right2, compare) {
      while (right2 > left2) {
        if (right2 - left2 > 600) {
          var n2 = right2 - left2 + 1;
          var m3 = k2 - left2 + 1;
          var z = Math.log(n2);
          var s4 = 0.5 * Math.exp(2 * z / 3);
          var sd = 0.5 * Math.sqrt(z * s4 * (n2 - s4) / n2) * (m3 - n2 / 2 < 0 ? -1 : 1);
          var newLeft = Math.max(left2, Math.floor(k2 - m3 * s4 / n2 + sd));
          var newRight = Math.min(right2, Math.floor(k2 + (n2 - m3) * s4 / n2 + sd));
          quickselectStep(arr, k2, newLeft, newRight, compare);
        }
        var t = arr[k2];
        var i2 = left2;
        var j = right2;
        swap2(arr, left2, k2);
        if (compare(arr[right2], t) > 0) {
          swap2(arr, left2, right2);
        }
        while (i2 < j) {
          swap2(arr, i2, j);
          i2++;
          j--;
          while (compare(arr[i2], t) < 0) {
            i2++;
          }
          while (compare(arr[j], t) > 0) {
            j--;
          }
        }
        if (compare(arr[left2], t) === 0) {
          swap2(arr, left2, j);
        } else {
          j++;
          swap2(arr, j, right2);
        }
        if (j <= k2) {
          left2 = j + 1;
        }
        if (k2 <= j) {
          right2 = j - 1;
        }
      }
    }
    function swap2(arr, i2, j) {
      var tmp2 = arr[i2];
      arr[i2] = arr[j];
      arr[j] = tmp2;
    }
    function defaultCompare(a5, b) {
      return a5 < b ? -1 : a5 > b ? 1 : 0;
    }
    var RBush2 = function RBush3(maxEntries) {
      if (maxEntries === void 0) maxEntries = 9;
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
    };
    RBush2.prototype.all = function all() {
      return this._all(this.data, []);
    };
    RBush2.prototype.search = function search2(bbox) {
      var node = this.data;
      var result = [];
      if (!intersects2(bbox, node)) {
        return result;
      }
      var toBBox = this.toBBox;
      var nodesToSearch = [];
      while (node) {
        for (var i2 = 0; i2 < node.children.length; i2++) {
          var child = node.children[i2];
          var childBBox = node.leaf ? toBBox(child) : child;
          if (intersects2(bbox, childBBox)) {
            if (node.leaf) {
              result.push(child);
            } else if (contains(bbox, childBBox)) {
              this._all(child, result);
            } else {
              nodesToSearch.push(child);
            }
          }
        }
        node = nodesToSearch.pop();
      }
      return result;
    };
    RBush2.prototype.collides = function collides(bbox) {
      var node = this.data;
      if (!intersects2(bbox, node)) {
        return false;
      }
      var nodesToSearch = [];
      while (node) {
        for (var i2 = 0; i2 < node.children.length; i2++) {
          var child = node.children[i2];
          var childBBox = node.leaf ? this.toBBox(child) : child;
          if (intersects2(bbox, childBBox)) {
            if (node.leaf || contains(bbox, childBBox)) {
              return true;
            }
            nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return false;
    };
    RBush2.prototype.load = function load(data2) {
      if (!(data2 && data2.length)) {
        return this;
      }
      if (data2.length < this._minEntries) {
        for (var i2 = 0; i2 < data2.length; i2++) {
          this.insert(data2[i2]);
        }
        return this;
      }
      var node = this._build(data2.slice(), 0, data2.length - 1, 0);
      if (!this.data.children.length) {
        this.data = node;
      } else if (this.data.height === node.height) {
        this._splitRoot(this.data, node);
      } else {
        if (this.data.height < node.height) {
          var tmpNode = this.data;
          this.data = node;
          node = tmpNode;
        }
        this._insert(node, this.data.height - node.height - 1, true);
      }
      return this;
    };
    RBush2.prototype.insert = function insert(item) {
      if (item) {
        this._insert(item, this.data.height - 1);
      }
      return this;
    };
    RBush2.prototype.clear = function clear() {
      this.data = createNode3([]);
      return this;
    };
    RBush2.prototype.remove = function remove2(item, equalsFn) {
      if (!item) {
        return this;
      }
      var node = this.data;
      var bbox = this.toBBox(item);
      var path2 = [];
      var indexes2 = [];
      var i2, parent, goingUp;
      while (node || path2.length) {
        if (!node) {
          node = path2.pop();
          parent = path2[path2.length - 1];
          i2 = indexes2.pop();
          goingUp = true;
        }
        if (node.leaf) {
          var index3 = findItem(item, node.children, equalsFn);
          if (index3 !== -1) {
            node.children.splice(index3, 1);
            path2.push(node);
            this._condense(path2);
            return this;
          }
        }
        if (!goingUp && !node.leaf && contains(node, bbox)) {
          path2.push(node);
          indexes2.push(i2);
          i2 = 0;
          parent = node;
          node = node.children[0];
        } else if (parent) {
          i2++;
          node = parent.children[i2];
          goingUp = false;
        } else {
          node = null;
        }
      }
      return this;
    };
    RBush2.prototype.toBBox = function toBBox(item) {
      return item;
    };
    RBush2.prototype.compareMinX = function compareMinX(a5, b) {
      return a5.minX - b.minX;
    };
    RBush2.prototype.compareMinY = function compareMinY(a5, b) {
      return a5.minY - b.minY;
    };
    RBush2.prototype.toJSON = function toJSON() {
      return this.data;
    };
    RBush2.prototype.fromJSON = function fromJSON(data2) {
      this.data = data2;
      return this;
    };
    RBush2.prototype._all = function _all(node, result) {
      var nodesToSearch = [];
      while (node) {
        if (node.leaf) {
          result.push.apply(result, node.children);
        } else {
          nodesToSearch.push.apply(nodesToSearch, node.children);
        }
        node = nodesToSearch.pop();
      }
      return result;
    };
    RBush2.prototype._build = function _build(items, left2, right2, height) {
      var N = right2 - left2 + 1;
      var M2 = this._maxEntries;
      var node;
      if (N <= M2) {
        node = createNode3(items.slice(left2, right2 + 1));
        calcBBox2(node, this.toBBox);
        return node;
      }
      if (!height) {
        height = Math.ceil(Math.log(N) / Math.log(M2));
        M2 = Math.ceil(N / Math.pow(M2, height - 1));
      }
      node = createNode3([]);
      node.leaf = false;
      node.height = height;
      var N2 = Math.ceil(N / M2);
      var N1 = N2 * Math.ceil(Math.sqrt(M2));
      multiSelect(items, left2, right2, N1, this.compareMinX);
      for (var i2 = left2; i2 <= right2; i2 += N1) {
        var right22 = Math.min(i2 + N1 - 1, right2);
        multiSelect(items, i2, right22, N2, this.compareMinY);
        for (var j = i2; j <= right22; j += N2) {
          var right3 = Math.min(j + N2 - 1, right22);
          node.children.push(this._build(items, j, right3, height - 1));
        }
      }
      calcBBox2(node, this.toBBox);
      return node;
    };
    RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path2) {
      while (true) {
        path2.push(node);
        if (node.leaf || path2.length - 1 === level) {
          break;
        }
        var minArea = Infinity;
        var minEnlargement = Infinity;
        var targetNode = void 0;
        for (var i2 = 0; i2 < node.children.length; i2++) {
          var child = node.children[i2];
          var area2 = bboxArea(child);
          var enlargement = enlargedArea(bbox, child) - area2;
          if (enlargement < minEnlargement) {
            minEnlargement = enlargement;
            minArea = area2 < minArea ? area2 : minArea;
            targetNode = child;
          } else if (enlargement === minEnlargement) {
            if (area2 < minArea) {
              minArea = area2;
              targetNode = child;
            }
          }
        }
        node = targetNode || node.children[0];
      }
      return node;
    };
    RBush2.prototype._insert = function _insert(item, level, isNode) {
      var bbox = isNode ? item : this.toBBox(item);
      var insertPath = [];
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);
      node.children.push(item);
      extend6(node, bbox);
      while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
          this._split(insertPath, level);
          level--;
        } else {
          break;
        }
      }
      this._adjustParentBBoxes(bbox, insertPath, level);
    };
    RBush2.prototype._split = function _split(insertPath, level) {
      var node = insertPath[level];
      var M2 = node.children.length;
      var m3 = this._minEntries;
      this._chooseSplitAxis(node, m3, M2);
      var splitIndex = this._chooseSplitIndex(node, m3, M2);
      var newNode = createNode3(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;
      calcBBox2(node, this.toBBox);
      calcBBox2(newNode, this.toBBox);
      if (level) {
        insertPath[level - 1].children.push(newNode);
      } else {
        this._splitRoot(node, newNode);
      }
    };
    RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
      this.data = createNode3([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox2(this.data, this.toBBox);
    };
    RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m3, M2) {
      var index3;
      var minOverlap = Infinity;
      var minArea = Infinity;
      for (var i2 = m3; i2 <= M2 - m3; i2++) {
        var bbox1 = distBBox(node, 0, i2, this.toBBox);
        var bbox2 = distBBox(node, i2, M2, this.toBBox);
        var overlap = intersectionArea2(bbox1, bbox2);
        var area2 = bboxArea(bbox1) + bboxArea(bbox2);
        if (overlap < minOverlap) {
          minOverlap = overlap;
          index3 = i2;
          minArea = area2 < minArea ? area2 : minArea;
        } else if (overlap === minOverlap) {
          if (area2 < minArea) {
            minArea = area2;
            index3 = i2;
          }
        }
      }
      return index3 || M2 - m3;
    };
    RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m3, M2) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      var xMargin = this._allDistMargin(node, m3, M2, compareMinX);
      var yMargin = this._allDistMargin(node, m3, M2, compareMinY);
      if (xMargin < yMargin) {
        node.children.sort(compareMinX);
      }
    };
    RBush2.prototype._allDistMargin = function _allDistMargin(node, m3, M2, compare) {
      node.children.sort(compare);
      var toBBox = this.toBBox;
      var leftBBox = distBBox(node, 0, m3, toBBox);
      var rightBBox = distBBox(node, M2 - m3, M2, toBBox);
      var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
      for (var i2 = m3; i2 < M2 - m3; i2++) {
        var child = node.children[i2];
        extend6(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
      }
      for (var i$1 = M2 - m3 - 1; i$1 >= m3; i$1--) {
        var child$1 = node.children[i$1];
        extend6(rightBBox, node.leaf ? toBBox(child$1) : child$1);
        margin += bboxMargin(rightBBox);
      }
      return margin;
    };
    RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path2, level) {
      for (var i2 = level; i2 >= 0; i2--) {
        extend6(path2[i2], bbox);
      }
    };
    RBush2.prototype._condense = function _condense(path2) {
      for (var i2 = path2.length - 1, siblings = void 0; i2 >= 0; i2--) {
        if (path2[i2].children.length === 0) {
          if (i2 > 0) {
            siblings = path2[i2 - 1].children;
            siblings.splice(siblings.indexOf(path2[i2]), 1);
          } else {
            this.clear();
          }
        } else {
          calcBBox2(path2[i2], this.toBBox);
        }
      }
    };
    function findItem(item, items, equalsFn) {
      if (!equalsFn) {
        return items.indexOf(item);
      }
      for (var i2 = 0; i2 < items.length; i2++) {
        if (equalsFn(item, items[i2])) {
          return i2;
        }
      }
      return -1;
    }
    function calcBBox2(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    function distBBox(node, k2, p3, toBBox, destNode) {
      if (!destNode) {
        destNode = createNode3(null);
      }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;
      for (var i2 = k2; i2 < p3; i2++) {
        var child = node.children[i2];
        extend6(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    function extend6(a5, b) {
      a5.minX = Math.min(a5.minX, b.minX);
      a5.minY = Math.min(a5.minY, b.minY);
      a5.maxX = Math.max(a5.maxX, b.maxX);
      a5.maxY = Math.max(a5.maxY, b.maxY);
      return a5;
    }
    function compareNodeMinX(a5, b) {
      return a5.minX - b.minX;
    }
    function compareNodeMinY(a5, b) {
      return a5.minY - b.minY;
    }
    function bboxArea(a5) {
      return (a5.maxX - a5.minX) * (a5.maxY - a5.minY);
    }
    function bboxMargin(a5) {
      return a5.maxX - a5.minX + (a5.maxY - a5.minY);
    }
    function enlargedArea(a5, b) {
      return (Math.max(b.maxX, a5.maxX) - Math.min(b.minX, a5.minX)) * (Math.max(b.maxY, a5.maxY) - Math.min(b.minY, a5.minY));
    }
    function intersectionArea2(a5, b) {
      var minX = Math.max(a5.minX, b.minX);
      var minY = Math.max(a5.minY, b.minY);
      var maxX = Math.min(a5.maxX, b.maxX);
      var maxY2 = Math.min(a5.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY2 - minY);
    }
    function contains(a5, b) {
      return a5.minX <= b.minX && a5.minY <= b.minY && b.maxX <= a5.maxX && b.maxY <= a5.maxY;
    }
    function intersects2(a5, b) {
      return b.minX <= a5.maxX && b.minY <= a5.maxY && b.maxX >= a5.minX && b.maxY >= a5.minY;
    }
    function createNode3(children) {
      return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    }
    function multiSelect(arr, left2, right2, n2, compare) {
      var stack = [left2, right2];
      while (stack.length) {
        right2 = stack.pop();
        left2 = stack.pop();
        if (right2 - left2 <= n2) {
          continue;
        }
        var mid2 = left2 + Math.ceil((right2 - left2) / n2 / 2) * n2;
        quickselect2(arr, mid2, left2, right2, compare);
        stack.push(left2, mid2, mid2, right2);
      }
    }
    return RBush2;
  });
})(rbush);
var RBush = rbush.exports;
var Shape = function(Shape4) {
  Shape4["GROUP"] = "g";
  Shape4["FRAGMENT"] = "fragment";
  Shape4["CIRCLE"] = "circle";
  Shape4["ELLIPSE"] = "ellipse";
  Shape4["IMAGE"] = "image";
  Shape4["RECT"] = "rect";
  Shape4["LINE"] = "line";
  Shape4["POLYLINE"] = "polyline";
  Shape4["POLYGON"] = "polygon";
  Shape4["TEXT"] = "text";
  Shape4["PATH"] = "path";
  Shape4["HTML"] = "html";
  Shape4["MESH"] = "mesh";
  return Shape4;
}({});
var ClipSpaceNearZ = function(ClipSpaceNearZ2) {
  ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 0] = "ZERO";
  ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
  return ClipSpaceNearZ2;
}({});
var AbstractRendererPlugin = function() {
  function AbstractRendererPlugin2() {
    _classCallCheck(this, AbstractRendererPlugin2);
    this.plugins = [];
  }
  return _createClass(AbstractRendererPlugin2, [{
    key: "addRenderingPlugin",
    value: function addRenderingPlugin(plugin) {
      this.plugins.push(plugin);
      this.context.renderingPlugins.push(plugin);
    }
  }, {
    key: "removeAllRenderingPlugins",
    value: function removeAllRenderingPlugins() {
      var _this2 = this;
      this.plugins.forEach(function(plugin) {
        var index3 = _this2.context.renderingPlugins.indexOf(plugin);
        if (index3 >= 0) {
          _this2.context.renderingPlugins.splice(index3, 1);
        }
      });
    }
  }]);
}();
var AbstractRenderer = function() {
  function AbstractRenderer2(config) {
    _classCallCheck(this, AbstractRenderer2);
    this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
    this.plugins = [];
    this.config = _objectSpread2({
      /**
       * only dirty object will cause re-render
       */
      enableDirtyCheck: true,
      enableCulling: false,
      /**
       * enable auto rendering by default
       */
      enableAutoRendering: true,
      /**
       * enable dirty rectangle rendering by default
       */
      enableDirtyRectangleRendering: true,
      enableDirtyRectangleRenderingDebug: false,
      enableSizeAttenuation: true,
      enableRenderingOptimization: false
    }, config);
  }
  return _createClass(AbstractRenderer2, [{
    key: "registerPlugin",
    value: function registerPlugin(plugin) {
      var index3 = this.plugins.findIndex(function(p3) {
        return p3 === plugin;
      });
      if (index3 === -1) {
        this.plugins.push(plugin);
      }
    }
  }, {
    key: "unregisterPlugin",
    value: function unregisterPlugin(plugin) {
      var index3 = this.plugins.findIndex(function(p3) {
        return p3 === plugin;
      });
      if (index3 > -1) {
        this.plugins.splice(index3, 1);
      }
    }
  }, {
    key: "getPlugins",
    value: function getPlugins() {
      return this.plugins;
    }
  }, {
    key: "getPlugin",
    value: function getPlugin(name2) {
      return this.plugins.find(function(plugin) {
        return plugin.name === name2;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.config;
    }
  }, {
    key: "setConfig",
    value: function setConfig(config) {
      Object.assign(this.config, config);
    }
  }]);
}();
var addVec3 = vec3_exports.add;
var copyVec3 = vec3_exports.copy;
var maxVec3 = vec3_exports.max;
var minVec3 = vec3_exports.min;
var scaleVec3 = vec3_exports.scale;
var subVec3 = vec3_exports.sub;
var AABB = function() {
  function AABB2() {
    _classCallCheck(this, AABB2);
    this.center = [0, 0, 0];
    this.halfExtents = [0, 0, 0];
    this.min = [0, 0, 0];
    this.max = [0, 0, 0];
  }
  return _createClass(AABB2, [{
    key: "update",
    value: function update2(center2, halfExtents) {
      copyVec3(this.center, center2);
      copyVec3(this.halfExtents, halfExtents);
      subVec3(this.min, this.center, this.halfExtents);
      addVec3(this.max, this.center, this.halfExtents);
    }
  }, {
    key: "setMinMax",
    value: function setMinMax(min10, max11) {
      addVec3(this.center, max11, min10);
      scaleVec3(this.center, this.center, 0.5);
      subVec3(this.halfExtents, max11, min10);
      scaleVec3(this.halfExtents, this.halfExtents, 0.5);
      copyVec3(this.min, min10);
      copyVec3(this.max, max11);
    }
  }, {
    key: "getMin",
    value: function getMin() {
      return this.min;
    }
  }, {
    key: "getMax",
    value: function getMax() {
      return this.max;
    }
  }, {
    key: "add",
    value: function add10(aabb) {
      if (AABB2.isEmpty(aabb)) {
        return;
      }
      if (AABB2.isEmpty(this)) {
        this.setMinMax(aabb.getMin(), aabb.getMax());
        return;
      }
      var tc = this.center;
      var tcx = tc[0];
      var tcy = tc[1];
      var tcz = tc[2];
      var th = this.halfExtents;
      var thx = th[0];
      var thy = th[1];
      var thz = th[2];
      var tminx = tcx - thx;
      var tmaxx = tcx + thx;
      var tminy = tcy - thy;
      var tmaxy = tcy + thy;
      var tminz = tcz - thz;
      var tmaxz = tcz + thz;
      var oc = aabb.center;
      var ocx = oc[0];
      var ocy = oc[1];
      var ocz = oc[2];
      var oh = aabb.halfExtents;
      var ohx = oh[0];
      var ohy = oh[1];
      var ohz = oh[2];
      var ominx = ocx - ohx;
      var omaxx = ocx + ohx;
      var ominy = ocy - ohy;
      var omaxy = ocy + ohy;
      var ominz = ocz - ohz;
      var omaxz = ocz + ohz;
      if (ominx < tminx) {
        tminx = ominx;
      }
      if (omaxx > tmaxx) {
        tmaxx = omaxx;
      }
      if (ominy < tminy) {
        tminy = ominy;
      }
      if (omaxy > tmaxy) {
        tmaxy = omaxy;
      }
      if (ominz < tminz) {
        tminz = ominz;
      }
      if (omaxz > tmaxz) {
        tmaxz = omaxz;
      }
      tc[0] = (tminx + tmaxx) * 0.5;
      tc[1] = (tminy + tmaxy) * 0.5;
      tc[2] = (tminz + tmaxz) * 0.5;
      th[0] = (tmaxx - tminx) * 0.5;
      th[1] = (tmaxy - tminy) * 0.5;
      th[2] = (tmaxz - tminz) * 0.5;
      this.min[0] = tminx;
      this.min[1] = tminy;
      this.min[2] = tminz;
      this.max[0] = tmaxx;
      this.max[1] = tmaxy;
      this.max[2] = tmaxz;
    }
  }, {
    key: "setFromTransformedAABB",
    value: function setFromTransformedAABB(aabb, m3) {
      var bc = this.center;
      var br = this.halfExtents;
      var ac = aabb.center;
      var ar = aabb.halfExtents;
      var mx0 = m3[0];
      var mx1 = m3[4];
      var mx2 = m3[8];
      var my0 = m3[1];
      var my1 = m3[5];
      var my2 = m3[9];
      var mz0 = m3[2];
      var mz1 = m3[6];
      var mz2 = m3[10];
      var mx0a = Math.abs(mx0);
      var mx1a = Math.abs(mx1);
      var mx2a = Math.abs(mx2);
      var my0a = Math.abs(my0);
      var my1a = Math.abs(my1);
      var my2a = Math.abs(my2);
      var mz0a = Math.abs(mz0);
      var mz1a = Math.abs(mz1);
      var mz2a = Math.abs(mz2);
      bc[0] = m3[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
      bc[1] = m3[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
      bc[2] = m3[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
      br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
      br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
      br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
      subVec3(this.min, bc, br);
      addVec3(this.max, bc, br);
    }
  }, {
    key: "intersects",
    value: function intersects2(aabb) {
      var aMax = this.getMax();
      var aMin = this.getMin();
      var bMax = aabb.getMax();
      var bMin = aabb.getMin();
      return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
    }
  }, {
    key: "intersection",
    value: function intersection3(aabb) {
      if (!this.intersects(aabb)) {
        return null;
      }
      var intersection4 = new AABB2();
      var min10 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
      var max11 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
      intersection4.setMinMax(min10, max11);
      return intersection4;
    }
    /**
     * get n-vertex
     * @param plane plane of CullingVolume
     */
  }, {
    key: "getNegativeFarPoint",
    value: function getNegativeFarPoint(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.min);
      }
      if (plane.pnVertexFlag === 272) {
        return [this.min[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 257) {
        return [this.min[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 256) {
        return [this.min[0], this.max[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 17) {
        return [this.max[0], this.min[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 16) {
        return [this.max[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 1) {
        return [this.max[0], this.max[1], this.min[2]];
      }
      return [this.max[0], this.max[1], this.max[2]];
    }
    /**
     * get p-vertex
     * @param plane plane of CullingVolume
     */
  }, {
    key: "getPositiveFarPoint",
    value: function getPositiveFarPoint(plane) {
      if (plane.pnVertexFlag === 273) {
        return copyVec3([0, 0, 0], this.max);
      }
      if (plane.pnVertexFlag === 272) {
        return [this.max[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 257) {
        return [this.max[0], this.min[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 256) {
        return [this.max[0], this.min[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 17) {
        return [this.min[0], this.max[1], this.max[2]];
      }
      if (plane.pnVertexFlag === 16) {
        return [this.min[0], this.max[1], this.min[2]];
      }
      if (plane.pnVertexFlag === 1) {
        return [this.min[0], this.min[1], this.max[2]];
      }
      return [this.min[0], this.min[1], this.min[2]];
    }
  }], [{
    key: "isEmpty",
    value: function isEmpty3(aabb) {
      return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
    }
  }]);
}();
var Plane = function() {
  function Plane2(distance7, normal) {
    _classCallCheck(this, Plane2);
    this.distance = distance7 || 0;
    this.normal = normal || vec3_exports.fromValues(0, 1, 0);
    this.updatePNVertexFlag();
  }
  return _createClass(Plane2, [{
    key: "updatePNVertexFlag",
    value: function updatePNVertexFlag() {
      this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point7) {
      return vec3_exports.dot(point7, this.normal) - this.distance;
    }
  }, {
    key: "normalize",
    value: function normalize10() {
      var invLen = 1 / vec3_exports.len(this.normal);
      vec3_exports.scale(this.normal, this.normal, invLen);
      this.distance *= invLen;
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(start, end, point7) {
      var d0 = this.distanceToPoint(start);
      var d1 = this.distanceToPoint(end);
      var t = d0 / (d0 - d1);
      var intersects2 = t >= 0 && t <= 1;
      if (intersects2 && point7) {
        vec3_exports.lerp(point7, start, end, t);
      }
      return intersects2;
    }
  }]);
}();
var Mask = function(Mask2) {
  Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
  Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
  Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
  return Mask2;
}({});
var Frustum = function() {
  function Frustum2(planes) {
    _classCallCheck(this, Frustum2);
    this.planes = [];
    if (planes) {
      this.planes = planes;
    } else {
      for (var i2 = 0; i2 < 6; i2++) {
        this.planes.push(new Plane());
      }
    }
  }
  return _createClass(Frustum2, [{
    key: "extractFromVPMatrix",
    value: function extractFromVPMatrix(projectionMatrix) {
      var _projectionMatrix = _slicedToArray(projectionMatrix, 16), m0 = _projectionMatrix[0], m1 = _projectionMatrix[1], m22 = _projectionMatrix[2], m3 = _projectionMatrix[3], m4 = _projectionMatrix[4], m5 = _projectionMatrix[5], m6 = _projectionMatrix[6], m7 = _projectionMatrix[7], m8 = _projectionMatrix[8], m9 = _projectionMatrix[9], m10 = _projectionMatrix[10], m11 = _projectionMatrix[11], m12 = _projectionMatrix[12], m13 = _projectionMatrix[13], m14 = _projectionMatrix[14], m15 = _projectionMatrix[15];
      vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
      this.planes[0].distance = m15 - m12;
      vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
      this.planes[1].distance = m15 + m12;
      vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
      this.planes[2].distance = m15 + m13;
      vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
      this.planes[3].distance = m15 - m13;
      vec3_exports.set(this.planes[4].normal, m3 - m22, m7 - m6, m11 - m10);
      this.planes[4].distance = m15 - m14;
      vec3_exports.set(this.planes[5].normal, m3 + m22, m7 + m6, m11 + m10);
      this.planes[5].distance = m15 + m14;
      this.planes.forEach(function(plane) {
        plane.normalize();
        plane.updatePNVertexFlag();
      });
    }
  }]);
}();
var Point2 = function() {
  function Point6() {
    var x3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    _classCallCheck(this, Point6);
    this.x = 0;
    this.y = 0;
    this.x = x3;
    this.y = y4;
  }
  return _createClass(Point6, [{
    key: "clone",
    value: function clone8() {
      return new Point6(this.x, this.y);
    }
  }, {
    key: "copyFrom",
    value: function copyFrom(p3) {
      this.x = p3.x;
      this.y = p3.y;
    }
  }]);
}();
var Rectangle = function() {
  function Rectangle2(x3, y4, width, height) {
    _classCallCheck(this, Rectangle2);
    this.x = x3;
    this.y = y4;
    this.width = width;
    this.height = height;
    this.left = x3;
    this.right = x3 + width;
    this.top = y4;
    this.bottom = y4 + height;
  }
  return _createClass(Rectangle2, [{
    key: "toJSON",
    value: function toJSON() {
    }
  }], [{
    key: "fromRect",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect/fromRect_static
       */
      function fromRect(rect4) {
        return new Rectangle2(rect4.x, rect4.y, rect4.width, rect4.height);
      }
    )
    /**
     * will return a new rect instance
     */
  }, {
    key: "applyTransform",
    value: function applyTransform2(rect4, matrix3) {
      var topLeft = vec4_exports.fromValues(rect4.x, rect4.y, 0, 1);
      var topRight = vec4_exports.fromValues(rect4.x + rect4.width, rect4.y, 0, 1);
      var bottomLeft = vec4_exports.fromValues(rect4.x, rect4.y + rect4.height, 0, 1);
      var bottomRight = vec4_exports.fromValues(rect4.x + rect4.width, rect4.y + rect4.height, 0, 1);
      var transformedTopLeft = vec4_exports.create();
      var transformedTopRight = vec4_exports.create();
      var transformedBottomLeft = vec4_exports.create();
      var transformedBottomRight = vec4_exports.create();
      vec4_exports.transformMat4(transformedTopLeft, topLeft, matrix3);
      vec4_exports.transformMat4(transformedTopRight, topRight, matrix3);
      vec4_exports.transformMat4(transformedBottomLeft, bottomLeft, matrix3);
      vec4_exports.transformMat4(transformedBottomRight, bottomRight, matrix3);
      var minX = Math.min(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
      var minY = Math.min(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
      var maxX = Math.max(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
      var maxY2 = Math.max(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
      return Rectangle2.fromRect({
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      });
    }
  }]);
}();
var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
function getAngle2(angle4) {
  if (angle4 === void 0) {
    return 0;
  }
  if (angle4 > 360 || angle4 < -360) {
    return angle4 % 360;
  }
  return angle4;
}
var $vec3$3 = vec3_exports.create();
function createVec3(x3) {
  var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var clone8 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  if (Array.isArray(x3) && x3.length === 3) {
    return clone8 ? vec3_exports.clone(x3) : vec3_exports.copy($vec3$3, x3);
  }
  if (isNumber(x3)) {
    return clone8 ? vec3_exports.fromValues(x3, y4, z) : vec3_exports.set($vec3$3, x3, y4, z);
  }
  return clone8 ? vec3_exports.fromValues(x3[0], x3[1] || y4, x3[2] || z) : vec3_exports.set($vec3$3, x3[0], x3[1] || y4, x3[2] || z);
}
var DEG_RAD = Math.PI / 180;
function deg2rad(deg2) {
  return deg2 * DEG_RAD;
}
var RAD_DEG = 180 / Math.PI;
function rad2deg(rad2) {
  return rad2 * RAD_DEG;
}
function turn2deg(turn2) {
  return 360 * turn2;
}
var HALF_PI = Math.PI / 2;
function getEulerFromQuat(out, quat2) {
  var x3 = quat2[0];
  var y4 = quat2[1];
  var z = quat2[2];
  var w2 = quat2[3];
  var x22 = x3 * x3;
  var y22 = y4 * y4;
  var z2 = z * z;
  var w22 = w2 * w2;
  var unit = x22 + y22 + z2 + w22;
  var test = x3 * w2 - y4 * z;
  if (test > 0.499995 * unit) {
    out[0] = HALF_PI;
    out[1] = 2 * Math.atan2(y4, x3);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    out[0] = -HALF_PI;
    out[1] = 2 * Math.atan2(y4, x3);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x3 * z - w2 * y4));
    out[1] = Math.atan2(2 * (x3 * w2 + y4 * z), 1 - 2 * (z2 + w22));
    out[2] = Math.atan2(2 * (x3 * y4 + z * w2), 1 - 2 * (y22 + z2));
  }
  return out;
}
function getEulerFromMat4(out, m3) {
  var x3;
  var z;
  var _mat4$getScaling = mat4_exports.getScaling(vec3_exports.create(), m3), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 3), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1], sz = _mat4$getScaling2[2];
  var y4 = Math.asin(-m3[2] / sx);
  if (y4 < HALF_PI) {
    if (y4 > -HALF_PI) {
      x3 = Math.atan2(m3[6] / sy, m3[10] / sz);
      z = Math.atan2(m3[1] / sx, m3[0] / sx);
    } else {
      z = 0;
      x3 = -Math.atan2(m3[4] / sy, m3[5] / sy);
    }
  } else {
    z = 0;
    x3 = Math.atan2(m3[4] / sy, m3[5] / sy);
  }
  out[0] = x3;
  out[1] = y4;
  out[2] = z;
  return out;
}
function getEuler(out, quat2) {
  if (quat2.length === 16) {
    return getEulerFromMat4(out, quat2);
  }
  return getEulerFromQuat(out, quat2);
}
function fromRotationTranslationScale2(rotation, x3, y4, scaleX2, scaleY2) {
  var cos3 = Math.cos(rotation);
  var sin3 = Math.sin(rotation);
  return mat3_exports.fromValues(scaleX2 * cos3, scaleY2 * sin3, 0, -scaleX2 * sin3, scaleY2 * cos3, 0, x3, y4, 1);
}
function makePerspective(out, left2, right2, top, bottom, near, far) {
  var zero5 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  var twoNear = 2 * near;
  var rightMinusLeft = right2 - left2;
  var topMinusBottom = top - bottom;
  var x3 = twoNear / rightMinusLeft;
  var y4 = twoNear / topMinusBottom;
  var a5 = (right2 + left2) / rightMinusLeft;
  var b = (top + bottom) / topMinusBottom;
  var c6;
  var d4;
  var farMinusNear = far - near;
  var farMulNear = far * near;
  if (zero5) {
    c6 = -far / farMinusNear;
    d4 = -farMulNear / farMinusNear;
  } else {
    c6 = -(far + near) / farMinusNear;
    d4 = -2 * farMulNear / farMinusNear;
  }
  out[0] = x3;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y4;
  out[6] = 0;
  out[7] = 0;
  out[8] = a5;
  out[9] = b;
  out[10] = c6;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d4;
  out[15] = 0;
  return out;
}
function decompose2(mat) {
  var row0x = mat[0];
  var row0y = mat[1];
  var row1x = mat[3];
  var row1y = mat[4];
  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
  var determinant3 = row0x * row1y - row0y * row1x;
  if (determinant3 < 0) {
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  }
  if (scalingX) {
    var invScalingX = 1 / scalingX;
    row0x *= invScalingX;
    row0y *= invScalingX;
  }
  if (scalingY) {
    var invScalingY = 1 / scalingY;
    row1x *= invScalingY;
    row1y *= invScalingY;
  }
  var rotation = Math.atan2(row0y, row0x);
  var angle4 = rad2deg(rotation);
  return [mat[6], mat[7], scalingX, scalingY, angle4];
}
var tmp = mat4_exports.create();
var perspectiveMatrix = mat4_exports.create();
var tmpVec4 = vec4_exports.create();
var row = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
var pdum3 = vec3_exports.create();
function decomposeMat4(matrix3, translation, scale12, skew2, perspective2, quaternion) {
  if (!normalize6(tmp, matrix3)) return false;
  mat4_exports.copy(perspectiveMatrix, tmp);
  perspectiveMatrix[3] = 0;
  perspectiveMatrix[7] = 0;
  perspectiveMatrix[11] = 0;
  perspectiveMatrix[15] = 1;
  if (Math.abs(mat4_exports.determinant(perspectiveMatrix)) < 1e-8) return false;
  var a03 = tmp[3];
  var a13 = tmp[7];
  var a23 = tmp[11];
  var a30 = tmp[12];
  var a31 = tmp[13];
  var a32 = tmp[14];
  var a33 = tmp[15];
  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
    tmpVec4[0] = a03;
    tmpVec4[1] = a13;
    tmpVec4[2] = a23;
    tmpVec4[3] = a33;
    var ret = mat4_exports.invert(perspectiveMatrix, perspectiveMatrix);
    if (!ret) return false;
    mat4_exports.transpose(perspectiveMatrix, perspectiveMatrix);
    vec4_exports.transformMat4(perspective2, tmpVec4, perspectiveMatrix);
  } else {
    perspective2[0] = perspective2[1] = perspective2[2] = 0;
    perspective2[3] = 1;
  }
  translation[0] = a30;
  translation[1] = a31;
  translation[2] = a32;
  mat3from4(row, tmp);
  scale12[0] = vec3_exports.length(row[0]);
  vec3_exports.normalize(row[0], row[0]);
  skew2[0] = vec3_exports.dot(row[0], row[1]);
  combine2(row[1], row[1], row[0], 1, -skew2[0]);
  scale12[1] = vec3_exports.length(row[1]);
  vec3_exports.normalize(row[1], row[1]);
  skew2[0] /= scale12[1];
  skew2[1] = vec3_exports.dot(row[0], row[2]);
  combine2(row[2], row[2], row[0], 1, -skew2[1]);
  skew2[2] = vec3_exports.dot(row[1], row[2]);
  combine2(row[2], row[2], row[1], 1, -skew2[2]);
  scale12[2] = vec3_exports.length(row[2]);
  vec3_exports.normalize(row[2], row[2]);
  skew2[1] /= scale12[2];
  skew2[2] /= scale12[2];
  vec3_exports.cross(pdum3, row[1], row[2]);
  if (vec3_exports.dot(row[0], pdum3) < 0) {
    for (var i2 = 0; i2 < 3; i2++) {
      scale12[i2] *= -1;
      row[i2][0] *= -1;
      row[i2][1] *= -1;
      row[i2][2] *= -1;
    }
  }
  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
  if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];
  if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];
  if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];
  return true;
}
function normalize6(out, mat) {
  var m44 = mat[15];
  if (m44 === 0) return false;
  var scale12 = 1 / m44;
  for (var i2 = 0; i2 < 16; i2++) out[i2] = mat[i2] * scale12;
  return true;
}
function mat3from4(out, mat4x4) {
  out[0][0] = mat4x4[0];
  out[0][1] = mat4x4[1];
  out[0][2] = mat4x4[2];
  out[1][0] = mat4x4[4];
  out[1][1] = mat4x4[5];
  out[1][2] = mat4x4[6];
  out[2][0] = mat4x4[8];
  out[2][1] = mat4x4[9];
  out[2][2] = mat4x4[10];
}
function combine2(out, a5, b, scale1, scale22) {
  out[0] = a5[0] * scale1 + b[0] * scale22;
  out[1] = a5[1] * scale1 + b[1] * scale22;
  out[2] = a5[2] * scale1 + b[2] * scale22;
}
var CameraType = function(CameraType2) {
  CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
  CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
  CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
  return CameraType2;
}({});
var CameraTrackingMode = function(CameraTrackingMode2) {
  CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
  return CameraTrackingMode2;
}({});
var CameraProjectionMode = function(CameraProjectionMode2) {
  CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
  return CameraProjectionMode2;
}({});
var CameraEvent = {
  UPDATED: "updated"
};
var MIN_DISTANCE = 2e-4;
var Camera = function() {
  function Camera2() {
    _classCallCheck(this, Camera2);
    this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
    this.eventEmitter = new eventemitter3_default();
    this.matrix = mat4_exports.create();
    this.right = vec3_exports.fromValues(1, 0, 0);
    this.up = vec3_exports.fromValues(0, 1, 0);
    this.forward = vec3_exports.fromValues(0, 0, 1);
    this.position = vec3_exports.fromValues(0, 0, 1);
    this.focalPoint = vec3_exports.fromValues(0, 0, 0);
    this.distanceVector = vec3_exports.fromValues(0, 0, -1);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.maxDistance = Infinity;
    this.minDistance = -Infinity;
    this.zoom = 1;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 1e3;
    this.aspect = 1;
    this.projectionMatrix = mat4_exports.create();
    this.projectionMatrixInverse = mat4_exports.create();
    this.jitteredProjectionMatrix = void 0;
    this.enableUpdate = true;
    this.type = CameraType.EXPLORING;
    this.trackingMode = CameraTrackingMode.DEFAULT;
    this.projectionMode = CameraProjectionMode.PERSPECTIVE;
    this.frustum = new Frustum();
    this.orthoMatrix = mat4_exports.create();
  }
  return _createClass(Camera2, [{
    key: "isOrtho",
    value: (
      // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
      //   this.setType(type, trackingMode);
      // }
      function isOrtho() {
        return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
      }
    )
  }, {
    key: "getProjectionMode",
    value: function getProjectionMode() {
      return this.projectionMode;
    }
  }, {
    key: "getPerspective",
    value: function getPerspective() {
      return this.jitteredProjectionMatrix || this.projectionMatrix;
    }
  }, {
    key: "getPerspectiveInverse",
    value: function getPerspectiveInverse() {
      return this.projectionMatrixInverse;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this.frustum;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
  }, {
    key: "getFocalPoint",
    value: function getFocalPoint() {
      return this.focalPoint;
    }
  }, {
    key: "getDollyingStep",
    value: function getDollyingStep() {
      return this.dollyingStep;
    }
  }, {
    key: "getNear",
    value: function getNear() {
      return this.near;
    }
  }, {
    key: "getFar",
    value: function getFar() {
      return this.far;
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.zoom;
    }
  }, {
    key: "getOrthoMatrix",
    value: function getOrthoMatrix() {
      return this.orthoMatrix;
    }
  }, {
    key: "getView",
    value: function getView() {
      return this.view;
    }
  }, {
    key: "setEnableUpdate",
    value: function setEnableUpdate(enabled) {
      this.enableUpdate = enabled;
    }
  }, {
    key: "setType",
    value: function setType(type, trackingMode) {
      this.type = type;
      if (this.type === CameraType.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }
      this._getAngles();
      if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
        this.setTrackingMode(trackingMode);
      }
      return this;
    }
  }, {
    key: "setProjectionMode",
    value: function setProjectionMode(projectionMode) {
      this.projectionMode = projectionMode;
      return this;
    }
  }, {
    key: "setTrackingMode",
    value: function setTrackingMode(trackingMode) {
      if (this.type !== CameraType.TRACKING) {
        throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
      }
      this.trackingMode = trackingMode;
      return this;
    }
    /**
     * If flag is true, it reverses the azimuth and elevation angles.
     * Subsequent calls to rotate, setAzimuth, setElevation,
     * changeAzimuth or changeElevation will cause the inverted effect.
     * setRoll or changeRoll is not affected by this method.
     *
     * This inversion is useful when one wants to simulate that the world
     * is moving, instead of the camera.
     *
     * By default the camera angles are not reversed.
     * @param {Boolean} flag the boolean flag to reverse the angles.
     */
  }, {
    key: "setWorldRotation",
    value: function setWorldRotation(flag) {
      this.rotateWorld = flag;
      this._getAngles();
      return this;
    }
    /**
     *  MV 
     */
  }, {
    key: "getViewTransform",
    value: function getViewTransform() {
      return mat4_exports.invert(mat4_exports.create(), this.matrix);
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      return this.matrix;
    }
  }, {
    key: "jitterProjectionMatrix",
    value: function jitterProjectionMatrix(x3, y4) {
      var translation = mat4_exports.fromTranslation(mat4_exports.create(), [x3, y4, 0]);
      this.jitteredProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), translation, this.projectionMatrix);
    }
  }, {
    key: "clearJitterProjectionMatrix",
    value: function clearJitterProjectionMatrix() {
      this.jitteredProjectionMatrix = void 0;
    }
    /**
     * 
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix3) {
      this.matrix = matrix3;
      this._update();
      return this;
    }
    /**
     * Set projection matrix manually.
     */
  }, {
    key: "setProjectionMatrix",
    value: function setProjectionMatrix(matrix3) {
      this.projectionMatrix = matrix3;
    }
  }, {
    key: "setFov",
    value: function setFov(fov) {
      this.setPerspective(this.near, this.far, fov, this.aspect);
      return this;
    }
  }, {
    key: "setAspect",
    value: function setAspect(aspect) {
      this.setPerspective(this.near, this.far, this.fov, aspect);
      return this;
    }
  }, {
    key: "setNear",
    value: function setNear(near) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
      }
      return this;
    }
  }, {
    key: "setFar",
    value: function setFar(far) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
      }
      return this;
    }
    /**
     * Sets an offset in a larger frustum, used in PixelPicking
     */
  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x3, y4, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === void 0) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x3;
      this.view.offsetY = y4;
      this.view.width = width;
      this.view.height = height;
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== void 0) {
        this.view.enabled = false;
      }
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.zoom = zoom;
      if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      }
      return this;
    }
    /**
     * Zoom by specified point in viewport coordinates.
     */
  }, {
    key: "setZoomByViewportPoint",
    value: function setZoomByViewportPoint(zoom, viewportPoint) {
      var _this$canvas$viewport = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
      var roll = this.roll;
      this.rotate(0, 0, -roll);
      this.setPosition(ox, oy);
      this.setFocalPoint(ox, oy);
      this.setZoom(zoom);
      this.rotate(0, 0, roll);
      var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
      var dvec = vec3_exports.fromValues(cx - ox, cy - oy, 0);
      var dx = vec3_exports.dot(dvec, this.right) / vec3_exports.length(this.right);
      var dy = vec3_exports.dot(dvec, this.up) / vec3_exports.length(this.up);
      var _this$getPosition = this.getPosition(), _this$getPosition2 = _slicedToArray(_this$getPosition, 2), px2 = _this$getPosition2[0], py = _this$getPosition2[1];
      var _this$getFocalPoint = this.getFocalPoint(), _this$getFocalPoint2 = _slicedToArray(_this$getFocalPoint, 2), fx = _this$getFocalPoint2[0], fy = _this$getFocalPoint2[1];
      this.setPosition(px2 - dx, py - dy);
      this.setFocalPoint(fx - dx, fy - dy);
      return this;
    }
  }, {
    key: "setPerspective",
    value: function setPerspective(near, far, fov, aspect) {
      var _this$view;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.fov = fov;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
      var height = 2 * top;
      var width = this.aspect * height;
      var left2 = -0.5 * width;
      if ((_this$view = this.view) !== null && _this$view !== void 0 && _this$view.enabled) {
        var fullWidth = this.view.fullWidth;
        var fullHeight = this.view.fullHeight;
        left2 += this.view.offsetX * width / fullWidth;
        top -= this.view.offsetY * height / fullHeight;
        width *= this.view.width / fullWidth;
        height *= this.view.height / fullHeight;
      }
      makePerspective(this.projectionMatrix, left2, left2 + width, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
      mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "setOrthographic",
    value: function setOrthographic(l2, r2, t, b, near, far) {
      var _this$view2;
      this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
      this.rright = r2;
      this.left = l2;
      this.top = t;
      this.bottom = b;
      this.near = near;
      this.far = far;
      var dx = (this.rright - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.rright + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left2 = cx - dx;
      var right2 = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;
      if ((_this$view2 = this.view) !== null && _this$view2 !== void 0 && _this$view2.enabled) {
        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left2 += scaleW * this.view.offsetX;
        right2 = left2 + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
        mat4_exports.ortho(this.projectionMatrix, left2, right2, top, bottom, near, far);
      } else {
        mat4_exports.orthoZO(this.projectionMatrix, left2, right2, top, bottom, near, far);
      }
      mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
      this._getOrthoMatrix();
      this.triggerUpdate();
      return this;
    }
    /**
     * Move the camera in world coordinates.
     * It will keep looking at the current focal point.
     *
     * support scalars or vectors.
     * @example
     * setPosition(1, 2, 3);
     * setPosition([1, 2, 3]);
     */
  }, {
    key: "setPosition",
    value: function setPosition(x3) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.position[1];
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.position[2];
      var position = createVec3(x3, y4, z);
      this._setPosition(position);
      this.setFocalPoint(this.focalPoint);
      this.triggerUpdate();
      return this;
    }
    /**
     * Sets the focal point of this camera in world coordinates.
     *
     * support scalars or vectors.
     * @example
     * setFocalPoint(1, 2, 3);
     * setFocalPoint([1, 2, 3]);
     */
  }, {
    key: "setFocalPoint",
    value: function setFocalPoint(x3) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.focalPoint[1];
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.focalPoint[2];
      var up = vec3_exports.fromValues(0, 1, 0);
      this.focalPoint = createVec3(x3, y4, z);
      if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
        var d4 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
        x3 = d4[0];
        y4 = d4[1];
        z = d4[2];
        var r2 = vec3_exports.length(d4);
        var el = rad2deg(Math.asin(y4 / r2));
        var az = 90 + rad2deg(Math.atan2(z, x3));
        var m3 = mat4_exports.create();
        mat4_exports.rotateY(m3, m3, deg2rad(az));
        mat4_exports.rotateX(m3, m3, deg2rad(el));
        up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m3);
      }
      mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
      this._getAxes();
      this._getDistance();
      this._getAngles();
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getDistance",
    value: function getDistance() {
      return this.distance;
    }
  }, {
    key: "getDistanceVector",
    value: function getDistanceVector() {
      return this.distanceVector;
    }
    /**
     * Moves the camera towards/from the focal point.
     */
  }, {
    key: "setDistance",
    value: function setDistance(d4) {
      if (this.distance === d4 || d4 < 0) {
        return this;
      }
      this.distance = d4;
      if (this.distance < MIN_DISTANCE) {
        this.distance = MIN_DISTANCE;
      }
      this.dollyingStep = this.distance / 100;
      var pos = vec3_exports.create();
      d4 = this.distance;
      var n2 = this.forward;
      var f2 = this.focalPoint;
      pos[0] = d4 * n2[0] + f2[0];
      pos[1] = d4 * n2[1] + f2[1];
      pos[2] = d4 * n2[2] + f2[2];
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "setMaxDistance",
    value: function setMaxDistance(d4) {
      this.maxDistance = d4;
      return this;
    }
  }, {
    key: "setMinDistance",
    value: function setMinDistance(d4) {
      this.minDistance = d4;
      return this;
    }
    /**
     * 
     * the azimuth in degrees
     */
  }, {
    key: "setAzimuth",
    value: function setAzimuth(az) {
      this.azimuth = getAngle2(az);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getAzimuth",
    value: function getAzimuth() {
      return this.azimuth;
    }
    /**
     * 
     */
  }, {
    key: "setElevation",
    value: function setElevation(el) {
      this.elevation = getAngle2(el);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getElevation",
    value: function getElevation() {
      return this.elevation;
    }
    /**
     * 
     */
  }, {
    key: "setRoll",
    value: function setRoll(angle4) {
      this.roll = getAngle2(angle4);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "getRoll",
    value: function getRoll() {
      return this.roll;
    }
    /**
     * 
     */
  }, {
    key: "_update",
    value: function _update() {
      this._getAxes();
      this._getPosition();
      this._getDistance();
      this._getAngles();
      this._getOrthoMatrix();
      this.triggerUpdate();
    }
    /**
     * 
     */
  }, {
    key: "computeMatrix",
    value: function computeMatrix() {
      var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.roll));
      mat4_exports.identity(this.matrix);
      var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
      var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
      var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
      rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
      var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
        mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CameraType.TRACKING) {
        mat4_exports.translate(this.matrix, this.matrix, this.position);
        mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
      }
    }
    /**
     * Sets the camera position in the camera matrix
     */
  }, {
    key: "_setPosition",
    value: function _setPosition(x3, y4, z) {
      this.position = createVec3(x3, y4, z);
      var m3 = this.matrix;
      m3[12] = this.position[0];
      m3[13] = this.position[1];
      m3[14] = this.position[2];
      m3[15] = 1;
      this._getOrthoMatrix();
    }
    /**
     * Recalculates axes based on the current matrix
     */
  }, {
    key: "_getAxes",
    value: function _getAxes() {
      vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
      vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
      vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
      vec3_exports.normalize(this.right, this.right);
      vec3_exports.normalize(this.up, this.up);
      vec3_exports.normalize(this.forward, this.forward);
    }
    /**
     * Recalculates euler angles based on the current state
     */
  }, {
    key: "_getAngles",
    value: function _getAngles() {
      var x3 = this.distanceVector[0];
      var y4 = this.distanceVector[1];
      var z = this.distanceVector[2];
      var r2 = vec3_exports.length(this.distanceVector);
      if (r2 === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }
      if (this.type === CameraType.TRACKING) {
        this.elevation = rad2deg(Math.asin(y4 / r2));
        this.azimuth = rad2deg(Math.atan2(-x3, -z));
      } else if (this.rotateWorld) {
        this.elevation = rad2deg(Math.asin(y4 / r2));
        this.azimuth = rad2deg(Math.atan2(-x3, -z));
      } else {
        this.elevation = -rad2deg(Math.asin(y4 / r2));
        this.azimuth = -rad2deg(Math.atan2(-x3, -z));
      }
    }
    /**
     *  ORBITING 
     */
  }, {
    key: "_getPosition",
    value: function _getPosition() {
      vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
      this._getDistance();
    }
    /**
     *  TRACKING 
     */
  }, {
    key: "_getFocalPoint",
    value: function _getFocalPoint() {
      vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
      vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
      this._getDistance();
    }
    /**
     * 
     */
  }, {
    key: "_getDistance",
    value: function _getDistance() {
      this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
      this.distance = vec3_exports.length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    }
  }, {
    key: "_getOrthoMatrix",
    value: function _getOrthoMatrix() {
      if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
        return;
      }
      var position = this.position;
      var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], -this.roll * Math.PI / 180);
      mat4_exports.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, vec3_exports.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), vec3_exports.fromValues(this.zoom, this.zoom, 1), position);
    }
  }, {
    key: "triggerUpdate",
    value: function triggerUpdate() {
      if (this.enableUpdate) {
        var viewMatrix = this.getViewTransform();
        var vpMatrix = mat4_exports.multiply(mat4_exports.create(), this.getPerspective(), viewMatrix);
        this.getFrustum().extractFromVPMatrix(vpMatrix);
        this.eventEmitter.emit(CameraEvent.UPDATED);
      }
    }
  }, {
    key: "rotate",
    value: function rotate7(azimuth, elevation, roll) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "dolly",
    value: function dolly(value2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "createLandmark",
    value: function createLandmark(name2, params) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "gotoLandmark",
    value: function gotoLandmark(name2, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "cancelLandmarkAnimation",
    value: function cancelLandmarkAnimation() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}();
var Strategy = function(Strategy2) {
  Strategy2[Strategy2["Standard"] = 0] = "Standard";
  return Strategy2;
}({});
var SortReason = function(SortReason2) {
  SortReason2[SortReason2["ADDED"] = 0] = "ADDED";
  SortReason2[SortReason2["REMOVED"] = 1] = "REMOVED";
  SortReason2[SortReason2["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
  return SortReason2;
}({});
var $vec3$2 = vec3_exports.create();
var $mat4$1 = mat4_exports.create();
var $quat$2 = quat_exports.create();
function updateLocalTransform(transform2) {
  if (!transform2.localDirtyFlag) {
    return;
  }
  var hasSkew = transform2.localSkew[0] !== 0 || transform2.localSkew[1] !== 0;
  if (hasSkew) {
    mat4_exports.fromRotationTranslationScaleOrigin(transform2.localTransform, transform2.localRotation, transform2.localPosition, vec3_exports.fromValues(1, 1, 1), transform2.origin);
    if (transform2.localSkew[0] !== 0 || transform2.localSkew[1] !== 0) {
      mat4_exports.identity($mat4$1);
      $mat4$1[4] = Math.tan(transform2.localSkew[0]);
      $mat4$1[1] = Math.tan(transform2.localSkew[1]);
      mat4_exports.multiply(transform2.localTransform, transform2.localTransform, $mat4$1);
    }
    var scaling = mat4_exports.fromRotationTranslationScaleOrigin($mat4$1, quat_exports.set($quat$2, 0, 0, 0, 1), vec3_exports.set($vec3$2, 1, 1, 1), transform2.localScale, transform2.origin);
    mat4_exports.multiply(transform2.localTransform, transform2.localTransform, scaling);
  } else {
    var localTransform = transform2.localTransform, localPosition = transform2.localPosition, localRotation = transform2.localRotation, localScale = transform2.localScale, origin = transform2.origin;
    var hasPosition = localPosition[0] !== 0 || localPosition[1] !== 0 || localPosition[2] !== 0;
    var hasRotation = localRotation[3] !== 1 || localRotation[0] !== 0 || localRotation[1] !== 0 || localRotation[2] !== 0;
    var hasScale = localScale[0] !== 1 || localScale[1] !== 1 || localScale[2] !== 1;
    var hasOrigin = origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0;
    if (!hasRotation && !hasScale && !hasOrigin) {
      if (hasPosition) {
        mat4_exports.fromTranslation(localTransform, localPosition);
      } else {
        mat4_exports.identity(localTransform);
      }
    } else {
      mat4_exports.fromRotationTranslationScaleOrigin(localTransform, localRotation, localPosition, localScale, origin);
    }
  }
  transform2.localDirtyFlag = false;
}
function updateWorldTransform(transform2, parentTransform) {
  if (!transform2.dirtyFlag) {
    return;
  }
  if (!parentTransform) {
    mat4_exports.copy(transform2.worldTransform, transform2.localTransform);
  } else {
    mat4_exports.multiply(transform2.worldTransform, parentTransform.worldTransform, transform2.localTransform);
  }
  transform2.dirtyFlag = false;
}
var EMPTY_PARSED_PATH = {
  absolutePath: [],
  hasArc: false,
  segments: [],
  polygons: [],
  polylines: [],
  curve: null,
  totalLength: 0,
  rect: new Rectangle(0, 0, 0, 0)
};
var PropertySyntax = function(PropertySyntax2) {
  PropertySyntax2["COORDINATE"] = "<coordinate>";
  PropertySyntax2["COLOR"] = "<color>";
  PropertySyntax2["PAINT"] = "<paint>";
  PropertySyntax2["NUMBER"] = "<number>";
  PropertySyntax2["ANGLE"] = "<angle>";
  PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
  PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
  PropertySyntax2["LENGTH"] = "<length>";
  PropertySyntax2["PERCENTAGE"] = "<percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
  PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
  PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
  PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
  PropertySyntax2["PATH"] = "<path>";
  PropertySyntax2["FILTER"] = "<filter>";
  PropertySyntax2["Z_INDEX"] = "<z-index>";
  PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
  PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
  PropertySyntax2["MARKER"] = "<marker>";
  PropertySyntax2["TRANSFORM"] = "<transform>";
  PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
  PropertySyntax2["TEXT"] = "<text>";
  PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
  return PropertySyntax2;
}({});
function define2(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define2(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l2;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l2 = m3[1].length, m3 = parseInt(m3[1], 16), l2 === 6 ? rgbn(m3) : l2 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l2 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l2 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g, b, a5) {
  if (a5 <= 0) r2 = g = b = NaN;
  return new Rgb(r2, g, b, a5);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r2, g, b, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define2(Rgb, rgb, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a5 = clampa(this.opacity);
  return `${a5 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a5 === 1 ? ")" : `, ${a5})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h2, s4, l2, a5) {
  if (a5 <= 0) h2 = s4 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h2 = s4 = NaN;
  else if (s4 <= 0) h2 = NaN;
  return new Hsl(h2, s4, l2, a5);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g = o2.g / 255, b = o2.b / 255, min10 = Math.min(r2, g, b), max11 = Math.max(r2, g, b), h2 = NaN, s4 = max11 - min10, l2 = (max11 + min10) / 2;
  if (s4) {
    if (r2 === max11) h2 = (g - b) / s4 + (g < b) * 6;
    else if (g === max11) h2 = (b - r2) / s4 + 2;
    else h2 = (r2 - g) / s4 + 4;
    s4 /= l2 < 0.5 ? max11 + min10 : 2 - max11 - min10;
    h2 *= 60;
  } else {
    s4 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s4, l2, o2.opacity);
}
function hsl(h2, s4, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s4, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s4, l2, opacity) {
  this.h = +h2;
  this.s = +s4;
  this.l = +l2;
  this.opacity = +opacity;
}
define2(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s4 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s4, m1 = 2 * l2 - m22;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m22),
      hsl2rgb(h2, m1, m22),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a5 = clampa(this.opacity);
    return `${a5 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a5 === 1 ? ")" : `, ${a5})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h2, m1, m22) {
  return (h2 < 60 ? m1 + (m22 - m1) * h2 / 60 : h2 < 180 ? m22 : h2 < 240 ? m1 + (m22 - m1) * (240 - h2) / 60 : m1) * 255;
}
function memoize2(func, resolver) {
  if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
    throw new TypeError("Expected a function");
  }
  var _memoized = function memoized() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = _memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    _memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  _memoized.cache = new (memoize2.Cache || Map)();
  memoize2.cacheList.push(_memoized.cache);
  return _memoized;
}
memoize2.Cache = Map;
memoize2.cacheList = [];
memoize2.clearCache = function() {
  memoize2.cacheList.forEach(function(cache2) {
    return cache2.clear();
  });
};
var UnitType = function(UnitType2) {
  UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
  UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
  UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
  UnitType2[UnitType2["kEms"] = 3] = "kEms";
  UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
  UnitType2[UnitType2["kRems"] = 5] = "kRems";
  UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
  UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
  UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
  UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
  UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
  UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
  UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
  return UnitType2;
}({});
var UnitCategory = function(UnitCategory2) {
  UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
  UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
  UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
  UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
  UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
  UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
  return UnitCategory2;
}({});
var Nested = function(Nested2) {
  Nested2[Nested2["kYes"] = 0] = "kYes";
  Nested2[Nested2["kNo"] = 1] = "kNo";
  return Nested2;
}({});
var ParenLess = function(ParenLess2) {
  ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
  ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
  return ParenLess2;
}({});
var data = [
  {
    name: "em",
    unit_type: UnitType.kEms
  },
  // {
  //   name: 'ex',
  //   unit_type: UnitType.kExs,
  // },
  {
    name: "px",
    unit_type: UnitType.kPixels
  },
  // {
  //   name: "cm",
  //   unit_type: UnitType.kCentimeters,
  // },
  // {
  //   name: "mm",
  //   unit_type: UnitType.kMillimeters,
  // },
  // {
  //   name: "q",
  //   unit_type: UnitType.kQuarterMillimeters,
  // },
  // {
  //   name: "in",
  //   unit_type: UnitType.kInches,
  // },
  // {
  //   name: "pt",
  //   unit_type: UnitType.kPoints,
  // },
  // {
  //   name: "pc",
  //   unit_type: UnitType.kPicas,
  // },
  {
    name: "deg",
    unit_type: UnitType.kDegrees
  },
  {
    name: "rad",
    unit_type: UnitType.kRadians
  },
  {
    name: "grad",
    unit_type: UnitType.kGradians
  },
  {
    name: "ms",
    unit_type: UnitType.kMilliseconds
  },
  {
    name: "s",
    unit_type: UnitType.kSeconds
  },
  // {
  //   name: "hz",
  //   unit_type: UnitType.kHertz,
  // },
  // {
  //   name: "khz",
  //   unit_type: UnitType.kKilohertz,
  // },
  // {
  //   name: "dpi",
  //   unit_type: "kDotsPerInch",
  // },
  // {
  //   name: "dpcm",
  //   unit_type: "kDotsPerCentimeter",
  // },
  // {
  //   name: "dppx",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "x",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "vw",
  //   unit_type: "kViewportWidth",
  // },
  // {
  //   name: "vh",
  //   unit_type: "kViewportHeight",
  // },
  // {
  //   name: "vi",
  //   unit_type: "kViewportInlineSize",
  // },
  // {
  //   name: "vb",
  //   unit_type: "kViewportBlockSize",
  // },
  // {
  //   name: "vmin",
  //   unit_type: UnitType.kViewportMin,
  // },
  // {
  //   name: "vmax",
  //   unit_type: UnitType.kViewportMax,
  // },
  // {
  //   name: "svw",
  //   unit_type: "kSmallViewportWidth",
  // },
  // {
  //   name: "svh",
  //   unit_type: "kSmallViewportHeight",
  // },
  // {
  //   name: "svi",
  //   unit_type: "kSmallViewportInlineSize",
  // },
  // {
  //   name: "svb",
  //   unit_type: "kSmallViewportBlockSize",
  // },
  // {
  //   name: "svmin",
  //   unit_type: "kSmallViewportMin",
  // },
  // {
  //   name: "svmax",
  //   unit_type: "kSmallViewportMax",
  // },
  // {
  //   name: "lvw",
  //   unit_type: "kLargeViewportWidth",
  // },
  // {
  //   name: "lvh",
  //   unit_type: "kLargeViewportHeight",
  // },
  // {
  //   name: "lvi",
  //   unit_type: "kLargeViewportInlineSize",
  // },
  // {
  //   name: "lvb",
  //   unit_type: "kLargeViewportBlockSize",
  // },
  // {
  //   name: "lvmin",
  //   unit_type: UnitType.kLargeViewportMin,
  // },
  // {
  //   name: "lvmax",
  //   unit_type: UnitType.kLargeViewportMax,
  // },
  // {
  //   name: "dvw",
  //   unit_type: UnitType.kDynamicViewportWidth,
  // },
  // {
  //   name: "dvh",
  //   unit_type: UnitType.kDynamicViewportHeight,
  // },
  // {
  //   name: "dvi",
  //   unit_type: UnitType.kDynamicViewportInlineSize,
  // },
  // {
  //   name: "dvb",
  //   unit_type: UnitType.kDynamicViewportBlockSize,
  // },
  // {
  //   name: "dvmin",
  //   unit_type: UnitType.kDynamicViewportMin,
  // },
  // {
  //   name: "dvmax",
  //   unit_type: UnitType.kDynamicViewportMax,
  // },
  // {
  //   name: "cqw",
  //   unit_type: UnitType.kContainerWidth,
  // },
  // {
  //   name: "cqh",
  //   unit_type: UnitType.kContainerHeight,
  // },
  // {
  //   name: "cqi",
  //   unit_type: UnitType.kContainerInlineSize,
  // },
  // {
  //   name: "cqb",
  //   unit_type: UnitType.kContainerBlockSize,
  // },
  // {
  //   name: "cqmin",
  //   unit_type: UnitType.kContainerMin,
  // },
  // {
  //   name: "cqmax",
  //   unit_type: UnitType.kContainerMax,
  // },
  {
    name: "rem",
    unit_type: UnitType.kRems
  },
  // {
  //   name: 'fr',
  //   unit_type: UnitType.kFraction,
  // },
  {
    name: "turn",
    unit_type: UnitType.kTurns
  }
  // {
  //   name: 'ch',
  //   unit_type: UnitType.kChs,
  // },
  // {
  //   name: '__qem',
  //   unit_type: UnitType.kQuirkyEms,
  // },
];
var CSSStyleValueType = function(CSSStyleValueType2) {
  CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
  CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
  CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
  CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
  CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
  CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
  CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
  CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
  CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
  CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
  CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
  CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
  CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
  CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
  CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
  CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
  return CSSStyleValueType2;
}({});
var stringToUnitType = function stringToUnitType2(name2) {
  return data.find(function(item) {
    return item.name === name2;
  }).unit_type;
};
var unitFromName = function unitFromName2(name2) {
  if (!name2) {
    return UnitType.kUnknown;
  }
  if (name2 === "number") {
    return UnitType.kNumber;
  }
  if (name2 === "percent" || name2 === "%") {
    return UnitType.kPercentage;
  }
  return stringToUnitType(name2);
};
var unitTypeToUnitCategory = function unitTypeToUnitCategory2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return UnitCategory.kUNumber;
    case UnitType.kPercentage:
      return UnitCategory.kUPercent;
    case UnitType.kPixels:
      return UnitCategory.kULength;
    case UnitType.kMilliseconds:
    case UnitType.kSeconds:
      return UnitCategory.kUTime;
    case UnitType.kDegrees:
    case UnitType.kRadians:
    case UnitType.kGradians:
    case UnitType.kTurns:
      return UnitCategory.kUAngle;
    default:
      return UnitCategory.kUOther;
  }
};
var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory2(category) {
  switch (category) {
    case UnitCategory.kUNumber:
      return UnitType.kNumber;
    case UnitCategory.kULength:
      return UnitType.kPixels;
    case UnitCategory.kUPercent:
      return UnitType.kPercentage;
    case UnitCategory.kUTime:
      return UnitType.kSeconds;
    case UnitCategory.kUAngle:
      return UnitType.kDegrees;
    default:
      return UnitType.kUnknown;
  }
};
var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor2(unit_type) {
  var factor = 1;
  switch (unit_type) {
    case UnitType.kPixels:
    case UnitType.kDegrees:
    case UnitType.kSeconds:
      break;
    case UnitType.kMilliseconds:
      factor = 1e-3;
      break;
    case UnitType.kRadians:
      factor = 180 / Math.PI;
      break;
    case UnitType.kGradians:
      factor = 0.9;
      break;
    case UnitType.kTurns:
      factor = 360;
      break;
  }
  return factor;
};
var unitTypeToString = function unitTypeToString2(type) {
  switch (type) {
    case UnitType.kNumber:
    case UnitType.kInteger:
      return "";
    case UnitType.kPercentage:
      return "%";
    case UnitType.kEms:
      return "em";
    case UnitType.kRems:
      return "rem";
    case UnitType.kPixels:
      return "px";
    case UnitType.kDegrees:
      return "deg";
    case UnitType.kRadians:
      return "rad";
    case UnitType.kGradians:
      return "grad";
    case UnitType.kMilliseconds:
      return "ms";
    case UnitType.kSeconds:
      return "s";
    case UnitType.kTurns:
      return "turn";
  }
  return "";
};
var CSSStyleValue = function() {
  function CSSStyleValue2() {
    _classCallCheck(this, CSSStyleValue2);
  }
  return _createClass(CSSStyleValue2, [{
    key: "toString",
    value: (
      // protected abstract toCSSValue(): CSSValue;
      function toString5() {
        return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
      }
    )
  }, {
    key: "isNumericValue",
    value: function isNumericValue() {
      return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
    }
  }], [{
    key: "isAngle",
    value: (
      // static parse(propertyName: string, value: string): CSSStyleValue {
      //   return parseCSSStyleValue(propertyName, value)[0];
      // }
      // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
      //   return parseCSSStyleValue(propertyName, value);
      // }
      function isAngle(unit) {
        return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
      }
    )
    // static isViewportPercentageLength(type: UnitType) {
    //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
    // }
    // static isContainerPercentageLength(type: UnitType) {
    //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
    // }
  }, {
    key: "isLength",
    value: function isLength(type) {
      return type >= UnitType.kEms && type < UnitType.kDegrees;
    }
  }, {
    key: "isRelativeUnit",
    value: function isRelativeUnit(type) {
      return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
      type === UnitType.kRems;
    }
  }, {
    key: "isTime",
    value: function isTime(unit) {
      return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
    }
    // static isFrequency(unit: UnitType) {
    //   return unit == UnitType.kHertz || unit == UnitType.kKilohertz;
    // }
    // static isResolution(type: UnitType) {
    //   return type >= UnitType.kDotsPerPixel && type <= UnitType.kDotsPerCentimeter;
    // }
    // static isFlex(unit: UnitType) {
    //   return unit === UnitType.kFraction;
    // }
  }]);
}();
var CSSColorValue = function(_CSSStyleValue) {
  function CSSColorValue2(colorSpace) {
    var _this2;
    _classCallCheck(this, CSSColorValue2);
    _this2 = _callSuper(this, CSSColorValue2);
    _this2.colorSpace = colorSpace;
    return _this2;
  }
  _inherits(CSSColorValue2, _CSSStyleValue);
  return _createClass(CSSColorValue2, [{
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kColorType;
    }
    /**
     * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
     */
  }, {
    key: "to",
    value: function to(colorSpace) {
      return this;
    }
  }]);
}(CSSStyleValue);
var GradientType = function(GradientType2) {
  GradientType2[GradientType2["Constant"] = 0] = "Constant";
  GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
  GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
  return GradientType2;
}({});
var CSSGradientValue = function(_CSSStyleValue) {
  function CSSGradientValue2(type, value2) {
    var _this2;
    _classCallCheck(this, CSSGradientValue2);
    _this2 = _callSuper(this, CSSGradientValue2);
    _this2.type = type;
    _this2.value = value2;
    return _this2;
  }
  _inherits(CSSGradientValue2, _CSSStyleValue);
  return _createClass(CSSGradientValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSGradientValue2(this.type, this.value);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n2, p3, result) {
      return result;
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kColorType;
    }
  }]);
}(CSSStyleValue);
var CSSKeywordValue = function(_CSSStyleValue) {
  function CSSKeywordValue2(value2) {
    var _this2;
    _classCallCheck(this, CSSKeywordValue2);
    _this2 = _callSuper(this, CSSKeywordValue2);
    _this2.value = value2;
    return _this2;
  }
  _inherits(CSSKeywordValue2, _CSSStyleValue);
  return _createClass(CSSKeywordValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSKeywordValue2(this.value);
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kKeywordType;
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n2, p3, result) {
      return result + this.value;
    }
  }]);
}(CSSStyleValue);
var formatInfinityOrNaN = function formatInfinityOrNaN2(number3) {
  var suffix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var result = "";
  if (!Number.isFinite(number3)) {
    if (number3 > 0) result = "infinity";
    else result = "-infinity";
  } else {
    result = "NaN";
  }
  return result += suffix;
};
var toCanonicalUnit = function toCanonicalUnit2(unit) {
  return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
};
var CSSUnitValue = function(_CSSStyleValue) {
  function CSSUnitValue2(value2) {
    var _this2;
    var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
    _classCallCheck(this, CSSUnitValue2);
    _this2 = _callSuper(this, CSSUnitValue2);
    var unit;
    if (typeof unitOrName === "string") {
      unit = unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }
    _this2.unit = unit;
    _this2.value = value2;
    return _this2;
  }
  _inherits(CSSUnitValue2, _CSSStyleValue);
  return _createClass(CSSUnitValue2, [{
    key: "clone",
    value: function clone8() {
      return new CSSUnitValue2(this.value, this.unit);
    }
  }, {
    key: "equals",
    value: function equals7(other) {
      var other_unit_value = other;
      return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
    }
  }, {
    key: "getType",
    value: function getType2() {
      return CSSStyleValueType.kUnitType;
    }
  }, {
    key: "convertTo",
    value: function convertTo(target_unit) {
      if (this.unit === target_unit) {
        return new CSSUnitValue2(this.value, this.unit);
      }
      var canonical_unit = toCanonicalUnit(this.unit);
      if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
        return null;
      }
      var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
      return new CSSUnitValue2(this.value * scale_factor, target_unit);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n2, p3, result) {
      var text;
      switch (this.unit) {
        case UnitType.kUnknown:
          break;
        case UnitType.kInteger:
          text = Number(this.value).toFixed(0);
          break;
        case UnitType.kNumber:
        case UnitType.kPercentage:
        case UnitType.kEms:
        case UnitType.kRems:
        case UnitType.kPixels:
        case UnitType.kDegrees:
        case UnitType.kRadians:
        case UnitType.kGradians:
        case UnitType.kMilliseconds:
        case UnitType.kSeconds:
        case UnitType.kTurns: {
          var kMinInteger = -999999;
          var kMaxInteger = 999999;
          var value2 = this.value;
          var unit = unitTypeToString(this.unit);
          if (value2 < kMinInteger || value2 > kMaxInteger) {
            var _unit = unitTypeToString(this.unit);
            if (!Number.isFinite(value2) || Number.isNaN(value2)) {
              text = formatInfinityOrNaN(value2, _unit);
            } else {
              text = value2 + (_unit || "");
            }
          } else {
            text = "".concat(value2).concat(unit);
          }
        }
      }
      result += text;
      return result;
    }
  }]);
}(CSSStyleValue);
var Opx = new CSSUnitValue(0, "px");
new CSSUnitValue(1, "px");
var Odeg = new CSSUnitValue(0, "deg");
var CSSRGB = function(_CSSColorValue) {
  function CSSRGB2(r2, g, b) {
    var _this2;
    var alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    var isNone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    _classCallCheck(this, CSSRGB2);
    _this2 = _callSuper(this, CSSRGB2, ["rgb"]);
    _this2.r = r2;
    _this2.g = g;
    _this2.b = b;
    _this2.alpha = alpha;
    _this2.isNone = isNone;
    return _this2;
  }
  _inherits(CSSRGB2, _CSSColorValue);
  return _createClass(CSSRGB2, [{
    key: "clone",
    value: function clone8() {
      return new CSSRGB2(this.r, this.g, this.b, this.alpha);
    }
  }, {
    key: "buildCSSText",
    value: function buildCSSText(n2, p3, result) {
      return "".concat(result, "rgba(").concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
    }
  }]);
}(CSSColorValue);
var unsetKeywordValue = new CSSKeywordValue("unset");
var initialKeywordValue = new CSSKeywordValue("initial");
var inheritKeywordValue = new CSSKeywordValue("inherit");
var keywordCache = {
  "": unsetKeywordValue,
  unset: unsetKeywordValue,
  initial: initialKeywordValue,
  inherit: inheritKeywordValue
};
var getOrCreateKeyword = function getOrCreateKeyword2(name2) {
  if (!keywordCache[name2]) {
    keywordCache[name2] = new CSSKeywordValue(name2);
  }
  return keywordCache[name2];
};
var noneColor = new CSSRGB(0, 0, 0, 0, true);
var transparentColor = new CSSRGB(0, 0, 0, 0);
var getOrCreateRGBA = memoize2(function(r2, g, b, a5) {
  return new CSSRGB(r2, g, b, a5);
}, function(r2, g, b, a5) {
  return "rgba(".concat(r2, ",").concat(g, ",").concat(b, ",").concat(a5, ")");
});
var getOrCreateUnitValue = function getOrCreateUnitValue2(value2) {
  var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
  return new CSSUnitValue(value2, unitOrName);
};
new CSSUnitValue(50, "%");
function colorStopToString(colorStop) {
  var type = colorStop.type, value2 = colorStop.value;
  if (type === "hex") {
    return "#".concat(value2);
  }
  if (type === "literal") {
    return value2;
  }
  if (type === "rgb") {
    return "rgb(".concat(value2.join(","), ")");
  }
  return "rgba(".concat(value2.join(","), ")");
}
var parseGradient$1 = /* @__PURE__ */ function() {
  var tokens4 = {
    linearGradient: /^(linear\-gradient)/i,
    repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
    /**
     * @see https://projects.verou.me/conic-gradient/
     */
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error3(msg) {
    throw new Error("".concat(input, ": ").concat(msg));
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error3("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient("linear-gradient", tokens4.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens4.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens4.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens4.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens4.conicGradient, matchListRadialOrientations);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan2(tokens4.comma)) {
          error3("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan2(pattern);
    if (captures) {
      if (!scan2(tokens4.startCall)) {
        error3("Missing (");
      }
      var result = callback(captures);
      if (!scan2(tokens4.endCall)) {
        error3("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens4.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens4.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations;
    var radialOrientation = matchRadialOrientation();
    var lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan2(tokens4.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent2 = matchExtentKeyword();
      if (extent2) {
        radialType = extent2;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            // @ts-ignore
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle3 = match("shape", /^(circle)/i, 0);
    if (circle3) {
      circle3.style = matchLength() || matchExtentKeyword();
    }
    return circle3;
  }
  function matchEllipse() {
    var ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens4.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error3("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher();
    var result = [];
    if (captures) {
      result.push(captures);
      while (scan2(tokens4.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error3("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color3 = matchColor();
    if (!color3) {
      error3("Expected color definition");
    }
    color3.length = matchDistance();
    return color3;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens4.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens4.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens4.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens4.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan2(tokens4.number)[1];
  }
  function matchDistance() {
    return match("%", tokens4.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens4.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens4.pixelValue, 1) || match("em", tokens4.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan2(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan2(regexp) {
    var blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    var captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size3) {
    input = input.substring(size3);
  }
  return function(code) {
    input = code;
    return getAST();
  };
}();
function computeLinearGradient(min10, width, height, angle4) {
  var rad2 = deg2rad(angle4.value);
  var rx = 0;
  var ry = 0;
  var rcx = rx + width / 2;
  var rcy = ry + height / 2;
  var length5 = Math.abs(width * Math.cos(rad2)) + Math.abs(height * Math.sin(rad2));
  var x12 = min10[0] + rcx - Math.cos(rad2) * length5 / 2;
  var y12 = min10[1] + rcy - Math.sin(rad2) * length5 / 2;
  var x22 = min10[0] + rcx + Math.cos(rad2) * length5 / 2;
  var y22 = min10[1] + rcy + Math.sin(rad2) * length5 / 2;
  return {
    x1: x12,
    y1: y12,
    x2: x22,
    y2: y22
  };
}
function computeRadialGradient(min10, width, height, cx, cy, size3) {
  var x3 = cx.value;
  var y4 = cy.value;
  if (cx.unit === UnitType.kPercentage) {
    x3 = cx.value / 100 * width;
  }
  if (cy.unit === UnitType.kPercentage) {
    y4 = cy.value / 100 * height;
  }
  var r2 = Math.max(distanceSquareRoot([0, 0], [x3, y4]), distanceSquareRoot([0, height], [x3, y4]), distanceSquareRoot([width, height], [x3, y4]), distanceSquareRoot([width, 0], [x3, y4]));
  if (size3) {
    if (size3 instanceof CSSUnitValue) {
      r2 = size3.value;
    } else if (size3 instanceof CSSKeywordValue) {
      if (size3.value === "closest-side") {
        r2 = Math.min(x3, width - x3, y4, height - y4);
      } else if (size3.value === "farthest-side") {
        r2 = Math.max(x3, width - x3, y4, height - y4);
      } else if (size3.value === "closest-corner") {
        r2 = Math.min(distanceSquareRoot([0, 0], [x3, y4]), distanceSquareRoot([0, height], [x3, y4]), distanceSquareRoot([width, height], [x3, y4]), distanceSquareRoot([width, 0], [x3, y4]));
      }
    }
  }
  return {
    x: x3 + min10[0],
    y: y4 + min10[1],
    r: r2
  };
}
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function spaceColorStops(colorStops) {
  var _colorStops$length;
  var length5 = colorStops.length;
  colorStops[length5 - 1].length = (_colorStops$length = colorStops[length5 - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
    type: "%",
    value: "100"
  };
  if (length5 > 1) {
    var _colorStops$0$length;
    colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
      type: "%",
      value: "0"
    };
  }
  var previousIndex = 0;
  var previousOffset = Number(colorStops[0].length.value);
  for (var i2 = 1; i2 < length5; i2++) {
    var _colorStops$i$length;
    var offset2 = (_colorStops$i$length = colorStops[i2].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
    if (!isNil(offset2) && !isNil(previousOffset)) {
      for (var j = 1; j < i2 - previousIndex; j++) colorStops[previousIndex + j].length = {
        type: "%",
        value: "".concat(previousOffset + (Number(offset2) - previousOffset) * j / (i2 - previousIndex))
      };
      previousIndex = i2;
      previousOffset = Number(offset2);
    }
  }
}
var SideOrCornerToDegMap = {
  left: 270 - 90,
  top: 0 - 90,
  bottom: 180 - 90,
  right: 90 - 90,
  "left top": 315 - 90,
  "top left": 315 - 90,
  "left bottom": 225 - 90,
  "bottom left": 225 - 90,
  "right top": 45 - 90,
  "top right": 45 - 90,
  "right bottom": 135 - 90,
  "bottom right": 135 - 90
};
var angleToDeg = memoize2(function(orientation) {
  var angle4;
  if (orientation.type === "angular") {
    angle4 = Number(orientation.value);
  } else {
    angle4 = SideOrCornerToDegMap[orientation.value] || 0;
  }
  return getOrCreateUnitValue(angle4, "deg");
});
var positonToCSSUnitValue = memoize2(function(position) {
  var cx = 50;
  var cy = 50;
  var unitX = "%";
  var unitY = "%";
  if ((position === null || position === void 0 ? void 0 : position.type) === "position") {
    var _position$value = position.value, x3 = _position$value.x, y4 = _position$value.y;
    if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "position-keyword") {
      if (x3.value === "left") {
        cx = 0;
      } else if (x3.value === "center") {
        cx = 50;
      } else if (x3.value === "right") {
        cx = 100;
      } else if (x3.value === "top") {
        cy = 0;
      } else if (x3.value === "bottom") {
        cy = 100;
      }
    }
    if ((y4 === null || y4 === void 0 ? void 0 : y4.type) === "position-keyword") {
      if (y4.value === "left") {
        cx = 0;
      } else if (y4.value === "center") {
        cy = 50;
      } else if (y4.value === "right") {
        cx = 100;
      } else if (y4.value === "top") {
        cy = 0;
      } else if (y4.value === "bottom") {
        cy = 100;
      }
    }
    if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "px" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "%" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "em") {
      unitX = x3 === null || x3 === void 0 ? void 0 : x3.type;
      cx = Number(x3.value);
    }
    if ((y4 === null || y4 === void 0 ? void 0 : y4.type) === "px" || (y4 === null || y4 === void 0 ? void 0 : y4.type) === "%" || (y4 === null || y4 === void 0 ? void 0 : y4.type) === "em") {
      unitY = y4 === null || y4 === void 0 ? void 0 : y4.type;
      cy = Number(y4.value);
    }
  }
  return {
    cx: getOrCreateUnitValue(cx, unitX),
    cy: getOrCreateUnitValue(cy, unitY)
  };
});
var parseGradient = memoize2(function(colorStr) {
  if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
    var ast = parseGradient$1(colorStr);
    return ast.map(function(_ref) {
      var type2 = _ref.type, orientation = _ref.orientation, colorStops = _ref.colorStops;
      spaceColorStops(colorStops);
      var steps2 = colorStops.map(function(colorStop) {
        return {
          offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
          color: colorStopToString(colorStop)
        };
      });
      if (type2 === "linear-gradient") {
        return new CSSGradientValue(GradientType.LinearGradient, {
          angle: orientation ? angleToDeg(orientation) : Odeg,
          steps: steps2
        });
      }
      if (type2 === "radial-gradient") {
        if (!orientation) {
          orientation = [{
            type: "shape",
            value: "circle"
          }];
        }
        if (orientation[0].type === "shape" && orientation[0].value === "circle") {
          var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
          var size3;
          if (orientation[0].style) {
            var _orientation$0$style = orientation[0].style, _type = _orientation$0$style.type, value2 = _orientation$0$style.value;
            if (_type === "extent-keyword") {
              size3 = getOrCreateKeyword(value2);
            } else {
              size3 = getOrCreateUnitValue(value2, _type);
            }
          }
          return new CSSGradientValue(GradientType.RadialGradient, {
            cx,
            cy,
            size: size3,
            steps: steps2
          });
        }
      }
      return void 0;
    });
  }
  var type = colorStr[0];
  if (colorStr[1] === "(" || colorStr[2] === "(") {
    if (type === "l") {
      var arr = regexLG.exec(colorStr);
      if (arr) {
        var _arr$2$match;
        var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
          return stop.split(":");
        })) || [];
        return [new CSSGradientValue(GradientType.LinearGradient, {
          angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
          steps: steps.map(function(_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2), offset2 = _ref3[0], color3 = _ref3[1];
            return {
              offset: getOrCreateUnitValue(Number(offset2) * 100, "%"),
              color: color3
            };
          })
        })];
      }
    } else if (type === "r") {
      var parsedRadialGradient = parseRadialGradient(colorStr);
      if (parsedRadialGradient) {
        if (isString(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
        }
      }
    } else if (type === "p") {
      return parsePattern(colorStr);
    }
  }
});
function parseRadialGradient(gradientStr) {
  var arr = regexRG.exec(gradientStr);
  if (arr) {
    var _arr$4$match;
    var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
      return stop.split(":");
    })) || [];
    return {
      cx: getOrCreateUnitValue(50, "%"),
      cy: getOrCreateUnitValue(50, "%"),
      steps: steps.map(function(_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2), offset2 = _ref5[0], color3 = _ref5[1];
        return {
          offset: getOrCreateUnitValue(Number(offset2) * 100, "%"),
          color: color3
        };
      })
    };
  }
  return null;
}
function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);
  if (arr) {
    var repetition = arr[1];
    var src = arr[2];
    switch (repetition) {
      case "a":
        repetition = "repeat";
        break;
      case "x":
        repetition = "repeat-x";
        break;
      case "y":
        repetition = "repeat-y";
        break;
      case "n":
        repetition = "no-repeat";
        break;
      default:
        repetition = "no-repeat";
    }
    return {
      image: src,
      // @ts-ignore
      repetition
    };
  }
  return null;
}
function isPattern(object) {
  return object && !!object.image;
}
function isCSSRGB(object) {
  return object && !isNil(object.r) && !isNil(object.g) && !isNil(object.b);
}
var parseColor = memoize2(function(colorStr) {
  if (isPattern(colorStr)) {
    return _objectSpread2({
      repetition: "repeat"
    }, colorStr);
  }
  if (isNil(colorStr)) {
    colorStr = "";
  }
  if (colorStr === "transparent") {
    return transparentColor;
  }
  if (colorStr === "currentColor") {
    colorStr = "black";
  } else if (colorStr === "none") {
    return noneColor;
  }
  var g = parseGradient(colorStr);
  if (g) {
    return g;
  }
  var color$1 = color(colorStr);
  var rgba3 = [0, 0, 0, 0];
  if (color$1 !== null) {
    rgba3[0] = color$1.r || 0;
    rgba3[1] = color$1.g || 0;
    rgba3[2] = color$1.b || 0;
    rgba3[3] = color$1.opacity;
  }
  return getOrCreateRGBA.apply(void 0, rgba3);
});
function mergeColors(left2, right2) {
  if (!isCSSRGB(left2) || !isCSSRGB(right2)) {
    return;
  }
  return [[Number(left2.r), Number(left2.g), Number(left2.b), Number(left2.alpha)], [Number(right2.r), Number(right2.g), Number(right2.b), Number(right2.alpha)], function(color3) {
    var rgba3 = color3.slice();
    if (rgba3[3]) {
      for (var i2 = 0; i2 < 3; i2++) rgba3[i2] = Math.round(clamp_default(rgba3[i2], 0, 255));
    }
    rgba3[3] = clamp_default(rgba3[3], 0, 1);
    return "rgba(".concat(rgba3.join(","), ")");
  }];
}
function parseDimension(unitRegExp, string) {
  if (isNil(string)) {
    return getOrCreateUnitValue(0, "px");
  }
  string = "".concat(string).trim().toLowerCase();
  if (isFinite(Number(string))) {
    if ("px".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "px");
    }
    if ("deg".search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), "deg");
    }
  }
  var matchedUnits = [];
  string = string.replace(unitRegExp, function(match) {
    matchedUnits.push(match);
    return "U".concat(match);
  });
  var taggedUnitRegExp = "U(".concat(unitRegExp.source, ")");
  return matchedUnits.map(function(unit) {
    return getOrCreateUnitValue(Number(string.replace(new RegExp("U".concat(unit), "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
  })[0];
}
var parseLengthUnmemoize = function parseLengthUnmemoize2(css) {
  return parseDimension(new RegExp("px", "g"), css);
};
var parseLength = memoize2(parseLengthUnmemoize);
var parserPercentageUnmemoize = function parserPercentageUnmemoize2(css) {
  return parseDimension(new RegExp("%", "g"), css);
};
memoize2(parserPercentageUnmemoize);
var parseLengthOrPercentageUnmemoize = function parseLengthOrPercentageUnmemoize2(css) {
  if (isNumber(css) || isFinite(Number(css))) {
    return getOrCreateUnitValue(Number(css) || 0, "px");
  }
  return parseDimension(new RegExp("px|%|em|rem", "g"), css);
};
var parseLengthOrPercentage = memoize2(parseLengthOrPercentageUnmemoize);
var parseAngleUnmemoize = function parseAngleUnmemoize2(css) {
  return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css);
};
var parseAngle = memoize2(parseAngleUnmemoize);
function mergeDimensions(left2, right2, target, nonNegative) {
  var index3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var unit = "";
  var leftValue = left2.value || 0;
  var rightValue = right2.value || 0;
  var canonicalUnit = toCanonicalUnit(left2.unit);
  var leftCanonicalUnitValue = left2.convertTo(canonicalUnit);
  var rightCanonicalUnitValue = right2.convertTo(canonicalUnit);
  if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
    leftValue = leftCanonicalUnitValue.value;
    rightValue = rightCanonicalUnitValue.value;
    unit = unitTypeToString(left2.unit);
  } else if (CSSUnitValue.isLength(left2.unit) || CSSUnitValue.isLength(right2.unit)) {
    leftValue = convertPercentUnit(left2, index3, target);
    rightValue = convertPercentUnit(right2, index3, target);
    unit = "px";
  }
  return [leftValue, rightValue, function(value2) {
    if (nonNegative) {
      value2 = Math.max(value2, 0);
    }
    return value2 + unit;
  }];
}
function convertAngleUnit(value2) {
  var deg2 = 0;
  if (value2.unit === UnitType.kDegrees) {
    deg2 = value2.value;
  } else if (value2.unit === UnitType.kRadians) {
    deg2 = rad2deg(Number(value2.value));
  } else if (value2.unit === UnitType.kTurns) {
    deg2 = turn2deg(Number(value2.value));
  } else if (value2.value) {
    deg2 = value2.value;
  }
  return deg2;
}
function parseDimensionArrayFormat(string, size3) {
  var parsed;
  if (Array.isArray(string)) {
    parsed = string.map(function(segment) {
      return Number(segment);
    });
  } else if (isString(string)) {
    parsed = string.split(" ").map(function(segment) {
      return Number(segment);
    });
  } else if (isNumber(string)) {
    parsed = [string];
  }
  if (size3 === 2) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0]];
    }
    return [parsed[0], parsed[1]];
  }
  if (size3 === 4) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0], parsed[0], parsed[0]];
    }
    if (parsed.length === 2) {
      return [parsed[0], parsed[1], parsed[0], parsed[1]];
    }
    if (parsed.length === 3) {
      return [parsed[0], parsed[1], parsed[2], parsed[1]];
    }
    return [parsed[0], parsed[1], parsed[2], parsed[3]];
  }
  if (size3 === "even" && parsed.length % 2 === 1) {
    return [].concat(_toConsumableArray(parsed), _toConsumableArray(parsed));
  }
  return parsed;
}
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  var useMin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (valueWithUnit.unit === UnitType.kPixels) {
    return Number(valueWithUnit.value);
  }
  if (valueWithUnit.unit === UnitType.kPercentage && target) {
    var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
    return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
  }
  return 0;
}
var parseParam = function parseParam2(css) {
  return parseDimension(/deg|rad|grad|turn|px|%/g, css);
};
var supportedFilters = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
function parseFilter() {
  var filterStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  filterStr = filterStr.toLowerCase().trim();
  if (filterStr === "none") {
    return [];
  }
  var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = filterRegExp.exec(filterStr)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    if (supportedFilters.indexOf(match[1]) > -1) {
      result.push({
        name: match[1],
        params: match[2].split(" ").map(function(p3) {
          return parseParam(p3) || parseColor(p3);
        })
      });
    }
    if (filterRegExp.lastIndex === filterStr.length) {
      return result;
    }
  }
  return [];
}
function numberToString(x3) {
  return x3.toString();
}
var parseNumberUnmemoize = function parseNumberUnmemoize2(string) {
  if (typeof string === "number") {
    return getOrCreateUnitValue(string);
  }
  if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
    return getOrCreateUnitValue(Number(string));
  }
  return getOrCreateUnitValue(0);
};
var parseNumber = memoize2(parseNumberUnmemoize);
memoize2(function(string) {
  if (isString(string)) {
    return string.split(" ").map(parseNumber);
  }
  return string.map(parseNumber);
});
function mergeNumbers(left2, right2) {
  return [left2, right2, numberToString];
}
function clampedMergeNumbers(min10, max11) {
  return function(left2, right2) {
    return [left2, right2, function(x3) {
      return numberToString(clamp_default(x3, min10, max11));
    }];
  };
}
function mergeNumberLists(left2, right2) {
  if (left2.length !== right2.length) {
    return;
  }
  return [left2, right2, function(numberList) {
    return numberList;
  }];
}
function getOrCalculatePathTotalLength(path2) {
  if (path2.parsedStyle.d.totalLength === 0) {
    path2.parsedStyle.d.totalLength = getTotalLength(path2.parsedStyle.d.absolutePath);
  }
  return path2.parsedStyle.d.totalLength;
}
function getOrCalculatePolylineTotalLength(polyline) {
  if (polyline.parsedStyle.points.totalLength === 0) {
    polyline.parsedStyle.points.totalLength = length$2(polyline.parsedStyle.points.points);
  }
  return polyline.parsedStyle.points.totalLength;
}
function removeRedundantMCommand(path2) {
  for (var i2 = 0; i2 < path2.length; i2++) {
    var prevSegment = path2[i2 - 1];
    var segment = path2[i2];
    var cmd = segment[0];
    if (cmd === "M") {
      if (prevSegment) {
        var prevCmd = prevSegment[0];
        var srcPoint = [segment[1], segment[2]];
        var destPoint = void 0;
        if (prevCmd === "L" || prevCmd === "M") {
          destPoint = [prevSegment[1], prevSegment[2]];
        } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
          destPoint = [prevSegment[prevSegment.length - 2], prevSegment[prevSegment.length - 1]];
        }
        if (destPoint && isSamePoint(srcPoint, destPoint)) {
          path2.splice(i2, 1);
          i2--;
        }
      }
    }
  }
}
function hasArcOrBezier(path2) {
  var hasArc = false;
  var count4 = path2.length;
  for (var i2 = 0; i2 < count4; i2++) {
    var params = path2[i2];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc = true;
      break;
    }
  }
  return hasArc;
}
function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i2 = 0; i2 < pathArray.length; i2++) {
    var params = pathArray[i2];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
function isSamePoint(point1, point22) {
  return point1[0] === point22[0] && point1[1] === point22[1];
}
function getPathBBox2(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max(xArr);
  var maxY2 = max(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
    var _segment = segmentsWithAngle[_i];
    var _currentPoint = _segment.currentPoint;
    var extra = void 0;
    if (_currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minX -= extra.xExtra;
    } else if (_currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxX += extra.xExtra;
    }
    if (_currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minY -= extra.yExtra;
    } else if (_currentPoint[1] === maxY2) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxY2 += extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function toSymmetry(point7, center2) {
  return [center2[0] + (center2[0] - point7[0]), center2[1] + (center2[1] - point7[1])];
}
var angleBetween3 = function angleBetween4(v0, v1) {
  var p3 = v0.x * v1.x + v0.y * v1.y;
  var n2 = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
  var sign3 = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
  var angle4 = sign3 * Math.acos(p3 / n2);
  return angle4;
};
var pointOnEllipticalArc = function pointOnEllipticalArc2(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  xAxisRotation = mod_default(xAxisRotation, 360);
  var xAxisRotationRadians = deg2rad(xAxisRotation);
  if (p0.x === p1.x && p0.y === p1.y) {
    return {
      x: p0.x,
      y: p0.y,
      ellipticalArcAngle: 0
    };
  }
  if (rx === 0 || ry === 0) {
    return {
      x: 0,
      y: 0,
      ellipticalArcAngle: 0
    };
  }
  var dx = (p0.x - p1.x) / 2;
  var dy = (p0.y - p1.y) / 2;
  var transformedPoint = {
    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= Math.sqrt(radiiCheck);
    ry *= Math.sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center2 = {
    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween3({
    x: 1,
    y: 0
  }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween3(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  var angle4 = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * Math.cos(angle4);
  var ellipseComponentY = ry * Math.sin(angle4);
  var point7 = {
    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center2.x,
    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center2.y,
    ellipticalArcStartAngle: startAngle,
    ellipticalArcEndAngle: startAngle + sweepAngle,
    ellipticalArcAngle: angle4,
    ellipticalArcCenter: center2,
    resultantRx: rx,
    resultantRy: ry
  };
  return point7;
};
function path2Segments(path2) {
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count4 = path2.length;
  for (var i2 = 0; i2 < count4; i2++) {
    var params = path2[i2];
    nextParams = path2[i2 + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null,
      currentPoint: null,
      nextPoint: null,
      arcParams: null,
      box: null,
      cubicParams: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i2;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment.arcParams = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path2[lastStartMovePointIndex + 1];
    } else {
      var len5 = params.length;
      currentPoint = [params[len5 - 2], params[len5 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path2[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment.currentPoint = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment.nextPoint = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i2 - 1];
      var _cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
        segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var _preSegment = segments[i2 - 1];
      var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
      var _cp3 = [params[1], params[2]];
      if (_preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      }
    } else if (command === "A") {
      var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
      var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
      segment.startTangent = [dx1, dy1];
      segment.endTangent = [dx2, dy2];
    }
    segments.push(segment);
  }
  return segments;
}
function getTangentAtRatio(segment, ratio) {
  var sign3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
  var p1 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, ratio);
  var p22 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, sign3 ? ratio + 5e-3 : ratio - 5e-3);
  var xDist = p22.x - p1.x;
  var yDist = p22.y - p1.y;
  var dist5 = Math.sqrt(xDist * xDist + yDist * yDist);
  return {
    x: -xDist / dist5,
    y: -yDist / dist5
  };
}
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u2, v) {
  return vMag(u2) * vMag(v) ? (u2[0] * v[0] + u2[1] * v[1]) / (vMag(u2) * vMag(v)) : 1;
}
function vAngle(u2, v) {
  return (u2[0] * v[1] < u2[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u2, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(deg2rad(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x12 = startPoint[0];
  var y12 = startPoint[1];
  var x22 = params[6];
  var y22 = params[7];
  var xp = Math.cos(xRotation) * (x12 - x22) / 2 + Math.sin(xRotation) * (y12 - y22) / 2;
  var yp = -1 * Math.sin(xRotation) * (x12 - x22) / 2 + Math.cos(xRotation) * (y12 - y22) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f2 = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f2 *= -1;
  }
  if (isNaN(f2)) {
    f2 = 0;
  }
  var cxp = ry ? f2 * rx * yp / ry : 0;
  var cyp = rx ? f2 * -ry * xp / rx : 0;
  var cx = (x12 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y12 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u2);
  var dTheta = vAngle(u2, v);
  if (vRatio(u2, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u2, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta -= 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta += 2 * Math.PI;
  }
  return {
    cx,
    cy,
    //  0 
    rx: isSamePoint(startPoint, [x22, y22]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x22, y22]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function commandsToPathString(commands, object, transform2) {
  return commands.reduce(function(prev, cur) {
    var path2 = "";
    if (cur[0] === "M" || cur[0] === "L") {
      var p3 = vec3_exports.fromValues(cur[1], cur[2], 0);
      if (transform2) {
        vec3_exports.transformMat4(p3, p3, transform2);
      }
      path2 = "".concat(cur[0]).concat(p3[0], ",").concat(p3[1]);
    } else if (cur[0] === "Z") {
      path2 = cur[0];
    } else if (cur[0] === "C") {
      var p1 = vec3_exports.fromValues(cur[1], cur[2], 0);
      var p22 = vec3_exports.fromValues(cur[3], cur[4], 0);
      var p32 = vec3_exports.fromValues(cur[5], cur[6], 0);
      if (transform2) {
        vec3_exports.transformMat4(p1, p1, transform2);
        vec3_exports.transformMat4(p22, p22, transform2);
        vec3_exports.transformMat4(p32, p32, transform2);
      }
      path2 = "".concat(cur[0]).concat(p1[0], ",").concat(p1[1], ",").concat(p22[0], ",").concat(p22[1], ",").concat(p32[0], ",").concat(p32[1]);
    } else if (cur[0] === "A") {
      var c6 = vec3_exports.fromValues(cur[6], cur[7], 0);
      if (transform2) {
        vec3_exports.transformMat4(c6, c6, transform2);
      }
      path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], ",").concat(cur[5], ",").concat(c6[0], ",").concat(c6[1]);
    } else if (cur[0] === "Q") {
      var _p = vec3_exports.fromValues(cur[1], cur[2], 0);
      var _p2 = vec3_exports.fromValues(cur[3], cur[4], 0);
      if (transform2) {
        vec3_exports.transformMat4(_p, _p, transform2);
        vec3_exports.transformMat4(_p2, _p2, transform2);
      }
      path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], "}");
    }
    return prev += path2;
  }, "");
}
function lineToCommands(x12, y12, x22, y22) {
  return [["M", x12, y12], ["L", x22, y22]];
}
function ellipseToCommands(rx, ry, cx, cy) {
  var factor = (-1 + Math.sqrt(2)) / 3 * 4;
  var dx = rx * factor;
  var dy = ry * factor;
  var left2 = cx - rx;
  var right2 = cx + rx;
  var top = cy - ry;
  var bottom = cy + ry;
  return [["M", left2, cy], ["C", left2, cy - dy, cx - dx, top, cx, top], ["C", cx + dx, top, right2, cy - dy, right2, cy], ["C", right2, cy + dy, cx + dx, bottom, cx, bottom], ["C", cx - dx, bottom, left2, cy + dy, left2, cy], ["Z"]];
}
function polygonToCommands(points, closed) {
  var result = points.map(function(point7, i2) {
    return [i2 === 0 ? "M" : "L", point7[0], point7[1]];
  });
  if (closed) {
    result.push(["Z"]);
  }
  return result;
}
function rectToCommands(width, height, x3, y4, radius) {
  if (radius) {
    var _radius = _slicedToArray(radius, 4), tlr = _radius[0], trr = _radius[1], brr = _radius[2], blr = _radius[3];
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY !== 0 ? 1 : 0;
    return [["M", signX * tlr + x3, y4], ["L", width - signX * trr + x3, y4], trr ? ["A", trr, trr, 0, 0, sweepFlag, width + x3, signY * trr + y4] : null, ["L", width + x3, height - signY * brr + y4], brr ? ["A", brr, brr, 0, 0, sweepFlag, width + x3 - signX * brr, height + y4] : null, ["L", x3 + signX * blr, height + y4], blr ? ["A", blr, blr, 0, 0, sweepFlag, x3, height + y4 - signY * blr] : null, ["L", x3, signY * tlr + y4], tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x3, y4] : null, ["Z"]].filter(function(command) {
      return command;
    });
  }
  return [["M", x3, y4], ["L", x3 + width, y4], ["L", x3 + width, y4 + height], ["L", x3, y4 + height], ["Z"]];
}
function convertToPath(object) {
  var transform2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : object.getLocalTransform();
  var commands = [];
  switch (object.nodeName) {
    case Shape.LINE:
      var _parsedStyle = object.parsedStyle, _parsedStyle$x = _parsedStyle.x1, x12 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = _parsedStyle.y1, y12 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$x2 = _parsedStyle.x2, x22 = _parsedStyle$x2 === void 0 ? 0 : _parsedStyle$x2, _parsedStyle$y2 = _parsedStyle.y2, y22 = _parsedStyle$y2 === void 0 ? 0 : _parsedStyle$y2;
      commands = lineToCommands(x12, y12, x22, y22);
      break;
    case Shape.CIRCLE: {
      var _parsedStyle2 = object.parsedStyle, _parsedStyle2$r = _parsedStyle2.r, r2 = _parsedStyle2$r === void 0 ? 0 : _parsedStyle2$r, _parsedStyle2$cx = _parsedStyle2.cx, cx = _parsedStyle2$cx === void 0 ? 0 : _parsedStyle2$cx, _parsedStyle2$cy = _parsedStyle2.cy, cy = _parsedStyle2$cy === void 0 ? 0 : _parsedStyle2$cy;
      commands = ellipseToCommands(r2, r2, cx, cy);
      break;
    }
    case Shape.ELLIPSE: {
      var _parsedStyle3 = object.parsedStyle, _parsedStyle3$rx = _parsedStyle3.rx, rx = _parsedStyle3$rx === void 0 ? 0 : _parsedStyle3$rx, _parsedStyle3$ry = _parsedStyle3.ry, ry = _parsedStyle3$ry === void 0 ? 0 : _parsedStyle3$ry, _parsedStyle3$cx = _parsedStyle3.cx, _cx = _parsedStyle3$cx === void 0 ? 0 : _parsedStyle3$cx, _parsedStyle3$cy = _parsedStyle3.cy, _cy = _parsedStyle3$cy === void 0 ? 0 : _parsedStyle3$cy;
      commands = ellipseToCommands(rx, ry, _cx, _cy);
      break;
    }
    case Shape.POLYLINE:
    case Shape.POLYGON:
      var points = object.parsedStyle.points;
      commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
      break;
    case Shape.RECT:
      var _parsedStyle4 = object.parsedStyle, _parsedStyle4$width = _parsedStyle4.width, width = _parsedStyle4$width === void 0 ? 0 : _parsedStyle4$width, _parsedStyle4$height = _parsedStyle4.height, height = _parsedStyle4$height === void 0 ? 0 : _parsedStyle4$height, _parsedStyle4$x = _parsedStyle4.x, x3 = _parsedStyle4$x === void 0 ? 0 : _parsedStyle4$x, _parsedStyle4$y = _parsedStyle4.y, y4 = _parsedStyle4$y === void 0 ? 0 : _parsedStyle4$y, radius = _parsedStyle4.radius;
      var hasRadius = radius && radius.some(function(r3) {
        return r3 !== 0;
      });
      commands = rectToCommands(width, height, x3, y4, hasRadius && radius.map(function(r3) {
        return clamp_default(r3, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }));
      break;
    case Shape.PATH:
      var absolutePath = object.parsedStyle.d.absolutePath;
      commands = _toConsumableArray(absolutePath);
      break;
  }
  if (commands.length) {
    return commandsToPathString(commands, object, transform2);
  }
}
var internalParsePath = function internalParsePath2(path2) {
  if (path2 === "" || Array.isArray(path2) && path2.length === 0) {
    return {
      absolutePath: [],
      hasArc: false,
      segments: [],
      polygons: [],
      polylines: [],
      curve: null,
      totalLength: 0,
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
  }
  var absolutePath;
  try {
    absolutePath = normalizePath(path2);
  } catch (_unused) {
    absolutePath = normalizePath("");
    console.error("[g]: Invalid SVG Path definition: ".concat(path2));
  }
  removeRedundantMCommand(absolutePath);
  var hasArc = hasArcOrBezier(absolutePath);
  var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
  var segments = path2Segments(absolutePath);
  var _getPathBBox = getPathBBox2(segments, 0), x3 = _getPathBBox.x, y4 = _getPathBBox.y, width = _getPathBBox.width, height = _getPathBBox.height;
  return {
    absolutePath,
    hasArc,
    segments,
    polygons,
    polylines,
    // curve,
    // Delay the calculation of length.
    totalLength: 0,
    rect: {
      x: Number.isFinite(x3) ? x3 : 0,
      y: Number.isFinite(y4) ? y4 : 0,
      width: Number.isFinite(width) ? width : 0,
      height: Number.isFinite(height) ? height : 0
    }
  };
};
var memoizedParsePath = memoize2(internalParsePath);
function parsePath(path2) {
  return isString(path2) ? memoizedParsePath(path2) : internalParsePath(path2);
}
function mergePaths(left2, right2, object) {
  var curve1 = left2.curve;
  var curve2 = right2.curve;
  if (!curve1 || curve1.length === 0) {
    curve1 = path2Curve(left2.absolutePath, false);
    left2.curve = curve1;
  }
  if (!curve2 || curve2.length === 0) {
    curve2 = path2Curve(right2.absolutePath, false);
    right2.curve = curve2;
  }
  var curves = [curve1, curve2];
  if (curve1.length !== curve2.length) {
    curves = equalizeSegments(curve1, curve2);
  }
  var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
  return [curve0, getRotatedCurve(curves[1], curve0), function(pathArray) {
    return pathArray;
  }];
}
function parsePoints(pointsOrStr, object) {
  var points;
  if (isString(pointsOrStr)) {
    points = pointsOrStr.split(" ").map(function(pointStr) {
      var _pointStr$split = pointStr.split(","), _pointStr$split2 = _slicedToArray(_pointStr$split, 2), x3 = _pointStr$split2[0], y4 = _pointStr$split2[1];
      return [Number(x3), Number(y4)];
    });
  } else {
    points = pointsOrStr;
  }
  return {
    points,
    totalLength: 0,
    segments: []
  };
}
function mergePoints(left2, right2) {
  return [left2.points, right2.points, function(points) {
    return points;
  }];
}
var _ = null;
var TRANSFORM_REGEXP = /\s*(\w+)\(([^)]*)\)/g;
function cast(pattern) {
  return function(contents) {
    var i2 = 0;
    return pattern.map(function(x3) {
      return x3 === _ ? contents[i2++] : x3;
    });
  };
}
function id(x3) {
  return x3;
}
var transformFunctions = {
  // @ts-ignore
  matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
  matrix3d: ["NNNNNNNNNNNNNNNN", id],
  rotate: ["A"],
  rotateX: ["A"],
  rotateY: ["A"],
  rotateZ: ["A"],
  rotate3d: ["NNNA"],
  perspective: ["L"],
  scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
  scaleX: ["N", cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
  scaleY: ["N", cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
  scaleZ: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
  scale3d: ["NNN", id],
  skew: ["Aa", null, id],
  skewX: ["A", null, cast([_, Odeg])],
  skewY: ["A", null, cast([Odeg, _])],
  translate: ["Tt", cast([_, _, Opx]), id],
  translateX: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
  translateY: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
  translateZ: ["L", cast([Opx, Opx, _])],
  translate3d: ["TTL", id]
};
function parseArrayTransform(transform2) {
  var result = [];
  var length5 = transform2.length;
  for (var i2 = 0; i2 < length5; i2++) {
    var item = transform2[i2];
    var name2 = item[0];
    var args = item.slice(1);
    if (name2 === "translate" || name2 === "skew") {
      if (args.length === 1) args.push(0);
    } else if (name2 === "scale") {
      if (args.length === 1) args.push(args[0]);
    }
    var functionData = transformFunctions[name2];
    if (!functionData) return [];
    var parsedArgs = args.map(function(value2) {
      return getOrCreateUnitValue(value2);
    });
    result.push({
      t: name2,
      d: parsedArgs
    });
  }
  return result;
}
function parseTransform(transform2) {
  if (Array.isArray(transform2)) {
    return parseArrayTransform(transform2);
  }
  transform2 = (transform2 || "none").trim();
  if (transform2 === "none") {
    return [];
  }
  var result = [];
  var match;
  var prevLastIndex = 0;
  TRANSFORM_REGEXP.lastIndex = 0;
  while (match = TRANSFORM_REGEXP.exec(transform2)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i2 = 0; i2 < argTypes.length; i2++) {
      var arg = args[i2];
      var type = argTypes[i2];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A6(s4) {
            return s4.trim() === "0" ? Odeg : parseAngle(s4);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (TRANSFORM_REGEXP.lastIndex === transform2.length) {
      return result;
    }
  }
  return [];
}
function parseTransformUnmemoize(transform2) {
  if (Array.isArray(transform2)) {
    return parseArrayTransform(transform2);
  }
  transform2 = (transform2 || "none").trim();
  if (transform2 === "none") {
    return [];
  }
  var result = [];
  var match;
  var prevLastIndex = 0;
  TRANSFORM_REGEXP.lastIndex = 0;
  while (match = TRANSFORM_REGEXP.exec(transform2)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1];
    var functionData = transformFunctions[functionName];
    if (!functionData) {
      return [];
    }
    var args = match[2].split(",");
    var argTypes = functionData[0];
    if (argTypes.length < args.length) {
      return [];
    }
    var parsedArgs = [];
    for (var i2 = 0; i2 < argTypes.length; i2++) {
      var arg = args[i2];
      var type = argTypes[i2];
      var parsedArg = void 0;
      if (!arg) {
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        parsedArg = {
          A: function A6(s4) {
            return s4.trim() === "0" ? Odeg : parseAngleUnmemoize(s4);
          },
          N: parseNumberUnmemoize,
          T: parseLengthOrPercentageUnmemoize,
          L: parseLengthUnmemoize
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === void 0) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    });
    if (TRANSFORM_REGEXP.lastIndex === transform2.length) {
      return result;
    }
  }
  return [];
}
function convertItemToMatrix(item) {
  var x3;
  var y4;
  var z;
  var angle4;
  switch (item.t) {
    case "rotateX":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, 0, Math.cos(angle4), Math.sin(angle4), 0, 0, -Math.sin(angle4), Math.cos(angle4), 0, 0, 0, 0, 1];
    case "rotateY":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle4), 0, -Math.sin(angle4), 0, 0, 1, 0, 0, Math.sin(angle4), 0, Math.cos(angle4), 0, 0, 0, 0, 1];
    case "rotate":
    case "rotateZ":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle4), Math.sin(angle4), 0, 0, -Math.sin(angle4), Math.cos(angle4), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "rotate3d":
      x3 = item.d[0].value;
      y4 = item.d[1].value;
      z = item.d[2].value;
      angle4 = deg2rad(convertAngleUnit(item.d[3]));
      var sqrLength = x3 * x3 + y4 * y4 + z * z;
      if (sqrLength === 0) {
        x3 = 1;
        y4 = 0;
        z = 0;
      } else if (sqrLength !== 1) {
        var length5 = Math.sqrt(sqrLength);
        x3 /= length5;
        y4 /= length5;
        z /= length5;
      }
      var s4 = Math.sin(angle4 / 2);
      var sc = s4 * Math.cos(angle4 / 2);
      var sq = s4 * s4;
      return [1 - 2 * (y4 * y4 + z * z) * sq, 2 * (x3 * y4 * sq + z * sc), 2 * (x3 * z * sq - y4 * sc), 0, 2 * (x3 * y4 * sq - z * sc), 1 - 2 * (x3 * x3 + z * z) * sq, 2 * (y4 * z * sq + x3 * sc), 0, 2 * (x3 * z * sq + y4 * sc), 2 * (y4 * z * sq - x3 * sc), 1 - 2 * (x3 * x3 + y4 * y4) * sq, 0, 0, 0, 0, 1];
    case "scale":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleX":
      return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleY":
      return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "scaleZ":
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
    case "scale3d":
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
    case "skew":
      var xAngle = deg2rad(convertAngleUnit(item.d[0]));
      var yAngle = deg2rad(convertAngleUnit(item.d[1]));
      return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewX":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, Math.tan(angle4), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "skewY":
      angle4 = deg2rad(convertAngleUnit(item.d[0]));
      return [1, Math.tan(angle4), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case "translate":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      y4 = convertPercentUnit(item.d[1], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y4, 0, 1];
    case "translateX":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, 0, 0, 1];
    case "translateY":
      y4 = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y4, 0, 1];
    case "translateZ":
      z = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
    case "translate3d":
      x3 = convertPercentUnit(item.d[0], 0, null) || 0;
      y4 = convertPercentUnit(item.d[1], 0, null) || 0;
      z = convertPercentUnit(item.d[2], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y4, z, 1];
    case "perspective":
      var t = convertPercentUnit(item.d[0], 0, null) || 0;
      var p3 = t ? -1 / t : 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p3, 0, 0, 0, 1];
    case "matrix":
      return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
    case "matrix3d":
      return item.d.map(function(d4) {
        return d4.value;
      });
  }
}
function multiplyMatrices(a5, b) {
  return [a5[0] * b[0] + a5[4] * b[1] + a5[8] * b[2] + a5[12] * b[3], a5[1] * b[0] + a5[5] * b[1] + a5[9] * b[2] + a5[13] * b[3], a5[2] * b[0] + a5[6] * b[1] + a5[10] * b[2] + a5[14] * b[3], a5[3] * b[0] + a5[7] * b[1] + a5[11] * b[2] + a5[15] * b[3], a5[0] * b[4] + a5[4] * b[5] + a5[8] * b[6] + a5[12] * b[7], a5[1] * b[4] + a5[5] * b[5] + a5[9] * b[6] + a5[13] * b[7], a5[2] * b[4] + a5[6] * b[5] + a5[10] * b[6] + a5[14] * b[7], a5[3] * b[4] + a5[7] * b[5] + a5[11] * b[6] + a5[15] * b[7], a5[0] * b[8] + a5[4] * b[9] + a5[8] * b[10] + a5[12] * b[11], a5[1] * b[8] + a5[5] * b[9] + a5[9] * b[10] + a5[13] * b[11], a5[2] * b[8] + a5[6] * b[9] + a5[10] * b[10] + a5[14] * b[11], a5[3] * b[8] + a5[7] * b[9] + a5[11] * b[10] + a5[15] * b[11], a5[0] * b[12] + a5[4] * b[13] + a5[8] * b[14] + a5[12] * b[15], a5[1] * b[12] + a5[5] * b[13] + a5[9] * b[14] + a5[13] * b[15], a5[2] * b[12] + a5[6] * b[13] + a5[10] * b[14] + a5[14] * b[15], a5[3] * b[12] + a5[7] * b[13] + a5[11] * b[14] + a5[15] * b[15]];
}
function convertToMatrix(transformList) {
  if (transformList.length === 0) {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
}
function makeMatrixDecomposition(transformList) {
  var translate6 = [0, 0, 0];
  var scale12 = [1, 1, 1];
  var skew2 = [0, 0, 0];
  var perspective2 = [0, 0, 0, 1];
  var quaternion = [0, 0, 0, 1];
  decomposeMat4(
    // @ts-ignore
    convertToMatrix(transformList),
    translate6,
    scale12,
    skew2,
    perspective2,
    quaternion
  );
  return [[translate6, scale12, skew2, quaternion, perspective2]];
}
var composeMatrix = /* @__PURE__ */ function() {
  function multiply7(a5, b) {
    var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    for (var i2 = 0; i2 < 4; i2++) {
      for (var j = 0; j < 4; j++) {
        for (var k2 = 0; k2 < 4; k2++) {
          result[i2][j] += b[i2][k2] * a5[k2][j];
        }
      }
    }
    return result;
  }
  function is2D(m3) {
    return m3[0][2] === 0 && m3[0][3] === 0 && m3[1][2] === 0 && m3[1][3] === 0 && m3[2][0] === 0 && m3[2][1] === 0 && m3[2][2] === 1 && m3[2][3] === 0 && m3[3][2] === 0 && m3[3][3] === 1;
  }
  function composeMatrix2(translate6, scale12, skew2, quat2, perspective2) {
    var matrix3 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    for (var i2 = 0; i2 < 4; i2++) {
      matrix3[i2][3] = perspective2[i2];
    }
    for (var _i = 0; _i < 3; _i++) {
      for (var j = 0; j < 3; j++) {
        matrix3[3][_i] += translate6[j] * matrix3[j][_i];
      }
    }
    var x3 = quat2[0];
    var y4 = quat2[1];
    var z = quat2[2];
    var w2 = quat2[3];
    var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    rotMatrix[0][0] = 1 - 2 * (y4 * y4 + z * z);
    rotMatrix[0][1] = 2 * (x3 * y4 - z * w2);
    rotMatrix[0][2] = 2 * (x3 * z + y4 * w2);
    rotMatrix[1][0] = 2 * (x3 * y4 + z * w2);
    rotMatrix[1][1] = 1 - 2 * (x3 * x3 + z * z);
    rotMatrix[1][2] = 2 * (y4 * z - x3 * w2);
    rotMatrix[2][0] = 2 * (x3 * z - y4 * w2);
    rotMatrix[2][1] = 2 * (y4 * z + x3 * w2);
    rotMatrix[2][2] = 1 - 2 * (x3 * x3 + y4 * y4);
    matrix3 = multiply7(matrix3, rotMatrix);
    var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    if (skew2[2]) {
      temp[2][1] = skew2[2];
      matrix3 = multiply7(matrix3, temp);
    }
    if (skew2[1]) {
      temp[2][1] = 0;
      temp[2][0] = skew2[0];
      matrix3 = multiply7(matrix3, temp);
    }
    if (skew2[0]) {
      temp[2][0] = 0;
      temp[1][0] = skew2[0];
      matrix3 = multiply7(matrix3, temp);
    }
    for (var _i2 = 0; _i2 < 3; _i2++) {
      for (var _j = 0; _j < 3; _j++) {
        matrix3[_i2][_j] *= scale12[_i2];
      }
    }
    if (is2D(matrix3)) {
      return [matrix3[0][0], matrix3[0][1], matrix3[1][0], matrix3[1][1], matrix3[3][0], matrix3[3][1]];
    }
    return matrix3[0].concat(matrix3[1], matrix3[2], matrix3[3]);
  }
  return composeMatrix2;
}();
function numberToLongString(x3) {
  return x3.toFixed(6).replace(".000000", "");
}
function mergeMatrices(left2, right2) {
  var leftArgs;
  var rightArgs;
  if (left2.decompositionPair !== right2) {
    left2.decompositionPair = right2;
    leftArgs = makeMatrixDecomposition(left2);
  }
  if (right2.decompositionPair !== left2) {
    right2.decompositionPair = left2;
    rightArgs = makeMatrixDecomposition(right2);
  }
  if (leftArgs[0] === null || rightArgs[0] === null) return [
    // @ts-ignore
    [false],
    // @ts-ignore
    [true],
    // @ts-ignore
    function(x3) {
      return x3 ? right2[0].d : left2[0].d;
    }
  ];
  leftArgs[0].push(0);
  rightArgs[0].push(1);
  return [
    leftArgs,
    rightArgs,
    // @ts-ignore
    function(list) {
      var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
      var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
      var stringifiedArgs = mat.map(numberToLongString).join(",");
      return stringifiedArgs;
    }
  ];
}
function dot5(v1, v2) {
  var result = 0;
  for (var i2 = 0; i2 < v1.length; i2++) {
    result += v1[i2] * v2[i2];
  }
  return result;
}
function quat(fromQ, toQ, f2) {
  var product = dot5(fromQ, toQ);
  product = clamp_default(product, -1, 1);
  var quat2 = [];
  if (product === 1) {
    quat2 = fromQ;
  } else {
    var theta = Math.acos(product);
    var w2 = Math.sin(f2 * theta) * 1 / Math.sqrt(1 - product * product);
    for (var i2 = 0; i2 < 4; i2++) {
      quat2.push(fromQ[i2] * (Math.cos(f2 * theta) - product * w2) + toQ[i2] * w2);
    }
  }
  return quat2;
}
function typeTo2D(type) {
  return type.replace(/[XY]/, "");
}
function typeTo3D(type) {
  return type.replace(/(X|Y|Z|3d)?$/, "3d");
}
var isMatrixOrPerspective = function isMatrixOrPerspective2(lt, rt) {
  return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
};
function mergeTransforms(left2, right2, target) {
  var flipResults = false;
  if (!left2.length || !right2.length) {
    if (!left2.length) {
      flipResults = true;
      left2 = right2;
      right2 = [];
    }
    var _loop = function _loop2() {
      var _left$i = left2[i2], type2 = _left$i.t, args = _left$i.d;
      var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
      right2.push({
        t: type2,
        d: args.map(function(arg) {
          if (typeof arg === "number") {
            return getOrCreateUnitValue(defaultValue);
          }
          return getOrCreateUnitValue(defaultValue, arg.unit);
        })
      });
    };
    for (var i2 = 0; i2 < left2.length; i2++) {
      _loop();
    }
  }
  var leftResult = [];
  var rightResult = [];
  var types = [];
  if (left2.length !== right2.length) {
    var merged = mergeMatrices(left2, right2);
    leftResult = [merged[0]];
    rightResult = [merged[1]];
    types = [["matrix", [merged[2]]]];
  } else {
    for (var _i3 = 0; _i3 < left2.length; _i3++) {
      var leftType = left2[_i3].t;
      var rightType = right2[_i3].t;
      var leftArgs = left2[_i3].d;
      var rightArgs = right2[_i3].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;
      if (isMatrixOrPerspective(leftType, rightType)) {
        var _merged = mergeMatrices([left2[_i3]], [right2[_i3]]);
        leftResult.push(_merged[0]);
        rightResult.push(_merged[1]);
        types.push(["matrix", [_merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType);
        leftArgs = leftFunctionData[2](leftArgs);
        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType);
        leftArgs = leftFunctionData[1](leftArgs);
        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        var _merged2 = mergeMatrices(left2, right2);
        leftResult = [_merged2[0]];
        rightResult = [_merged2[1]];
        types = [["matrix", [_merged2[2]]]];
        break;
      }
      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];
      for (var j = 0; j < leftArgs.length; j++) {
        var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = _merged3[0];
        rightArgsCopy[j] = _merged3[1];
        stringConversions.push(_merged3[2]);
      }
      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }
  if (flipResults) {
    var tmp2 = leftResult;
    leftResult = rightResult;
    rightResult = tmp2;
  }
  return [leftResult, rightResult, function(list) {
    return list.map(function(args, i3) {
      var stringifiedArgs = args.map(function(arg, j2) {
        return types[i3][1][j2](arg);
      }).join(",");
      if (types[i3][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
        types[i3][0] = "matrix3d";
      }
      if (types[i3][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
        types[i3][0] = "matrix";
      }
      return "".concat(types[i3][0], "(").concat(stringifiedArgs, ")");
    }).join(" ");
  }];
}
var parseTransformOrigin = memoize2(function(value2) {
  if (isString(value2)) {
    if (value2 === "text-anchor") {
      return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
    }
    var values4 = value2.split(" ");
    if (values4.length === 1) {
      if (values4[0] === "top" || values4[0] === "bottom") {
        values4[1] = values4[0];
        values4[0] = "center";
      } else {
        values4[1] = "center";
      }
    }
    if (values4.length !== 2) {
      return null;
    }
    return [parseLengthOrPercentage(convertKeyword2Percent(values4[0])), parseLengthOrPercentage(convertKeyword2Percent(values4[1]))];
  }
  return [getOrCreateUnitValue(value2[0] || 0, "px"), getOrCreateUnitValue(value2[1] || 0, "px")];
});
function convertKeyword2Percent(keyword) {
  if (keyword === "center") {
    return "50%";
  }
  if (keyword === "left" || keyword === "top") {
    return "0%";
  }
  if (keyword === "right" || keyword === "bottom") {
    return "100%";
  }
  return keyword;
}
var BUILT_IN_PROPERTIES = [
  {
    /**
     * used in CSS Layout API
     * eg. `display: 'flex'`
     */
    n: "display",
    k: ["none"]
  },
  {
    /**
     * range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
     */
    n: "opacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
     */
    n: "fillOpacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
     */
    n: "strokeOpacity",
    "int": true,
    inh: true,
    d: "1",
    syntax: PropertySyntax.OPACITY_VALUE
  },
  {
    /**
     * background-color is not inheritable
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
     */
    n: "fill",
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT
  },
  {
    n: "fillRule",
    k: ["nonzero", "evenodd"],
    d: "nonzero"
  },
  /**
   * default to none
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
   */
  {
    n: "stroke",
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.PAINT,
    /**
     * Stroke 'none' won't affect geometry but others will.
     */
    l: true
  },
  {
    n: "shadowType",
    k: ["inner", "outer", "both"],
    d: "outer",
    l: true
  },
  {
    n: "shadowColor",
    "int": true,
    syntax: PropertySyntax.COLOR
  },
  {
    n: "shadowOffsetX",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowOffsetY",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "shadowBlur",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.SHADOW_BLUR
  },
  {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
     */
    n: "lineWidth",
    "int": true,
    inh: true,
    d: "1",
    l: true,
    a: ["strokeWidth"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "increasedLineWidthForHitTesting",
    inh: true,
    d: "0",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "lineJoin",
    inh: true,
    l: true,
    a: ["strokeLinejoin"],
    k: ["miter", "bevel", "round"],
    d: "miter"
  },
  {
    n: "lineCap",
    inh: true,
    l: true,
    a: ["strokeLinecap"],
    k: ["butt", "round", "square"],
    d: "butt"
  },
  {
    n: "lineDash",
    "int": true,
    inh: true,
    k: ["none"],
    a: ["strokeDasharray"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  {
    n: "lineDashOffset",
    "int": true,
    inh: true,
    d: "0",
    a: ["strokeDashoffset"],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "offsetPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "offsetDistance",
    "int": true,
    syntax: PropertySyntax.OFFSET_DISTANCE
  },
  {
    n: "dx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "dy",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "zIndex",
    ind: true,
    "int": true,
    d: "0",
    k: ["auto"],
    syntax: PropertySyntax.Z_INDEX
  },
  {
    n: "visibility",
    k: ["visible", "hidden"],
    ind: true,
    inh: true,
    /**
     * support interpolation
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
     */
    "int": true,
    d: "visible"
  },
  {
    n: "pointerEvents",
    inh: true,
    k: [
      "none",
      "auto",
      "stroke",
      "fill",
      "painted",
      "visible",
      "visiblestroke",
      "visiblefill",
      "visiblepainted",
      // 'bounding-box',
      "all"
    ],
    d: "auto"
  },
  {
    n: "filter",
    ind: true,
    l: true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.FILTER
  },
  {
    n: "clipPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPath",
    syntax: PropertySyntax.DEFINED_PATH
  },
  {
    n: "textPathSide",
    k: ["left", "right"],
    d: "left"
  },
  {
    n: "textPathStartOffset",
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "transform",
    p: 100,
    "int": true,
    k: ["none"],
    d: "none",
    syntax: PropertySyntax.TRANSFORM
  },
  {
    n: "transformOrigin",
    p: 100,
    d: "0 0",
    // // int: true,
    // d: (nodeName: string) => {
    //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
    //     return 'center';
    //   }
    //   if (nodeName === Shape.TEXT) {
    //     return 'text-anchor';
    //   }
    //   return 'left top';
    // },
    l: true,
    syntax: PropertySyntax.TRANSFORM_ORIGIN
  },
  {
    n: "cx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cy",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "cz",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "r",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "rx",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "ry",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  // Rect Image Group
  {
    // x in local space
    n: "x",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // y in local space
    n: "y",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    // z in local space
    n: "z",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "width",
    "int": true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "height",
    "int": true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
     */
    k: ["auto", "fit-content", "min-content", "max-content"],
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "radius",
    "int": true,
    l: true,
    d: "0",
    syntax: PropertySyntax.LENGTH_PERCENTAGE_14
  },
  // Line
  {
    n: "x1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z1",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "x2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "y2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  {
    n: "z2",
    "int": true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  // Path
  {
    n: "d",
    "int": true,
    l: true,
    d: "",
    syntax: PropertySyntax.PATH,
    p: 50
  },
  // Polyline & Polygon
  {
    n: "points",
    /**
     * support interpolation
     */
    "int": true,
    l: true,
    syntax: PropertySyntax.LIST_OF_POINTS,
    p: 50
  },
  // Text
  {
    n: "text",
    l: true,
    d: "",
    syntax: PropertySyntax.TEXT,
    p: 50
  },
  {
    n: "textTransform",
    l: true,
    inh: true,
    k: ["capitalize", "uppercase", "lowercase", "none"],
    d: "none",
    syntax: PropertySyntax.TEXT_TRANSFORM,
    p: 51
    // it must get parsed after text
  },
  {
    n: "font",
    l: true
  },
  {
    n: "fontSize",
    "int": true,
    inh: true,
    /**
     * @see https://www.w3schools.com/css/css_font_size.asp
     */
    d: "16px",
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  {
    n: "fontFamily",
    l: true,
    inh: true,
    d: "sans-serif"
  },
  {
    n: "fontStyle",
    l: true,
    inh: true,
    k: ["normal", "italic", "oblique"],
    d: "normal"
  },
  {
    n: "fontWeight",
    l: true,
    inh: true,
    k: ["normal", "bold", "bolder", "lighter"],
    d: "normal"
  },
  {
    n: "fontVariant",
    l: true,
    inh: true,
    k: ["normal", "small-caps"],
    d: "normal"
  },
  {
    n: "lineHeight",
    l: true,
    syntax: PropertySyntax.LENGTH,
    "int": true,
    d: "0"
  },
  {
    n: "letterSpacing",
    l: true,
    syntax: PropertySyntax.LENGTH,
    "int": true,
    d: "0"
  },
  {
    n: "miterLimit",
    l: true,
    syntax: PropertySyntax.NUMBER,
    d: function d(nodeName) {
      if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
        return "4";
      }
      return "10";
    }
  },
  {
    n: "wordWrap",
    l: true
  },
  {
    n: "wordWrapWidth",
    l: true
  },
  {
    n: "maxLines",
    l: true
  },
  {
    n: "textOverflow",
    l: true,
    d: "clip"
  },
  {
    n: "leading",
    l: true
  },
  {
    n: "textBaseline",
    l: true,
    inh: true,
    k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
    d: "alphabetic"
  },
  {
    n: "textAlign",
    l: true,
    inh: true,
    k: ["start", "center", "middle", "end", "left", "right"],
    d: "start"
  },
  // {
  //   n: 'whiteSpace',
  //   l: true,
  // },
  {
    n: "markerStart",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerEnd",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerMid",
    syntax: PropertySyntax.MARKER
  },
  {
    n: "markerStartOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    "int": true,
    d: "0"
  },
  {
    n: "markerEndOffset",
    syntax: PropertySyntax.LENGTH,
    l: true,
    "int": true,
    d: "0"
  }
];
var GEOMETRY_ATTRIBUTE_NAMES = new Set(BUILT_IN_PROPERTIES.filter(function(n2) {
  return !!n2.l;
}).map(function(n2) {
  return n2.n;
}));
var propertyMetadataCache = {};
var DefaultStyleValueRegistry = function() {
  function DefaultStyleValueRegistry2(runtime2) {
    var _this2 = this;
    _classCallCheck(this, DefaultStyleValueRegistry2);
    this.runtime = runtime2;
    BUILT_IN_PROPERTIES.forEach(function(property) {
      _this2.registerMetadata(property);
    });
  }
  return _createClass(DefaultStyleValueRegistry2, [{
    key: "registerMetadata",
    value: function registerMetadata(metadata) {
      [metadata.n].concat(_toConsumableArray(metadata.a || [])).forEach(function(name2) {
        propertyMetadataCache[name2] = metadata;
      });
    }
  }, {
    key: "getPropertySyntax",
    value: function getPropertySyntax(syntax) {
      return this.runtime.CSSPropertySyntaxFactory[syntax];
    }
    /**
     * * parse value, eg.
     * fill: 'red' => CSSRGB
     * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
     * fontSize: '2em' => { unit: 'px', value: 32 }
     *
     * * calculate used value
     * * post process
     */
  }, {
    key: "processProperties",
    value: function processProperties(object, attributes) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        skipUpdateAttribute: false,
        skipParse: false,
        forceUpdateGeometry: false,
        usedAttributes: [],
        memoize: true
      };
      Object.assign(object.attributes, attributes);
      var oldClipPath = object.parsedStyle.clipPath;
      var oldOffsetPath = object.parsedStyle.offsetPath;
      assignParsedStyle(object, attributes);
      var needUpdateGeometry = !!options.forceUpdateGeometry;
      if (!needUpdateGeometry) {
        for (var i2 in attributes) {
          if (GEOMETRY_ATTRIBUTE_NAMES.has(i2)) {
            needUpdateGeometry = true;
            break;
          }
        }
      }
      var list = getParsedStyleListOf(object);
      if (list.has("fill") && attributes.fill) {
        object.parsedStyle.fill = parseColor(attributes.fill);
      }
      if (list.has("stroke") && attributes.stroke) {
        object.parsedStyle.stroke = parseColor(attributes.stroke);
      }
      if (list.has("shadowColor") && attributes.shadowColor) {
        object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
      }
      if (list.has("filter") && attributes.filter) {
        object.parsedStyle.filter = parseFilter(attributes.filter);
      }
      if (list.has("radius") && !isNil(attributes.radius)) {
        object.parsedStyle.radius = parseDimensionArrayFormat(
          // @ts-ignore
          attributes.radius,
          4
        );
      }
      if (list.has("lineDash") && !isNil(attributes.lineDash)) {
        object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, "even");
      }
      if (list.has("points") && attributes.points) {
        object.parsedStyle.points = parsePoints(attributes.points);
      }
      if (list.has("d") && attributes.d === "") {
        object.parsedStyle.d = _objectSpread2({}, EMPTY_PARSED_PATH);
      }
      if (list.has("d") && attributes.d) {
        object.parsedStyle.d = parsePath(
          // @ts-ignore
          attributes.d
        );
      }
      if (list.has("textTransform") && attributes.textTransform) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TEXT_TRANSFORM].calculator(null, null, {
          value: attributes.textTransform
        }, object, null);
      }
      if (list.has("clipPath") && !is_undefined_default(attributes.clipPath)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
      }
      if (list.has("offsetPath") && attributes.offsetPath) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
      }
      if (list.has("transform") && attributes.transform) {
        object.parsedStyle.transform = parseTransform(attributes.transform);
      }
      if (list.has("transformOrigin") && attributes.transformOrigin) {
        object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
      }
      if (list.has("markerStart") && attributes.markerStart) {
        object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          null,
          // @ts-ignore
          attributes.markerStart,
          // @ts-ignore
          attributes.markerStart,
          null,
          null
        );
      }
      if (list.has("markerEnd") && attributes.markerEnd) {
        object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          null,
          // @ts-ignore
          attributes.markerEnd,
          // @ts-ignore
          attributes.markerEnd,
          null,
          null
        );
      }
      if (list.has("markerMid") && attributes.markerMid) {
        object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
          "",
          // @ts-ignore
          attributes.markerMid,
          // @ts-ignore
          attributes.markerMid,
          null,
          null
        );
      }
      if (list.has("zIndex") && !isNil(attributes.zIndex)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.Z_INDEX].postProcessor(object);
      }
      if (list.has("offsetDistance") && !isNil(attributes.offsetDistance)) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.OFFSET_DISTANCE].postProcessor(object);
      }
      if (list.has("transform") && attributes.transform) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM].postProcessor(object);
      }
      if (list.has("transformOrigin") && attributes.transformOrigin) {
        this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM_ORIGIN].postProcessor(object);
      }
      if (needUpdateGeometry) {
        object.geometry.dirty = true;
        object.dirty(true, true);
        if (!options.forceUpdateGeometry) {
          this.runtime.sceneGraphService.dirtyToRoot(object);
        }
      }
    }
    /**
     * update geometry when relative props changed,
     * eg. r of Circle, width/height of Rect
     */
  }, {
    key: "updateGeometry",
    value: function updateGeometry(object) {
      var nodeName = object.nodeName;
      var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
      if (geometryUpdater) {
        var geometry = object.geometry;
        if (!geometry.contentBounds) {
          geometry.contentBounds = new AABB();
        }
        if (!geometry.renderBounds) {
          geometry.renderBounds = new AABB();
        }
        var parsedStyle = object.parsedStyle;
        var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), _geometryUpdater$upda2 = _geometryUpdater$upda.cx, cx = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.cy, cy = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.cz, cz = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.hwidth, hwidth = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5, _geometryUpdater$upda6 = _geometryUpdater$upda.hheight, hheight = _geometryUpdater$upda6 === void 0 ? 0 : _geometryUpdater$upda6, _geometryUpdater$upda7 = _geometryUpdater$upda.hdepth, hdepth = _geometryUpdater$upda7 === void 0 ? 0 : _geometryUpdater$upda7;
        var halfExtents = [Math.abs(hwidth), Math.abs(hheight), hdepth];
        var stroke2 = parsedStyle.stroke, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$increase = parsedStyle.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _parsedStyle$increase === void 0 ? 0 : _parsedStyle$increase, _parsedStyle$shadowTy = parsedStyle.shadowType, shadowType = _parsedStyle$shadowTy === void 0 ? "outer" : _parsedStyle$shadowTy, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter3 = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;
        var center2 = [cx, cy, cz];
        geometry.contentBounds.update(center2, halfExtents);
        var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
        var hasStroke = stroke2 && !stroke2.isNone;
        if (hasStroke) {
          var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
          halfExtents[0] += halfLineWidth;
          halfExtents[1] += halfLineWidth;
        }
        geometry.renderBounds.update(center2, halfExtents);
        if (shadowColor && shadowType && shadowType !== "inner") {
          var _geometry$renderBound = geometry.renderBounds, min10 = _geometry$renderBound.min, max11 = _geometry$renderBound.max;
          var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
          var shadowBlurInPixels = shadowBlur || 0;
          var shadowOffsetXInPixels = shadowOffsetX || 0;
          var shadowOffsetYInPixels = shadowOffsetY || 0;
          var shadowLeft = min10[0] - shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowRight = max11[0] + shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowTop = min10[1] - shadowBlurInPixels + shadowOffsetYInPixels;
          var shadowBottom = max11[1] + shadowBlurInPixels + shadowOffsetYInPixels;
          min10[0] = Math.min(min10[0], shadowLeft);
          max11[0] = Math.max(max11[0], shadowRight);
          min10[1] = Math.min(min10[1], shadowTop);
          max11[1] = Math.max(max11[1], shadowBottom);
          geometry.renderBounds.setMinMax(min10, max11);
        }
        filter3.forEach(function(_ref) {
          var name2 = _ref.name, params = _ref.params;
          if (name2 === "blur") {
            var blurRadius = params[0].value;
            geometry.renderBounds.update(geometry.renderBounds.center, vec3_exports.add(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
          } else if (name2 === "drop-shadow") {
            var _shadowOffsetX = params[0].value;
            var _shadowOffsetY = params[1].value;
            var _shadowBlur = params[2].value;
            var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
            var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
            var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
            var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
            var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
            _min[0] = Math.min(_min[0], _shadowLeft);
            _max[0] = Math.max(_max[0], _shadowRight);
            _min[1] = Math.min(_min[1], _shadowTop);
            _max[1] = Math.max(_max[1], _shadowBottom);
            geometry.renderBounds.setMinMax(_min, _max);
          }
        });
        object.geometry.dirty = false;
        var flipY = hwidth < 0;
        var flipX = hheight < 0;
        var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object, true) : 0);
        var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object, true) : 0);
        if (usedOriginXValue || usedOriginYValue) {
          object.setOrigin(usedOriginXValue, usedOriginYValue);
        }
      }
    }
  }, {
    key: "updateSizeAttenuation",
    value: function updateSizeAttenuation(node, zoom) {
      if (node.style.isSizeAttenuation) {
        if (!node.style.rawLineWidth) {
          node.style.rawLineWidth = node.style.lineWidth;
        }
        node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;
        if (node.nodeName === Shape.CIRCLE) {
          if (!node.style.rawR) {
            node.style.rawR = node.style.r;
          }
          node.style.r = (node.style.rawR || 1) / zoom;
        }
      } else {
        if (node.style.rawLineWidth) {
          node.style.lineWidth = node.style.rawLineWidth;
          delete node.style.rawLineWidth;
        }
        if (node.nodeName === Shape.CIRCLE) {
          if (node.style.rawR) {
            node.style.r = node.style.rawR;
            delete node.style.rawR;
          }
        }
      }
    }
  }]);
}();
function assignParsedStyle(object, attributes) {
  var list = getParsedStyleListOf(object);
  for (var key in attributes) {
    if (list.has(key)) {
      object.parsedStyle[key] = attributes[key];
    }
  }
}
function getParsedStyleListOf(object) {
  return object.constructor.PARSED_STYLE_LIST;
}
var CSSPropertyAngle = function() {
  function CSSPropertyAngle2() {
    _classCallCheck(this, CSSPropertyAngle2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyAngle2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      return convertAngleUnit(parsed);
    }
  }]);
}();
var CSSPropertyClipPath = function() {
  function CSSPropertyClipPath2() {
    _classCallCheck(this, CSSPropertyClipPath2);
  }
  return _createClass(CSSPropertyClipPath2, [{
    key: "calculator",
    value: function calculator(name2, oldPath, newPath, object, runtime2) {
      if (newPath instanceof CSSKeywordValue) {
        newPath = null;
      }
      runtime2.sceneGraphService.updateDisplayObjectDependency(name2, oldPath, newPath, object);
      if (name2 === "clipPath") {
        object.forEach(function(leaf) {
          if (leaf.childNodes.length === 0) {
            runtime2.sceneGraphService.dirtyToRoot(leaf);
          }
        });
      }
      return newPath;
    }
  }]);
}();
var CSSPropertyColor = function() {
  function CSSPropertyColor2() {
    _classCallCheck(this, CSSPropertyColor2);
    this.parser = parseColor;
    this.mixer = mergeColors;
  }
  return _createClass(CSSPropertyColor2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return parsed.value === "none" ? noneColor : transparentColor;
      }
      return parsed;
    }
  }]);
}();
var CSSPropertyFilter = function() {
  function CSSPropertyFilter2() {
    _classCallCheck(this, CSSPropertyFilter2);
  }
  return _createClass(CSSPropertyFilter2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    }
  }]);
}();
function getFontSize(object) {
  var _ref = object.parsedStyle, fontSize = _ref.fontSize;
  return isNil(fontSize) ? null : fontSize;
}
var CSSPropertyLengthOrPercentage = function() {
  function CSSPropertyLengthOrPercentage2() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyLengthOrPercentage2, [{
    key: "calculator",
    value: (
      /**
       * according to parent's bounds
       *
       * @example
       * CSS.percent(50) -> CSS.px(0.5 * parent.width)
       */
      function calculator(name2, oldParsed, computed, object, runtime2) {
        if (isNumber(computed)) {
          return computed;
        }
        if (CSSUnitValue.isRelativeUnit(computed.unit)) {
          if (computed.unit === UnitType.kPercentage) {
            return 0;
          }
          if (computed.unit === UnitType.kEms) {
            if (object.parentNode) {
              var fontSize = getFontSize(object.parentNode);
              if (fontSize) {
                fontSize *= computed.value;
                return fontSize;
              }
            }
            return 0;
          }
          if (computed.unit === UnitType.kRems) {
            var _object$ownerDocument;
            if (object !== null && object !== void 0 && (_object$ownerDocument = object.ownerDocument) !== null && _object$ownerDocument !== void 0 && _object$ownerDocument.documentElement) {
              var _fontSize = getFontSize(object.ownerDocument.documentElement);
              if (_fontSize) {
                _fontSize *= computed.value;
                return _fontSize;
              }
            }
            return 0;
          }
        } else {
          return computed.value;
        }
      }
    )
  }]);
}();
var CSSPropertyLengthOrPercentage12 = function() {
  function CSSPropertyLengthOrPercentage122() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage122);
    this.mixer = mergeNumberLists;
  }
  return _createClass(CSSPropertyLengthOrPercentage122, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.map(function(c6) {
        return c6.value;
      });
    }
  }]);
}();
var CSSPropertyLengthOrPercentage14 = function() {
  function CSSPropertyLengthOrPercentage142() {
    _classCallCheck(this, CSSPropertyLengthOrPercentage142);
    this.mixer = mergeNumberLists;
  }
  return _createClass(CSSPropertyLengthOrPercentage142, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.map(function(c6) {
        return c6.value;
      });
    }
  }]);
}();
var CSSPropertyMarker = function() {
  function CSSPropertyMarker2() {
    _classCallCheck(this, CSSPropertyMarker2);
  }
  return _createClass(CSSPropertyMarker2, [{
    key: "calculator",
    value: function calculator(name2, oldMarker, newMarker, object) {
      var _newMarker;
      if (newMarker instanceof CSSKeywordValue) {
        newMarker = null;
      }
      var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
      if (cloned) {
        cloned.style.isMarker = true;
      }
      return cloned;
    }
  }]);
}();
var CSSPropertyNumber = function() {
  function CSSPropertyNumber2() {
    _classCallCheck(this, CSSPropertyNumber2);
    this.mixer = mergeNumbers;
  }
  return _createClass(CSSPropertyNumber2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.value;
    }
  }]);
}();
var CSSPropertyOffsetDistance = function() {
  function CSSPropertyOffsetDistance2() {
    _classCallCheck(this, CSSPropertyOffsetDistance2);
    this.mixer = clampedMergeNumbers(0, 1);
  }
  return _createClass(CSSPropertyOffsetDistance2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.value;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
      if (!offsetPath) {
        return;
      }
      var nodeName = offsetPath.nodeName;
      if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
        var point7 = offsetPath.getPoint(offsetDistance);
        if (point7) {
          object.setLocalPosition(point7.x, point7.y);
        }
      }
    }
  }]);
}();
var CSSPropertyOpacity = function() {
  function CSSPropertyOpacity2() {
    _classCallCheck(this, CSSPropertyOpacity2);
    this.mixer = clampedMergeNumbers(0, 1);
  }
  return _createClass(CSSPropertyOpacity2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed) {
      return computed.value;
    }
  }]);
}();
var CSSPropertyPath = function() {
  function CSSPropertyPath2() {
    _classCallCheck(this, CSSPropertyPath2);
    this.parser = parsePath;
    this.mixer = mergePaths;
  }
  return _createClass(CSSPropertyPath2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed) {
      if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
        return {
          absolutePath: [],
          hasArc: false,
          segments: [],
          polygons: [],
          polylines: [],
          curve: null,
          totalLength: 0,
          rect: new Rectangle(0, 0, 0, 0)
        };
      }
      return parsed;
    }
  }]);
}();
var CSSPropertyPoints = _createClass(function CSSPropertyPoints2() {
  _classCallCheck(this, CSSPropertyPoints2);
  this.mixer = mergePoints;
});
var CSSPropertyShadowBlur = function(_CSSPropertyLengthOrP) {
  function CSSPropertyShadowBlur2() {
    var _this2;
    _classCallCheck(this, CSSPropertyShadowBlur2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, CSSPropertyShadowBlur2, [].concat(args));
    _this2.mixer = clampedMergeNumbers(0, Infinity);
    return _this2;
  }
  _inherits(CSSPropertyShadowBlur2, _CSSPropertyLengthOrP);
  return _createClass(CSSPropertyShadowBlur2);
}(CSSPropertyLengthOrPercentage);
var CSSPropertyText = function() {
  function CSSPropertyText2() {
    _classCallCheck(this, CSSPropertyText2);
  }
  return _createClass(CSSPropertyText2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        if (parsed.value === "unset") {
          return "";
        }
        return parsed.value;
      }
      return "".concat(parsed);
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      object.nodeValue = "".concat(object.parsedStyle.text) || "";
    }
  }]);
}();
var CSSPropertyTextTransform = function() {
  function CSSPropertyTextTransform2() {
    _classCallCheck(this, CSSPropertyTextTransform2);
  }
  return _createClass(CSSPropertyTextTransform2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      var rawText = object.getAttribute("text");
      if (rawText) {
        var transformedText = rawText;
        if (parsed.value === "capitalize") {
          transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
        } else if (parsed.value === "lowercase") {
          transformedText = rawText.toLowerCase();
        } else if (parsed.value === "uppercase") {
          transformedText = rawText.toUpperCase();
        }
        object.parsedStyle.text = transformedText;
      }
      return parsed.value;
    }
  }]);
}();
var CANVAS_Map = /* @__PURE__ */ new WeakMap();
function cleanExistedCanvas(container, canvas, cleanUp) {
  if (container) {
    var $dom = typeof container === "string" ? document.getElementById(container) : container;
    if (CANVAS_Map.has($dom)) CANVAS_Map.get($dom).destroy(cleanUp);
    CANVAS_Map.set($dom, canvas);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isElement2(target) {
  return !!target.getAttribute;
}
function sortedIndex(array2, value2) {
  var low = 0;
  var high = array2.length;
  while (low < high) {
    var mid2 = low + high >>> 1;
    if (sortByZIndex(array2[mid2], value2) < 0) {
      low = mid2 + 1;
    } else {
      high = mid2;
    }
  }
  return low;
}
function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.parsedStyle.zIndex || 0);
  var zIndex2 = Number(o2.parsedStyle.zIndex || 0);
  if (zIndex1 === zIndex2) {
    var parent = o1.parentNode;
    if (parent) {
      var children = parent.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }
  return zIndex1 - zIndex2;
}
function findClosestClipPathTarget(object) {
  var el = object;
  do {
    var _el$parsedStyle;
    var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;
    if (clipPath) return el;
    el = el.parentElement;
  } while (el !== null);
  return null;
}
var PX_SUFFIX = "px";
function setDOMSize($el, width, height) {
  if (isBrowser && $el.style) {
    $el.style.width = width + PX_SUFFIX;
    $el.style.height = height + PX_SUFFIX;
  }
}
function getStyle($el, property) {
  if (isBrowser) {
    return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
  }
}
function getWidth($el) {
  var width = getStyle($el, "width");
  if (width === "auto") {
    return $el.offsetWidth;
  }
  return parseFloat(width);
}
function getHeight($el) {
  var height = getStyle($el, "height");
  if (height === "auto") {
    return $el.offsetHeight;
  }
  return parseFloat(height);
}
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var clock = typeof performance === "object" && performance.now ? performance : Date;
function isInFragment(node) {
  if (node.nodeName === Shape.FRAGMENT) return true;
  return node.getRootNode().nodeName === Shape.FRAGMENT;
}
function isFillOrStrokeAffected() {
  var pointerEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "auto";
  var fill = arguments.length > 1 ? arguments[1] : void 0;
  var stroke2 = arguments.length > 2 ? arguments[2] : void 0;
  var hasFill = false;
  var hasStroke = false;
  var isFillOtherThanNone = !!fill && !fill.isNone;
  var isStrokeOtherThanNone = !!stroke2 && !stroke2.isNone;
  if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
    hasFill = isFillOtherThanNone;
    hasStroke = isStrokeOtherThanNone;
  } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
    hasFill = true;
  } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
    hasStroke = true;
  } else if (pointerEvents === "visible" || pointerEvents === "all") {
    hasFill = true;
    hasStroke = true;
  }
  return [hasFill, hasStroke];
}
var uId = 1;
var uniqueId = function uniqueId2() {
  return uId++;
};
var root = (
  // eslint-disable-next-line no-nested-ternary
  typeof self === "object" && self.self === self ? self : (
    // @ts-ignore
    typeof global === "object" && global.global === global ? (
      // @ts-ignore
      global
    ) : {}
  )
);
var nowOffset = Date.now();
var pnow = function pnow2() {
  if (root.performance && typeof root.performance.now === "function") {
    return root.performance.now();
  }
  return Date.now() - nowOffset;
};
var reservedCBs = {};
var lastTime = Date.now();
var polyfillRaf = function polyfillRaf2(callback) {
  if (typeof callback !== "function") {
    throw new TypeError("".concat(callback, " is not a function"));
  }
  var currentTime = Date.now();
  var gap = currentTime - lastTime;
  var delay = gap > 16 ? 0 : 16 - gap;
  var id4 = uniqueId();
  reservedCBs[id4] = callback;
  if (Object.keys(reservedCBs).length > 1) return id4;
  setTimeout(function() {
    lastTime = currentTime;
    var copied = reservedCBs;
    reservedCBs = {};
    Object.keys(copied).forEach(function(key) {
      return copied[key](pnow());
    });
  }, delay);
  return id4;
};
var polyfillCaf = function polyfillCaf2(id4) {
  delete reservedCBs[id4];
};
var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
var getRequestAnimationFrame = function getRequestAnimationFrame2(vp2) {
  if (typeof vp2 !== "string") return polyfillRaf;
  if (vp2 === "") return root.requestAnimationFrame;
  return root["".concat(vp2, "RequestAnimationFrame")];
};
var getCancelAnimationFrame = function getCancelAnimationFrame2(vp2) {
  if (typeof vp2 !== "string") return polyfillCaf;
  if (vp2 === "") return root.cancelAnimationFrame;
  return root["".concat(vp2, "CancelAnimationFrame")] || root["".concat(vp2, "CancelRequestAnimationFrame")];
};
var find2 = function find3(arr, predicate) {
  var i2 = 0;
  while (arr[i2] !== void 0) {
    if (predicate(arr[i2])) return arr[i2];
    i2 += 1;
  }
};
var vp = find2(vendorPrefixes, function(vp2) {
  return !!getRequestAnimationFrame(vp2);
});
var raf = getRequestAnimationFrame(vp);
var caf = getCancelAnimationFrame(vp);
root.requestAnimationFrame = raf;
root.cancelAnimationFrame = caf;
var AsyncParallelHook = function() {
  function AsyncParallelHook2() {
    _classCallCheck(this, AsyncParallelHook2);
    this.callbacks = [];
  }
  return _createClass(AsyncParallelHook2, [{
    key: "getCallbacksNum",
    value: function getCallbacksNum() {
      return this.callbacks.length;
    }
  }, {
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "promise",
    value: function promise() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return Promise.all(this.callbacks.map(function(callback) {
        return callback.apply(void 0, args);
      }));
    }
  }]);
}();
var AsyncSeriesWaterfallHook = function() {
  function AsyncSeriesWaterfallHook2() {
    _classCallCheck(this, AsyncSeriesWaterfallHook2);
    this.callbacks = [];
  }
  return _createClass(AsyncSeriesWaterfallHook2, [{
    key: "tapPromise",
    value: function tapPromise(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "promise",
    value: function() {
      var _promise = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
        var _this$callbacks, result, i2, callback, _args = arguments;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.callbacks.length) {
                _context.next = 6;
                break;
              }
              _context.next = 1;
              return (_this$callbacks = this.callbacks)[0].apply(_this$callbacks, _args);
            case 1:
              result = _context.sent;
              i2 = 0;
            case 2:
              if (!(i2 < this.callbacks.length - 1)) {
                _context.next = 5;
                break;
              }
              callback = this.callbacks[i2];
              _context.next = 3;
              return callback(result);
            case 3:
              result = _context.sent;
            case 4:
              i2++;
              _context.next = 2;
              break;
            case 5:
              return _context.abrupt("return", result);
            case 6:
              return _context.abrupt("return", null);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function promise() {
        return _promise.apply(this, arguments);
      }
      return promise;
    }()
  }]);
}();
var SyncHook = function() {
  function SyncHook2() {
    _classCallCheck(this, SyncHook2);
    this.callbacks = [];
  }
  return _createClass(SyncHook2, [{
    key: "tap",
    value: function tap(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "call",
    value: function call() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argsArr = arguments;
      this.callbacks.forEach(function(callback) {
        callback.apply(void 0, argsArr);
      });
    }
  }]);
}();
var SyncWaterfallHook = function() {
  function SyncWaterfallHook2() {
    _classCallCheck(this, SyncWaterfallHook2);
    this.callbacks = [];
  }
  return _createClass(SyncWaterfallHook2, [{
    key: "tap",
    value: function tap(options, fn) {
      this.callbacks.push(fn);
    }
  }, {
    key: "call",
    value: function call() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (this.callbacks.length) {
        var argsArr = arguments;
        var result = this.callbacks[0].apply(void 0, argsArr);
        for (var i2 = 0; i2 < this.callbacks.length - 1; i2++) {
          var callback = this.callbacks[i2];
          result = callback(result);
        }
        return result;
      }
      return null;
    }
  }]);
}();
var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
var stringRegExp = /([\"\'])[^\'\"]+\1/;
function getFontAttr(attributes) {
  var _attributes$fontSize = attributes.fontSize, fontSize = _attributes$fontSize === void 0 ? 16 : _attributes$fontSize, _attributes$fontFamil = attributes.fontFamily, fontFamily = _attributes$fontFamil === void 0 ? "sans-serif" : _attributes$fontFamil, _attributes$fontStyle = attributes.fontStyle, fontStyle = _attributes$fontStyle === void 0 ? "normal" : _attributes$fontStyle, _attributes$fontVaria = attributes.fontVariant, fontVariant = _attributes$fontVaria === void 0 ? "normal" : _attributes$fontVaria, _attributes$fontWeigh = attributes.fontWeight, fontWeight = _attributes$fontWeigh === void 0 ? "normal" : _attributes$fontWeigh;
  return {
    fontSize,
    fontFamily,
    fontStyle,
    fontVariant,
    fontWeight
  };
}
var toFontString = memoize2(function toFontStringRaw(attributes) {
  var _getFontAttr = getFontAttr(attributes), fontSize = _getFontAttr.fontSize, fontFamily = _getFontAttr.fontFamily, fontStyle = _getFontAttr.fontStyle, fontVariant = _getFontAttr.fontVariant, fontWeight = _getFontAttr.fontWeight;
  var fontSizeString = isNumber(fontSize) && "".concat(fontSize, "px") || "16px";
  var fontFamilies = fontFamily.split(",");
  for (var i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
    var _fontFamily = fontFamilies[i2].trim();
    if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
      _fontFamily = '"'.concat(_fontFamily, '"');
    }
    fontFamilies[i2] = _fontFamily;
  }
  return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
}, function(attributes) {
  var _getFontAttr2 = getFontAttr(attributes), fontSize = _getFontAttr2.fontSize, fontFamily = _getFontAttr2.fontFamily, fontStyle = _getFontAttr2.fontStyle, fontVariant = _getFontAttr2.fontVariant, fontWeight = _getFontAttr2.fontWeight;
  return "".concat(fontStyle, "_").concat(fontVariant, "_").concat(fontWeight, "_").concat(fontSize, "_").concat(fontFamily);
});
var MIN_SCALE = 1e-6;
var clampScale = function clampScale2(item) {
  return Math.max(item, MIN_SCALE);
};
function createSkewMatrix(skewMatrix, skewX2, skewY2) {
  mat4_exports.identity(skewMatrix);
  skewMatrix[4] = Math.tan(skewX2);
  skewMatrix[1] = Math.tan(skewY2);
  return skewMatrix;
}
var $mat4_1 = mat4_exports.create();
var $mat4_2 = mat4_exports.create();
var parser = {
  scale: function scale7(d4) {
    mat4_exports.fromScaling($mat4_1, [d4[0].value, d4[1].value, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleX: function scaleX(d4) {
    mat4_exports.fromScaling($mat4_1, [d4[0].value, 1, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleY: function scaleY(d4) {
    mat4_exports.fromScaling($mat4_1, [1, d4[0].value, 1].map(function(item) {
      return clampScale(item);
    }));
  },
  scaleZ: function scaleZ(d4) {
    mat4_exports.fromScaling($mat4_1, [1, 1, d4[0].value].map(function(item) {
      return clampScale(item);
    }));
  },
  scale3d: function scale3d(d4) {
    mat4_exports.fromScaling($mat4_1, [d4[0].value, d4[1].value, d4[2].value].map(function(item) {
      return clampScale(item);
    }));
  },
  translate: function translate3(d4) {
    mat4_exports.fromTranslation($mat4_1, [d4[0].value, d4[1].value, 0]);
  },
  translateX: function translateX(d4) {
    mat4_exports.fromTranslation($mat4_1, [d4[0].value, 0, 0]);
  },
  translateY: function translateY(d4) {
    mat4_exports.fromTranslation($mat4_1, [0, d4[0].value, 0]);
  },
  translateZ: function translateZ(d4) {
    mat4_exports.fromTranslation($mat4_1, [0, 0, d4[0].value]);
  },
  translate3d: function translate3d(d4) {
    mat4_exports.fromTranslation($mat4_1, [d4[0].value, d4[1].value, d4[2].value]);
  },
  rotate: function rotate4(d4) {
    mat4_exports.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d4[0])));
  },
  rotateX: function rotateX4(d4) {
    mat4_exports.fromXRotation($mat4_1, deg2rad(convertAngleUnit(d4[0])));
  },
  rotateY: function rotateY4(d4) {
    mat4_exports.fromYRotation($mat4_1, deg2rad(convertAngleUnit(d4[0])));
  },
  rotateZ: function rotateZ4(d4) {
    mat4_exports.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d4[0])));
  },
  rotate3d: function rotate3d(d4) {
    mat4_exports.fromRotation($mat4_1, deg2rad(convertAngleUnit(d4[3])), [d4[0].value, d4[1].value, d4[2].value]);
  },
  skew: function skew(d4) {
    createSkewMatrix($mat4_1, deg2rad(d4[0].value), deg2rad(d4[1].value));
  },
  skewX: function skewX(d4) {
    createSkewMatrix($mat4_1, deg2rad(d4[0].value), 0);
  },
  skewY: function skewY(d4) {
    createSkewMatrix($mat4_1, 0, deg2rad(d4[0].value));
  },
  matrix: function matrix(d4) {
    mat4_exports.set($mat4_1, d4[0].value, d4[1].value, 0, 0, d4[2].value, d4[3].value, 0, 0, 0, 0, 1, 0, d4[4].value, d4[5].value, 0, 1);
  },
  matrix3d: function matrix3d(d4) {
    mat4_exports.set.apply(mat4_exports, [$mat4_1].concat(_toConsumableArray(d4.map(function(s4) {
      return s4.value;
    }))));
  }
};
var $vec3One$1 = vec3_exports.fromValues(1, 1, 1);
var $vec3Zero$1 = vec3_exports.create();
var optimizer = {
  translate: function translate4(object, d4) {
    runtime.sceneGraphService.setLocalScale(object, $vec3One$1, false);
    runtime.sceneGraphService.setLocalEulerAngles(object, $vec3Zero$1, void 0, void 0, false);
    runtime.sceneGraphService.setLocalPosition(object, [d4[0].value, d4[1].value, 0], false);
    runtime.sceneGraphService.dirtyLocalTransform(object, object.transformable);
  }
};
function parsedTransformToMat4(transform2, object) {
  if (transform2.length) {
    if (transform2.length === 1 && optimizer[transform2[0].t]) {
      optimizer[transform2[0].t](object, transform2[0].d);
      return;
    }
    var m3 = mat4_exports.identity($mat4_2);
    for (var i2 = 0; i2 < transform2.length; i2++) {
      var _transform$i = transform2[i2], t = _transform$i.t, d4 = _transform$i.d;
      var p3 = parser[t];
      if (p3) {
        p3(d4);
        mat4_exports.mul(m3, m3, $mat4_1);
      }
    }
    object.setLocalTransform(m3);
  } else {
    object.resetLocalTransform();
  }
  return object.getLocalTransform();
}
var CSSPropertyTransform = function() {
  function CSSPropertyTransform2() {
    _classCallCheck(this, CSSPropertyTransform2);
    this.parser = parseTransformUnmemoize;
    this.mixer = mergeTransforms;
  }
  return _createClass(CSSPropertyTransform2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      parsedTransformToMat4(object.parsedStyle.transform, object);
    }
  }]);
}();
var CSSPropertyTransformOrigin = function() {
  function CSSPropertyTransformOrigin2() {
    _classCallCheck(this, CSSPropertyTransformOrigin2);
  }
  return _createClass(CSSPropertyTransformOrigin2, [{
    key: "postProcessor",
    value: function postProcessor(object) {
      var transformOrigin = object.parsedStyle.transformOrigin;
      if (transformOrigin[0].unit === UnitType.kPixels && transformOrigin[1].unit === UnitType.kPixels) {
        object.setOrigin(transformOrigin[0].value, transformOrigin[1].value);
      } else {
        object.getGeometryBounds();
      }
    }
  }]);
}();
var CSSPropertyZIndex = function() {
  function CSSPropertyZIndex2() {
    _classCallCheck(this, CSSPropertyZIndex2);
  }
  return _createClass(CSSPropertyZIndex2, [{
    key: "calculator",
    value: function calculator(name2, oldParsed, computed, object) {
      return computed.value;
    }
  }, {
    key: "postProcessor",
    value: function postProcessor(object) {
      if (object.parentNode) {
        var parentEntity = object.parentNode;
        var parentRenderable = parentEntity.renderable;
        var parentSortable = parentEntity.sortable;
        if (parentRenderable) {
          parentEntity.dirty();
        }
        if (parentSortable) {
          parentSortable.dirty = true;
          parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
        }
      }
    }
  }]);
}();
var CircleUpdater = function() {
  function CircleUpdater2() {
    _classCallCheck(this, CircleUpdater2);
  }
  return _createClass(CircleUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$r = parsedStyle.r, r2 = _parsedStyle$r === void 0 ? 0 : _parsedStyle$r;
      return {
        cx,
        cy,
        hwidth: r2,
        hheight: r2
      };
    }
  }]);
}();
var EllipseUpdater = function() {
  function EllipseUpdater2() {
    _classCallCheck(this, EllipseUpdater2);
  }
  return _createClass(EllipseUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$rx = parsedStyle.rx, rx = _parsedStyle$rx === void 0 ? 0 : _parsedStyle$rx, _parsedStyle$ry = parsedStyle.ry, ry = _parsedStyle$ry === void 0 ? 0 : _parsedStyle$ry;
      return {
        cx,
        cy,
        hwidth: rx,
        hheight: ry
      };
    }
  }]);
}();
var LineUpdater = function() {
  function LineUpdater2() {
    _classCallCheck(this, LineUpdater2);
  }
  return _createClass(LineUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2;
      var minX = Math.min(x12, x22);
      var maxX = Math.max(x12, x22);
      var minY = Math.min(y12, y22);
      var maxY2 = Math.max(y12, y22);
      var width = maxX - minX;
      var height = maxY2 - minY;
      var hwidth = width / 2;
      var hheight = height / 2;
      return {
        cx: minX + hwidth,
        cy: minY + hheight,
        hwidth,
        hheight
      };
    }
  }]);
}();
var PathUpdater = function() {
  function PathUpdater2() {
    _classCallCheck(this, PathUpdater2);
  }
  return _createClass(PathUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      var d4 = parsedStyle.d;
      var _d$rect = d4.rect, x3 = _d$rect.x, y4 = _d$rect.y, width = _d$rect.width, height = _d$rect.height;
      var hwidth = width / 2;
      var hheight = height / 2;
      return {
        cx: x3 + hwidth,
        cy: y4 + hheight,
        hwidth,
        hheight
      };
    }
  }]);
}();
var PolylineUpdater = function() {
  function PolylineUpdater2() {
    _classCallCheck(this, PolylineUpdater2);
  }
  return _createClass(PolylineUpdater2, [{
    key: "update",
    value: function update2(parsedStyle) {
      if (parsedStyle.points && isArray(parsedStyle.points.points)) {
        var points = parsedStyle.points.points;
        var minX = Math.min.apply(Math, _toConsumableArray(points.map(function(point7) {
          return point7[0];
        })));
        var maxX = Math.max.apply(Math, _toConsumableArray(points.map(function(point7) {
          return point7[0];
        })));
        var minY = Math.min.apply(Math, _toConsumableArray(points.map(function(point7) {
          return point7[1];
        })));
        var maxY2 = Math.max.apply(Math, _toConsumableArray(points.map(function(point7) {
          return point7[1];
        })));
        var width = maxX - minX;
        var height = maxY2 - minY;
        var hwidth = width / 2;
        var hheight = height / 2;
        return {
          cx: minX + hwidth,
          cy: minY + hheight,
          hwidth,
          hheight
        };
      }
      return {
        cx: 0,
        cy: 0,
        hwidth: 0,
        hheight: 0
      };
    }
  }]);
}();
var RectUpdater = function() {
  function RectUpdater2() {
    _classCallCheck(this, RectUpdater2);
  }
  return _createClass(RectUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y4 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, src = parsedStyle.src, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      var contentWidth = width;
      var contentHeight = height;
      if (src && !isString(src)) {
        if (!contentWidth) {
          contentWidth = src.width;
          parsedStyle.width = contentWidth;
        }
        if (!contentHeight) {
          contentHeight = src.height;
          parsedStyle.height = contentHeight;
        }
      }
      return {
        cx: x3 + contentWidth / 2,
        cy: y4 + contentHeight / 2,
        hwidth: contentWidth / 2,
        hheight: contentHeight / 2
      };
    }
  }]);
}();
var TextUpdater = function() {
  function TextUpdater2(globalRuntime) {
    _classCallCheck(this, TextUpdater2);
    this.globalRuntime = globalRuntime;
  }
  return _createClass(TextUpdater2, [{
    key: "isReadyToMeasure",
    value: function isReadyToMeasure(parsedStyle, object) {
      var text = parsedStyle.text;
      return text;
    }
  }, {
    key: "update",
    value: function update2(parsedStyle, object) {
      var _object$ownerDocument;
      var text = parsedStyle.text, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$dx = parsedStyle.dx, dx = _parsedStyle$dx === void 0 ? 0 : _parsedStyle$dx, _parsedStyle$dy = parsedStyle.dy, dy = _parsedStyle$dy === void 0 ? 0 : _parsedStyle$dy, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y4 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y;
      if (!this.isReadyToMeasure(parsedStyle, object)) {
        parsedStyle.metrics = {
          font: "",
          width: 0,
          height: 0,
          lines: [],
          lineWidths: [],
          lineHeight: 0,
          maxLineWidth: 0,
          fontProperties: {
            ascent: 0,
            descent: 0,
            fontSize: 0
          },
          lineMetrics: []
        };
        return {
          hwidth: 0,
          hheight: 0,
          cx: 0,
          cy: 0
        };
      }
      var _ref = (object === null || object === void 0 || (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
      var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
      parsedStyle.metrics = metrics;
      var width = metrics.width, height = metrics.height;
      var hwidth = width / 2;
      var hheight = height / 2;
      var lineXOffset = x3 + hwidth;
      if (textAlign === "center" || textAlign === "middle") {
        lineXOffset += lineWidth / 2 - hwidth;
      } else if (textAlign === "right" || textAlign === "end") {
        lineXOffset += lineWidth - hwidth * 2;
      }
      var lineYOffset = y4 - hheight;
      if (textBaseline === "middle") {
        lineYOffset += hheight;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        lineYOffset += hheight * 2;
      } else if (textBaseline === "alphabetic") ;
      else if (textBaseline === "bottom" || textBaseline === "ideographic") {
        lineYOffset += 0;
      }
      if (dx) {
        lineXOffset += dx;
      }
      if (dy) {
        lineYOffset += dy;
      }
      return {
        cx: lineXOffset,
        cy: lineYOffset,
        hwidth,
        hheight
      };
    }
  }]);
}();
var GroupUpdater = function() {
  function GroupUpdater2() {
    _classCallCheck(this, GroupUpdater2);
  }
  return _createClass(GroupUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      return {
        cx: 0,
        cy: 0,
        hwidth: 0,
        hheight: 0
      };
    }
  }]);
}();
var HTMLUpdater = function() {
  function HTMLUpdater2() {
    _classCallCheck(this, HTMLUpdater2);
  }
  return _createClass(HTMLUpdater2, [{
    key: "update",
    value: function update2(parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y4 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      return {
        cx: x3 + width / 2,
        cy: y4 + height / 2,
        hwidth: width / 2,
        hheight: height / 2
      };
    }
  }]);
}();
var FederatedEvent = function() {
  function FederatedEvent2(manager) {
    _classCallCheck(this, FederatedEvent2);
    this.eventPhase = FederatedEvent2.prototype.NONE;
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new Point2();
    this.page = new Point2();
    this.canvas = new Point2();
    this.viewport = new Point2();
    this.composed = false;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  return _createClass(FederatedEvent2, [{
    key: "name",
    get: (
      /**
       * The type of event, supports the following:
       * * pointerdown
       * * touchstart
       * * mousedown
       * * rightdown
       * * ...
       */
      /**
       * @deprecated
       */
      function get4() {
        return this.type;
      }
    )
  }, {
    key: "layerX",
    get: function get4() {
      return this.layer.x;
    }
  }, {
    key: "layerY",
    get: function get4() {
      return this.layer.y;
    }
  }, {
    key: "pageX",
    get: function get4() {
      return this.page.x;
    }
  }, {
    key: "pageY",
    get: function get4() {
      return this.page.y;
    }
  }, {
    key: "x",
    get: function get4() {
      return this.canvas.x;
    }
  }, {
    key: "y",
    get: function get4() {
      return this.canvas.y;
    }
  }, {
    key: "canvasX",
    get: function get4() {
      return this.canvas.x;
    }
  }, {
    key: "canvasY",
    get: function get4() {
      return this.canvas.y;
    }
  }, {
    key: "viewportX",
    get: function get4() {
      return this.viewport.x;
    }
  }, {
    key: "viewportY",
    get: function get4() {
      return this.viewport.y;
    }
  }, {
    key: "composedPath",
    value: (
      /**
       * The propagation path for this event
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
       *
       * So composedPath()[0] represents the original target.
       * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
       */
      function composedPath() {
        if (this.manager && (!this.path || this.path[0] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
    )
    /**
     * @deprecated
     */
  }, {
    key: "propagationPath",
    get: function get4() {
      return this.composedPath();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
     */
  }, {
    key: "preventDefault",
    value: function preventDefault() {
      if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
        this.nativeEvent.preventDefault();
      }
      this.defaultPrevented = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
     */
  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
     */
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
     */
  }, {
    key: "initEvent",
    value: (
      /**
       * added for compatibility with DOM Event,
       * deprecated props and methods
       */
      function initEvent() {
      }
    )
  }, {
    key: "initUIEvent",
    value: function initUIEvent() {
    }
  }, {
    key: "clone",
    value: function clone8() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}();
var FederatedMouseEvent = function(_ref) {
  function FederatedMouseEvent2() {
    var _this2;
    _classCallCheck(this, FederatedMouseEvent2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, FederatedMouseEvent2, [].concat(args));
    _this2.client = new Point2();
    _this2.movement = new Point2();
    _this2.offset = new Point2();
    _this2.global = new Point2();
    _this2.screen = new Point2();
    return _this2;
  }
  _inherits(FederatedMouseEvent2, _ref);
  return _createClass(FederatedMouseEvent2, [{
    key: "clientX",
    get: function get4() {
      return this.client.x;
    }
  }, {
    key: "clientY",
    get: function get4() {
      return this.client.y;
    }
  }, {
    key: "movementX",
    get: function get4() {
      return this.movement.x;
    }
  }, {
    key: "movementY",
    get: function get4() {
      return this.movement.y;
    }
  }, {
    key: "offsetX",
    get: function get4() {
      return this.offset.x;
    }
  }, {
    key: "offsetY",
    get: function get4() {
      return this.offset.y;
    }
  }, {
    key: "globalX",
    get: function get4() {
      return this.global.x;
    }
  }, {
    key: "globalY",
    get: function get4() {
      return this.global.y;
    }
  }, {
    key: "screenX",
    get: function get4() {
      return this.screen.x;
    }
  }, {
    key: "screenY",
    get: function get4() {
      return this.screen.y;
    }
  }, {
    key: "getModifierState",
    value: function getModifierState(key) {
      return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
  }, {
    key: "initMouseEvent",
    value: function initMouseEvent() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}(FederatedEvent);
var FederatedPointerEvent = function(_FederatedMouseEvent) {
  function FederatedPointerEvent2() {
    var _this2;
    _classCallCheck(this, FederatedPointerEvent2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, FederatedPointerEvent2, [].concat(args));
    _this2.width = 0;
    _this2.height = 0;
    _this2.isPrimary = false;
    return _this2;
  }
  _inherits(FederatedPointerEvent2, _FederatedMouseEvent);
  return _createClass(FederatedPointerEvent2, [{
    key: "getCoalescedEvents",
    value: (
      /**
       * The type of pointer that triggered the event.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
       */
      /**
       * Pressure applied by the pointing device during the event.
       *s
       * A Touch's force property will be represented by this value.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
       */
      /**
       * Barrel pressure on a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
       */
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
       */
      /**
       * Twist of a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
       */
      function getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
    )
    /**
     * @see https://chromestatus.com/feature/5765569655603200
     */
  }, {
    key: "getPredictedEvents",
    value: function getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
    /**
     * @see https://github.com/antvis/G/issues/1115
     * We currently reuses event objects in the event system,
     * avoiding the creation of a large number of event objects.
     * Reused objects are only used to carry different data,
     * such as coordinate information, native event objects,
     * and therefore the lifecycle is limited to the event handler,
     * which can lead to unintended consequences if an attempt is made to cache the entire event object.
     *
     * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
     */
  }, {
    key: "clone",
    value: function clone8() {
      return this.manager.clonePointerEvent(this);
    }
  }]);
}(FederatedMouseEvent);
var FederatedWheelEvent = function(_FederatedMouseEvent) {
  function FederatedWheelEvent2() {
    _classCallCheck(this, FederatedWheelEvent2);
    return _callSuper(this, FederatedWheelEvent2, arguments);
  }
  _inherits(FederatedWheelEvent2, _FederatedMouseEvent);
  return _createClass(FederatedWheelEvent2, [{
    key: "clone",
    value: (
      /**
       * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
       * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
       */
      /** Horizontal scroll amount */
      /** Vertical scroll amount */
      /** z-axis scroll amount. */
      function clone8() {
        return this.manager.cloneWheelEvent(this);
      }
    )
  }]);
}(FederatedMouseEvent);
var CustomEvent = function(_FederatedEvent) {
  function CustomEvent2(eventName, object) {
    var _this2;
    _classCallCheck(this, CustomEvent2);
    _this2 = _callSuper(this, CustomEvent2, [null]);
    _this2.type = eventName;
    _this2.detail = object;
    Object.assign(_this2, object);
    return _this2;
  }
  _inherits(CustomEvent2, _FederatedEvent);
  return _createClass(CustomEvent2);
}(FederatedEvent);
var EventTarget = function() {
  function EventTarget2() {
    _classCallCheck(this, EventTarget2);
    this.emitter = new eventemitter3_default();
  }
  return _createClass(EventTarget2, [{
    key: "on",
    value: (
      /**
       * @deprecated
       * @alias addEventListener
       */
      function on(type, listener, options) {
        this.addEventListener(type, listener, options);
        return this;
      }
    )
    /**
     * support `capture` & `once` in options
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
     */
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      var capture = false;
      var once = false;
      if (is_boolean_default(options)) capture = options;
      else if (options) {
        var _options$capture = options.capture;
        capture = _options$capture === void 0 ? false : _options$capture;
        var _options$once = options.once;
        once = _options$once === void 0 ? false : _options$once;
      }
      if (capture) type += "capture";
      listener = isFunction(listener) ? listener : listener.handleEvent;
      var context = isFunction(listener) ? void 0 : listener;
      if (once) this.emitter.once(type, listener, context);
      else this.emitter.on(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias removeEventListener
     */
  }, {
    key: "off",
    value: function off(type, listener, options) {
      if (type) {
        this.removeEventListener(type, listener, options);
      } else {
        this.removeAllEventListeners();
      }
      return this;
    }
  }, {
    key: "removeAllEventListeners",
    value: function removeAllEventListeners() {
      var _this$emitter;
      (_this$emitter = this.emitter) === null || _this$emitter === void 0 || _this$emitter.removeAllListeners();
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      var _listener;
      if (!this.emitter) return this;
      var capture = is_boolean_default(options) ? options : options === null || options === void 0 ? void 0 : options.capture;
      if (capture) type += "capture";
      listener = isFunction(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
      var context = isFunction(listener) ? void 0 : listener;
      this.emitter.off(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias dispatchEvent
     */
  }, {
    key: "emit",
    value: function emit(eventName, object) {
      this.dispatchEvent(new CustomEvent(eventName, object));
    }
  }, {
    key: "dispatchEventToSelf",
    value: function dispatchEventToSelf(e3) {
      e3.target || (e3.target = this);
      e3.currentTarget = this;
      this.emitter.emit(e3.type, e3);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(e3) {
      var skipPropagate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var dispatchToSelf = arguments.length > 2 ? arguments[2] : void 0;
      if (dispatchToSelf) {
        this.dispatchEventToSelf(e3);
        return true;
      }
      var canvas;
      if (this.document) {
        canvas = this;
      } else if (this.defaultView) {
        canvas = this.defaultView;
      } else {
        var _ownerDocument;
        canvas = (_ownerDocument = this.ownerDocument) === null || _ownerDocument === void 0 ? void 0 : _ownerDocument.defaultView;
      }
      if (canvas) {
        e3.manager = canvas.getEventService();
        if (!e3.manager) return false;
        e3.defaultPrevented = false;
        if (e3.path) {
          e3.path.length = 0;
        } else {
          e3.page = [];
        }
        if (!skipPropagate) {
          e3.target = this;
        }
        e3.manager.dispatchEvent(e3, e3.type, skipPropagate);
      } else {
        this.dispatchEventToSelf(e3);
      }
      return !e3.defaultPrevented;
    }
  }]);
}();
var Node = function(_EventTarget) {
  function Node5() {
    var _this2;
    _classCallCheck(this, Node5);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Node5, [].concat(args));
    _this2.shadow = false;
    _this2.ownerDocument = null;
    _this2.isConnected = false;
    _this2.baseURI = "";
    _this2.childNodes = [];
    _this2.nodeType = 0;
    _this2.nodeName = "";
    _this2.nodeValue = null;
    _this2.parentNode = null;
    _this2.destroyed = false;
    return _this2;
  }
  _inherits(Node5, _EventTarget);
  return _createClass(Node5, [{
    key: "textContent",
    get: (
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
       */
      function get4() {
        var out = "";
        if (this.nodeName === Shape.TEXT) {
          out += this.style.text;
        }
        var _iterator = _createForOfIteratorHelper(this.childNodes), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _child = _step.value;
            if (_child.nodeName === Shape.TEXT) {
              out += _child.nodeValue;
            } else {
              out += _child.textContent;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return out;
      }
    ),
    set: function set10(content) {
      var _this2 = this;
      this.childNodes.slice().forEach(function(child) {
        _this2.removeChild(child);
      });
      if (this.nodeName === Shape.TEXT) {
        this.style.text = "".concat(content);
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
     */
  }, {
    key: "getRootNode",
    value: function getRootNode() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this.parentNode) {
        return this.parentNode.getRootNode(opts);
      }
      if (opts.composed && this.host) {
        return this.host.getRootNode(opts);
      }
      return this;
    }
  }, {
    key: "hasChildNodes",
    value: function hasChildNodes() {
      return this.childNodes.length > 0;
    }
  }, {
    key: "isDefaultNamespace",
    value: function isDefaultNamespace(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "lookupNamespaceURI",
    value: function lookupNamespaceURI(prefix) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "lookupPrefix",
    value: function lookupPrefix(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "normalize",
    value: function normalize10() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
     */
  }, {
    key: "isEqualNode",
    value: function isEqualNode(otherNode) {
      return this === otherNode;
    }
  }, {
    key: "isSameNode",
    value: function isSameNode(otherNode) {
      return this.isEqualNode(otherNode);
    }
  }, {
    key: "parent",
    get: (
      /**
       * @deprecated
       * @alias parentNode
       */
      function get4() {
        return this.parentNode;
      }
    )
  }, {
    key: "parentElement",
    get: function get4() {
      return null;
    }
  }, {
    key: "nextSibling",
    get: function get4() {
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get4() {
      return null;
    }
  }, {
    key: "firstChild",
    get: function get4() {
      return this.childNodes.length > 0 ? this.childNodes[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get4() {
      return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
     * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
     */
  }, {
    key: "compareDocumentPosition",
    value: function compareDocumentPosition(other) {
      if (other === this) {
        return 0;
      }
      var node1Root = other;
      var node2Root = this;
      var node1Hierarchy = [node1Root];
      var node2Hierarchy = [node2Root];
      while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
        var _node1Root$parentNode;
        node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
        node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
      }
      if (node1Root !== node2Root) {
        return Node5.DOCUMENT_POSITION_DISCONNECTED | Node5.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node5.DOCUMENT_POSITION_PRECEDING;
      }
      var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
      var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
      if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
        return longerHierarchy === node1Hierarchy ? (
          // other is a child of this
          Node5.DOCUMENT_POSITION_CONTAINED_BY | Node5.DOCUMENT_POSITION_FOLLOWING
        ) : (
          // this is a child of other
          Node5.DOCUMENT_POSITION_CONTAINS | Node5.DOCUMENT_POSITION_PRECEDING
        );
      }
      var longerStart = longerHierarchy.length - shorterHierarchy.length;
      for (var i2 = shorterHierarchy.length - 1; i2 >= 0; i2--) {
        var shorterHierarchyNode = shorterHierarchy[i2];
        var longerHierarchyNode = longerHierarchy[longerStart + i2];
        if (longerHierarchyNode !== shorterHierarchyNode) {
          var siblings = shorterHierarchyNode.parentNode.childNodes;
          if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
            if (shorterHierarchy === node1Hierarchy) {
              return Node5.DOCUMENT_POSITION_PRECEDING;
            }
            return Node5.DOCUMENT_POSITION_FOLLOWING;
          }
          if (longerHierarchy === node1Hierarchy) {
            return Node5.DOCUMENT_POSITION_PRECEDING;
          }
          return Node5.DOCUMENT_POSITION_FOLLOWING;
        }
      }
      return Node5.DOCUMENT_POSITION_FOLLOWING;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
     */
  }, {
    key: "contain",
    value: (
      /**
       * @deprecated
       * @alias contains
       */
      function contain2(other) {
        return this.contains(other);
      }
    )
  }, {
    key: "contains",
    value: function contains(other) {
      var tmp2 = other;
      while (tmp2 && this !== tmp2) {
        tmp2 = tmp2.parentNode;
      }
      return !!tmp2;
    }
  }, {
    key: "getAncestor",
    value: function getAncestor(n2) {
      var temp = this;
      while (n2 > 0 && temp) {
        temp = temp.parentNode;
        n2--;
      }
      return temp;
    }
  }, {
    key: "forEach",
    value: function forEach4(callback) {
      var stack = [this];
      while (stack.length > 0) {
        var node = stack.pop();
        var result = callback(node);
        if (result === false) {
          break;
        }
        for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
          stack.push(node.childNodes[i2]);
        }
      }
    }
  }], [{
    key: "isNode",
    value: function isNode(target) {
      return !!target.childNodes;
    }
  }]);
}(EventTarget);
Node.DOCUMENT_POSITION_DISCONNECTED = 1;
Node.DOCUMENT_POSITION_PRECEDING = 2;
Node.DOCUMENT_POSITION_FOLLOWING = 4;
Node.DOCUMENT_POSITION_CONTAINS = 8;
Node.DOCUMENT_POSITION_CONTAINED_BY = 16;
Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
var PROPAGATION_LIMIT = 2048;
var EventService = function() {
  function EventService2(globalRuntime, context) {
    var _this2 = this;
    _classCallCheck(this, EventService2);
    this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
    this.cursor = "default";
    this.mappingTable = {};
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this.tmpMatrix = mat4_exports.create();
    this.tmpVec3 = vec3_exports.create();
    this.onPointerDown = function(from) {
      var e3 = _this2.createPointerEvent(from);
      _this2.dispatchEvent(e3, "pointerdown");
      if (e3.pointerType === "touch") {
        _this2.dispatchEvent(e3, "touchstart");
      } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
        var isRightButton = e3.button === 2;
        _this2.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
      }
      var trackingData = _this2.trackingData(from.pointerId);
      trackingData.pressTargetsByButton[from.button] = e3.composedPath();
      _this2.freeEvent(e3);
    };
    this.onPointerUp = function(from) {
      var now2 = clock.now();
      var e3 = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      _this2.dispatchEvent(e3, "pointerup");
      if (e3.pointerType === "touch") {
        _this2.dispatchEvent(e3, "touchend");
      } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
        var isRightButton = e3.button === 2;
        _this2.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
      }
      var trackingData = _this2.trackingData(from.pointerId);
      var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      var clickTarget = pressTarget;
      if (pressTarget && !e3.composedPath().includes(pressTarget)) {
        var currentTarget = pressTarget;
        while (currentTarget && !e3.composedPath().includes(currentTarget)) {
          e3.currentTarget = currentTarget;
          _this2.notifyTarget(e3, "pointerupoutside");
          if (e3.pointerType === "touch") {
            _this2.notifyTarget(e3, "touchendoutside");
          } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
            var _isRightButton = e3.button === 2;
            _this2.notifyTarget(e3, _isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          if (Node.isNode(currentTarget)) {
            currentTarget = currentTarget.parentNode;
          }
        }
        delete trackingData.pressTargetsByButton[from.button];
        clickTarget = currentTarget;
      }
      if (clickTarget) {
        var _e$detail;
        var clickEvent = _this2.clonePointerEvent(e3, "click");
        clickEvent.target = clickTarget;
        clickEvent.path = [];
        if (!trackingData.clicksByButton[from.button]) {
          trackingData.clicksByButton[from.button] = {
            clickCount: 0,
            target: clickEvent.target,
            timeStamp: now2
          };
        }
        var canvas = _this2.context.renderingContext.root.ownerDocument.defaultView;
        var clickHistory = trackingData.clicksByButton[from.button];
        if (clickHistory.target === clickEvent.target && now2 - clickHistory.timeStamp < canvas.getConfig().dblClickSpeed) {
          ++clickHistory.clickCount;
        } else {
          clickHistory.clickCount = 1;
        }
        clickHistory.target = clickEvent.target;
        clickHistory.timeStamp = now2;
        clickEvent.detail = clickHistory.clickCount;
        if (!((_e$detail = e3.detail) !== null && _e$detail !== void 0 && _e$detail.preventClick)) {
          if (!_this2.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
            _this2.dispatchEvent(clickEvent, "click");
          }
          _this2.dispatchEvent(clickEvent, "pointertap");
        }
        _this2.freeEvent(clickEvent);
      }
      _this2.freeEvent(e3);
    };
    this.onPointerMove = function(from) {
      var e3 = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      var isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
      var trackingData = _this2.trackingData(from.pointerId);
      var outTarget = _this2.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget !== e3.target) {
        var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
        var outEvent = _this2.createPointerEvent(from, outType, outTarget || void 0);
        _this2.dispatchEvent(outEvent, "pointerout");
        if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
        if (!e3.composedPath().includes(outTarget)) {
          var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
            leaveEvent.currentTarget = leaveEvent.target;
            _this2.notifyTarget(leaveEvent);
            if (isMouse) {
              _this2.notifyTarget(leaveEvent, "mouseleave");
            }
            if (Node.isNode(leaveEvent.target)) {
              leaveEvent.target = leaveEvent.target.parentNode;
            }
          }
          _this2.freeEvent(leaveEvent);
        }
        _this2.freeEvent(outEvent);
      }
      if (outTarget !== e3.target) {
        var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
        var overEvent = _this2.clonePointerEvent(e3, overType);
        _this2.dispatchEvent(overEvent, "pointerover");
        if (isMouse) _this2.dispatchEvent(overEvent, "mouseover");
        var overTargetAncestor = outTarget && Node.isNode(outTarget) && outTarget.parentNode;
        while (overTargetAncestor && overTargetAncestor !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          if (overTargetAncestor === e3.target) break;
          overTargetAncestor = overTargetAncestor.parentNode;
        }
        var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
        if (didPointerEnter) {
          var enterEvent = _this2.clonePointerEvent(e3, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
            enterEvent.currentTarget = enterEvent.target;
            _this2.notifyTarget(enterEvent);
            if (isMouse) _this2.notifyTarget(enterEvent, "mouseenter");
            if (Node.isNode(enterEvent.target)) {
              enterEvent.target = enterEvent.target.parentNode;
            }
          }
          _this2.freeEvent(enterEvent);
        }
        _this2.freeEvent(overEvent);
      }
      _this2.dispatchEvent(e3, "pointermove");
      if (e3.pointerType === "touch") _this2.dispatchEvent(e3, "touchmove");
      if (isMouse) {
        _this2.dispatchEvent(e3, "mousemove");
        _this2.cursor = _this2.getCursor(e3.target);
      }
      trackingData.overTargets = e3.composedPath();
      _this2.freeEvent(e3);
    };
    this.onPointerOut = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
        var outTarget = _this2.findMountedTarget(trackingData.overTargets);
        var outEvent = _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
        _this2.dispatchEvent(outEvent);
        if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
        var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && leaveEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          leaveEvent.currentTarget = leaveEvent.target;
          _this2.notifyTarget(leaveEvent);
          if (isMouse) {
            _this2.notifyTarget(leaveEvent, "mouseleave");
          }
          if (Node.isNode(leaveEvent.target)) {
            leaveEvent.target = leaveEvent.target.parentNode;
          }
        }
        trackingData.overTargets = null;
        _this2.freeEvent(outEvent);
        _this2.freeEvent(leaveEvent);
      }
      _this2.cursor = null;
    };
    this.onPointerOver = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      var e3 = _this2.createPointerEvent(from);
      var isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
      _this2.dispatchEvent(e3, "pointerover");
      if (isMouse) _this2.dispatchEvent(e3, "mouseover");
      if (e3.pointerType === "mouse") _this2.cursor = _this2.getCursor(e3.target);
      var enterEvent = _this2.clonePointerEvent(e3, "pointerenter");
      enterEvent.eventPhase = enterEvent.AT_TARGET;
      while (enterEvent.target && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
        enterEvent.currentTarget = enterEvent.target;
        _this2.notifyTarget(enterEvent);
        if (isMouse) {
          _this2.notifyTarget(enterEvent, "mouseenter");
        }
        if (Node.isNode(enterEvent.target)) {
          enterEvent.target = enterEvent.target.parentNode;
        }
      }
      trackingData.overTargets = e3.composedPath();
      _this2.freeEvent(e3);
      _this2.freeEvent(enterEvent);
    };
    this.onPointerUpOutside = function(from) {
      var trackingData = _this2.trackingData(from.pointerId);
      var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      var e3 = _this2.createPointerEvent(from);
      if (pressTarget) {
        var currentTarget = pressTarget;
        while (currentTarget) {
          e3.currentTarget = currentTarget;
          _this2.notifyTarget(e3, "pointerupoutside");
          if (e3.pointerType === "touch") ;
          else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
            _this2.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
          }
          if (Node.isNode(currentTarget)) {
            currentTarget = currentTarget.parentNode;
          }
        }
        delete trackingData.pressTargetsByButton[from.button];
      }
      _this2.freeEvent(e3);
    };
    this.onWheel = function(from) {
      var wheelEvent = _this2.createWheelEvent(from);
      _this2.dispatchEvent(wheelEvent);
      _this2.freeEvent(wheelEvent);
    };
    this.onClick = function(from) {
      if (_this2.context.config.useNativeClickEvent) {
        var e3 = _this2.createPointerEvent(from);
        _this2.dispatchEvent(e3);
        _this2.freeEvent(e3);
      }
    };
    this.onPointerCancel = function(from) {
      var e3 = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
      _this2.dispatchEvent(e3);
      _this2.freeEvent(e3);
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  return _createClass(EventService2, [{
    key: "init",
    value: function init() {
      this.rootTarget = this.context.renderingContext.root.parentNode;
      this.addEventMapping("pointerdown", this.onPointerDown);
      this.addEventMapping("pointerup", this.onPointerUp);
      this.addEventMapping("pointermove", this.onPointerMove);
      this.addEventMapping("pointerout", this.onPointerOut);
      this.addEventMapping("pointerleave", this.onPointerOut);
      this.addEventMapping("pointercancel", this.onPointerCancel);
      this.addEventMapping("pointerover", this.onPointerOver);
      this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
      this.addEventMapping("wheel", this.onWheel);
      this.addEventMapping("click", this.onClick);
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.mappingTable = {};
      this.mappingState = {};
      this.eventPool.clear();
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var bbox = this.context.contextService.getBoundingClientRect();
      var scaleX2 = 1;
      var scaleY2 = 1;
      var $el = this.context.contextService.getDomElement();
      if ($el && bbox) {
        var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;
        if (offsetWidth && offsetHeight) {
          scaleX2 = bbox.width / offsetWidth;
          scaleY2 = bbox.height / offsetHeight;
        }
      }
      return {
        scaleX: scaleX2,
        scaleY: scaleY2,
        bbox
      };
    }
    /**
     * Should account for CSS Transform applied on container.
     * @see https://github.com/antvis/G/issues/1161
     * @see https://github.com/antvis/G/issues/1677
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
     */
  }, {
    key: "client2Viewport",
    value: function client2Viewport(client) {
      var _this$getScale = this.getScale(), scaleX2 = _this$getScale.scaleX, scaleY2 = _this$getScale.scaleY, bbox = _this$getScale.bbox;
      return new Point2((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX2, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY2);
    }
  }, {
    key: "viewport2Client",
    value: function viewport2Client(canvas) {
      var _this$getScale2 = this.getScale(), scaleX2 = _this$getScale2.scaleX, scaleY2 = _this$getScale2.scaleY, bbox = _this$getScale2.bbox;
      return new Point2((canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX2, (canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY2);
    }
  }, {
    key: "viewport2Canvas",
    value: function viewport2Canvas(_ref) {
      var x3 = _ref.x, y4 = _ref.y;
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var _this$context$config = this.context.config, width = _this$context$config.width, height = _this$context$config.height;
      var projectionMatrixInverse = camera.getPerspectiveInverse();
      var worldMatrix = camera.getWorldTransform();
      var vpMatrix = mat4_exports.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
      var viewport = vec3_exports.set(this.tmpVec3, x3 / width * 2 - 1, (1 - y4 / height) * 2 - 1, 0);
      vec3_exports.transformMat4(viewport, viewport, vpMatrix);
      return new Point2(viewport[0], viewport[1]);
    }
  }, {
    key: "canvas2Viewport",
    value: function canvas2Viewport(canvasP) {
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var projectionMatrix = camera.getPerspective();
      var viewMatrix = camera.getViewTransform();
      var vpMatrix = mat4_exports.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
      var clip = vec3_exports.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
      vec3_exports.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
      var _this$context$config2 = this.context.config, width = _this$context$config2.width, height = _this$context$config2.height;
      return new Point2((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
    }
  }, {
    key: "setPickHandler",
    value: function setPickHandler(pickHandler) {
      this.pickHandler = pickHandler;
    }
  }, {
    key: "addEventMapping",
    value: function addEventMapping(type, fn) {
      if (!this.mappingTable[type]) {
        this.mappingTable[type] = [];
      }
      this.mappingTable[type].push({
        fn,
        priority: 0
      });
      this.mappingTable[type].sort(function(a5, b) {
        return a5.priority - b.priority;
      });
    }
  }, {
    key: "mapEvent",
    value: function mapEvent(e3) {
      if (!this.rootTarget) {
        return;
      }
      var mappers = this.mappingTable[e3.type];
      if (mappers) {
        for (var i2 = 0, j = mappers.length; i2 < j; i2++) {
          mappers[i2].fn(e3);
        }
      } else {
        console.warn("[EventService]: Event mapping not defined for ".concat(e3.type));
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(e3, type, skipPropagate) {
      if (!skipPropagate) {
        e3.propagationStopped = false;
        e3.propagationImmediatelyStopped = false;
        this.propagate(e3, type);
      } else {
        e3.eventPhase = e3.AT_TARGET;
        var canvas = this.rootTarget.defaultView || null;
        e3.currentTarget = canvas;
        this.notifyListeners(e3, type);
      }
    }
  }, {
    key: "propagate",
    value: function propagate(e3, type) {
      if (!e3.target) {
        return;
      }
      var composedPath = e3.composedPath();
      e3.eventPhase = e3.CAPTURING_PHASE;
      for (var i2 = composedPath.length - 1; i2 >= 1; i2--) {
        e3.currentTarget = composedPath[i2];
        this.notifyTarget(e3, type);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
      }
      e3.eventPhase = e3.AT_TARGET;
      e3.currentTarget = e3.target;
      this.notifyTarget(e3, type);
      if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
      var index3 = composedPath.indexOf(e3.currentTarget);
      e3.eventPhase = e3.BUBBLING_PHASE;
      for (var _i = index3 + 1; _i < composedPath.length; _i++) {
        e3.currentTarget = composedPath[_i];
        this.notifyTarget(e3, type);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
      }
    }
  }, {
    key: "propagationPath",
    value: function propagationPath(target) {
      var propagationPath2 = [target];
      var canvas = this.rootTarget.defaultView || null;
      if (canvas && canvas === target) {
        propagationPath2.unshift(canvas.document);
        return propagationPath2;
      }
      for (var i2 = 0; i2 < PROPAGATION_LIMIT && target !== this.rootTarget; i2++) {
        if (Node.isNode(target) && target.parentNode) {
          propagationPath2.push(target.parentNode);
          target = target.parentNode;
        }
      }
      if (canvas) {
        propagationPath2.push(canvas);
      }
      return propagationPath2;
    }
  }, {
    key: "hitTest",
    value: function hitTest(position) {
      var viewportX = position.viewportX, viewportY = position.viewportY;
      var _this$context$config3 = this.context.config, width = _this$context$config3.width, height = _this$context$config3.height, disableHitTesting = _this$context$config3.disableHitTesting;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      return !disableHitTesting && this.pickHandler(position) || this.rootTarget || // return Document
      null;
    }
    /**
     * whether the native event trigger came from Canvas,
     * should account for HTML shape
     */
  }, {
    key: "isNativeEventFromCanvas",
    value: function isNativeEventFromCanvas($el, nativeEvent) {
      var _target;
      var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;
      if ((_target = target) !== null && _target !== void 0 && _target.shadowRoot) {
        target = nativeEvent.composedPath()[0];
      }
      if (target) {
        if (target === $el) {
          return true;
        }
        if ($el && $el.contains) {
          return $el.contains(target);
        }
      }
      if (nativeEvent !== null && nativeEvent !== void 0 && nativeEvent.composedPath) {
        return nativeEvent.composedPath().indexOf($el) > -1;
      }
      return false;
    }
    /**
     * Find HTML from composed path in native UI event.
     */
  }, {
    key: "getExistedHTML",
    value: function getExistedHTML(event) {
      if (event.nativeEvent.composedPath) {
        for (var _i2 = 0, _arr = event.nativeEvent.composedPath(); _i2 < _arr.length; _i2++) {
          var eventTarget = _arr[_i2];
          var existed = this.nativeHTMLMap.get(eventTarget);
          if (existed) {
            return existed;
          }
        }
      }
      return null;
    }
  }, {
    key: "pickTarget",
    value: function pickTarget(event) {
      return this.hitTest({
        clientX: event.clientX,
        clientY: event.clientY,
        viewportX: event.viewportX,
        viewportY: event.viewportY,
        x: event.canvasX,
        y: event.canvasY
      });
    }
  }, {
    key: "createPointerEvent",
    value: function createPointerEvent(from, type, target, fallbackTarget) {
      var event = this.allocateEvent(FederatedPointerEvent);
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      var $el = this.context.contextService.getDomElement();
      event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;
      if (typeof type === "string") {
        event.type = type;
      }
      return event;
    }
  }, {
    key: "createWheelEvent",
    value: function createWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      var $el = this.context.contextService.getDomElement();
      event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);
      return event;
    }
  }, {
    key: "trackingData",
    value: function trackingData(id4) {
      if (!this.mappingState.trackingData[id4]) {
        this.mappingState.trackingData[id4] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        };
      }
      return this.mappingState.trackingData[id4];
    }
  }, {
    key: "cloneWheelEvent",
    value: function cloneWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = from.type;
      return event;
    }
  }, {
    key: "clonePointerEvent",
    value: function clonePointerEvent(from, type) {
      var event = this.allocateEvent(FederatedPointerEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = type !== null && type !== void 0 ? type : event.type;
      return event;
    }
  }, {
    key: "copyPointerData",
    value: function copyPointerData(from, to) {
      to.pointerId = from.pointerId;
      to.width = from.width;
      to.height = from.height;
      to.isPrimary = from.isPrimary;
      to.pointerType = from.pointerType;
      to.pressure = from.pressure;
      to.tangentialPressure = from.tangentialPressure;
      to.tiltX = from.tiltX;
      to.tiltY = from.tiltY;
      to.twist = from.twist;
    }
  }, {
    key: "copyMouseData",
    value: function copyMouseData(from, to) {
      to.altKey = from.altKey;
      to.button = from.button;
      to.buttons = from.buttons;
      to.ctrlKey = from.ctrlKey;
      to.metaKey = from.metaKey;
      to.shiftKey = from.shiftKey;
      to.client.copyFrom(from.client);
      to.movement.copyFrom(from.movement);
      to.canvas.copyFrom(from.canvas);
      to.screen.copyFrom(from.screen);
      to.global.copyFrom(from.global);
      to.offset.copyFrom(from.offset);
    }
  }, {
    key: "copyWheelData",
    value: function copyWheelData(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    }
  }, {
    key: "copyData",
    value: function copyData2(from, to) {
      to.isTrusted = from.isTrusted;
      to.timeStamp = clock.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.page.copyFrom(from.page);
      to.viewport.copyFrom(from.viewport);
    }
  }, {
    key: "allocateEvent",
    value: function allocateEvent(constructor) {
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      var event = this.eventPool.get(constructor).pop() || new constructor(this);
      event.eventPhase = event.NONE;
      event.currentTarget = null;
      event.path = [];
      event.target = null;
      return event;
    }
  }, {
    key: "freeEvent",
    value: function freeEvent(event) {
      if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
      var constructor = event.constructor;
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      this.eventPool.get(constructor).push(event);
    }
  }, {
    key: "notifyTarget",
    value: function notifyTarget(e3, type) {
      type = type !== null && type !== void 0 ? type : e3.type;
      var key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? "".concat(type, "capture") : type;
      this.notifyListeners(e3, key);
      if (e3.eventPhase === e3.AT_TARGET) {
        this.notifyListeners(e3, type);
      }
    }
  }, {
    key: "notifyListeners",
    value: function notifyListeners(e3, type) {
      var emitter = e3.currentTarget.emitter;
      var listeners = emitter._events[type];
      if (!listeners) return;
      if ("fn" in listeners) {
        if (listeners.once) {
          emitter.removeListener(type, listeners.fn, void 0, true);
        }
        listeners.fn.call(e3.currentTarget || listeners.context, e3);
      } else {
        for (var i2 = 0; i2 < listeners.length && !e3.propagationImmediatelyStopped; i2++) {
          if (listeners[i2].once) {
            emitter.removeListener(type, listeners[i2].fn, void 0, true);
          }
          listeners[i2].fn.call(e3.currentTarget || listeners[i2].context, e3);
        }
      }
    }
    /**
     * some detached nodes may exist in propagation path, need to skip them
     */
  }, {
    key: "findMountedTarget",
    value: function findMountedTarget(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      var currentTarget = propagationPath[propagationPath.length - 1];
      for (var i2 = propagationPath.length - 2; i2 >= 0; i2--) {
        var target = propagationPath[i2];
        if (target === this.rootTarget || Node.isNode(target) && target.parentNode === currentTarget) {
          currentTarget = propagationPath[i2];
        } else {
          break;
        }
      }
      return currentTarget;
    }
  }, {
    key: "getCursor",
    value: function getCursor(target) {
      var tmp2 = target;
      while (tmp2) {
        var cursor = isElement2(tmp2) && tmp2.getAttribute("cursor");
        if (cursor) {
          return cursor;
        }
        tmp2 = Node.isNode(tmp2) && tmp2.parentNode;
      }
    }
  }]);
}();
var OffscreenCanvasCreator = function() {
  function OffscreenCanvasCreator2() {
    _classCallCheck(this, OffscreenCanvasCreator2);
  }
  return _createClass(OffscreenCanvasCreator2, [{
    key: "getOrCreateCanvas",
    value: function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
      if (this.canvas) {
        return this.canvas;
      }
      if (offscreenCanvas || runtime.offscreenCanvas) {
        this.canvas = offscreenCanvas || runtime.offscreenCanvas;
        this.context = this.canvas.getContext("2d", _objectSpread2({
          willReadFrequently: true
        }, contextAttributes));
      } else {
        try {
          this.canvas = new window.OffscreenCanvas(0, 0);
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
          if (!this.context || !this.context.measureText) {
            this.canvas = document.createElement("canvas");
            this.context = this.canvas.getContext("2d");
          }
        } catch (_unused) {
          this.canvas = document.createElement("canvas");
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
        }
      }
      this.canvas.width = 10;
      this.canvas.height = 10;
      return this.canvas;
    }
  }, {
    key: "getOrCreateContext",
    value: function getOrCreateContext(offscreenCanvas, contextAttributes) {
      if (this.context) {
        return this.context;
      }
      this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
      return this.context;
    }
  }], [{
    key: "createCanvas",
    value: (
      /**
       * @returns new canvas instance
       */
      function createCanvas() {
        try {
          return new window.OffscreenCanvas(0, 0);
        } catch (_unused2) {
        }
        try {
          return document.createElement("canvas");
        } catch (_unused3) {
        }
        return null;
      }
    )
  }]);
}();
var RenderReason = function(RenderReason2) {
  RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
  RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
  RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
  return RenderReason2;
}({});
var RenderingService = function() {
  function RenderingService2(globalRuntime, context) {
    _classCallCheck(this, RenderingService2);
    this.inited = false;
    this.stats = {
      /**
       * total display objects in scenegraph
       */
      total: 0,
      /**
       * number of display objects need to render in current frame
       */
      rendered: 0
    };
    this.zIndexCounter = 0;
    this.hooks = {
      /**
       * called before any frame rendered
       */
      init: new SyncHook(),
      initAsync: new AsyncParallelHook(),
      /**
       * only dirty object which has sth changed will be rendered
       */
      dirtycheck: new SyncWaterfallHook(),
      /**
       * do culling
       */
      cull: new SyncWaterfallHook(),
      /**
       * called at beginning of each frame, won't get called if nothing to re-render
       */
      beginFrame: new SyncHook(),
      /**
       * called before every dirty object get rendered
       */
      beforeRender: new SyncHook(),
      /**
       * called when every dirty object rendering even it's culled
       */
      render: new SyncHook(),
      /**
       * called after every dirty object get rendered
       */
      afterRender: new SyncHook(),
      /**
       * commit - draw the result on the canvas
       */
      endFrame: new SyncHook(),
      destroy: new SyncHook(),
      /**
       * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
       */
      pick: new AsyncSeriesWaterfallHook(),
      /**
       * Unsafe but sync version of pick.
       */
      pickSync: new SyncWaterfallHook(),
      /**
       * used in event system
       */
      pointerDown: new SyncHook(),
      pointerUp: new SyncHook(),
      pointerMove: new SyncHook(),
      pointerOut: new SyncHook(),
      pointerOver: new SyncHook(),
      pointerWheel: new SyncHook(),
      pointerCancel: new SyncHook(),
      click: new SyncHook()
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  return _createClass(RenderingService2, [{
    key: "init",
    value: function init(callback) {
      var _this2 = this;
      var context = _objectSpread2(_objectSpread2({}, this.globalRuntime), this.context);
      this.context.renderingPlugins.forEach(function(plugin) {
        plugin.apply(context, _this2.globalRuntime);
      });
      this.hooks.init.call();
      if (this.hooks.initAsync.getCallbacksNum() === 0) {
        this.inited = true;
        callback();
      } else {
        this.hooks.initAsync.promise().then(function() {
          _this2.inited = true;
          callback();
        })["catch"](function(err) {
        });
      }
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.stats;
    }
    /**
     * Meet the following conditions:
     * * disable DirtyRectangleRendering
     * * camera changed
     */
  }, {
    key: "disableDirtyRectangleRendering",
    value: function disableDirtyRectangleRendering() {
      var renderer = this.context.config.renderer;
      var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
      return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
    }
  }, {
    key: "render",
    value: function render3(canvasConfig, frame2, rerenderCallback) {
      var _this2 = this;
      this.stats.total = 0;
      this.stats.rendered = 0;
      this.zIndexCounter = 0;
      var renderingContext = this.context.renderingContext;
      this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
      this.globalRuntime.sceneGraphService.triggerPendingEvents();
      if (renderingContext.renderReasons.size && this.inited) {
        renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
        var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
        var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !onlyCameraChanged;
        if (shouldTriggerRenderHooks) {
          this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
        }
        this.hooks.beginFrame.call(frame2);
        if (shouldTriggerRenderHooks) {
          renderingContext.renderListCurrentFrame.forEach(function(object) {
            _this2.hooks.beforeRender.call(object);
            _this2.hooks.render.call(object);
            _this2.hooks.afterRender.call(object);
          });
        }
        this.hooks.endFrame.call(frame2);
        renderingContext.renderListCurrentFrame = [];
        renderingContext.renderReasons.clear();
        rerenderCallback();
      }
    }
  }, {
    key: "renderDisplayObject",
    value: function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
      var self2 = this;
      var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
      function internalRenderSingleDisplayObject(object) {
        var renderable = object.renderable, sortable = object.sortable;
        var objectChanged = enableDirtyCheck ? (
          // @ts-ignore
          renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? object : null
        ) : object;
        var objectToRender = null;
        if (objectChanged) {
          objectToRender = enableCulling ? self2.hooks.cull.call(objectChanged, self2.context.camera) : objectChanged;
          if (objectToRender) {
            self2.stats.rendered += 1;
            renderingContext.renderListCurrentFrame.push(objectToRender);
          }
        }
        object.dirty(false);
        sortable.renderOrder = self2.zIndexCounter;
        self2.zIndexCounter += 1;
        self2.stats.total += 1;
        if (sortable.dirty) {
          self2.sort(object, sortable);
          sortable.dirty = false;
          sortable.dirtyChildren = [];
          sortable.dirtyReason = void 0;
        }
      }
      var stack = [displayObject];
      while (stack.length > 0) {
        var _currentObject$sortab;
        var currentObject = stack.pop();
        internalRenderSingleDisplayObject(currentObject);
        var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
        for (var i2 = objects.length - 1; i2 >= 0; i2--) {
          stack.push(objects[i2]);
        }
      }
    }
  }, {
    key: "sort",
    value: function sort2(displayObject, sortable) {
      var _sortable$sorted, _sortable$sorted2;
      if ((sortable === null || sortable === void 0 || (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) > 0 && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
        sortable.dirtyChildren.forEach(function(child) {
          var sortIndex = sortable.sorted.indexOf(child);
          if (sortIndex > -1) {
            sortable.sorted.splice(sortIndex, 1);
          }
          var index3 = displayObject.childNodes.indexOf(child);
          if (index3 > -1) {
            if (sortable.sorted.length === 0) {
              sortable.sorted.push(child);
            } else {
              var _index = sortedIndex(sortable.sorted, child);
              sortable.sorted.splice(_index, 0, child);
            }
          }
        });
      } else {
        sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      }
      if (((_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) > 0 && displayObject.childNodes.filter(function(child) {
        return child.parsedStyle.zIndex;
      }).length === 0) {
        sortable.sorted = [];
      }
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.inited = false;
      this.hooks.destroy.call();
      this.globalRuntime.sceneGraphService.clearPendingEvents();
    }
  }, {
    key: "dirtify",
    value: function dirtify() {
      this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
    }
  }]);
}();
var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
var DefaultSceneGraphSelector = function() {
  function DefaultSceneGraphSelector2() {
    _classCallCheck(this, DefaultSceneGraphSelector2);
  }
  return _createClass(DefaultSceneGraphSelector2, [{
    key: "selectOne",
    value: function selectOne(query, root2) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root2.find(function(node) {
          return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      }
      if (query.startsWith("#")) {
        return root2.find(function(node) {
          return node.id === _this2.getIdOrClassname(query);
        });
      }
      if (query.startsWith("[")) {
        var _this$getAttribute = this.getAttribute(query), name2 = _this$getAttribute.name, value2 = _this$getAttribute.value;
        if (name2) {
          return root2.find(function(node) {
            return root2 !== node && (name2 === "name" ? node.name === value2 : _this2.attributeToString(node, name2) === value2);
          });
        }
        return null;
      }
      return root2.find(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  }, {
    key: "selectAll",
    value: function selectAll(query, root2) {
      var _this2 = this;
      if (query.startsWith(".")) {
        return root2.findAll(function(node) {
          return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      }
      if (query.startsWith("#")) {
        return root2.findAll(function(node) {
          return root2 !== node && node.id === _this2.getIdOrClassname(query);
        });
      }
      if (query.startsWith("[")) {
        var _this$getAttribute2 = this.getAttribute(query), name2 = _this$getAttribute2.name, value2 = _this$getAttribute2.value;
        if (name2) {
          return root2.findAll(function(node) {
            return root2 !== node && (name2 === "name" ? node.name === value2 : _this2.attributeToString(node, name2) === value2);
          });
        }
        return [];
      }
      return root2.findAll(function(node) {
        return root2 !== node && node.nodeName === query;
      });
    }
  }, {
    key: "is",
    value: function is(query, node) {
      if (query.startsWith(".")) {
        return node.className === this.getIdOrClassname(query);
      }
      if (query.startsWith("#")) {
        return node.id === this.getIdOrClassname(query);
      }
      if (query.startsWith("[")) {
        var _this$getAttribute3 = this.getAttribute(query), name2 = _this$getAttribute3.name, value2 = _this$getAttribute3.value;
        return name2 === "name" ? node.name === value2 : this.attributeToString(node, name2) === value2;
      }
      return node.nodeName === query;
    }
  }, {
    key: "getIdOrClassname",
    value: function getIdOrClassname(query) {
      return query.substring(1);
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(query) {
      var matches = query.match(ATTRIBUTE_REGEXP);
      var name2 = "";
      var value2 = "";
      if (matches && matches.length > 2) {
        name2 = matches[1].replace(/"/g, "");
        value2 = matches[2].replace(/"/g, "");
      }
      return {
        name: name2,
        value: value2
      };
    }
  }, {
    key: "attributeToString",
    value: function attributeToString(node, name2) {
      if (!node.getAttribute) {
        return "";
      }
      var value2 = node.getAttribute(name2);
      if (isNil(value2)) {
        return "";
      }
      if (value2.toString) {
        return value2.toString();
      }
      return "";
    }
  }]);
}();
var ElementEvent = function(ElementEvent2) {
  ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
  ElementEvent2["INSERTED"] = "DOMNodeInserted";
  ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
  ElementEvent2["REMOVED"] = "removed";
  ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
  ElementEvent2["REPARENT"] = "reparent";
  ElementEvent2["DESTROY"] = "destroy";
  ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
  ElementEvent2["CULLED"] = "culled";
  return ElementEvent2;
}({});
var MutationEvent = function(_FederatedEvent) {
  function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
    var _this2;
    _classCallCheck(this, MutationEvent2);
    _this2 = _callSuper(this, MutationEvent2, [null]);
    _this2.relatedNode = relatedNode;
    _this2.prevValue = prevValue;
    _this2.newValue = newValue;
    _this2.attrName = attrName;
    _this2.attrChange = attrChange;
    _this2.prevParsedValue = prevParsedValue;
    _this2.newParsedValue = newParsedValue;
    _this2.type = typeArg;
    return _this2;
  }
  _inherits(MutationEvent2, _FederatedEvent);
  return _createClass(MutationEvent2);
}(FederatedEvent);
MutationEvent.ADDITION = 2;
MutationEvent.MODIFICATION = 1;
MutationEvent.REMOVAL = 3;
var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
var $vec2Zero = vec2_exports.create();
var $vec3Zero = vec3_exports.create();
var $vec3One = vec3_exports.fromValues(1, 1, 1);
var $mat4Identity = mat4_exports.create();
var $vec2 = vec2_exports.create();
var $vec3$1 = vec3_exports.create();
var $mat4 = mat4_exports.create();
var $quat$1 = quat_exports.create();
var $setLocalTransform_1 = vec3_exports.create();
var $setLocalTransform_2 = quat_exports.create();
var $setLocalTransform_3 = vec3_exports.create();
var $setLocalPosition = vec3_exports.create();
var $setPosition_1 = vec3_exports.create();
var $setPosition_ParentInvertMatrix = mat4_exports.create();
var $setEulerAngles_InvParentRot = quat_exports.create();
var $rotateLocal = quat_exports.create();
var $rotate_ParentInvertRotation = quat_exports.create();
var $triggerPendingEvents_detail = {
  affectChildren: true
};
var DefaultSceneGraphService = function() {
  function DefaultSceneGraphService2(runtime2) {
    _classCallCheck(this, DefaultSceneGraphService2);
    this.pendingEvents = /* @__PURE__ */ new Map();
    this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
    this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
    this.runtime = runtime2;
  }
  return _createClass(DefaultSceneGraphService2, [{
    key: "matches",
    value: function matches(query, root2) {
      return this.runtime.sceneGraphSelector.is(query, root2);
    }
  }, {
    key: "querySelector",
    value: function querySelector(query, root2) {
      return this.runtime.sceneGraphSelector.selectOne(query, root2);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(query, root2) {
      return this.runtime.sceneGraphSelector.selectAll(query, root2);
    }
  }, {
    key: "attach",
    value: function attach(child, parent, index3) {
      var _sortable$sorted;
      var detached = false;
      if (child.parentNode) {
        detached = child.parentNode !== parent;
        this.detach(child);
      }
      var isChildFragment = child.nodeName === Shape.FRAGMENT;
      var isAttachToFragment = isInFragment(parent);
      child.parentNode = parent;
      var nodes = isChildFragment ? child.childNodes : [child];
      if (isNumber(index3)) {
        nodes.forEach(function(node) {
          parent.childNodes.splice(index3, 0, node);
          node.parentNode = parent;
        });
      } else {
        nodes.forEach(function(node) {
          parent.childNodes.push(node);
          node.parentNode = parent;
        });
      }
      var _ref = parent, sortable = _ref.sortable;
      if (sortable !== null && sortable !== void 0 && (_sortable$sorted = sortable.sorted) !== null && _sortable$sorted !== void 0 && _sortable$sorted.length || sortable.dirty || child.parsedStyle.zIndex) {
        if (sortable.dirtyChildren.indexOf(child) === -1) {
          sortable.dirtyChildren.push(child);
        }
        sortable.dirty = true;
        sortable.dirtyReason = SortReason.ADDED;
      }
      if (isAttachToFragment) return;
      if (isChildFragment) {
        this.dirtifyFragment(child);
      } else {
        var transform2 = child.transformable;
        if (transform2) {
          this.dirtyWorldTransform(child, transform2);
        }
      }
      if (detached) {
        var _parent$ownerDocument;
        var enableCancelEventPropagation = ((_parent$ownerDocument = parent.ownerDocument) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.defaultView) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.getConfig()) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.future) === null || _parent$ownerDocument === void 0 ? void 0 : _parent$ownerDocument.experimentalCancelEventPropagation) === true;
        child.dispatchEvent(reparentEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      }
    }
  }, {
    key: "detach",
    value: function detach(child) {
      var _sortable$sorted2, _style;
      if (!child.parentNode) {
        return;
      }
      var transform2 = child.transformable;
      var _ref2 = child.parentNode, sortable = _ref2.sortable;
      if (sortable !== null && sortable !== void 0 && (_sortable$sorted2 = sortable.sorted) !== null && _sortable$sorted2 !== void 0 && _sortable$sorted2.length || (_style = child.style) !== null && _style !== void 0 && _style.zIndex) {
        if (sortable.dirtyChildren.indexOf(child) === -1) {
          sortable.dirtyChildren.push(child);
        }
        sortable.dirty = true;
        sortable.dirtyReason = SortReason.REMOVED;
      }
      var index3 = child.parentNode.childNodes.indexOf(child);
      if (index3 > -1) {
        child.parentNode.childNodes.splice(index3, 1);
      }
      if (transform2) {
        this.dirtyWorldTransform(child, transform2);
      }
      child.parentNode = null;
    }
    // #region local-transform ----------------------------------------------------------------
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition(element) {
      return element.transformable.localPosition;
    }
  }, {
    key: "getLocalRotation",
    value: function getLocalRotation(element) {
      return element.transformable.localRotation;
    }
  }, {
    key: "getLocalScale",
    value: function getLocalScale(element) {
      return element.transformable.localScale;
    }
  }, {
    key: "getLocalSkew",
    value: function getLocalSkew(element) {
      return element.transformable.localSkew;
    }
  }, {
    key: "getLocalTransform",
    value: function getLocalTransform(element) {
      var transform2 = element.transformable;
      updateLocalTransform(transform2);
      return transform2.localTransform;
    }
    /**
     * move to position in local space
     */
  }, {
    key: "setLocalPosition",
    value: function setLocalPosition(element, position) {
      var _position$;
      var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var transform2 = element.transformable;
      $setLocalPosition[0] = position[0];
      $setLocalPosition[1] = position[1];
      $setLocalPosition[2] = (_position$ = position[2]) !== null && _position$ !== void 0 ? _position$ : 0;
      if (vec3_exports.equals(transform2.localPosition, $setLocalPosition)) {
        return;
      }
      vec3_exports.copy(transform2.localPosition, $setLocalPosition);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * translate in local space
     *
     * @example
     * ```
     * translateLocal(x, y, z)
     * translateLocal(vec3(x, y, z))
     * ```
     */
  }, {
    key: "translateLocal",
    value: function translateLocal(element, translation) {
      var y4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof translation === "number") {
        translation = vec3_exports.fromValues(translation, y4, z);
      }
      var transform2 = element.transformable;
      if (vec3_exports.equals(translation, $vec3Zero)) return;
      vec3_exports.transformQuat(translation, translation, transform2.localRotation);
      vec3_exports.add(transform2.localPosition, transform2.localPosition, translation);
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(element, rotation, y4, z, w2) {
      var dirtify = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
      if (typeof rotation === "number") {
        rotation = quat_exports.set($quat$1, rotation, y4, z, w2);
      }
      var transform2 = element.transformable;
      quat_exports.copy(transform2.localRotation, rotation);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * rotate in local space
     * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
     */
  }, {
    key: "rotateLocal",
    value: function rotateLocal(element, degrees4) {
      var y4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees4 === "number") {
        degrees4 = vec3_exports.fromValues(degrees4, y4, z);
      }
      var transform2 = element.transformable;
      quat_exports.fromEuler($rotateLocal, degrees4[0], degrees4[1], degrees4[2]);
      quat_exports.mul(transform2.localRotation, transform2.localRotation, $rotateLocal);
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalScale",
    value: function setLocalScale(element, scaling) {
      var _scaling$;
      var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var transform2 = element.transformable;
      vec3_exports.set($vec3$1, scaling[0], scaling[1], (_scaling$ = scaling[2]) !== null && _scaling$ !== void 0 ? _scaling$ : transform2.localScale[2]);
      if (vec3_exports.equals($vec3$1, transform2.localScale)) {
        return;
      }
      vec3_exports.copy(transform2.localScale, $vec3$1);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * scale in local space
     */
  }, {
    key: "scaleLocal",
    value: function scaleLocal(element, scaling) {
      var _scaling$2;
      var transform2 = element.transformable;
      vec3_exports.multiply(transform2.localScale, transform2.localScale, vec3_exports.set($vec3$1, scaling[0], scaling[1], (_scaling$2 = scaling[2]) !== null && _scaling$2 !== void 0 ? _scaling$2 : 1));
      this.dirtyLocalTransform(element, transform2);
    }
  }, {
    key: "setLocalSkew",
    value: function setLocalSkew(element, skew2, y4) {
      var dirtify = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (typeof skew2 === "number") {
        skew2 = vec2_exports.set($vec2, skew2, y4);
      }
      var transform2 = element.transformable;
      vec2_exports.copy(transform2.localSkew, skew2);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * set euler angles(degrees) in local space
     */
  }, {
    key: "setLocalEulerAngles",
    value: function setLocalEulerAngles(element, degrees4) {
      var y4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var dirtify = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      if (typeof degrees4 === "number") {
        degrees4 = vec3_exports.fromValues(degrees4, y4, z);
      }
      var transform2 = element.transformable;
      quat_exports.fromEuler(transform2.localRotation, degrees4[0], degrees4[1], degrees4[2]);
      if (dirtify) {
        this.dirtyLocalTransform(element, transform2);
      }
    }
  }, {
    key: "setLocalTransform",
    value: function setLocalTransform(element, transform2) {
      var t = mat4_exports.getTranslation($setLocalTransform_1, transform2);
      var r2 = mat4_exports.getRotation($setLocalTransform_2, transform2);
      var s4 = mat4_exports.getScaling($setLocalTransform_3, transform2);
      this.setLocalScale(element, s4, false);
      this.setLocalPosition(element, t, false);
      this.setLocalRotation(element, r2, void 0, void 0, void 0, false);
      this.dirtyLocalTransform(element, element.transformable);
    }
  }, {
    key: "resetLocalTransform",
    value: function resetLocalTransform(element) {
      this.setLocalScale(element, $vec3One, false);
      this.setLocalPosition(element, $vec3Zero, false);
      this.setLocalEulerAngles(element, $vec3Zero, void 0, void 0, false);
      this.setLocalSkew(element, $vec2Zero, void 0, false);
      this.dirtyLocalTransform(element, element.transformable);
    }
    // #endregion local-transform
    // #region transform ----------------------------------------------------------------
  }, {
    key: "getPosition",
    value: function getPosition(element) {
      var transform2 = element.transformable;
      return mat4_exports.getTranslation(transform2.position, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getRotation",
    value: function getRotation2(element) {
      var transform2 = element.transformable;
      return mat4_exports.getRotation(transform2.rotation, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getScale",
    value: function getScale(element) {
      var transform2 = element.transformable;
      return mat4_exports.getScaling(transform2.scaling, this.getWorldTransform(element, transform2));
    }
  }, {
    key: "getOrigin",
    value: function getOrigin2(element) {
      element.getGeometryBounds();
      return element.transformable.origin;
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform(element) {
      var transform2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : element.transformable;
      if (!transform2.localDirtyFlag && !transform2.dirtyFlag) {
        return transform2.worldTransform;
      }
      if (element.parentNode && element.parentNode.transformable) {
        this.getWorldTransform(element.parentNode);
      }
      this.internalUpdateTransform(element);
      return transform2.worldTransform;
    }
    /**
     * move to position in world space
     *
     *  g  move/moveTo
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
     */
  }, {
    key: "setPosition",
    value: function setPosition(element, position) {
      var _position$2;
      var transform2 = element.transformable;
      $setPosition_1[0] = position[0];
      $setPosition_1[1] = position[1];
      $setPosition_1[2] = (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : 0;
      if (vec3_exports.equals(this.getPosition(element), $setPosition_1)) {
        return;
      }
      vec3_exports.copy(transform2.position, $setPosition_1);
      if (element.parentNode === null || !element.parentNode.transformable) {
        vec3_exports.copy(transform2.localPosition, $setPosition_1);
      } else {
        var parentTransform = element.parentNode.transformable;
        mat4_exports.copy($setPosition_ParentInvertMatrix, parentTransform.worldTransform);
        mat4_exports.invert($setPosition_ParentInvertMatrix, $setPosition_ParentInvertMatrix);
        vec3_exports.transformMat4(transform2.localPosition, $setPosition_1, $setPosition_ParentInvertMatrix);
      }
      this.dirtyLocalTransform(element, transform2);
    }
    /**
     * translate in world space
     *
     * @example
     * ```
     * translate(x, y, z)
     * translate(vec3(x, y, z))
     * ```
     *
     *  g  translate 2D
     * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
     */
  }, {
    key: "translate",
    value: function translate6(element, translation) {
      var y4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof translation === "number") {
        translation = vec3_exports.set($vec3$1, translation, y4, z);
      }
      if (vec3_exports.equals(translation, $vec3Zero)) return;
      vec3_exports.add($vec3$1, this.getPosition(element), translation);
      this.setPosition(element, $vec3$1);
    }
  }, {
    key: "setRotation",
    value: function setRotation(element, rotation, y4, z, w2) {
      var transform2 = element.transformable;
      if (typeof rotation === "number") {
        rotation = quat_exports.fromValues(rotation, y4, z, w2);
      }
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.setLocalRotation(element, rotation);
      } else {
        var parentRot = this.getRotation(element.parentNode);
        quat_exports.copy($quat$1, parentRot);
        quat_exports.invert($quat$1, $quat$1);
        quat_exports.multiply(transform2.localRotation, $quat$1, rotation);
        quat_exports.normalize(transform2.localRotation, transform2.localRotation);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * rotate in world space
     */
  }, {
    key: "rotate",
    value: function rotate7(element, degrees4) {
      var y4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees4 === "number") {
        degrees4 = vec3_exports.fromValues(degrees4, y4, z);
      }
      var transform2 = element.transformable;
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.rotateLocal(element, degrees4);
      } else {
        var rotation = $quat$1;
        quat_exports.fromEuler(rotation, degrees4[0], degrees4[1], degrees4[2]);
        var rot = this.getRotation(element);
        var parentRot = this.getRotation(element.parentNode);
        quat_exports.copy($rotate_ParentInvertRotation, parentRot);
        quat_exports.invert($rotate_ParentInvertRotation, $rotate_ParentInvertRotation);
        quat_exports.multiply(rotation, $rotate_ParentInvertRotation, rotation);
        quat_exports.multiply(transform2.localRotation, rotation, rot);
        quat_exports.normalize(transform2.localRotation, transform2.localRotation);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    /**
     * same as pivot in Pixi.js
     *
     * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
     */
  }, {
    key: "setOrigin",
    value: function setOrigin(element, origin) {
      var y4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof origin === "number") {
        origin = [origin, y4, z];
      }
      var transform2 = element.transformable;
      if (origin[0] === transform2.origin[0] && origin[1] === transform2.origin[1] && origin[2] === transform2.origin[2]) {
        return;
      }
      var originVec = transform2.origin;
      originVec[0] = origin[0];
      originVec[1] = origin[1];
      originVec[2] = origin[2] || 0;
      this.dirtyLocalTransform(element, transform2);
    }
    /**
     * set euler angles(degrees) in world space
     */
  }, {
    key: "setEulerAngles",
    value: function setEulerAngles(element, degrees4) {
      var y4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      if (typeof degrees4 === "number") {
        degrees4 = vec3_exports.fromValues(degrees4, y4, z);
      }
      var transform2 = element.transformable;
      if (element.parentNode === null || !element.parentNode.transformable) {
        this.setLocalEulerAngles(element, degrees4);
      } else {
        quat_exports.fromEuler(transform2.localRotation, degrees4[0], degrees4[1], degrees4[2]);
        var parentRotation = this.getRotation(element.parentNode);
        quat_exports.copy($setEulerAngles_InvParentRot, quat_exports.invert($quat$1, parentRotation));
        quat_exports.mul(transform2.localRotation, transform2.localRotation, $setEulerAngles_InvParentRot);
        this.dirtyLocalTransform(element, transform2);
      }
    }
    // #endregion transform
    // #region bbox ----------------------------------------------------------------
  }, {
    key: "getTransformedGeometryBounds",
    value: function getTransformedGeometryBounds(element) {
      var render3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var existedAABB = arguments.length > 2 ? arguments[2] : void 0;
      var bounds = this.getGeometryBounds(element, render3);
      if (!AABB.isEmpty(bounds)) {
        var aabb = existedAABB || new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        return aabb;
      }
      return null;
    }
    /**
     * won't account for children
     */
  }, {
    key: "getGeometryBounds",
    value: function getGeometryBounds(element) {
      var render3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _ref3 = element, geometry = _ref3.geometry;
      if (geometry.dirty) {
        runtime.styleValueRegistry.updateGeometry(element);
      }
      var bounds = render3 ? geometry.renderBounds : geometry.contentBounds || null;
      return bounds || new AABB();
    }
    /**
     * account for children in world space
     */
  }, {
    key: "getBounds",
    value: function getBounds2(element) {
      var _this2 = this;
      var render3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _ref4 = element, renderable = _ref4.renderable;
      if (!renderable.boundsDirty && !render3 && renderable.bounds) {
        return renderable.bounds;
      }
      if (!renderable.renderBoundsDirty && render3 && renderable.renderBounds) {
        return renderable.renderBounds;
      }
      var existedAABB = render3 ? renderable.renderBounds : renderable.bounds;
      var aabb = this.getTransformedGeometryBounds(element, render3, existedAABB);
      var children = element.childNodes;
      children.forEach(function(child) {
        var childBounds = _this2.getBounds(child, render3);
        if (childBounds) {
          if (!aabb) {
            aabb = existedAABB || new AABB();
            aabb.update(childBounds.center, childBounds.halfExtents);
          } else {
            aabb.add(childBounds);
          }
        }
      });
      if (!aabb) {
        aabb = new AABB();
      }
      if (render3) {
        var clipped = findClosestClipPathTarget(element);
        if (clipped) {
          var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render3);
          if (!aabb) {
            aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);
          } else if (clipPathBounds) {
            aabb = clipPathBounds.intersection(aabb);
          }
        }
      }
      if (render3) {
        renderable.renderBounds = aabb;
        renderable.renderBoundsDirty = false;
      } else {
        renderable.bounds = aabb;
        renderable.boundsDirty = false;
      }
      return aabb;
    }
    /**
     * account for children in local space
     */
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds2(element) {
      if (element.parentNode) {
        var parentInvert = $mat4Identity;
        if (element.parentNode.transformable) {
          parentInvert = mat4_exports.invert($mat4, this.getWorldTransform(element.parentNode));
        }
        var bounds = this.getBounds(element);
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds(element);
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect(element) {
      var _element$ownerDocumen;
      var aabb;
      var bounds = this.getGeometryBounds(element);
      if (!AABB.isEmpty(bounds)) {
        aabb = new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      }
      var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 || (_element$ownerDocumen = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.getContextService().getBoundingClientRect();
      if (aabb) {
        var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left2 = _aabb$getMin2[0], top = _aabb$getMin2[1];
        var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right2 = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
        return new Rectangle(left2 + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right2 - left2, bottom - top);
      }
      return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
    }
    // #endregion bbox
    // #region other ----------------------------------------------------------------
  }, {
    key: "internalUpdateTransform",
    value: function internalUpdateTransform(element) {
      var _element$parentNode;
      var parentTransform = (_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 ? void 0 : _element$parentNode.transformable;
      updateLocalTransform(element.transformable);
      updateWorldTransform(element.transformable, parentTransform);
    }
  }, {
    key: "internalUpdateElement",
    value: function internalUpdateElement(element, ancestors) {
      var _element$ownerDocumen2, _element$transformabl, _element$renderable, _element$renderable2;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.defaultView) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.getConfig()) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.future) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.experimentalAttributeUpdateOptimization) === true;
      var parent = ancestors[ancestors.length - 1];
      var transformDirty = (parent === null || parent === void 0 ? void 0 : parent.transformDirty) || ((_element$transformabl = element.transformable) === null || _element$transformabl === void 0 ? void 0 : _element$transformabl.localDirtyFlag);
      if (element.transformable) {
        var _element$transformabl2;
        (_element$transformabl2 = element.transformable).dirtyFlag || (_element$transformabl2.dirtyFlag = transformDirty);
      }
      this.internalUpdateTransform(element);
      if (transformDirty) {
        var _element$dirty;
        (_element$dirty = element.dirty) === null || _element$dirty === void 0 || _element$dirty.call(element, true, true);
      }
      var shapeUpdated = ((_element$renderable = element.renderable) === null || _element$renderable === void 0 ? void 0 : _element$renderable.boundsDirty) || ((_element$renderable2 = element.renderable) === null || _element$renderable2 === void 0 ? void 0 : _element$renderable2.renderBoundsDirty);
      if ((transformDirty || shapeUpdated) && (parent === null || parent === void 0 ? void 0 : parent.shapeUpdated) === false && enableAttributeUpdateOptimization) {
        var tempElIndex = ancestors.length - 1;
        while (tempElIndex >= 0) {
          var _dirty, _ref5;
          var tempEl = ancestors[tempElIndex];
          if (tempEl.shapeUpdated) {
            break;
          }
          (_dirty = (_ref5 = tempEl.node).dirty) === null || _dirty === void 0 || _dirty.call(_ref5, true, true);
          tempEl.shapeUpdated = true;
          tempElIndex -= 1;
        }
      }
      return transformDirty;
    }
  }, {
    key: "syncHierarchy",
    value: function syncHierarchy(rootNode) {
      var _transformable, _transformable2;
      var stack = [rootNode];
      var ancestors = rootNode.parentNode ? [{
        node: rootNode.parentNode,
        transformDirty: ((_transformable = rootNode.parentNode.transformable) === null || _transformable === void 0 ? void 0 : _transformable.localDirtyFlag) || ((_transformable2 = rootNode.parentNode.transformable) === null || _transformable2 === void 0 ? void 0 : _transformable2.dirtyFlag),
        shapeUpdated: false
      }] : [];
      while (stack.length > 0) {
        var node = stack.pop();
        var parent = ancestors[ancestors.length - 1];
        while (ancestors.length > 0 && node.parentNode !== parent.node) {
          parent = ancestors.pop();
        }
        var transformDirty = this.internalUpdateElement(node, ancestors);
        if (node.childNodes.length > 0) {
          for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
            stack.push(node.childNodes[i2]);
          }
          ancestors.push({
            node,
            transformDirty,
            shapeUpdated: false
          });
        }
      }
    }
  }, {
    key: "dirtyLocalTransform",
    value: function dirtyLocalTransform(element, transform2) {
      if (isInFragment(element)) return;
      if (!transform2.localDirtyFlag) {
        transform2.localDirtyFlag = true;
        if (!transform2.dirtyFlag) {
          this.dirtyWorldTransform(element, transform2);
        }
      }
    }
  }, {
    key: "dirtyWorldTransform",
    value: function dirtyWorldTransform(element, transform2) {
      this.dirtifyWorldInternal(element, transform2);
      this.dirtyToRoot(element, true);
    }
  }, {
    key: "dirtifyWorldInternal",
    value: function dirtifyWorldInternal(element, transform2) {
      var _element$ownerDocumen3, _this2 = this;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen3 = element.ownerDocument) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.defaultView) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.getConfig()) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.future) === null || _element$ownerDocumen3 === void 0 ? void 0 : _element$ownerDocumen3.experimentalAttributeUpdateOptimization) === true;
      if (!transform2.dirtyFlag) {
        transform2.dirtyFlag = true;
        element.dirty(true, true);
        if (!enableAttributeUpdateOptimization) {
          element.childNodes.forEach(function(child) {
            var childTransform = child.transformable;
            _this2.dirtifyWorldInternal(child, childTransform);
          });
        }
      }
    }
  }, {
    key: "dirtyToRoot",
    value: function dirtyToRoot(element) {
      var _element$ownerDocumen4;
      var affectChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var p3 = element;
      var enableAttributeUpdateOptimization = ((_element$ownerDocumen4 = element.ownerDocument) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.defaultView) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.getConfig()) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.future) === null || _element$ownerDocumen4 === void 0 ? void 0 : _element$ownerDocumen4.experimentalAttributeUpdateOptimization) === true;
      while (p3) {
        var _dirty2, _ref6;
        (_dirty2 = (_ref6 = p3).dirty) === null || _dirty2 === void 0 || _dirty2.call(_ref6, true, true);
        if (enableAttributeUpdateOptimization) {
          break;
        } else {
          p3 = p3.parentNode;
        }
      }
      if (affectChildren) {
        element.forEach(function(e3) {
          var _e$dirty;
          (_e$dirty = e3.dirty) === null || _e$dirty === void 0 || _e$dirty.call(e3, true, true);
        });
      }
      this.informDependentDisplayObjects(element);
      this.pendingEvents.set(element, affectChildren);
    }
  }, {
    key: "dirtifyFragment",
    value: function dirtifyFragment(element) {
      var _dirty3, _ref7;
      var transform2 = element.transformable;
      if (transform2) {
        transform2.dirtyFlag = true;
        transform2.localDirtyFlag = true;
      }
      (_dirty3 = (_ref7 = element).dirty) === null || _dirty3 === void 0 || _dirty3.call(_ref7, true, true);
      var length5 = element.childNodes.length;
      for (var i2 = 0; i2 < length5; i2++) {
        this.dirtifyFragment(element.childNodes[i2]);
      }
      if (element.nodeName === Shape.FRAGMENT) {
        this.pendingEvents.set(element, false);
      }
    }
  }, {
    key: "triggerPendingEvents",
    value: function triggerPendingEvents() {
      var _this3 = this;
      var triggered = /* @__PURE__ */ new Set();
      var enableCancelEventPropagation;
      var enableAttributeUpdateOptimization;
      var trigger = function trigger2(element, detail) {
        if (!element.isConnected || triggered.has(element) || element.nodeName === Shape.FRAGMENT) {
          return;
        }
        _this3.boundsChangedEvent.detail = detail;
        _this3.boundsChangedEvent.target = element;
        if (element.isMutationObserved) {
          element.dispatchEvent(_this3.boundsChangedEvent);
        } else {
          if (enableCancelEventPropagation === void 0) {
            var _element$ownerDocumen5;
            enableCancelEventPropagation = ((_element$ownerDocumen5 = element.ownerDocument.defaultView) === null || _element$ownerDocumen5 === void 0 || (_element$ownerDocumen5 = _element$ownerDocumen5.getConfig()) === null || _element$ownerDocumen5 === void 0 || (_element$ownerDocumen5 = _element$ownerDocumen5.future) === null || _element$ownerDocumen5 === void 0 ? void 0 : _element$ownerDocumen5.experimentalCancelEventPropagation) === true;
          }
          element.ownerDocument.defaultView.dispatchEvent(_this3.boundsChangedEvent, true, enableCancelEventPropagation);
        }
        triggered.add(element);
      };
      this.pendingEvents.forEach(function(affectChildren, element) {
        if (element.nodeName === Shape.FRAGMENT) {
          return;
        }
        if (enableAttributeUpdateOptimization === void 0) {
          var _element$ownerDocumen6;
          enableAttributeUpdateOptimization = ((_element$ownerDocumen6 = element.ownerDocument) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.defaultView) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.getConfig()) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.future) === null || _element$ownerDocumen6 === void 0 ? void 0 : _element$ownerDocumen6.experimentalAttributeUpdateOptimization) === true;
        }
        $triggerPendingEvents_detail.affectChildren = affectChildren;
        if (enableAttributeUpdateOptimization) {
          trigger(element, $triggerPendingEvents_detail);
        } else {
          if (affectChildren) {
            element.forEach(function(e3) {
              trigger(e3, $triggerPendingEvents_detail);
            });
          } else {
            trigger(element, $triggerPendingEvents_detail);
          }
        }
      });
      triggered.clear();
      this.clearPendingEvents();
    }
  }, {
    key: "clearPendingEvents",
    value: function clearPendingEvents() {
      this.pendingEvents.clear();
    }
  }, {
    key: "updateDisplayObjectDependency",
    value: function updateDisplayObjectDependency(name2, oldPath, newPath, object) {
      if (oldPath && oldPath !== newPath) {
        var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
        if (oldDependencyMap && oldDependencyMap[name2]) {
          var index3 = oldDependencyMap[name2].indexOf(object);
          oldDependencyMap[name2].splice(index3, 1);
        }
      }
      if (newPath) {
        var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        if (!newDependencyMap) {
          this.displayObjectDependencyMap.set(newPath, {});
          newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        }
        if (!newDependencyMap[name2]) {
          newDependencyMap[name2] = [];
        }
        newDependencyMap[name2].push(object);
      }
    }
  }, {
    key: "informDependentDisplayObjects",
    value: function informDependentDisplayObjects(object) {
      var _object$ownerDocument, _this4 = this;
      var dependencyMap = this.displayObjectDependencyMap.get(object);
      if (!dependencyMap) {
        return;
      }
      var enableCancelEventPropagation = (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.getConfig()) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.future) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.experimentalCancelEventPropagation;
      Object.keys(dependencyMap).forEach(function(name2) {
        dependencyMap[name2].forEach(function(target) {
          _this4.dirtyToRoot(target, true);
          target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this4, _this4, name2, MutationEvent.MODIFICATION, _this4, _this4), enableCancelEventPropagation, enableCancelEventPropagation);
          if (target.isCustomElement && target.isConnected) {
            if (target.attributeChangedCallback) {
              target.attributeChangedCallback(name2, _this4, _this4);
            }
          }
        });
      });
    }
  }]);
}();
var LRU = function() {
  function LRU2(capacity) {
    _classCallCheck(this, LRU2);
    if (capacity <= 0) {
      throw new Error("LRU capacity must be a positive number.");
    }
    this.capacity = capacity;
    this.cache = /* @__PURE__ */ new Map();
  }
  return _createClass(LRU2, [{
    key: "get",
    value: function get4(key) {
      if (!this.cache.has(key)) {
        return void 0;
      }
      var value2 = this.cache.get(key);
      this.cache["delete"](key);
      this.cache.set(key, value2);
      return value2;
    }
    /**
     * Adds or updates an item in the cache. Marks the item as recently used.
     * If the cache is full, it removes the least recently used item.
     * @param key The key of the item.
     * @param value The value of the item.
     */
  }, {
    key: "put",
    value: function put(key, value2) {
      if (this.cache.has(key)) {
        this.cache["delete"](key);
      }
      this.cache.set(key, value2);
      if (this.cache.size > this.capacity) {
        var leastRecentlyUsedKey = this.cache.keys().next().value;
        this.cache["delete"](leastRecentlyUsedKey);
      }
    }
    /**
     * Returns the current number of items in the cache.
     */
  }, {
    key: "len",
    value: function len5() {
      return this.cache.size;
    }
    /**
     * Clears all items from the cache.
     */
  }, {
    key: "clear",
    value: function clear() {
      this.cache.clear();
    }
  }]);
}();
var TEXT_METRICS = {
  MetricsString: "|q",
  BaselineSymbol: "M",
  BaselineMultiplier: 1.4,
  HeightMultiplier: 2,
  Newlines: [
    10,
    // line feed
    13
    // carriage return
  ],
  BreakingSpaces: [
    9,
    // character tabulation
    32,
    // space
    8192,
    // en quad
    8193,
    // em quad
    8194,
    // en space
    8195,
    // em space
    8196,
    // three-per-em space
    8197,
    // four-per-em space
    8198,
    // six-per-em space
    8200,
    // punctuation space
    8201,
    // thin space
    8202,
    // hair space
    8287,
    // medium mathematical space
    12288
    // ideographic space
  ]
};
var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
var regexCannotStartZhCn = /[!%),.:;?\]}'""]/;
var regexCannotEndZhCn = /[$('"]/;
var regexCannotStartZhTw = /[!),.:;?\]}'""]/;
var regexCannotEndZhTw = /[([{'"]/;
var regexCannotStartJaJp = /[)\]'"?!:;,.]/;
var regexCannotEndJaJp = /[(['"...]/;
var regexCannotStartKoKr = /[!%),.:;?\]}'"]/;
var regexCannotEndKoKr = /[$([{'"#]/;
var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
var TextService = function() {
  function TextService2(runtime2) {
    var _this2 = this;
    _classCallCheck(this, TextService2);
    this.fontMetricsCache = {};
    this.shouldBreakByKinsokuShorui = function(_char, nextChar) {
      if (_this2.isBreakingSpace(nextChar)) return false;
      if (_char) {
        if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(_char)) {
          return true;
        }
      }
      return false;
    };
    this.trimByKinsokuShorui = function(prev) {
      var next = _toConsumableArray(prev);
      var prevLine = next[next.length - 2];
      if (!prevLine) {
        return prev;
      }
      var lastChar = prevLine[prevLine.length - 1];
      next[next.length - 2] = prevLine.slice(0, -1);
      next[next.length - 1] = lastChar + next[next.length - 1];
      return next;
    };
    this.runtime = runtime2;
    this.charWidthCache = new LRU(100);
  }
  return _createClass(TextService2, [{
    key: "measureFont",
    value: (
      /**
       * A global cache for character widths, keyed by font string.
       * e.g. { '16px Arial': { 'a': 8, 'b': 9 } }
       */
      /**
       * Calculates the ascent, descent and fontSize of a given font-style.
       */
      function measureFont(font, offscreenCanvas) {
        if (this.fontMetricsCache[font]) {
          return this.fontMetricsCache[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
          willReadFrequently: true
        });
        context.font = font;
        var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
        var height = TEXT_METRICS.HeightMultiplier * baseline;
        baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
        var pixels = imagedata.length;
        var line4 = width * 4;
        var i2 = 0;
        var idx = 0;
        var stop = false;
        for (i2 = 0; i2 < baseline; ++i2) {
          for (var j = 0; j < line4; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line4;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i2;
        idx = pixels - line4;
        stop = false;
        for (i2 = height; i2 > baseline; --i2) {
          for (var _j = 0; _j < line4; _j += 4) {
            if (imagedata[idx + _j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line4;
          } else {
            break;
          }
        }
        properties.descent = i2 - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        this.fontMetricsCache[font] = properties;
        return properties;
      }
    )
  }, {
    key: "measureText",
    value: function measureText2(text, parsedStyle, offscreenCanvas) {
      var _parsedStyle$fontSize = parsedStyle.fontSize, fontSize = _parsedStyle$fontSize === void 0 ? 16 : _parsedStyle$fontSize, _parsedStyle$wordWrap = parsedStyle.wordWrap, wordWrap = _parsedStyle$wordWrap === void 0 ? false : _parsedStyle$wordWrap, strokeHeight = parsedStyle.lineHeight, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, textPath = parsedStyle.textPath;
      parsedStyle.textPathSide;
      parsedStyle.textPathStartOffset;
      var _parsedStyle$leading = parsedStyle.leading, leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
      var font = toFontString(parsedStyle);
      var fontProperties = this.measureFont(font, offscreenCanvas);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = fontSize;
        fontProperties.ascent = fontSize;
      }
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      context.font = font;
      parsedStyle.isOverflowing = false;
      var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
      var lines = outputText.split(/(?:\r\n|\r|\n)/);
      var lineWidths = new Array(lines.length);
      var maxLineWidth = 0;
      if (textPath) {
        textPath.getTotalLength();
        for (var i2 = 0; i2 < lines.length; i2++) {
          context.measureText(lines[i2]).width + (lines[i2].length - 1) * letterSpacing;
        }
      } else {
        for (var _i = 0; _i < lines.length; _i++) {
          var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
          lineWidths[_i] = _lineWidth;
          maxLineWidth = Math.max(maxLineWidth, _lineWidth);
        }
        var _width = maxLineWidth + lineWidth;
        var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
        var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);
        lineHeight += leading;
        var offsetY = 0;
        if (textBaseline === "middle") {
          offsetY = -height / 2;
        } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
          offsetY = -height;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          offsetY = 0;
        }
        return {
          font,
          width: _width,
          height,
          lines,
          lineWidths,
          lineHeight,
          maxLineWidth,
          fontProperties,
          lineMetrics: lineWidths.map(function(width, i3) {
            var offsetX = 0;
            if (textAlign === "center" || textAlign === "middle") {
              offsetX -= width / 2;
            } else if (textAlign === "right" || textAlign === "end") {
              offsetX -= width;
            }
            return new Rectangle(offsetX - lineWidth / 2, offsetY + i3 * lineHeight, width + lineWidth, lineHeight);
          })
        };
      }
    }
  }, {
    key: "wordWrap",
    value: function wordWrap(text, parsedStyle, offscreenCanvas) {
      var _this2 = this;
      var chars = Array.from(text);
      if (chars.length === 0) {
        return "";
      }
      var self2 = this;
      var _parsedStyle$wordWrap2 = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap2 === void 0 ? 0 : _parsedStyle$wordWrap2, _parsedStyle$letterSp2 = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp2 === void 0 ? 0 : _parsedStyle$letterSp2, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
      var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      var maxWidth = wordWrapWidth + letterSpacing;
      var ellipsis = "";
      if (textOverflow === "ellipsis") {
        ellipsis = "...";
      } else if (textOverflow && textOverflow !== "clip") {
        ellipsis = textOverflow;
      }
      var lines = [""];
      var currentLineIndex = 0;
      var currentLineWidth = 0;
      var prevLineLastCharIndex = -1;
      var font = toFontString(parsedStyle);
      var charCache = this.charWidthCache.get(font);
      if (!charCache) {
        charCache = new LRU(500);
        this.charWidthCache.put(font, charCache);
      }
      var calcWidth = function calcWidth2(_char2) {
        return _this2.getFromCache(_char2, letterSpacing, charCache, context);
      };
      var ellipsisWidth = calcWidth(ellipsis);
      function findCharIndexClosestWidthThreshold(lineTxt, txtLastCharIndex, txtStartCharIndex, widthThreshold) {
        while (calcWidth(lineTxt) < widthThreshold && txtLastCharIndex < chars.length - 1) {
          if (self2.isNewline(chars[txtLastCharIndex + 1])) {
            break;
          }
          txtLastCharIndex += 1;
          lineTxt += chars[txtLastCharIndex];
        }
        while (calcWidth(lineTxt) > widthThreshold && // @see https://github.com/antvis/G/issues/1932
        txtLastCharIndex >= txtStartCharIndex) {
          txtLastCharIndex -= 1;
          lineTxt = lineTxt.slice(0, -1);
        }
        return {
          lineTxt,
          txtLastCharIndex
        };
      }
      function appendEllipsis(lineIndex, textCharIndex) {
        if (ellipsisWidth <= 0 || ellipsisWidth > maxWidth) {
          return;
        }
        if (!lines[lineIndex]) {
          lines[lineIndex] = ellipsis;
          return;
        }
        var result2 = findCharIndexClosestWidthThreshold(lines[lineIndex], textCharIndex, prevLineLastCharIndex + 1, maxWidth - ellipsisWidth);
        lines[lineIndex] = result2.lineTxt + ellipsis;
      }
      for (var i2 = 0; i2 < chars.length; i2++) {
        var _char3 = chars[i2];
        var prevChar = chars[i2 - 1];
        var nextChar = chars[i2 + 1];
        var charWidth = calcWidth(_char3);
        if (this.isNewline(_char3)) {
          if (currentLineIndex + 1 >= maxLines) {
            if (i2 < chars.length - 1) {
              appendEllipsis(currentLineIndex, i2 - 1);
            }
            parsedStyle.isOverflowing = true;
            break;
          }
          prevLineLastCharIndex = i2 - 1;
          currentLineIndex += 1;
          currentLineWidth = 0;
          lines[currentLineIndex] = "";
          continue;
        }
        if (charWidth > maxWidth) {
          appendEllipsis(currentLineIndex, i2 - 1);
          parsedStyle.isOverflowing = true;
          break;
        }
        if (currentLineWidth > 0 && currentLineWidth + charWidth > maxWidth) {
          var result = findCharIndexClosestWidthThreshold(lines[currentLineIndex], i2 - 1, prevLineLastCharIndex + 1, maxWidth);
          if (result.txtLastCharIndex !== i2 - 1) {
            lines[currentLineIndex] = result.lineTxt;
            if (result.txtLastCharIndex === chars.length - 1) {
              break;
            }
            i2 = result.txtLastCharIndex + 1;
            _char3 = chars[i2];
            prevChar = chars[i2 - 1];
            nextChar = chars[i2 + 1];
            charWidth = calcWidth(_char3);
          }
          if (currentLineIndex + 1 >= maxLines) {
            appendEllipsis(currentLineIndex, i2 - 1);
            parsedStyle.isOverflowing = true;
            break;
          }
          prevLineLastCharIndex = i2 - 1;
          currentLineIndex += 1;
          currentLineWidth = 0;
          lines[currentLineIndex] = "";
          if (this.isBreakingSpace(_char3)) {
            continue;
          }
          if (!this.canBreakInLastChar(_char3)) {
            lines = this.trimToBreakable(lines);
            currentLineWidth = this.sumTextWidthByCache(lines[currentLineIndex] || "", calcWidth);
          }
          if (this.shouldBreakByKinsokuShorui(_char3, nextChar)) {
            lines = this.trimByKinsokuShorui(lines);
            currentLineWidth += calcWidth(prevChar || "");
          }
        }
        currentLineWidth += charWidth;
        lines[currentLineIndex] += _char3;
      }
      return lines.join("\n");
    }
  }, {
    key: "isBreakingSpace",
    value: function isBreakingSpace(_char4) {
      if (typeof _char4 !== "string") {
        return false;
      }
      return TEXT_METRICS.BreakingSpaces.indexOf(_char4.charCodeAt(0)) >= 0;
    }
  }, {
    key: "isNewline",
    value: function isNewline(_char5) {
      if (typeof _char5 !== "string") {
        return false;
      }
      return TEXT_METRICS.Newlines.indexOf(_char5.charCodeAt(0)) >= 0;
    }
  }, {
    key: "trimToBreakable",
    value: function trimToBreakable(prev) {
      var next = _toConsumableArray(prev);
      var prevLine = next[next.length - 2];
      var index3 = this.findBreakableIndex(prevLine);
      if (index3 === -1 || !prevLine) return next;
      var trimmedChar = prevLine.slice(index3, index3 + 1);
      var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
      var trimFrom = index3 + 1;
      var trimTo = index3 + (isTrimmedWithSpace ? 0 : 1);
      next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
      next[next.length - 2] = prevLine.slice(0, trimTo);
      return next;
    }
  }, {
    key: "canBreakInLastChar",
    value: function canBreakInLastChar(_char6) {
      if (_char6 && LATIN_REGEX.test(_char6)) return false;
      return true;
    }
  }, {
    key: "sumTextWidthByCache",
    value: function sumTextWidthByCache(text, calcWidthWithCache) {
      return text.split("").reduce(function(sum4, c6) {
        return sum4 + calcWidthWithCache(c6);
      }, 0);
    }
  }, {
    key: "findBreakableIndex",
    value: function findBreakableIndex(line4) {
      for (var i2 = line4.length - 1; i2 >= 0; i2--) {
        if (!LATIN_REGEX.test(line4[i2])) return i2;
      }
      return -1;
    }
  }, {
    key: "getFromCache",
    value: function getFromCache(key, letterSpacing, cache2, context) {
      var width = cache2.get(key);
      if (typeof width !== "number") {
        var spacing = key.length * letterSpacing;
        var metrics = context.measureText(key);
        width = metrics.width + spacing;
        cache2.put(key, width);
      }
      return width;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.fontMetricsCache = {};
      this.charWidthCache.clear();
    }
  }]);
}();
var runtime = {};
var geometryUpdaterFactory = function(_ref) {
  var rectUpdater = new RectUpdater();
  var polylineUpdater = new PolylineUpdater();
  return _ref = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, Shape.FRAGMENT, null), Shape.CIRCLE, new CircleUpdater()), Shape.ELLIPSE, new EllipseUpdater()), Shape.RECT, rectUpdater), Shape.IMAGE, rectUpdater), Shape.GROUP, new GroupUpdater()), Shape.LINE, new LineUpdater()), Shape.TEXT, new TextUpdater(runtime)), Shape.POLYLINE, polylineUpdater), Shape.POLYGON, polylineUpdater), _defineProperty(_defineProperty(_defineProperty(_ref, Shape.PATH, new PathUpdater()), Shape.HTML, new HTMLUpdater()), Shape.MESH, null);
}();
var CSSPropertySyntaxFactory = function(_ref2) {
  var color3 = new CSSPropertyColor();
  var length5 = new CSSPropertyLengthOrPercentage();
  return _ref2 = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.PERCENTAGE, null), PropertySyntax.NUMBER, new CSSPropertyNumber()), PropertySyntax.ANGLE, new CSSPropertyAngle()), PropertySyntax.DEFINED_PATH, new CSSPropertyClipPath()), PropertySyntax.PAINT, color3), PropertySyntax.COLOR, color3), PropertySyntax.FILTER, new CSSPropertyFilter()), PropertySyntax.LENGTH, length5), PropertySyntax.LENGTH_PERCENTAGE, length5), PropertySyntax.LENGTH_PERCENTAGE_12, new CSSPropertyLengthOrPercentage12()), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.LENGTH_PERCENTAGE_14, new CSSPropertyLengthOrPercentage14()), PropertySyntax.COORDINATE, new CSSPropertyLengthOrPercentage()), PropertySyntax.OFFSET_DISTANCE, new CSSPropertyOffsetDistance()), PropertySyntax.OPACITY_VALUE, new CSSPropertyOpacity()), PropertySyntax.PATH, new CSSPropertyPath()), PropertySyntax.LIST_OF_POINTS, new CSSPropertyPoints()), PropertySyntax.SHADOW_BLUR, new CSSPropertyShadowBlur()), PropertySyntax.TEXT, new CSSPropertyText()), PropertySyntax.TEXT_TRANSFORM, new CSSPropertyTextTransform()), PropertySyntax.TRANSFORM, new CSSPropertyTransform()), _defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.TRANSFORM_ORIGIN, new CSSPropertyTransformOrigin()), PropertySyntax.Z_INDEX, new CSSPropertyZIndex()), PropertySyntax.MARKER, new CSSPropertyMarker());
}();
var getGlobalThis = function getGlobalThis2() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  return {};
};
runtime.CameraContribution = Camera;
runtime.AnimationTimeline = null;
runtime.EasingFunction = null;
runtime.offscreenCanvasCreator = new OffscreenCanvasCreator();
runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
runtime.textService = new TextService(runtime);
runtime.geometryUpdaterFactory = geometryUpdaterFactory;
runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
runtime.layoutRegistry = null;
runtime.globalThis = getGlobalThis();
runtime.enableStyleSyntax = true;
runtime.enableSizeAttenuation = false;
var entityCounter = 0;
var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
var Element2 = function(_Node) {
  function Element3() {
    var _this2;
    _classCallCheck(this, Element3);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Element3, [].concat(args));
    _this2.entity = entityCounter++;
    _this2.transformable = {
      dirtyFlag: false,
      localDirtyFlag: false,
      localPosition: [0, 0, 0],
      localRotation: [0, 0, 0, 1],
      localScale: [1, 1, 1],
      localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      localSkew: [0, 0],
      position: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      scaling: [1, 1, 1],
      worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
      origin: [0, 0, 0]
    };
    _this2.renderable = {
      bounds: void 0,
      boundsDirty: true,
      renderBounds: void 0,
      renderBoundsDirty: true,
      dirtyRenderBounds: void 0,
      dirty: false
    };
    _this2.geometry = {
      contentBounds: void 0,
      renderBounds: void 0,
      dirty: true
    };
    _this2.cullable = {
      strategy: Strategy.Standard,
      visibilityPlaneMask: -1,
      visible: true,
      enable: true
    };
    _this2.sortable = {
      dirty: false,
      sorted: void 0,
      renderOrder: 0,
      dirtyChildren: [],
      dirtyReason: void 0
    };
    _this2.rBushNode = {
      aabb: void 0
    };
    _this2.namespaceURI = "g";
    _this2.scrollLeft = 0;
    _this2.scrollTop = 0;
    _this2.clientTop = 0;
    _this2.clientLeft = 0;
    _this2.style = {};
    _this2.computedStyle = {};
    _this2.parsedStyle = {
      // opacity: '',
      // fillOpacity: '',
      // strokeOpacity: '',
      // transformOrigin: '',
      // visibility: '',
      // pointerEvents: '',
      // lineWidth: '',
      // lineCap: '',
      // lineJoin: '',
      // increasedLineWidthForHitTesting: '',
      // fontSize: '',
      // fontFamily: '',
      // fontStyle: '',
      // fontWeight: '',
      // fontVariant: '',
      // textAlign: '',
      // textBaseline: '',
      // textTransform: '',
    };
    _this2.attributes = {};
    return _this2;
  }
  _inherits(Element3, _Node);
  return _createClass(Element3, [{
    key: "dirty",
    value: (
      /**
       * @param flag - default `true`, whether the object needs to be updated
       * @param updateShape - default `false`, whether the bounding box of the object is updated
       */
      function dirty() {
        var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        var updateShape = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        this.renderable.dirty = flag;
        if (updateShape) {
          this.renderable.boundsDirty = flag;
          this.renderable.renderBoundsDirty = flag;
        }
      }
    )
  }, {
    key: "className",
    get: (
      /**
       * used with `getElementById()`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id
       */
      /**
       * used in `getElementsByClassName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       */
      function get4() {
        return this.getAttribute("class") || "";
      }
    ),
    set: function set10(className2) {
      this.setAttribute("class", className2);
    }
    /**
     * used in `getElementsByName`
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
     */
  }, {
    key: "classList",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
       */
      function get4() {
        return this.className.split(" ").filter(function(c6) {
          return c6 !== "";
        });
      }
    )
  }, {
    key: "tagName",
    get: function get4() {
      return this.nodeName;
    }
  }, {
    key: "children",
    get: function get4() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get4() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get4() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get4() {
      return this.lastChild;
    }
  }, {
    key: "parentElement",
    get: function get4() {
      return this.parentNode;
    }
  }, {
    key: "nextSibling",
    get: function get4() {
      if (this.parentNode) {
        var index3 = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index3 + 1] || null;
      }
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get4() {
      if (this.parentNode) {
        var index3 = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index3 - 1] || null;
      }
      return null;
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "appendChild",
    value: function appendChild(child, index3) {
      var _this$ownerDocument;
      if (child.destroyed) {
        throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
      }
      runtime.sceneGraphService.attach(child, this, index3);
      if ((_this$ownerDocument = this.ownerDocument) !== null && _this$ownerDocument !== void 0 && _this$ownerDocument.defaultView) {
        if (!isInFragment(this) && child.nodeName === Shape.FRAGMENT) {
          this.ownerDocument.defaultView.mountFragment(child);
        } else {
          this.ownerDocument.defaultView.mountChildren(child);
        }
      }
      if (this.isMutationObserved) {
        insertedEvent.relatedNode = this;
        child.dispatchEvent(insertedEvent);
      }
      return child;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      if (!refChild) {
        this.appendChild(newChild);
      } else {
        if (newChild.parentElement) {
          newChild.parentElement.removeChild(newChild);
        }
        var index3 = this.childNodes.indexOf(refChild);
        if (index3 === -1) {
          this.appendChild(newChild);
        } else {
          this.appendChild(newChild, index3);
        }
      }
      return newChild;
    }
  }, {
    key: "replaceChild",
    value: function replaceChild2(newChild, oldChild) {
      var index3 = this.childNodes.indexOf(oldChild);
      this.removeChild(oldChild);
      this.appendChild(newChild, index3);
      return oldChild;
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      var _this$ownerDocument2, _child$ownerDocument;
      var enableCancelEventPropagation = ((_this$ownerDocument2 = this.ownerDocument) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.defaultView) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.getConfig().future) === null || _this$ownerDocument2 === void 0 ? void 0 : _this$ownerDocument2.experimentalCancelEventPropagation) === true;
      removedEvent.relatedNode = this;
      child.dispatchEvent(removedEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      if ((_child$ownerDocument = child.ownerDocument) !== null && _child$ownerDocument !== void 0 && _child$ownerDocument.defaultView) {
        child.ownerDocument.defaultView.unmountChildren(child);
      }
      runtime.sceneGraphService.detach(child);
      return child;
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */
  }, {
    key: "removeChildren",
    value: function removeChildren() {
      for (var i2 = this.childNodes.length - 1; i2 >= 0; i2--) {
        var child = this.childNodes[i2];
        this.removeChild(child);
      }
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     */
  }, {
    key: "destroyChildren",
    value: function destroyChildren() {
      for (var i2 = this.childNodes.length - 1; i2 >= 0; i2--) {
        var child = this.childNodes[i2];
        if (child.childNodes.length > 0) {
          child.destroyChildren();
        }
        child.destroy();
      }
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
     */
  }, {
    key: "matches",
    value: function matches(selector) {
      return runtime.sceneGraphService.matches(selector, this);
    }
  }, {
    key: "getElementById",
    value: function getElementById(id4) {
      return runtime.sceneGraphService.querySelector("#".concat(id4), this);
    }
  }, {
    key: "getElementsByName",
    value: function getElementsByName(name2) {
      return runtime.sceneGraphService.querySelectorAll('[name="'.concat(name2, '"]'), this);
    }
  }, {
    key: "getElementsByClassName",
    value: function getElementsByClassName(className2) {
      return runtime.sceneGraphService.querySelectorAll(".".concat(className2), this);
    }
  }, {
    key: "getElementsByTagName",
    value: function getElementsByTagName(tagName) {
      return runtime.sceneGraphService.querySelectorAll(tagName, this);
    }
  }, {
    key: "querySelector",
    value: function querySelector(selectors) {
      return runtime.sceneGraphService.querySelector(selectors, this);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(selectors) {
      return runtime.sceneGraphService.querySelectorAll(selectors, this);
    }
    /**
     * should traverses the element and its parents (heading toward the document root)
     * until it finds a node that matches the specified CSS selector.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
     */
  }, {
    key: "closest",
    value: function closest(selectors) {
      var el = this;
      do {
        if (runtime.sceneGraphService.matches(selectors, el)) return el;
        el = el.parentElement;
      } while (el !== null);
      return null;
    }
    /**
     * search in scene group, but should not include itself
     */
  }, {
    key: "find",
    value: function find6(filter3) {
      var _this2 = this;
      var target = null;
      this.forEach(function(object) {
        if (object !== _this2 && filter3(object)) {
          target = object;
          return false;
        }
        return true;
      });
      return target;
    }
  }, {
    key: "findAll",
    value: function findAll(filter3) {
      var _this3 = this;
      var objects = [];
      this.forEach(function(object) {
        if (object !== _this3 && filter3(object)) {
          objects.push(object);
        }
      });
      return objects;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
     */
  }, {
    key: "after",
    value: function after() {
      var _this4 = this;
      if (this.parentNode) {
        var index3 = this.parentNode.childNodes.indexOf(this);
        for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          nodes[_key2] = arguments[_key2];
        }
        nodes.forEach(function(node, i2) {
          var _this4$parentNode;
          return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index3 + i2 + 1);
        });
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
     */
  }, {
    key: "before",
    value: function before() {
      if (this.parentNode) {
        var _ref;
        var index3 = this.parentNode.childNodes.indexOf(this);
        for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          nodes[_key3] = arguments[_key3];
        }
        var first3 = nodes[0], rest = nodes.slice(1);
        this.parentNode.appendChild(first3, index3);
        (_ref = first3).after.apply(_ref, _toConsumableArray(rest));
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
     */
  }, {
    key: "replaceWith",
    value: function replaceWith() {
      this.after.apply(this, arguments);
      this.remove();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
     */
  }, {
    key: "append",
    value: function append3() {
      var _this5 = this;
      for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        nodes[_key4] = arguments[_key4];
      }
      nodes.forEach(function(node) {
        return _this5.appendChild(node);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
     */
  }, {
    key: "prepend",
    value: function prepend() {
      var _this6 = this;
      for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        nodes[_key5] = arguments[_key5];
      }
      nodes.forEach(function(node, i2) {
        return _this6.appendChild(node, i2);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
     */
  }, {
    key: "replaceChildren",
    value: function replaceChildren2() {
      while (this.childNodes.length && this.firstChild) {
        this.removeChild(this.firstChild);
      }
      this.append.apply(this, arguments);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
     */
  }, {
    key: "remove",
    value: function remove2() {
      if (this.parentNode) {
        return this.parentNode.removeChild(this);
      }
      return this;
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      var _this$ownerDocument3;
      var enableCancelEventPropagation = ((_this$ownerDocument3 = this.ownerDocument) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.defaultView) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.getConfig().future) === null || _this$ownerDocument3 === void 0 ? void 0 : _this$ownerDocument3.experimentalCancelEventPropagation) === true;
      this.destroyChildren();
      this.dispatchEvent(destroyEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      this.remove();
      this.emitter.removeAllListeners();
      this.destroyed = true;
    }
  }, {
    key: "getGeometryBounds",
    value: function getGeometryBounds() {
      return runtime.sceneGraphService.getGeometryBounds(this);
    }
  }, {
    key: "getRenderBounds",
    value: function getRenderBounds() {
      return runtime.sceneGraphService.getBounds(this, true);
    }
    /**
     * get bounds in world space, account for children
     */
  }, {
    key: "getBounds",
    value: function getBounds2() {
      return runtime.sceneGraphService.getBounds(this);
    }
    /**
     * get bounds in local space, account for children
     */
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds2() {
      return runtime.sceneGraphService.getLocalBounds(this);
    }
    /**
     * account for context's bounds in client space,
     * but not accounting for children
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
     */
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      return runtime.sceneGraphService.getBoundingClientRect(this);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
     */
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [this.getBoundingClientRect()];
    }
  }, {
    key: "computedStyleMap",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
       * eg. circle.computedStyleMap().get('fill');
       */
      function computedStyleMap() {
        return new Map(Object.entries(this.computedStyle));
      }
    )
  }, {
    key: "getAttributeNames",
    value: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
       */
      function getAttributeNames() {
        return Object.keys(this.attributes);
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
     */
  }, {
    key: "getAttribute",
    value: function getAttribute(name2) {
      if (typeof name2 === "symbol") {
        return void 0;
      }
      var value2 = this.attributes[name2];
      if (value2 === void 0) {
        return value2;
      }
      return value2;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
     */
  }, {
    key: "hasAttribute",
    value: function hasAttribute(qualifiedName) {
      return this.getAttributeNames().includes(qualifiedName);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
     */
  }, {
    key: "hasAttributes",
    value: function hasAttributes() {
      return !!this.getAttributeNames().length;
    }
    /**
     * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
     */
  }, {
    key: "removeAttribute",
    value: function removeAttribute(attributeName) {
      this.setAttribute(attributeName, null);
      delete this.attributes[attributeName];
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
     */
  }, {
    key: "setAttribute",
    value: function setAttribute(attributeName, value2, force, memoize5) {
      this.attributes[attributeName] = value2;
    }
  }, {
    key: "getAttributeNS",
    value: function getAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "getAttributeNode",
    value: function getAttributeNode(qualifiedName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "getAttributeNodeNS",
    value: function getAttributeNodeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "hasAttributeNS",
    value: function hasAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeAttributeNS",
    value: function removeAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeAttributeNode",
    value: function removeAttributeNode(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNS",
    value: function setAttributeNS(namespace, qualifiedName, value2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNode",
    value: function setAttributeNode(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "setAttributeNodeNS",
    value: function setAttributeNodeNS(attr2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "toggleAttribute",
    value: function toggleAttribute(qualifiedName, force) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }]);
}(Node);
function isDisplayObject(value2) {
  return !!(value2 !== null && value2 !== void 0 && value2.nodeName);
}
var Proxy = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {
};
var attrModifiedEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
var $vec3 = vec3_exports.create();
var $quat = quat_exports.create();
var DisplayObject = function(_Element) {
  function DisplayObject2(config) {
    var _this2;
    _classCallCheck(this, DisplayObject2);
    _this2 = _callSuper(this, DisplayObject2);
    _this2.isCustomElement = false;
    _this2.isMutationObserved = false;
    _this2.activeAnimations = [];
    _this2.config = config;
    _this2.id = config.id || "";
    _this2.name = config.name || "";
    if (config.className || config["class"]) {
      _this2.className = config.className || config["class"];
    }
    _this2.nodeName = config.type || Shape.GROUP;
    if (config.initialParsedStyle) {
      Object.assign(_this2.parsedStyle, config.initialParsedStyle);
    }
    _this2.initAttributes(config.style);
    if (runtime.enableStyleSyntax) {
      _this2.style = new Proxy(
        // @ts-ignore
        {
          // ...this.attributes,
          setProperty: function setProperty(propertyName, value2) {
            _this2.setAttribute(propertyName, value2);
          },
          getPropertyValue: function getPropertyValue(propertyName) {
            return _this2.getAttribute(propertyName);
          },
          removeProperty: function removeProperty(propertyName) {
            _this2.removeAttribute(propertyName);
          },
          item: function item() {
            return "";
          }
        },
        {
          get: function get4(target, name2) {
            if (target[name2] !== void 0) {
              return target[name2];
            }
            return _this2.getAttribute(name2);
          },
          set: function set10(_2, prop, value2) {
            _this2.setAttribute(prop, value2);
            return true;
          }
        }
      );
    }
    return _this2;
  }
  _inherits(DisplayObject2, _Element);
  return _createClass(DisplayObject2, [{
    key: "destroy",
    value: function destroy2() {
      _superPropGet(DisplayObject2, "destroy", this, 3)([]);
      this.getAnimations().forEach(function(animation) {
        animation.cancel();
      });
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2, customCloneFunc) {
      var clonedStyle = _objectSpread2({}, this.attributes);
      for (var attributeName in clonedStyle) {
        var attribute = clonedStyle[attributeName];
        if (isDisplayObject(attribute) && // share the same clipPath if possible
        attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
          clonedStyle[attributeName] = attribute.cloneNode(deep2);
        }
        if (customCloneFunc) {
          clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
        }
      }
      var cloned = new this.constructor(_objectSpread2(_objectSpread2({}, this.config), {}, {
        style: clonedStyle
      }));
      cloned.setLocalTransform(this.getLocalTransform());
      if (deep2) {
        this.children.forEach(function(child) {
          if (!child.style.isMarker) {
            var clonedChild = child.cloneNode(deep2);
            cloned.appendChild(clonedChild);
          }
        });
      }
      return cloned;
    }
  }, {
    key: "initAttributes",
    value: function initAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var options = {
        forceUpdateGeometry: true
      };
      runtime.styleValueRegistry.processProperties(this, attributes, options);
      this.dirty();
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name2, value2) {
      var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var memoize5 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      if (is_undefined_default(value2)) {
        return;
      }
      if (force || value2 !== this.attributes[name2]) {
        this.internalSetAttribute(name2, value2, {
          memoize: memoize5
        });
        _superPropGet(DisplayObject2, "setAttribute", this, 3)([name2, value2]);
      }
    }
    /**
     * called when attributes get changed or initialized
     */
  }, {
    key: "internalSetAttribute",
    value: function internalSetAttribute(name2, value2) {
      var parseOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var oldValue = this.attributes[name2];
      var oldParsedValue = this.parsedStyle[name2];
      runtime.styleValueRegistry.processProperties(this, _defineProperty({}, name2, value2), parseOptions);
      this.dirty();
      var newParsedValue = this.parsedStyle[name2];
      if (this.isConnected) {
        attrModifiedEvent.relatedNode = this;
        attrModifiedEvent.prevValue = oldValue;
        attrModifiedEvent.newValue = value2;
        attrModifiedEvent.attrName = name2;
        attrModifiedEvent.prevParsedValue = oldParsedValue;
        attrModifiedEvent.newParsedValue = newParsedValue;
        if (this.isMutationObserved) {
          this.dispatchEvent(attrModifiedEvent);
        } else {
          var _this$ownerDocument$d;
          var enableCancelEventPropagation = ((_this$ownerDocument$d = this.ownerDocument.defaultView.getConfig().future) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.experimentalCancelEventPropagation) === true;
          attrModifiedEvent.target = this;
          this.ownerDocument.defaultView.dispatchEvent(attrModifiedEvent, true, enableCancelEventPropagation);
        }
      }
      if (this.isCustomElement && this.isConnected || !this.isCustomElement) {
        var _attributeChangedCall, _ref;
        (_attributeChangedCall = (_ref = this).attributeChangedCallback) === null || _attributeChangedCall === void 0 || _attributeChangedCall.call(_ref, name2, oldValue, value2, oldParsedValue, newParsedValue);
      }
    }
    // #region transformable
    /**
     * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
     *
     * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
     * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
     */
  }, {
    key: "getBBox",
    value: function getBBox2() {
      var aabb = this.getBounds();
      var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left2 = _aabb$getMin2[0], top = _aabb$getMin2[1];
      var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right2 = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
      return new Rectangle(left2, top, right2 - left2, bottom - top);
    }
  }, {
    key: "setOrigin",
    value: function setOrigin(position) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setOrigin(this, createVec3(position, y4, z, false));
      return this;
    }
  }, {
    key: "getOrigin",
    value: function getOrigin2() {
      return runtime.sceneGraphService.getOrigin(this);
    }
    /**
     * set position in world space
     */
  }, {
    key: "setPosition",
    value: function setPosition(position) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setPosition(this, createVec3(position, y4, z, false));
      return this;
    }
    /**
     * set position in local space
     */
  }, {
    key: "setLocalPosition",
    value: function setLocalPosition(position) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y4, z, false));
      return this;
    }
    /**
     * translate in world space
     */
  }, {
    key: "translate",
    value: function translate6(position) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.translate(this, createVec3(position, y4, z, false));
      return this;
    }
    /**
     * translate in local space
     */
  }, {
    key: "translateLocal",
    value: function translateLocal(position) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      runtime.sceneGraphService.translateLocal(this, createVec3(position, y4, z, false));
      return this;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return runtime.sceneGraphService.getPosition(this);
    }
  }, {
    key: "getLocalPosition",
    value: function getLocalPosition() {
      return runtime.sceneGraphService.getLocalPosition(this);
    }
    /**
     * compatible with G 3.0
     *
     * scaling in local space
     * scale(10) = scale(10, 10, 10)
     *
     * we can't set scale in world space
     */
  }, {
    key: "scale",
    value: function scale12(scaling, y4, z) {
      return this.scaleLocal(scaling, y4, z);
    }
  }, {
    key: "scaleLocal",
    value: function scaleLocal(scaling, y4, z) {
      if (typeof scaling === "number") {
        y4 = y4 || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y4, z, false);
      }
      runtime.sceneGraphService.scaleLocal(this, scaling);
      return this;
    }
    /**
     * set scaling in local space
     */
  }, {
    key: "setLocalScale",
    value: function setLocalScale(scaling, y4, z) {
      if (typeof scaling === "number") {
        y4 = y4 || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y4, z, false);
      }
      runtime.sceneGraphService.setLocalScale(this, scaling);
      return this;
    }
    /**
     * get scaling in local space
     */
  }, {
    key: "getLocalScale",
    value: function getLocalScale() {
      return runtime.sceneGraphService.getLocalScale(this);
    }
    /**
     * get scaling in world space
     */
  }, {
    key: "getScale",
    value: function getScale() {
      return runtime.sceneGraphService.getScale(this);
    }
    /**
     * only return degrees of Z axis in world space
     */
  }, {
    key: "getEulerAngles",
    value: function getEulerAngles() {
      var _getEuler = getEuler($vec3, runtime.sceneGraphService.getWorldTransform(this)), _getEuler2 = _slicedToArray(_getEuler, 3), ez = _getEuler2[2];
      return rad2deg(ez);
    }
    /**
     * only return degrees of Z axis in local space
     */
  }, {
    key: "getLocalEulerAngles",
    value: function getLocalEulerAngles() {
      var _getEuler3 = getEuler($vec3, runtime.sceneGraphService.getLocalRotation(this)), _getEuler4 = _slicedToArray(_getEuler3, 3), ez = _getEuler4[2];
      return rad2deg(ez);
    }
    /**
     * set euler angles(degrees) in world space
     */
  }, {
    key: "setEulerAngles",
    value: function setEulerAngles(z) {
      runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
      return this;
    }
    /**
     * set euler angles(degrees) in local space
     */
  }, {
    key: "setLocalEulerAngles",
    value: function setLocalEulerAngles(z) {
      runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
      return this;
    }
  }, {
    key: "rotateLocal",
    value: function rotateLocal(x3, y4, z) {
      if (isNil(y4) && isNil(z)) {
        runtime.sceneGraphService.rotateLocal(this, 0, 0, x3);
      } else {
        runtime.sceneGraphService.rotateLocal(this, x3, y4, z);
      }
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate7(x3, y4, z) {
      if (isNil(y4) && isNil(z)) {
        runtime.sceneGraphService.rotate(this, 0, 0, x3);
      } else {
        runtime.sceneGraphService.rotate(this, x3, y4, z);
      }
      return this;
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation, y4, z, w2) {
      runtime.sceneGraphService.setRotation(this, rotation, y4, z, w2);
      return this;
    }
  }, {
    key: "setLocalRotation",
    value: function setLocalRotation(rotation, y4, z, w2) {
      runtime.sceneGraphService.setLocalRotation(this, rotation, y4, z, w2);
      return this;
    }
  }, {
    key: "setLocalSkew",
    value: function setLocalSkew(skew2, y4) {
      runtime.sceneGraphService.setLocalSkew(this, skew2, y4);
      return this;
    }
  }, {
    key: "getRotation",
    value: function getRotation2() {
      return runtime.sceneGraphService.getRotation(this);
    }
  }, {
    key: "getLocalRotation",
    value: function getLocalRotation() {
      return runtime.sceneGraphService.getLocalRotation(this);
    }
  }, {
    key: "getLocalSkew",
    value: function getLocalSkew() {
      return runtime.sceneGraphService.getLocalSkew(this);
    }
  }, {
    key: "getLocalTransform",
    value: function getLocalTransform() {
      return runtime.sceneGraphService.getLocalTransform(this);
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      return runtime.sceneGraphService.getWorldTransform(this);
    }
  }, {
    key: "setLocalTransform",
    value: function setLocalTransform(transform2) {
      runtime.sceneGraphService.setLocalTransform(this, transform2);
      return this;
    }
  }, {
    key: "resetLocalTransform",
    value: function resetLocalTransform() {
      runtime.sceneGraphService.resetLocalTransform(this);
    }
    // #endregion transformable
    // #region animatable
    /**
     * returns an array of all Animation objects affecting this element
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
     */
  }, {
    key: "getAnimations",
    value: function getAnimations() {
      return this.activeAnimations;
    }
    /**
     * create an animation with WAAPI
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
     */
  }, {
    key: "animate",
    value: function animate2(keyframes, options) {
      var _this$ownerDocument;
      var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
      if (timeline) {
        return timeline.play(this, keyframes, options);
      }
      return null;
    }
    // #endregion animatable
    // #region visible
    /**
     * shortcut for Used value of `visibility`
     */
  }, {
    key: "isVisible",
    value: function isVisible() {
      var _this$parsedStyle;
      return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) !== "hidden";
    }
  }, {
    key: "interactive",
    get: function get4() {
      return this.isInteractive();
    },
    set: function set10(b) {
      this.style.pointerEvents = b ? "auto" : "none";
    }
  }, {
    key: "isInteractive",
    value: function isInteractive() {
      var _this$parsedStyle2;
      return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
    }
  }, {
    key: "isCulled",
    value: function isCulled() {
      return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
    }
    /**
     * bring to front in current group
     */
  }, {
    key: "toFront",
    value: function toFront() {
      if (this.parentNode) {
        this.style.zIndex = Math.max.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        }))) + 1;
      }
      return this;
    }
    /**
     * send to back in current group
     */
  }, {
    key: "toBack",
    value: function toBack() {
      if (this.parentNode) {
        this.style.zIndex = Math.min.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
          return Number(child.style.zIndex);
        }))) - 1;
      }
      return this;
    }
    // #endregion visible
    // #region deprecated
    /**
     * compatible with G 3.0
     * @alias object.config
     * @deprecated
     */
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.config;
    }
    /**
     * @alias style
     * @example
     * circle.style.r = 10;
     * const r = circle.style;
     * @deprecated
     */
  }, {
    key: "attr",
    value: function attr2() {
      var _this2 = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var name2 = args[0], value2 = args[1];
      if (!name2) {
        return this.attributes;
      }
      if (is_object_default(name2)) {
        Object.keys(name2).forEach(function(key) {
          _this2.setAttribute(key, name2[key]);
        });
        return this;
      }
      if (args.length === 2) {
        this.setAttribute(name2, value2);
        return this;
      }
      return this.attributes[name2];
    }
    /**
     * return 3x3 matrix in world space
     * @deprecated
     */
  }, {
    key: "getMatrix",
    value: function getMatrix(transformMat44) {
      var transform2 = transformMat44 || this.getWorldTransform();
      var _mat4$getTranslation = mat4_exports.getTranslation($vec3, transform2), _mat4$getTranslation2 = _slicedToArray(_mat4$getTranslation, 2), tx = _mat4$getTranslation2[0], ty = _mat4$getTranslation2[1];
      var _mat4$getScaling = mat4_exports.getScaling($vec3, transform2), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 2), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1];
      var rotation = mat4_exports.getRotation($quat, transform2);
      var _getEuler5 = getEuler($vec3, rotation), _getEuler6 = _slicedToArray(_getEuler5, 3), eux = _getEuler6[0], euz = _getEuler6[2];
      return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
    }
    /**
     * return 3x3 matrix in local space
     * @deprecated
     */
  }, {
    key: "getLocalMatrix",
    value: function getLocalMatrix() {
      return this.getMatrix(this.getLocalTransform());
    }
    /**
     * set 3x3 matrix in world space
     * @deprecated
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(mat) {
      var _decompose = decompose2(mat), _decompose2 = _slicedToArray(_decompose, 5), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle4 = _decompose2[4];
      this.setEulerAngles(angle4).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * set 3x3 matrix in local space
     * @deprecated
     */
  }, {
    key: "setLocalMatrix",
    value: function setLocalMatrix(mat) {
      var _decompose3 = decompose2(mat), _decompose4 = _slicedToArray(_decompose3, 5), tx = _decompose4[0], ty = _decompose4[1], scalingX = _decompose4[2], scalingY = _decompose4[3], angle4 = _decompose4[4];
      this.setLocalEulerAngles(angle4).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * Use `visibility: visible` instead.
     * @deprecated
     */
  }, {
    key: "show",
    value: function show3() {
      this.forEach(function(object) {
        object.style.visibility = "visible";
      });
    }
    /**
     * Use `visibility: hidden` instead.
     * @deprecated
     */
  }, {
    key: "hide",
    value: function hide3() {
      this.forEach(function(object) {
        object.style.visibility = "hidden";
      });
    }
    /**
     * Use `childElementCount` instead.
     * @deprecated
     */
  }, {
    key: "getCount",
    value: function getCount() {
      return this.childElementCount;
    }
    /**
     * Use `parentElement` instead.
     * @deprecated
     */
  }, {
    key: "getParent",
    value: function getParent() {
      return this.parentElement;
    }
    /**
     * Use `children` instead.
     * @deprecated
     */
  }, {
    key: "getChildren",
    value: function getChildren() {
      return this.children;
    }
    /**
     * Use `firstElementChild` instead.
     * @deprecated
     */
  }, {
    key: "getFirst",
    value: function getFirst() {
      return this.firstElementChild;
    }
    /**
     * Use `lastElementChild` instead.
     * @deprecated
     */
  }, {
    key: "getLast",
    value: function getLast() {
      return this.lastElementChild;
    }
    /**
     * Use `this.children[index]` instead.
     * @deprecated
     */
  }, {
    key: "getChildByIndex",
    value: function getChildByIndex(index3) {
      return this.children[index3] || null;
    }
    /**
     * Use `appendChild` instead.
     * @deprecated
     */
  }, {
    key: "add",
    value: function add10(child, index3) {
      return this.appendChild(child, index3);
    }
    /**
     * @deprecated
     */
  }, {
    key: "set",
    value: function set10(name2, value2) {
      this.config[name2] = value2;
    }
    /**
     * @deprecated
     */
  }, {
    key: "get",
    value: function get4(name2) {
      return this.config[name2];
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */
  }, {
    key: "moveTo",
    value: function moveTo(position) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      this.setPosition(position, y4, z);
      return this;
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */
  }, {
    key: "move",
    value: function move(position) {
      var y4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      this.setPosition(position, y4, z);
      return this;
    }
    /**
     * Use `this.style.zIndex` instead.
     * @deprecated
     */
  }, {
    key: "setZIndex",
    value: function setZIndex(zIndex) {
      this.style.zIndex = zIndex;
      return this;
    }
    // #endregion deprecated
  }]);
}(Element2);
DisplayObject.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "display", "draggable", "droppable", "fill", "fillOpacity", "fillRule", "filter", "increasedLineWidthForHitTesting", "lineCap", "lineDash", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "hitArea", "offsetDistance", "offsetPath", "offsetX", "offsetY", "opacity", "pointerEvents", "shadowColor", "shadowType", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "strokeWidth", "strokeLinecap", "strokeLineJoin", "strokeDasharray", "strokeDashoffset", "transform", "transformOrigin", "textTransform", "visibility", "zIndex"]);
var Circle = function(_DisplayObject) {
  function Circle3() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Circle3);
    return _callSuper(this, Circle3, [_objectSpread2({
      type: Shape.CIRCLE
    }, options)]);
  }
  _inherits(Circle3, _DisplayObject);
  return _createClass(Circle3);
}(DisplayObject);
Circle.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "r", "isBillboard", "isSizeAttenuation"]));
var _excluded$6 = ["style"];
var CustomElement = function(_DisplayObject) {
  function CustomElement2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$6);
    _classCallCheck(this, CustomElement2);
    _this2 = _callSuper(this, CustomElement2, [_objectSpread2({
      style
    }, rest)]);
    _this2.isCustomElement = true;
    return _this2;
  }
  _inherits(CustomElement2, _DisplayObject);
  return _createClass(CustomElement2);
}(DisplayObject);
CustomElement.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
var Ellipse = function(_DisplayObject) {
  function Ellipse2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Ellipse2);
    return _callSuper(this, Ellipse2, [_objectSpread2({
      type: Shape.ELLIPSE
    }, options)]);
  }
  _inherits(Ellipse2, _DisplayObject);
  return _createClass(Ellipse2);
}(DisplayObject);
Ellipse.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "rx", "ry", "isBillboard", "isSizeAttenuation"]));
var Fragment = function(_DisplayObject) {
  function Fragment3() {
    _classCallCheck(this, Fragment3);
    return _callSuper(this, Fragment3, [{
      type: Shape.FRAGMENT
    }]);
  }
  _inherits(Fragment3, _DisplayObject);
  return _createClass(Fragment3);
}(DisplayObject);
Fragment.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className"]);
var Group2 = function(_DisplayObject) {
  function Group3() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Group3);
    return _callSuper(this, Group3, [_objectSpread2({
      type: Shape.GROUP
    }, options)]);
  }
  _inherits(Group3, _DisplayObject);
  return _createClass(Group3);
}(DisplayObject);
Group2.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
var _excluded$5 = ["style"];
var HTML = function(_DisplayObject) {
  function HTML2() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$5);
    _classCallCheck(this, HTML2);
    _this2 = _callSuper(this, HTML2, [_objectSpread2({
      type: Shape.HTML,
      style
    }, rest)]);
    _this2.cullable.enable = false;
    return _this2;
  }
  _inherits(HTML2, _DisplayObject);
  return _createClass(HTML2, [{
    key: "getDomElement",
    value: function getDomElement() {
      return this.parsedStyle.$el;
    }
    /**
     * override with $el.getBoundingClientRect
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
     *
     * ! The calculation logic of the html element should be consistent with that of the canvas element
     */
    // getBoundingClientRect(): Rectangle {
    //   if (this.parsedStyle.$el) {
    //     return this.parsedStyle.$el.getBoundingClientRect();
    //   } else {
    //     const { x, y, width, height } = this.parsedStyle;
    //     return new Rectangle(x, y, width, height);
    //   }
    // }
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [this.getBoundingClientRect()];
    }
    // getBounds() {
    //   const clientRect = this.getBoundingClientRect();
    //   // calc context's offset
    //   // @ts-ignore
    //   const canvasRect = this.ownerDocument?.defaultView
    //     ?.getContextService()
    //     .getBoundingClientRect();
    //   const aabb = new AABB();
    //   const minX = clientRect.left - (canvasRect?.left || 0);
    //   const minY = clientRect.top - (canvasRect?.top || 0);
    //   aabb.setMinMax(
    //     [minX, minY, 0],
    //     [minX + clientRect.width, minY + clientRect.height, 0],
    //   );
    //   return aabb;
    // }
  }, {
    key: "getLocalBounds",
    value: function getLocalBounds2() {
      if (this.parentNode) {
        var parentInvert = mat4_exports.invert(mat4_exports.create(), this.parentNode.getWorldTransform());
        var bounds = this.getBounds();
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds();
    }
  }]);
}(DisplayObject);
HTML.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "$el", "innerHTML", "width", "height"]));
var Image2 = function(_DisplayObject) {
  function Image5() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Image5);
    return _callSuper(this, Image5, [_objectSpread2({
      type: Shape.IMAGE
    }, options)]);
  }
  _inherits(Image5, _DisplayObject);
  return _createClass(Image5);
}(DisplayObject);
Image2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "src", "width", "height", "isBillboard", "billboardRotation", "isSizeAttenuation", "keepAspectRatio"]));
var _excluded$4 = ["style"];
var Line = function(_DisplayObject) {
  function Line7() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$4);
    _classCallCheck(this, Line7);
    _this2 = _callSuper(this, Line7, [_objectSpread2({
      type: Shape.LINE,
      style: _objectSpread2({
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        z1: 0,
        z2: 0
      }, style)
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Line7, _DisplayObject);
  return _createClass(Line7, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x12 = _this$parsedStyle2.x1, x22 = _this$parsedStyle2.x2, y12 = _this$parsedStyle2.y1, y22 = _this$parsedStyle2.y2;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y4;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      if (isStart) {
        ox = x12;
        oy = y12;
        x3 = x22 - x12;
        y4 = y22 - y12;
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        ox = x22;
        oy = y22;
        x3 = x12 - x22;
        y4 = y12 - y22;
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y4, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset2, oy + Math.sin(rad2) * offset2);
    }
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$parsedStyle3 = this.parsedStyle, x12 = _this$parsedStyle3.x1, y12 = _this$parsedStyle3.y1, x22 = _this$parsedStyle3.x2, y22 = _this$parsedStyle3.y2;
      var _linePointAt = pointAt$3(x12, y12, x22, y22, ratio), x3 = _linePointAt.x, y4 = _linePointAt.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y4, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength2(distance7) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPoint(distance7 / this.getTotalLength(), inWorldSpace);
    }
  }, {
    key: "getTotalLength",
    value: function getTotalLength2() {
      var _this$parsedStyle4 = this.parsedStyle, x12 = _this$parsedStyle4.x1, y12 = _this$parsedStyle4.y1, x22 = _this$parsedStyle4.x2, y22 = _this$parsedStyle4.y2;
      return length$4(x12, y12, x22, y22);
    }
  }]);
}(DisplayObject);
Line.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x1", "y1", "x2", "y2", "z1", "z2", "isBillboard", "isSizeAttenuation", "markerStart", "markerEnd", "markerStartOffset", "markerEndOffset"]));
var _excluded$3 = ["style"];
var Path2 = function(_DisplayObject) {
  function Path5() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$3);
    _classCallCheck(this, Path5);
    _this2 = _callSuper(this, Path5, [_objectSpread2({
      type: Shape.PATH,
      style,
      initialParsedStyle: {
        miterLimit: 4,
        d: _objectSpread2({}, EMPTY_PARSED_PATH)
      }
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Path5, _DisplayObject);
  return _createClass(Path5, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "d") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y4;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      if (isStart) {
        var _this$getStartTangent = this.getStartTangent(), _this$getStartTangent2 = _slicedToArray(_this$getStartTangent, 2), p1 = _this$getStartTangent2[0], p22 = _this$getStartTangent2[1];
        ox = p22[0];
        oy = p22[1];
        x3 = p1[0] - p22[0];
        y4 = p1[1] - p22[1];
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var _this$getEndTangent = this.getEndTangent(), _this$getEndTangent2 = _slicedToArray(_this$getEndTangent, 2), _p = _this$getEndTangent2[0], _p2 = _this$getEndTangent2[1];
        ox = _p2[0];
        oy = _p2[1];
        x3 = _p[0] - _p2[0];
        y4 = _p[1] - _p2[1];
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y4, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset2, oy + Math.sin(rad2) * offset2);
    }
  }, {
    key: "placeMarkerMid",
    value: function placeMarkerMid(marker) {
      var segments = this.parsedStyle.d.segments;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      if (marker && isDisplayObject(marker)) {
        for (var i2 = 1; i2 < segments.length - 1; i2++) {
          var _segments$i$currentPo = _slicedToArray(segments[i2].currentPoint, 2), ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
          var cloned = i2 === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    }
    /**
     * Returns the total length of the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
     */
  }, {
    key: "getTotalLength",
    value: function getTotalLength2() {
      return getOrCalculatePathTotalLength(this);
    }
    /**
     * Returns the point at a given distance along the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
     */
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength$1(distance7) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var absolutePath = this.parsedStyle.d.absolutePath;
      var _getPointAtLength2 = getPointAtLength(absolutePath, distance7), x3 = _getPointAtLength2.x, y4 = _getPointAtLength2.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y4, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    }
    /**
     * Returns the point at a given ratio of the total length in path.
     */
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
    }
    /**
     * Get start tangent vector
     */
  }, {
    key: "getStartTangent",
    value: function getStartTangent() {
      var segments = this.parsedStyle.d.segments;
      var result = [];
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    }
    /**
     * Get end tangent vector
     */
  }, {
    key: "getEndTangent",
    value: function getEndTangent() {
      var segments = this.parsedStyle.d.segments;
      var length5 = segments.length;
      var result = [];
      if (length5 > 1) {
        var startPoint = segments[length5 - 2].currentPoint;
        var endPoint = segments[length5 - 1].currentPoint;
        var tangent = segments[length5 - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    }
  }]);
}(DisplayObject);
Path2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["d", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard", "isSizeAttenuation"]));
var _excluded$2 = ["style"];
var Polygon = function(_DisplayObject) {
  function Polygon5() {
    var _this2;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$2);
    _classCallCheck(this, Polygon5);
    _this2 = _callSuper(this, Polygon5, [_objectSpread2({
      type: Shape.POLYGON,
      style,
      initialParsedStyle: {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: true
      }
    }, rest)]);
    _this2.markerStartAngle = 0;
    _this2.markerEndAngle = 0;
    _this2.markerMidList = [];
    var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this2.markerStartAngle = markerStart.getLocalEulerAngles();
      _this2.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this2.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this2.appendChild(markerEnd);
    }
    _this2.transformMarker(true);
    _this2.transformMarker(false);
    return _this2;
  }
  _inherits(Polygon5, _DisplayObject);
  return _createClass(Polygon5, [{
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === "points") {
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === "markerStart") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === "markerEnd") {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === "markerMid") {
        this.placeMarkerMid(newParsedValue);
      }
    }
  }, {
    key: "transformMarker",
    value: function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, P = _this$parsedStyle2.points;
      var _ref2 = P || {}, points = _ref2.points;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker) || !points) {
        return;
      }
      var rad2 = 0;
      var x3;
      var y4;
      var ox;
      var oy;
      var offset2;
      var originalAngle;
      ox = points[0][0];
      oy = points[0][1];
      if (isStart) {
        x3 = points[1][0] - points[0][0];
        y4 = points[1][1] - points[0][1];
        offset2 = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var length5 = points.length;
        if (!this.parsedStyle.isClosed) {
          ox = points[length5 - 1][0];
          oy = points[length5 - 1][1];
          x3 = points[length5 - 2][0] - points[length5 - 1][0];
          y4 = points[length5 - 2][1] - points[length5 - 1][1];
        } else {
          x3 = points[length5 - 1][0] - points[0][0];
          y4 = points[length5 - 1][1] - points[0][1];
        }
        offset2 = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad2 = Math.atan2(y4, x3);
      marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad2) * offset2, oy + Math.sin(rad2) * offset2);
    }
  }, {
    key: "placeMarkerMid",
    value: function placeMarkerMid(marker) {
      var P = this.parsedStyle.points;
      var _ref3 = P || {}, points = _ref3.points;
      this.markerMidList.forEach(function(marker2) {
        marker2.remove();
      });
      this.markerMidList = [];
      if (marker && isDisplayObject(marker) && points) {
        for (var i2 = 1; i2 < (this.parsedStyle.isClosed ? points.length : points.length - 1); i2++) {
          var ox = points[i2][0];
          var oy = points[i2][1];
          var cloned = i2 === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
        }
      }
    }
  }]);
}(DisplayObject);
Polygon.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isClosed", "isBillboard", "isSizeAttenuation"]));
var _excluded$1 = ["style"];
var Polyline = function(_Polygon) {
  function Polyline2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$1);
    _classCallCheck(this, Polyline2);
    return _callSuper(this, Polyline2, [_objectSpread2({
      type: Shape.POLYLINE,
      style,
      initialParsedStyle: {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: false
      }
    }, rest)]);
  }
  _inherits(Polyline2, _Polygon);
  return _createClass(Polyline2, [{
    key: "getTotalLength",
    value: function getTotalLength2() {
      return getOrCalculatePolylineTotalLength(this);
    }
  }, {
    key: "getPointAtLength",
    value: function getPointAtLength2(distance7) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.getPoint(distance7 / this.getTotalLength(), inWorldSpace);
    }
  }, {
    key: "getPoint",
    value: function getPoint(ratio) {
      var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var points = this.parsedStyle.points.points;
      if (this.parsedStyle.points.segments.length === 0) {
        var segments = [];
        var tempLength = 0;
        var segmentT;
        var segmentL;
        var totalLength = this.getTotalLength();
        points.forEach(function(p3, i2) {
          if (points[i2 + 1]) {
            segmentT = [0, 0];
            segmentT[0] = tempLength / totalLength;
            segmentL = length$4(p3[0], p3[1], points[i2 + 1][0], points[i2 + 1][1]);
            tempLength += segmentL;
            segmentT[1] = tempLength / totalLength;
            segments.push(segmentT);
          }
        });
        this.parsedStyle.points.segments = segments;
      }
      var subt = 0;
      var index3 = 0;
      this.parsedStyle.points.segments.forEach(function(v, i2) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index3 = i2;
        }
      });
      var _linePointAt = pointAt$3(points[index3][0], points[index3][1], points[index3 + 1][0], points[index3 + 1][1], subt), x3 = _linePointAt.x, y4 = _linePointAt.y;
      var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y4, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      return new Point2(transformed[0], transformed[1]);
    }
  }, {
    key: "getStartTangent",
    value: function getStartTangent() {
      var points = this.parsedStyle.points.points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    }
  }, {
    key: "getEndTangent",
    value: function getEndTangent() {
      var points = this.parsedStyle.points.points;
      var l2 = points.length - 1;
      var result = [];
      result.push([points[l2 - 1][0], points[l2 - 1][1]]);
      result.push([points[l2][0], points[l2][1]]);
      return result;
    }
  }]);
}(Polygon);
Polyline.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(Polygon.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard"]));
var Rect = function(_DisplayObject) {
  function Rect4() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Rect4);
    return _callSuper(this, Rect4, [_objectSpread2({
      type: Shape.RECT
    }, options)]);
  }
  _inherits(Rect4, _DisplayObject);
  return _createClass(Rect4);
}(DisplayObject);
Rect.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "width", "height", "isBillboard", "isSizeAttenuation", "radius"]));
var _excluded = ["style"];
var Text = function(_DisplayObject) {
  function Text6() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded);
    _classCallCheck(this, Text6);
    return _callSuper(this, Text6, [_objectSpread2({
      type: Shape.TEXT,
      style: _objectSpread2({
        fill: "black"
      }, style)
    }, rest)]);
  }
  _inherits(Text6, _DisplayObject);
  return _createClass(Text6, [{
    key: "getComputedTextLength",
    value: function getComputedTextLength() {
      var _this$parsedStyle$met;
      this.getGeometryBounds();
      return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
    }
  }, {
    key: "getLineBoundingRects",
    value: function getLineBoundingRects() {
      var _this$parsedStyle$met2;
      this.getGeometryBounds();
      return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
    }
  }, {
    key: "isOverflowing",
    value: function isOverflowing() {
      this.getGeometryBounds();
      return !!this.parsedStyle.isOverflowing;
    }
  }]);
}(DisplayObject);
Text.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "isBillboard", "billboardRotation", "isSizeAttenuation", "text", "textAlign", "textBaseline", "fontStyle", "fontSize", "fontFamily", "fontWeight", "fontVariant", "lineHeight", "letterSpacing", "leading", "wordWrap", "wordWrapWidth", "maxLines", "textOverflow", "isOverflowing", "textPath", "textDecorationLine", "textDecorationColor", "textDecorationStyle", "textPathSide", "textPathStartOffset", "metrics", "dx", "dy"]));
var CustomElementRegistry = function() {
  function CustomElementRegistry2() {
    _classCallCheck(this, CustomElementRegistry2);
    this.registry = {};
    this.define(Shape.CIRCLE, Circle);
    this.define(Shape.ELLIPSE, Ellipse);
    this.define(Shape.RECT, Rect);
    this.define(Shape.IMAGE, Image2);
    this.define(Shape.LINE, Line);
    this.define(Shape.GROUP, Group2);
    this.define(Shape.PATH, Path2);
    this.define(Shape.POLYGON, Polygon);
    this.define(Shape.POLYLINE, Polyline);
    this.define(Shape.TEXT, Text);
    this.define(Shape.HTML, HTML);
  }
  return _createClass(CustomElementRegistry2, [{
    key: "define",
    value: function define3(name2, constructor) {
      this.registry[name2] = constructor;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
     */
  }, {
    key: "get",
    value: function get4(name2) {
      return this.registry[name2];
    }
  }]);
}();
var CSS = {
  /**
   * <number>
   * @see https://drafts.csswg.org/css-values-4/#number-value
   */
  number: function number2(n2) {
    return new CSSUnitValue(n2);
  },
  /**
   * <percentage>
   * @see https://drafts.csswg.org/css-values-4/#percentage-value
   */
  percent: function percent(n2) {
    return new CSSUnitValue(n2, "%");
  },
  /**
   * <length>
   */
  px: function px(n2) {
    return new CSSUnitValue(n2, "px");
  },
  /**
   * <length>
   */
  em: function em(n2) {
    return new CSSUnitValue(n2, "em");
  },
  rem: function rem(n2) {
    return new CSSUnitValue(n2, "rem");
  },
  /**
   * <angle>
   */
  deg: function deg(n2) {
    return new CSSUnitValue(n2, "deg");
  },
  /**
   * <angle>
   */
  grad: function grad(n2) {
    return new CSSUnitValue(n2, "grad");
  },
  /**
   * <angle>
   */
  rad: function rad(n2) {
    return new CSSUnitValue(n2, "rad");
  },
  /**
   * <angle>
   */
  turn: function turn(n2) {
    return new CSSUnitValue(n2, "turn");
  },
  /**
   * <time>
   */
  s: function s2(n2) {
    return new CSSUnitValue(n2, "s");
  },
  /**
   * <time>
   */
  ms: function ms(n2) {
    return new CSSUnitValue(n2, "ms");
  },
  /**
   * CSS Properties & Values API
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   */
  registerProperty: function registerProperty(definition) {
    var name2 = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
    runtime.styleValueRegistry.registerMetadata({
      n: name2,
      inh: inherits,
      "int": interpolable,
      d: initialValue,
      syntax
    });
  },
  /**
   * CSS Layout API
   * register layout
   *
   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
   */
  registerLayout: function registerLayout(name2, clazz) {
    runtime.layoutRegistry.registerLayout(name2, clazz);
  }
};
var Document2 = function(_Node) {
  function Document3() {
    var _this2;
    _classCallCheck(this, Document3);
    _this2 = _callSuper(this, Document3);
    _this2.defaultView = null;
    _this2.ownerDocument = null;
    _this2.nodeName = "document";
    try {
      _this2.timeline = new runtime.AnimationTimeline(_this2);
    } catch (_unused) {
    }
    var initialStyle = {};
    BUILT_IN_PROPERTIES.forEach(function(_ref) {
      var n2 = _ref.n, inh = _ref.inh, d4 = _ref.d;
      if (inh && d4) {
        initialStyle[n2] = isFunction(d4) ? d4(Shape.GROUP) : d4;
      }
    });
    _this2.documentElement = new Group2({
      id: "g-root",
      style: initialStyle
    });
    _this2.documentElement.ownerDocument = _this2;
    _this2.documentElement.parentNode = _this2;
    _this2.childNodes = [_this2.documentElement];
    return _this2;
  }
  _inherits(Document3, _Node);
  return _createClass(Document3, [{
    key: "children",
    get: function get4() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get4() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get4() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get4() {
      return this.lastChild;
    }
  }, {
    key: "createElement",
    value: (
      /**
       * @example const circle = document.createElement('circle', { style: { r: 10 } });
       */
      function createElement3(tagName, options) {
        if (tagName === "svg") {
          return this.documentElement;
        }
        var clazz = this.defaultView.customElements.get(tagName);
        if (!clazz) {
          console.warn("Unsupported tagName: ", tagName);
          clazz = tagName === "tspan" ? Text : Group2;
        }
        var shape23 = new clazz(options);
        shape23.ownerDocument = this;
        return shape23;
      }
    )
  }, {
    key: "createElementNS",
    value: function createElementNS(namespaceURI, tagName, options) {
      return this.createElement(tagName, options);
    }
  }, {
    key: "cloneNode",
    value: function cloneNode(deep2) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      try {
        this.documentElement.destroyChildren();
        this.timeline.destroy();
      } catch (_unused2) {
      }
    }
    /**
     * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
     */
  }, {
    key: "elementsFromBBox",
    value: function elementsFromBBox(minX, minY, maxX, maxY2) {
      var rBush = this.defaultView.context.rBushRoot;
      var rBushNodes = rBush.search({
        minX,
        minY,
        maxX,
        maxY: maxY2
      });
      var hitTestList = [];
      rBushNodes.forEach(function(_ref2) {
        var displayObject = _ref2.displayObject;
        var _displayObject$parsed = displayObject.parsedStyle.pointerEvents, pointerEvents = _displayObject$parsed === void 0 ? "auto" : _displayObject$parsed;
        var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
        if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
          hitTestList.push(displayObject);
        }
      });
      hitTestList.sort(function(a5, b) {
        return b.sortable.renderOrder - a5.sortable.renderOrder;
      });
      return hitTestList;
    }
  }, {
    key: "elementFromPointSync",
    value: function elementFromPointSync(x3, y4) {
      var _this$defaultView$can = this.defaultView.canvas2Viewport({
        x: x3,
        y: y4
      }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
      var _this$defaultView$get = this.defaultView.getConfig(), width = _this$defaultView$get.width, height = _this$defaultView$get.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      var _this$defaultView$vie = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
      var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: true,
        position: {
          x: x3,
          y: y4,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }), picked = _this$defaultView$get2.picked;
      return picked && picked[0] || this.documentElement;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
     */
  }, {
    key: "elementFromPoint",
    value: function() {
      var _elementFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(x3, y4) {
        var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                x: x3,
                y: y4
              }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
              _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context.next = 1;
                break;
              }
              return _context.abrupt("return", null);
            case 1:
              _this$defaultView$vie2 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
              _context.next = 2;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: true,
                position: {
                  x: x3,
                  y: y4,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 2:
              _yield$this$defaultVi = _context.sent;
              picked = _yield$this$defaultVi.picked;
              return _context.abrupt("return", picked && picked[0] || this.documentElement);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function elementFromPoint(_x, _x2) {
        return _elementFromPoint.apply(this, arguments);
      }
      return elementFromPoint;
    }()
  }, {
    key: "elementsFromPointSync",
    value: function elementsFromPointSync(x3, y4) {
      var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
        x: x3,
        y: y4
      }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
      var _this$defaultView$get4 = this.defaultView.getConfig(), width = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return [];
      }
      var _this$defaultView$vie3 = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
      var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: false,
        position: {
          x: x3,
          y: y4,
          viewportX,
          viewportY,
          clientX,
          clientY
        },
        picked: []
      }), picked = _this$defaultView$get5.picked;
      if (picked[picked.length - 1] !== this.documentElement) {
        picked.push(this.documentElement);
      }
      return picked;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
     */
  }, {
    key: "elementsFromPoint",
    value: function() {
      var _elementsFromPoint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(x3, y4) {
        var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
        return _regeneratorRuntime().wrap(function(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                x: x3,
                y: y4
              }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
              _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context2.next = 1;
                break;
              }
              return _context2.abrupt("return", []);
            case 1:
              _this$defaultView$vie4 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
              _context2.next = 2;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: false,
                position: {
                  x: x3,
                  y: y4,
                  viewportX,
                  viewportY,
                  clientX,
                  clientY
                },
                picked: []
              });
            case 2:
              _yield$this$defaultVi2 = _context2.sent;
              picked = _yield$this$defaultVi2.picked;
              if (picked[picked.length - 1] !== this.documentElement) {
                picked.push(this.documentElement);
              }
              return _context2.abrupt("return", picked);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function elementsFromPoint(_x3, _x4) {
        return _elementsFromPoint.apply(this, arguments);
      }
      return elementsFromPoint;
    }()
  }, {
    key: "appendChild",
    value: function appendChild(newChild, index3) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "removeChild",
    value: function removeChild(oldChild, destroy2) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "replaceChild",
    value: function replaceChild2(newChild, oldChild, destroy2) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "append",
    value: function append3() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
  }, {
    key: "prepend",
    value: function prepend() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
    /**
     * Execute query on documentElement.
     */
  }, {
    key: "getElementById",
    value: function getElementById(id4) {
      return this.documentElement.getElementById(id4);
    }
  }, {
    key: "getElementsByName",
    value: function getElementsByName(name2) {
      return this.documentElement.getElementsByName(name2);
    }
  }, {
    key: "getElementsByTagName",
    value: function getElementsByTagName(tagName) {
      return this.documentElement.getElementsByTagName(tagName);
    }
  }, {
    key: "getElementsByClassName",
    value: function getElementsByClassName(className2) {
      return this.documentElement.getElementsByClassName(className2);
    }
  }, {
    key: "querySelector",
    value: function querySelector(selectors) {
      return this.documentElement.querySelector(selectors);
    }
  }, {
    key: "querySelectorAll",
    value: function querySelectorAll(selectors) {
      return this.documentElement.querySelectorAll(selectors);
    }
  }, {
    key: "find",
    value: function find6(filter3) {
      return this.documentElement.find(filter3);
    }
  }, {
    key: "findAll",
    value: function findAll(filter3) {
      return this.documentElement.findAll(filter3);
    }
  }]);
}(Node);
var CullingPlugin = function() {
  function CullingPlugin2(strategies) {
    _classCallCheck(this, CullingPlugin2);
    this.strategies = strategies;
  }
  return _createClass(CullingPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
      var strategies = this.strategies;
      renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
        if (object) {
          var _config$future;
          var cullable = object.cullable;
          if (strategies.length === 0) {
            cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
          } else {
            cullable.visible = strategies.every(function(strategy) {
              return strategy.isVisible(camera, object);
            });
          }
          if (!object.isCulled() && object.isVisible()) {
            return object;
          }
          var enableCancelEventPropagation = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalCancelEventPropagation) === true;
          object.dispatchEvent(new CustomEvent(ElementEvent.CULLED), enableCancelEventPropagation, enableCancelEventPropagation);
          return null;
        }
        return object;
      });
      renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
        object.cullable.visibilityPlaneMask = -1;
      });
    }
  }]);
}();
CullingPlugin.tag = "Culling";
var EventPlugin = function() {
  function EventPlugin2() {
    var _this2 = this;
    _classCallCheck(this, EventPlugin2);
    this.autoPreventDefault = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.onPointerMove = function(nativeEvent) {
      var _this$context$renderi;
      var canvas = (_this$context$renderi = _this2.context.renderingContext.root) === null || _this$context$renderi === void 0 || (_this$context$renderi = _this$context$renderi.ownerDocument) === null || _this$context$renderi === void 0 ? void 0 : _this$context$renderi.defaultView;
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      var _iterator = _createForOfIteratorHelper(normalizedEvents), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var normalizedEvent = _step.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
    this.onClick = function(nativeEvent) {
      var _this$context$renderi2;
      var canvas = (_this$context$renderi2 = _this2.context.renderingContext.root) === null || _this$context$renderi2 === void 0 || (_this$context$renderi2 = _this$context$renderi2.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      var _iterator2 = _createForOfIteratorHelper(normalizedEvents), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var normalizedEvent = _step2.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    };
  }
  return _createClass(EventPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this;
      this.context = context;
      var renderingService = context.renderingService;
      var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
      this.context.eventService.setPickHandler(function(position) {
        var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({
          position,
          picked: [],
          topmost: true
          // we only concern the topmost element
        }), picked = _this2$context$render.picked;
        return picked[0] || null;
      });
      renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
        var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
        _this2.context.eventService.mapEvent(wheelEvent);
      });
      renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
        var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        if (_this2.autoPreventDefault && events[0].isNormalized) {
          var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        var _iterator3 = _createForOfIteratorHelper(events), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var event = _step3.value;
            var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(federatedEvent);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
        var $element = _this2.context.contextService.getDomElement();
        var isNativeEventFromCanvas = _this2.context.eventService.isNativeEventFromCanvas($element, nativeEvent);
        var outside2 = !isNativeEventFromCanvas ? "outside" : "";
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        var _iterator4 = _createForOfIteratorHelper(normalizedEvents), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var normalizedEvent = _step4.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            event.type += outside2;
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
      renderingService.hooks.click.tap(EventPlugin2.tag, this.onClick);
      renderingService.hooks.pointerCancel.tap(EventPlugin2.tag, function(nativeEvent) {
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        var _iterator5 = _createForOfIteratorHelper(normalizedEvents), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var normalizedEvent = _step5.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
    }
  }, {
    key: "bootstrapEvent",
    value: function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
      event.view = view;
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = normalizedEvent.pointerId;
      event.width = normalizedEvent.width;
      event.height = normalizedEvent.height;
      event.isPrimary = normalizedEvent.isPrimary;
      event.pointerType = normalizedEvent.pointerType;
      event.pressure = normalizedEvent.pressure;
      event.tangentialPressure = normalizedEvent.tangentialPressure;
      event.tiltX = normalizedEvent.tiltX;
      event.tiltY = normalizedEvent.tiltY;
      event.twist = normalizedEvent.twist;
      this.transferMouseData(event, normalizedEvent);
      var _this$context$eventSe = this.context.eventService.client2Viewport({
        x: normalizedEvent.clientX,
        y: normalizedEvent.clientY
      }), x3 = _this$context$eventSe.x, y4 = _this$context$eventSe.y;
      event.viewport.x = x3;
      event.viewport.y = y4;
      var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === "pointerleave") {
        event.type = "pointerout";
      }
      if (event.type.startsWith("mouse")) {
        event.type = event.type.replace("mouse", "pointer");
      }
      if (event.type.startsWith("touch")) {
        event.type = TOUCH_TO_POINTER[event.type] || event.type;
      }
      return event;
    }
  }, {
    key: "normalizeWheelEvent",
    value: function normalizeWheelEvent(nativeEvent) {
      var event = this.rootWheelEvent;
      this.transferMouseData(event, nativeEvent);
      event.deltaMode = nativeEvent.deltaMode;
      event.deltaX = nativeEvent.deltaX;
      event.deltaY = nativeEvent.deltaY;
      event.deltaZ = nativeEvent.deltaZ;
      var _this$context$eventSe3 = this.context.eventService.client2Viewport({
        x: nativeEvent.clientX,
        y: nativeEvent.clientY
      }), x3 = _this$context$eventSe3.x, y4 = _this$context$eventSe3.y;
      event.viewport.x = x3;
      event.viewport.y = y4;
      var _this$context$eventSe4 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe4.x, canvasY = _this$context$eventSe4.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.nativeEvent = nativeEvent;
      event.type = nativeEvent.type;
      return event;
    }
    /**
     * Transfers base & mouse event data from the nativeEvent to the federated event.
     */
  }, {
    key: "transferMouseData",
    value: function transferMouseData(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = clock.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.metaKey = nativeEvent.metaKey;
      event.shiftKey = nativeEvent.shiftKey;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.screen.x = nativeEvent.screenX;
      event.screen.y = nativeEvent.screenY;
      event.relatedTarget = null;
    }
  }, {
    key: "setCursor",
    value: function setCursor2(cursor) {
      this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
    }
  }, {
    key: "normalizeToPointerEvent",
    value: function normalizeToPointerEvent(event, canvas) {
      var normalizedEvents = [];
      if (canvas.isTouchEvent(event)) {
        for (var i2 = 0; i2 < event.changedTouches.length; i2++) {
          var touch = event.changedTouches[i2];
          if (is_undefined_default(touch.button)) touch.button = 0;
          if (is_undefined_default(touch.buttons)) touch.buttons = 1;
          if (is_undefined_default(touch.isPrimary)) {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (is_undefined_default(touch.width)) touch.width = touch.radiusX || 1;
          if (is_undefined_default(touch.height)) touch.height = touch.radiusY || 1;
          if (is_undefined_default(touch.tiltX)) touch.tiltX = 0;
          if (is_undefined_default(touch.tiltY)) touch.tiltY = 0;
          if (is_undefined_default(touch.pointerType)) touch.pointerType = "touch";
          if (is_undefined_default(touch.pointerId)) touch.pointerId = touch.identifier || 0;
          if (is_undefined_default(touch.pressure)) touch.pressure = touch.force || 0.5;
          if (is_undefined_default(touch.twist)) touch.twist = 0;
          if (is_undefined_default(touch.tangentialPressure)) touch.tangentialPressure = 0;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (canvas.isMouseEvent(event)) {
        var tempEvent = event;
        if (is_undefined_default(tempEvent.isPrimary)) tempEvent.isPrimary = true;
        if (is_undefined_default(tempEvent.width)) tempEvent.width = 1;
        if (is_undefined_default(tempEvent.height)) tempEvent.height = 1;
        if (is_undefined_default(tempEvent.tiltX)) tempEvent.tiltX = 0;
        if (is_undefined_default(tempEvent.tiltY)) tempEvent.tiltY = 0;
        if (is_undefined_default(tempEvent.pointerType)) tempEvent.pointerType = "mouse";
        if (is_undefined_default(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;
        if (is_undefined_default(tempEvent.pressure)) tempEvent.pressure = 0.5;
        if (is_undefined_default(tempEvent.twist)) tempEvent.twist = 0;
        if (is_undefined_default(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
  }]);
}();
EventPlugin.tag = "Event";
var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
var FrustumCullingStrategy = function() {
  function FrustumCullingStrategy2() {
    _classCallCheck(this, FrustumCullingStrategy2);
  }
  return _createClass(FrustumCullingStrategy2, [{
    key: "isVisible",
    value: function isVisible(camera, object) {
      var _object$parentNode;
      var cullable = object.cullable;
      if (!cullable.enable) {
        return true;
      }
      var renderBounds = object.getRenderBounds();
      if (AABB.isEmpty(renderBounds)) {
        return false;
      }
      var frustum2 = camera.getFrustum();
      var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 || (_object$parentNode = _object$parentNode.cullable) === null || _object$parentNode === void 0 ? void 0 : _object$parentNode.visibilityPlaneMask;
      cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
      cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
      return cullable.visible;
    }
    /**
     *
     * @seeOptimized View Frustum Culling Algorithms for Bounding Boxes
     * @see https://github.com/antvis/GWebGPUEngine/issues/3
     *
     * *  the basic intersection test
     * *  masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
     * * TODO:  the plane-coherency test
     * * TODO:  mesh  Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
     *
     * @param aabb aabb
     * @param parentPlaneMask mask of parent
     * @param planes planes of frustum
     */
  }, {
    key: "computeVisibilityWithPlaneMask",
    value: function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
      if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
        return parentPlaneMask;
      }
      var mask = Mask.INSIDE;
      var isShape2D = shape2D.indexOf(object.nodeName) > -1;
      for (var k2 = 0, len5 = planes.length; k2 < len5; ++k2) {
        var flag = 1 << k2;
        if ((parentPlaneMask & flag) === 0) {
          continue;
        }
        if (isShape2D && (k2 === 4 || k2 === 5)) {
          continue;
        }
        var _planes$k = planes[k2], normal = _planes$k.normal, distance7 = _planes$k.distance;
        if (vec3_exports.dot(normal, aabb.getPositiveFarPoint(planes[k2])) + distance7 < 0) {
          return Mask.OUTSIDE;
        }
        if (vec3_exports.dot(normal, aabb.getNegativeFarPoint(planes[k2])) + distance7 < 0) {
          mask |= flag;
        }
      }
      return mask;
    }
  }]);
}();
var PrepareRendererPlugin = function() {
  function PrepareRendererPlugin2() {
    _classCallCheck(this, PrepareRendererPlugin2);
    this.syncTasks = /* @__PURE__ */ new Map();
    this.isFirstTimeRendering = true;
    this.syncing = false;
    this.isFirstTimeRenderingFinished = false;
  }
  return _createClass(PrepareRendererPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this, _runtime$globalThis$r, _config$future;
      var config = context.config, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      this.rBush = rBushRoot;
      var handleAttributeChanged = function handleAttributeChanged2(e3) {
        renderingService.dirtify();
      };
      var handleBoundsChanged = function handleBoundsChanged2(e3) {
        _this2.syncTasks.set(e3.target, e3.detail.affectChildren);
        renderingService.dirtify();
      };
      var handleMounted = function handleMounted2(e3) {
        var object = e3.target;
        if (runtime.enableSizeAttenuation) {
          runtime.styleValueRegistry.updateSizeAttenuation(object, canvas.getCamera().getZoom());
        }
      };
      var handleUnmounted = function handleUnmounted2(e3) {
        var object = e3.target;
        var rBushNode = object.rBushNode;
        if (rBushNode !== null && rBushNode !== void 0 && rBushNode.aabb) {
          _this2.rBush.remove(rBushNode.aabb);
        }
        _this2.syncTasks["delete"](object);
        runtime.sceneGraphService.dirtyToRoot(object);
        renderingService.dirtify();
      };
      renderingService.hooks.init.tap(PrepareRendererPlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        _this2.syncTasks.clear();
      });
      var ric = (_runtime$globalThis$r = runtime.globalThis.requestIdleCallback) !== null && _runtime$globalThis$r !== void 0 ? _runtime$globalThis$r : raf.bind(runtime.globalThis);
      var enableRICSyncRTree = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalRICSyncRTree) === true;
      renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
        if (_this2.isFirstTimeRendering) {
          _this2.isFirstTimeRendering = false;
          _this2.syncing = true;
          ric(function() {
            _this2.syncRTree(true);
            _this2.isFirstTimeRenderingFinished = true;
          });
        } else if (enableRICSyncRTree && runtime.globalThis.requestIdleCallback && runtime.globalThis.cancelIdleCallback) {
          runtime.globalThis.cancelIdleCallback(_this2.ricSyncRTreeId);
          _this2.ricSyncRTreeId = runtime.globalThis.requestIdleCallback(function() {
            return _this2.syncRTree();
          });
        } else {
          _this2.syncRTree();
        }
      });
    }
  }, {
    key: "syncNode",
    value: function syncNode(node) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!node.isConnected) return;
      var rBushNode = node.rBushNode;
      if (rBushNode.aabb) this.rBush.remove(rBushNode.aabb);
      var renderBounds = node.getRenderBounds();
      if (renderBounds) {
        var renderable = node.renderable;
        if (force) {
          if (!renderable.dirtyRenderBounds) {
            renderable.dirtyRenderBounds = new AABB();
          }
          renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
        }
        var _renderBounds$getMin = renderBounds.getMin(), _renderBounds$getMin2 = _slicedToArray(_renderBounds$getMin, 2), minX = _renderBounds$getMin2[0], minY = _renderBounds$getMin2[1];
        var _renderBounds$getMax = renderBounds.getMax(), _renderBounds$getMax2 = _slicedToArray(_renderBounds$getMax, 2), maxX = _renderBounds$getMax2[0], maxY2 = _renderBounds$getMax2[1];
        if (!rBushNode.aabb) {
          rBushNode.aabb = {};
        }
        rBushNode.aabb.displayObject = node;
        rBushNode.aabb.minX = minX;
        rBushNode.aabb.minY = minY;
        rBushNode.aabb.maxX = maxX;
        rBushNode.aabb.maxY = maxY2;
      }
      if (rBushNode.aabb) {
        if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
          return rBushNode.aabb;
        }
      }
    }
  }, {
    key: "syncRTree",
    value: function syncRTree() {
      var _this2 = this;
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!force && (this.syncing || this.syncTasks.size === 0)) {
        return;
      }
      this.syncing = true;
      var bulk = [];
      var synced = /* @__PURE__ */ new Set();
      var sync = function sync2(node) {
        if (!synced.has(node) && node.renderable) {
          var aabb = _this2.syncNode(node, force);
          if (aabb) {
            bulk.push(aabb);
            synced.add(node);
          }
        }
      };
      this.syncTasks.forEach(function(affectChildren, node) {
        if (affectChildren) {
          node.forEach(sync);
        }
        var parent = node;
        while (parent) {
          sync(parent);
          parent = parent.parentElement;
        }
      });
      this.rBush.load(bulk);
      bulk.length = 0;
      this.syncing = false;
    }
  }]);
}();
PrepareRendererPlugin.tag = "Prepare";
var CanvasEvent = function(CanvasEvent2) {
  CanvasEvent2["READY"] = "ready";
  CanvasEvent2["BEFORE_RENDER"] = "beforerender";
  CanvasEvent2["RERENDER"] = "rerender";
  CanvasEvent2["AFTER_RENDER"] = "afterrender";
  CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent2["RESIZE"] = "resize";
  CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
  CanvasEvent2["RENDERER_CHANGED"] = "rendererchanged";
  return CanvasEvent2;
}({});
var DEFAULT_CAMERA_Z = 500;
var DEFAULT_CAMERA_NEAR = 0.1;
var DEFAULT_CAMERA_FAR = 1e3;
var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
var Canvas = function(_EventTarget) {
  function Canvas3(config) {
    var _this2;
    _classCallCheck(this, Canvas3);
    _this2 = _callSuper(this, Canvas3);
    _this2.Element = DisplayObject;
    _this2.inited = false;
    _this2.context = {};
    var container = config.container, canvas = config.canvas, renderer = config.renderer, width = config.width, height = config.height, background = config.background, cursor = config.cursor, supportsMutipleCanvasesInOneContainer = config.supportsMutipleCanvasesInOneContainer, _config$cleanUpOnDest = config.cleanUpOnDestroy, cleanUpOnDestroy = _config$cleanUpOnDest === void 0 ? true : _config$cleanUpOnDest, offscreenCanvas = config.offscreenCanvas, devicePixelRatio = config.devicePixelRatio, requestAnimationFrame3 = config.requestAnimationFrame, cancelAnimationFrame3 = config.cancelAnimationFrame, createImage = config.createImage, supportsTouchEvents = config.supportsTouchEvents, supportsPointerEvents = config.supportsPointerEvents, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent, dblClickSpeed = config.dblClickSpeed;
    var canvasWidth = width;
    var canvasHeight = height;
    var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
    dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
    if (canvas) {
      canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
      canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
    }
    _this2.customElements = new CustomElementRegistry();
    _this2.devicePixelRatio = dpr;
    _this2.requestAnimationFrame = requestAnimationFrame3 !== null && requestAnimationFrame3 !== void 0 ? requestAnimationFrame3 : raf.bind(runtime.globalThis);
    _this2.cancelAnimationFrame = cancelAnimationFrame3 !== null && cancelAnimationFrame3 !== void 0 ? cancelAnimationFrame3 : caf.bind(runtime.globalThis);
    _this2.createImage = createImage !== null && createImage !== void 0 ? createImage : function() {
      return new window.Image();
    };
    _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
    _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
    _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
      return _this2.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
    };
    _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
      return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
    };
    if (offscreenCanvas) {
      runtime.offscreenCanvas = offscreenCanvas;
    }
    _this2.document = new Document2();
    _this2.document.defaultView = _this2;
    if (!supportsMutipleCanvasesInOneContainer) {
      cleanExistedCanvas(container, _this2, cleanUpOnDestroy);
    }
    _this2.initRenderingContext(_objectSpread2(_objectSpread2({}, config), {}, {
      width: canvasWidth,
      height: canvasHeight,
      background: background !== null && background !== void 0 ? background : "transparent",
      cursor: cursor !== null && cursor !== void 0 ? cursor : "default",
      cleanUpOnDestroy,
      devicePixelRatio: dpr,
      requestAnimationFrame: _this2.requestAnimationFrame,
      cancelAnimationFrame: _this2.cancelAnimationFrame,
      createImage: _this2.createImage,
      supportsTouchEvents: _this2.supportsTouchEvents,
      supportsPointerEvents: _this2.supportsPointerEvents,
      isTouchEvent: _this2.isTouchEvent,
      isMouseEvent: _this2.isMouseEvent,
      dblClickSpeed: dblClickSpeed !== null && dblClickSpeed !== void 0 ? dblClickSpeed : 200
    }));
    _this2.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
    _this2.initRenderer(renderer, true);
    return _this2;
  }
  _inherits(Canvas3, _EventTarget);
  return _createClass(Canvas3, [{
    key: "initRenderingContext",
    value: function initRenderingContext(mergedConfig) {
      this.context.config = mergedConfig;
      this.context.renderingContext = {
        /**
         * the root node in scene graph
         */
        root: this.document.documentElement,
        unculledEntities: [],
        renderListCurrentFrame: [],
        renderReasons: /* @__PURE__ */ new Set(),
        force: false,
        dirty: false
      };
    }
  }, {
    key: "initDefaultCamera",
    value: function initDefaultCamera(width, height, clipSpaceNearZ) {
      var _this2 = this;
      var camera = new runtime.CameraContribution();
      camera.clipSpaceNearZ = clipSpaceNearZ;
      camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
      camera.canvas = this;
      camera.eventEmitter.on(CameraEvent.UPDATED, function() {
        _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
        if (runtime.enableSizeAttenuation && _this2.getConfig().renderer.getConfig().enableSizeAttenuation) {
          _this2.updateSizeAttenuation();
        }
      });
      this.context.camera = camera;
    }
  }, {
    key: "updateSizeAttenuation",
    value: function updateSizeAttenuation() {
      var zoom = this.getCamera().getZoom();
      this.document.documentElement.forEach(function(node) {
        runtime.styleValueRegistry.updateSizeAttenuation(node, zoom);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return this.context.config;
    }
    /**
     * get the root displayObject in scenegraph
     * @alias this.document.documentElement
     */
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this.document.documentElement;
    }
    /**
     * get the camera of canvas
     */
  }, {
    key: "getCamera",
    value: function getCamera() {
      return this.context.camera;
    }
  }, {
    key: "getContextService",
    value: function getContextService() {
      return this.context.contextService;
    }
  }, {
    key: "getEventService",
    value: function getEventService() {
      return this.context.eventService;
    }
  }, {
    key: "getRenderingService",
    value: function getRenderingService() {
      return this.context.renderingService;
    }
  }, {
    key: "getRenderingContext",
    value: function getRenderingContext() {
      return this.context.renderingContext;
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.getRenderingService().getStats();
    }
    // /**
    //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
    //  */
    // getComputedStyle(node: DisplayObject) {
    //   return node.computedStyle;
    // }
  }, {
    key: "ready",
    get: function get4() {
      var _this3 = this;
      if (!this.readyPromise) {
        this.readyPromise = new Promise(function(resolve) {
          _this3.resolveReadyPromise = function() {
            resolve(_this3);
          };
        });
        if (this.inited) {
          this.resolveReadyPromise();
        }
      }
      return this.readyPromise;
    }
    /**
     * @param cleanUp - whether to clean up all the internal services of Canvas
     * @param skipTriggerEvent - whether to skip trigger destroy event
     */
  }, {
    key: "destroy",
    value: function destroy2() {
      var _this$getConfig$futur;
      var cleanUp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var skipTriggerEvent = arguments.length > 1 ? arguments[1] : void 0;
      memoize2.clearCache();
      var enableCancelEventPropagation = ((_this$getConfig$futur = this.getConfig().future) === null || _this$getConfig$futur === void 0 ? void 0 : _this$getConfig$futur.experimentalCancelEventPropagation) === true;
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
      }
      if (this.frameId) {
        this.cancelAnimationFrame(this.frameId);
      }
      var root2 = this.getRoot();
      if (cleanUp) {
        this.unmountChildren(root2);
        this.document.destroy();
        this.getEventService().destroy();
      }
      this.getRenderingService().destroy();
      this.getContextService().destroy();
      if (this.context.rBushRoot) {
        this.context.rBushRoot.clear();
      }
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
      }
      var clearEventRetain = function clearEventRetain2(event) {
        event.currentTarget = null;
        event.manager = null;
        event.target = null;
        event.relatedNode = null;
      };
      clearEventRetain(mountedEvent);
      clearEventRetain(unmountedEvent);
      clearEventRetain(beforeRenderEvent);
      clearEventRetain(rerenderEvent);
      clearEventRetain(afterRenderEvent);
      clearEventRetain(attrModifiedEvent);
      clearEventRetain(insertedEvent);
      clearEventRetain(removedEvent);
      clearEventRetain(destroyEvent);
      runtime.textService.clearCache();
    }
    /**
     * compatible with G 3.0
     * @deprecated
     * @alias resize
     */
  }, {
    key: "changeSize",
    value: function changeSize(width, height) {
      this.resize(width, height);
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var _canvasConfig$future;
      var canvasConfig = this.context.config;
      canvasConfig.width = width;
      canvasConfig.height = height;
      this.getContextService().resize(width, height);
      var camera = this.context.camera;
      var projectionMode = camera.getProjectionMode();
      camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
      if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
      } else {
        camera.setAspect(width / height);
      }
      var enableCancelEventPropagation = ((_canvasConfig$future = canvasConfig.future) === null || _canvasConfig$future === void 0 ? void 0 : _canvasConfig$future.experimentalCancelEventPropagation) === true;
      this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, {
        width,
        height
      }), enableCancelEventPropagation, enableCancelEventPropagation);
    }
    // proxy to document.documentElement
  }, {
    key: "appendChild",
    value: function appendChild(child, index3) {
      return this.document.documentElement.appendChild(child, index3);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild, refChild) {
      return this.document.documentElement.insertBefore(newChild, refChild);
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      return this.document.documentElement.removeChild(child);
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */
  }, {
    key: "removeChildren",
    value: function removeChildren() {
      this.document.documentElement.removeChildren();
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     * But the canvas remains running which means display objects can be appended later.
     */
  }, {
    key: "destroyChildren",
    value: function destroyChildren() {
      this.document.documentElement.destroyChildren();
    }
  }, {
    key: "render",
    value: function render3(frame2) {
      var _this$getConfig$futur2, _this4 = this;
      if (frame2) {
        beforeRenderEvent.detail = frame2;
        afterRenderEvent.detail = frame2;
      }
      var enableCancelEventPropagation = ((_this$getConfig$futur2 = this.getConfig().future) === null || _this$getConfig$futur2 === void 0 ? void 0 : _this$getConfig$futur2.experimentalCancelEventPropagation) === true;
      this.dispatchEvent(beforeRenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      var renderingService = this.getRenderingService();
      renderingService.render(this.getConfig(), frame2, function() {
        _this4.dispatchEvent(rerenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      });
      this.dispatchEvent(afterRenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
    }
  }, {
    key: "run",
    value: function run() {
      var _this5 = this;
      var _tick = function tick3(time, frame2) {
        _this5.render(frame2);
        _this5.frameId = _this5.requestAnimationFrame(_tick);
      };
      _tick();
    }
  }, {
    key: "initRenderer",
    value: function initRenderer(renderer) {
      var _this6 = this;
      var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!renderer) {
        throw new Error("Renderer is required.");
      }
      this.inited = false;
      this.readyPromise = void 0;
      this.context.rBushRoot = new RBush();
      this.context.renderingPlugins = [];
      this.context.renderingPlugins.push(
        new EventPlugin(),
        new PrepareRendererPlugin(),
        // new DirtyCheckPlugin(),
        new CullingPlugin([new FrustumCullingStrategy()])
      );
      this.loadRendererContainerModule(renderer);
      this.context.contextService = new this.context.ContextService(_objectSpread2(_objectSpread2({}, runtime), this.context));
      this.context.renderingService = new RenderingService(runtime, this.context);
      this.context.eventService = new EventService(runtime, this.context);
      this.context.eventService.init();
      if (this.context.contextService.init) {
        this.context.contextService.init();
        this.initRenderingService(renderer, firstContentfullPaint, true);
      } else {
        this.context.contextService.initAsync().then(function() {
          _this6.initRenderingService(renderer, firstContentfullPaint);
        })["catch"](function(err) {
          console.error(err);
        });
      }
    }
  }, {
    key: "initRenderingService",
    value: function initRenderingService(renderer) {
      var _this7 = this;
      var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.context.renderingService.init(function() {
        var _this7$getConfig$futu;
        _this7.inited = true;
        var enableCancelEventPropagation = ((_this7$getConfig$futu = _this7.getConfig().future) === null || _this7$getConfig$futu === void 0 ? void 0 : _this7$getConfig$futu.experimentalCancelEventPropagation) === true;
        if (firstContentfullPaint) {
          if (async) {
            _this7.requestAnimationFrame(function() {
              _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY), enableCancelEventPropagation, enableCancelEventPropagation);
            });
          } else {
            _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY), enableCancelEventPropagation, enableCancelEventPropagation);
          }
        } else {
          _this7.dispatchEvent(new CustomEvent(CanvasEvent.RENDERER_CHANGED), enableCancelEventPropagation, enableCancelEventPropagation);
        }
        if (_this7.readyPromise) {
          _this7.resolveReadyPromise();
        }
        if (!firstContentfullPaint) {
          _this7.getRoot().forEach(function(node) {
            var _dirty, _ref;
            (_dirty = (_ref = node).dirty) === null || _dirty === void 0 || _dirty.call(_ref, true, true);
          });
        }
        _this7.mountChildren(_this7.getRoot());
        if (renderer.getConfig().enableAutoRendering) {
          _this7.run();
        }
      });
    }
  }, {
    key: "loadRendererContainerModule",
    value: function loadRendererContainerModule(renderer) {
      var _this8 = this;
      var plugins = renderer.getPlugins();
      plugins.forEach(function(plugin) {
        plugin.context = _this8.context;
        plugin.init(runtime);
      });
    }
  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      var canvasConfig = this.getConfig();
      if (canvasConfig.renderer === renderer) {
        return;
      }
      var oldRenderer = canvasConfig.renderer;
      canvasConfig.renderer = renderer;
      this.destroy(false, true);
      _toConsumableArray((oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()) || []).reverse().forEach(function(plugin) {
        plugin.destroy(runtime);
      });
      this.initRenderer(renderer);
    }
  }, {
    key: "setCursor",
    value: function setCursor2(cursor) {
      var canvasConfig = this.getConfig();
      canvasConfig.cursor = cursor;
      this.getContextService().applyCursorStyle(cursor);
    }
  }, {
    key: "unmountChildren",
    value: function unmountChildren(parent) {
      var _this9 = this;
      parent.childNodes.forEach(function(child) {
        _this9.unmountChildren(child);
      });
      if (this.inited) {
        if (parent.isMutationObserved) {
          parent.dispatchEvent(unmountedEvent);
        } else {
          var _this$getConfig$futur3;
          var enableCancelEventPropagation = ((_this$getConfig$futur3 = this.getConfig().future) === null || _this$getConfig$futur3 === void 0 ? void 0 : _this$getConfig$futur3.experimentalCancelEventPropagation) === true;
          unmountedEvent.target = parent;
          this.dispatchEvent(unmountedEvent, true, enableCancelEventPropagation);
        }
        if (parent !== this.document.documentElement) {
          parent.ownerDocument = null;
        }
        parent.isConnected = false;
      }
      if (parent.isCustomElement) {
        if (parent.disconnectedCallback) {
          parent.disconnectedCallback();
        }
      }
    }
  }, {
    key: "mountChildren",
    value: function mountChildren(child) {
      var _this0 = this;
      var skipTriggerEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInFragment(child);
      if (this.inited) {
        if (!child.isConnected) {
          child.ownerDocument = this.document;
          child.isConnected = true;
          if (!skipTriggerEvent) {
            if (child.isMutationObserved) {
              child.dispatchEvent(mountedEvent);
            } else {
              var _this$getConfig$futur4;
              var enableCancelEventPropagation = ((_this$getConfig$futur4 = this.getConfig().future) === null || _this$getConfig$futur4 === void 0 ? void 0 : _this$getConfig$futur4.experimentalCancelEventPropagation) === true;
              mountedEvent.target = child;
              this.dispatchEvent(mountedEvent, true, enableCancelEventPropagation);
            }
          }
        }
      } else {
        console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", child.nodeName);
      }
      child.childNodes.forEach(function(c6) {
        _this0.mountChildren(c6, skipTriggerEvent);
      });
      if (child.isCustomElement) {
        if (child.connectedCallback) {
          child.connectedCallback();
        }
      }
    }
  }, {
    key: "mountFragment",
    value: function mountFragment(child) {
      this.mountChildren(child, false);
    }
  }, {
    key: "client2Viewport",
    value: function client2Viewport(client) {
      return this.getEventService().client2Viewport(client);
    }
  }, {
    key: "viewport2Client",
    value: function viewport2Client(canvas) {
      return this.getEventService().viewport2Client(canvas);
    }
  }, {
    key: "viewport2Canvas",
    value: function viewport2Canvas(viewport) {
      return this.getEventService().viewport2Canvas(viewport);
    }
  }, {
    key: "canvas2Viewport",
    value: function canvas2Viewport(canvas) {
      return this.getEventService().canvas2Viewport(canvas);
    }
    /**
     * @deprecated
     * @alias client2Viewport
     */
  }, {
    key: "getPointByClient",
    value: function getPointByClient(clientX, clientY) {
      return this.client2Viewport({
        x: clientX,
        y: clientY
      });
    }
    /**
     * @deprecated
     * @alias viewport2Client
     */
  }, {
    key: "getClientByPoint",
    value: function getClientByPoint(x3, y4) {
      return this.viewport2Client({
        x: x3,
        y: y4
      });
    }
  }]);
}(EventTarget);

// node_modules/@antv/g-camera-api/dist/index.esm.js
var AdvancedCamera = function(_Camera) {
  function AdvancedCamera2() {
    var _this2;
    _classCallCheck(this, AdvancedCamera2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, AdvancedCamera2, [].concat(args));
    _this2.landmarks = [];
    return _this2;
  }
  _inherits(AdvancedCamera2, _Camera);
  return _createClass(AdvancedCamera2, [{
    key: "rotate",
    value: (
      /**
       * Changes the azimuth and elevation with respect to the current camera axes
       * @param {Number} azimuth the relative azimuth
       * @param {Number} elevation the relative elevation
       * @param {Number} roll the relative roll
       */
      function rotate7(azimuth, elevation, roll) {
        this.relElevation = getAngle2(elevation);
        this.relAzimuth = getAngle2(azimuth);
        this.relRoll = getAngle2(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        if (this.type === CameraType.EXPLORING) {
          var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
          var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
          var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.relRoll));
          var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
          rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
          var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
          mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
        } else {
          if (Math.abs(this.elevation) > 90) {
            return this;
          }
          this.computeMatrix();
        }
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this._update();
        return this;
      }
    )
    /**
     * (right) & (up)
     */
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      var coords = createVec3(tx, ty, 0);
      var pos = vec3_exports.clone(this.position);
      vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.right, coords[0]));
      vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.up, coords[1]));
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    }
    /**
     *  n 
     */
  }, {
    key: "dolly",
    value: function dolly(value2) {
      var n2 = this.forward;
      var pos = vec3_exports.clone(this.position);
      var step2 = value2 * this.dollyingStep;
      var updatedDistance = this.distance + value2 * this.dollyingStep;
      step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
      pos[0] += step2 * n2[0];
      pos[1] += step2 * n2[1];
      pos[2] += step2 * n2[2];
      this._setPosition(pos);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getDistance();
      } else if (this.type === CameraType.TRACKING) {
        vec3_exports.add(this.focalPoint, pos, this.distanceVector);
      }
      this.triggerUpdate();
      return this;
    }
  }, {
    key: "cancelLandmarkAnimation",
    value: function cancelLandmarkAnimation() {
      if (this.landmarkAnimationID !== void 0) {
        this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
      }
    }
  }, {
    key: "createLandmark",
    value: function createLandmark(name2) {
      var _position$, _position$2, _focalPoint$, _focalPoint$2;
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _params$position = params.position, position = _params$position === void 0 ? this.position : _params$position, _params$focalPoint = params.focalPoint, focalPoint = _params$focalPoint === void 0 ? this.focalPoint : _params$focalPoint, roll = params.roll, zoom = params.zoom;
      var camera = new runtime.CameraContribution();
      camera.setType(this.type, void 0);
      camera.setPosition(position[0], (_position$ = position[1]) !== null && _position$ !== void 0 ? _position$ : this.position[1], (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : this.position[2]);
      camera.setFocalPoint(focalPoint[0], (_focalPoint$ = focalPoint[1]) !== null && _focalPoint$ !== void 0 ? _focalPoint$ : this.focalPoint[1], (_focalPoint$2 = focalPoint[2]) !== null && _focalPoint$2 !== void 0 ? _focalPoint$2 : this.focalPoint[2]);
      camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
      camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
      var landmark = {
        name: name2,
        matrix: mat4_exports.clone(camera.getWorldTransform()),
        right: vec3_exports.clone(camera.right),
        up: vec3_exports.clone(camera.up),
        forward: vec3_exports.clone(camera.forward),
        position: vec3_exports.clone(camera.getPosition()),
        focalPoint: vec3_exports.clone(camera.getFocalPoint()),
        distanceVector: vec3_exports.clone(camera.getDistanceVector()),
        distance: camera.getDistance(),
        dollyingStep: camera.getDollyingStep(),
        azimuth: camera.getAzimuth(),
        elevation: camera.getElevation(),
        roll: camera.getRoll(),
        relAzimuth: camera.relAzimuth,
        relElevation: camera.relElevation,
        relRoll: camera.relRoll,
        zoom: camera.getZoom()
      };
      this.landmarks.push(landmark);
      return landmark;
    }
  }, {
    key: "gotoLandmark",
    value: function gotoLandmark(name2) {
      var _this2 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var landmark = isString(name2) ? this.landmarks.find(function(l2) {
        return l2.name === name2;
      }) : name2;
      if (landmark) {
        var _ref = isNumber(options) ? {
          duration: options
        } : options, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? "linear" : _ref$easing, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 100 : _ref$duration, _ref$easingFunction = _ref.easingFunction, easingFunction = _ref$easingFunction === void 0 ? void 0 : _ref$easingFunction, _ref$onfinish = _ref.onfinish, onfinish = _ref$onfinish === void 0 ? void 0 : _ref$onfinish, _ref$onframe = _ref.onframe, onframe = _ref$onframe === void 0 ? void 0 : _ref$onframe;
        var epsilon4 = 0.01;
        this.cancelLandmarkAnimation();
        var destPosition = landmark.position;
        var destFocalPoint = landmark.focalPoint;
        var destZoom = landmark.zoom;
        var destRoll = landmark.roll;
        var easingFunc = easingFunction || runtime.EasingFunction(easing);
        var timeStart;
        var end = function end2() {
          _this2.setFocalPoint(destFocalPoint);
          _this2.setPosition(destPosition);
          _this2.setRoll(destRoll);
          _this2.setZoom(destZoom);
          _this2.computeMatrix();
          _this2.triggerUpdate();
          onfinish === null || onfinish === void 0 || onfinish();
        };
        if (duration === 0) return end();
        var _animate = function animate2(timestamp) {
          if (timeStart === void 0) {
            timeStart = timestamp;
          }
          var elapsed = timestamp - timeStart;
          if (elapsed >= duration) {
            end();
            return;
          }
          var t = easingFunc(elapsed / duration);
          var interFocalPoint = vec3_exports.create();
          var interPosition = vec3_exports.create();
          var interZoom = 1;
          var interRoll = 0;
          vec3_exports.lerp(interFocalPoint, _this2.focalPoint, destFocalPoint, t);
          vec3_exports.lerp(interPosition, _this2.position, destPosition, t);
          interRoll = _this2.roll * (1 - t) + destRoll * t;
          interZoom = _this2.zoom * (1 - t) + destZoom * t;
          _this2.setFocalPoint(interFocalPoint);
          _this2.setPosition(interPosition);
          _this2.setRoll(interRoll);
          _this2.setZoom(interZoom);
          var dist5 = vec3_exports.dist(interFocalPoint, destFocalPoint) + vec3_exports.dist(interPosition, destPosition);
          if (dist5 <= epsilon4 && destZoom === void 0 && destRoll === void 0) {
            return end();
          }
          _this2.computeMatrix();
          _this2.triggerUpdate();
          if (elapsed < duration) {
            onframe === null || onframe === void 0 || onframe(t);
            _this2.landmarkAnimationID = _this2.canvas.requestAnimationFrame(_animate);
          }
        };
        this.canvas.requestAnimationFrame(_animate);
      }
    }
    /**
     * Sets the camera to a distance such that the area covered by the bounding box is viewed.
     */
    // shot(displayObject: DisplayObject) {
    //   const aabb = displayObject.getBounds();
    //   if (!AABB.isEmpty(aabb)) {
    //     this.setElevation(0);
    //     this.setAzimuth(0);
    //     this.setRoll(0);
    //     const { halfExtents, center } = aabb;
    //     const maxDim = Math.max(halfExtents[0] * 2, halfExtents[1] * 2);
    //     const cc = center.map((c: number) => Math.round(c * 1000) / 1000) as [number, number, number];
    //     if (maxDim !== 0) {
    //       const d = (1.5 * maxDim) / Math.tan(this.fov * DEG_2_RAD);
    //       this.setPosition([cc[0], cc[1], cc[2] + d]);
    //     }
    //     this.setFocalPoint(cc);
    //   }
    // }
  }]);
}(Camera);
runtime.CameraContribution = AdvancedCamera;

// node_modules/@antv/g-dom-mutation-observer-api/dist/index.esm.js
var MutationRecord = function() {
  function MutationRecord2(type, target) {
    _classCallCheck(this, MutationRecord2);
    this.addedNodes = [];
    this.attributeName = null;
    this.attributeNamespace = null;
    this.nextSibling = null;
    this.oldValue = null;
    this.previousSibling = null;
    this.removedNodes = [];
    this.type = type;
    this.target = target;
  }
  return _createClass(MutationRecord2, null, [{
    key: "copy",
    value: function copy7(original) {
      var record = new MutationRecord2(original.type, original.target);
      record.addedNodes = original.addedNodes.slice();
      record.removedNodes = original.removedNodes.slice();
      record.previousSibling = original.previousSibling;
      record.nextSibling = original.nextSibling;
      record.attributeName = original.attributeName;
      record.attributeNamespace = original.attributeNamespace;
      record.oldValue = original.oldValue;
      return record;
    }
  }]);
}();
var uidCounter = 0;
var registrationsTable = /* @__PURE__ */ new WeakMap();
var Registration = function() {
  function Registration2(observer, target, options) {
    _classCallCheck(this, Registration2);
    this.transientObservedNodes = [];
    this.observer = observer;
    this.target = target;
    this.options = options;
  }
  return _createClass(Registration2, [{
    key: "enqueue",
    value: function enqueue(record) {
      var records = this.observer.records;
      var length5 = records.length;
      if (records.length > 0) {
        var lastRecord = records[length5 - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length5 - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length5] = record;
    }
  }, {
    key: "addListeners",
    value: function addListeners() {
      this.addListeners_(this.target);
    }
  }, {
    key: "addListeners_",
    value: function addListeners_(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);
      if (options.childList) node.addEventListener(ElementEvent.INSERTED, this, true);
      if (options.childList || options.subtree) node.addEventListener(ElementEvent.REMOVED, this, true);
    }
  }, {
    key: "removeListeners",
    value: function removeListeners() {
      this.removeListeners_(this.target);
    }
  }, {
    key: "removeListeners_",
    value: function removeListeners_(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);
      if (options.childList) node.removeEventListener(ElementEvent.INSERTED, this, true);
      if (options.childList || options.subtree) node.removeEventListener(ElementEvent.REMOVED, this, true);
    }
    /**
     * Adds a transient observer on node. The transient observer gets removed
     * next time we deliver the change records.
     */
    // addTransientObserver(node: IElement) {
    //   // Don't add transient observers on the target itself. We already have all
    //   // the required listeners set up on the target.
    //   if (node === this.target) return;
    //   this.addListeners_(node);
    //   this.transientObservedNodes.push(node);
    //   let registrations = registrationsTable.get(node);
    //   if (!registrations) registrationsTable.set(node, (registrations = []));
    //   // We know that registrations does not contain this because we already
    //   // checked if node === this.target.
    //   registrations.push(this);
    // }
  }, {
    key: "removeTransientObservers",
    value: function removeTransientObservers() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i2 = 0; i2 < registrations.length; i2++) {
          if (registrations[i2] === this) {
            registrations.splice(i2, 1);
            break;
          }
        }
      }, this);
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(e3) {
      e3.stopImmediatePropagation();
      var record;
      var target;
      switch (e3.type) {
        case ElementEvent.ATTR_MODIFIED:
          var name2 = e3.attrName;
          var namespace = e3.relatedNode.namespaceURI;
          target = e3.target;
          record = getRecord("attributes", target);
          record.attributeName = name2;
          record.attributeNamespace = namespace;
          var oldValue = e3.attrChange === MutationEvent.ADDITION ? null : e3.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.attributes) return;
            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name2) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
            return record;
          });
          break;
        case ElementEvent.REMOVED:
        case ElementEvent.INSERTED:
          target = e3.relatedNode;
          var changedNode = e3.target;
          var addedNodes;
          var removedNodes;
          if (e3.type === ElementEvent.INSERTED) {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {
            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;
          record = getRecord("childList", target);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.childList) return;
            return record;
          });
      }
      clearRecords();
    }
  }]);
}();
var MutationObserver = function() {
  function MutationObserver2(callback) {
    _classCallCheck(this, MutationObserver2);
    this.nodes = [];
    this.records = [];
    this.uid = uidCounter++;
    this.callback = callback;
  }
  return _createClass(MutationObserver2, [{
    key: "observe",
    value: function observe(target, options) {
      if (!options.childList && !options.attributes && !options.characterData || // 1.2
      options.attributeOldValue && !options.attributes || // 1.3
      options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4
      options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i2 = 0; i2 < registrations.length; i2++) {
        if (registrations[i2].observer === this) {
          registration = registrations[i2];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes.push(target);
      }
      registration.addListeners();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this2 = this;
      this.nodes.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i2 = 0; i2 < registrations.length; i2++) {
          var registration = registrations[i2];
          if (registration.observer === _this2) {
            registration.removeListeners();
            registrations.splice(i2, 1);
            break;
          }
        }
      }, this);
      this.records = [];
    }
  }, {
    key: "takeRecords",
    value: function takeRecords() {
      var copyOfRecords = this.records;
      this.records = [];
      return copyOfRecords;
    }
  }]);
}();
var currentRecord;
var recordWithOldValue;
function getRecord(type, target) {
  return currentRecord = new MutationRecord(type, target);
}
function getRecordWithOldValue(oldValue) {
  if (recordWithOldValue) return recordWithOldValue;
  recordWithOldValue = MutationRecord.copy(currentRecord);
  recordWithOldValue.oldValue = oldValue;
  return recordWithOldValue;
}
function clearRecords() {
  currentRecord = recordWithOldValue = void 0;
}
function recordRepresentsCurrentMutation(record) {
  return record === recordWithOldValue || record === currentRecord;
}
function selectRecord(lastRecord, newRecord) {
  if (lastRecord === newRecord) return lastRecord;
  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
  return null;
}
function removeTransientObserversFor(observer) {
  observer.nodes.forEach(function(node) {
    var registrations = registrationsTable.get(node);
    if (!registrations) return;
    registrations.forEach(function(registration) {
      if (registration.observer === observer) registration.removeTransientObservers();
    });
  });
}
function forEachAncestorAndObserverEnqueueRecord(target, callback) {
  for (var node = target; node; node = node.parentNode) {
    var registrations = registrationsTable.get(node);
    if (registrations) {
      for (var j = 0; j < registrations.length; j++) {
        var registration = registrations[j];
        var _options = registration.options;
        if (node !== target && !_options.subtree) continue;
        var record = callback(_options);
        if (record) registration.enqueue(record);
      }
    }
  }
}
var isScheduled = false;
var scheduledObservers = [];
function scheduleCallback(observer) {
  scheduledObservers.push(observer);
  if (!isScheduled) {
    isScheduled = true;
    if (typeof runtime.globalThis !== "undefined") {
      runtime.globalThis.setTimeout(dispatchCallbacks);
    } else {
      dispatchCallbacks();
    }
  }
}
function dispatchCallbacks() {
  isScheduled = false;
  var observers = scheduledObservers;
  scheduledObservers = [];
  observers.sort(function(o1, o2) {
    return o1.uid - o2.uid;
  });
  var anyNonEmpty = false;
  observers.forEach(function(observer) {
    var queue = observer.takeRecords();
    removeTransientObserversFor(observer);
    if (queue.length) {
      observer.callback(queue, observer);
      anyNonEmpty = true;
    }
  });
  if (anyNonEmpty) dispatchCallbacks();
}

// node_modules/@antv/g-web-animations-api/dist/index.esm.js
var AnimationEvent = function(_FederatedEvent) {
  function AnimationEvent2(manager, target, currentTime, timelineTime) {
    var _this2;
    _classCallCheck(this, AnimationEvent2);
    _this2 = _callSuper(this, AnimationEvent2, [manager]);
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    _this2.target = target;
    _this2.type = "finish";
    _this2.bubbles = false;
    _this2.currentTarget = target;
    _this2.defaultPrevented = false;
    _this2.eventPhase = _this2.AT_TARGET;
    _this2.timeStamp = Date.now();
    _this2.currentTime = currentTime;
    _this2.timelineTime = timelineTime;
    return _this2;
  }
  _inherits(AnimationEvent2, _FederatedEvent);
  return _createClass(AnimationEvent2);
}(FederatedEvent);
var sequenceNumber = 0;
var Animation = function() {
  function Animation2(effect, timeline) {
    var _this$effect;
    _classCallCheck(this, Animation2);
    this.currentTimePending = false;
    this._idle = true;
    this._paused = false;
    this._finishedFlag = true;
    this._currentTime = 0;
    this._playbackRate = 1;
    this._inTimeline = true;
    this.effect = effect;
    effect.animation = this;
    this.timeline = timeline;
    this.id = "".concat(sequenceNumber++);
    this._inEffect = !!this.effect.update(0);
    this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
    this._holdTime = 0;
    this._paused = false;
    this.oldPlayState = "idle";
    this.updatePromises();
  }
  return _createClass(Animation2, [{
    key: "pending",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
       */
      // animation: InternalAnimation | null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
       */
      function get4() {
        return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
      }
    )
  }, {
    key: "playState",
    get: function get4() {
      if (this._idle) return "idle";
      if (this._isFinished) return "finished";
      if (this._paused) return "paused";
      return "running";
    }
    /**
     * record previos state
     */
  }, {
    key: "ready",
    get: (
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
       * @example
        animation.pause();
        animation.ready.then(function() {
          // Displays 'running'
          alert(animation.playState);
        });
        animation.play();
       */
      function get4() {
        var _this2 = this;
        if (!this.readyPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.readyPromise = new Promise(function(resolve, reject) {
            _this2.resolveReadyPromise = function() {
              resolve(_this2);
            };
            _this2.rejectReadyPromise = function() {
              reject(new Error());
            };
          });
          if (!this.pending) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
    )
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
     * @example
      Promise.all(
        elem.getAnimations().map(
          function(animation) {
            return animation.finished
          }
        )
      ).then(
        function() {
          return elem.remove();
        }
      );
     */
  }, {
    key: "finished",
    get: function get4() {
      var _this2 = this;
      if (!this.finishedPromise) {
        if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
          this.timeline.animationsWithPromises.push(this);
        }
        this.finishedPromise = new Promise(function(resolve, reject) {
          _this2.resolveFinishedPromise = function() {
            resolve(_this2);
          };
          _this2.rejectFinishedPromise = function() {
            reject(new Error());
          };
        });
        if (this.playState === "finished") {
          this.resolveFinishedPromise();
        }
      }
      return this.finishedPromise;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
     */
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/oncancel
     */
    /**
     * get called after each frame when running
     */
  }, {
    key: "currentTime",
    get: function get4() {
      this.updatePromises();
      return this._idle || this.currentTimePending ? null : this._currentTime;
    },
    set: function set10(newTime) {
      newTime = Number(newTime);
      if (isNaN(newTime)) return;
      this.timeline.restart();
      if (!this._paused && this._startTime !== null) {
        var _this$timeline;
        this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
      }
      this.currentTimePending = false;
      if (this._currentTime === newTime) {
        return;
      }
      if (this._idle) {
        this._idle = false;
        this._paused = true;
      }
      this.tickCurrentTime(newTime, true);
      this.timeline.applyDirtiedAnimation(this);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
     */
  }, {
    key: "startTime",
    get: function get4() {
      return this._startTime;
    },
    set: function set10(newTime) {
      if (newTime !== null) {
        this.updatePromises();
        newTime = Number(newTime);
        if (isNaN(newTime)) return;
        if (this._paused || this._idle) return;
        this._startTime = newTime;
        this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    }
  }, {
    key: "playbackRate",
    get: function get4() {
      return this._playbackRate;
    },
    set: function set10(value2) {
      if (value2 === this._playbackRate) {
        return;
      }
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this._playbackRate = value2;
      this.startTime = null;
      if (this.playState !== "paused" && this.playState !== "idle") {
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
      }
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
  }, {
    key: "_isFinished",
    get: function get4() {
      return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
    }
  }, {
    key: "totalDuration",
    get: function get4() {
      return this._totalDuration;
    }
  }, {
    key: "_needsTick",
    get: function get4() {
      return this.pending || this.playState === "running" || !this._finishedFlag;
    }
  }, {
    key: "updatePromises",
    value: function updatePromises() {
      var _this$effect$target;
      if ((_this$effect$target = this.effect.target) !== null && _this$effect$target !== void 0 && _this$effect$target.destroyed) {
        this.readyPromise = void 0;
        this.finishedPromise = void 0;
        return false;
      }
      var oldPlayState = this.oldPlayState;
      var newPlayState = this.pending ? "pending" : this.playState;
      if (this.readyPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectReadyPromise();
          this.readyPromise = void 0;
        } else if (oldPlayState === "pending") {
          this.resolveReadyPromise();
        } else if (newPlayState === "pending") {
          this.readyPromise = void 0;
        }
      }
      if (this.finishedPromise && newPlayState !== oldPlayState) {
        if (newPlayState === "idle") {
          this.rejectFinishedPromise();
          this.finishedPromise = void 0;
        } else if (newPlayState === "finished") {
          this.resolveFinishedPromise();
        } else if (oldPlayState === "finished") {
          this.finishedPromise = void 0;
        }
      }
      this.oldPlayState = newPlayState;
      return this.readyPromise || this.finishedPromise;
    }
  }, {
    key: "play",
    value: function play() {
      this.updatePromises();
      this._paused = false;
      if (this._isFinished || this._idle) {
        this.rewind();
        this._startTime = null;
      }
      this._finishedFlag = false;
      this._idle = false;
      this.ensureAlive();
      this.timeline.applyDirtiedAnimation(this);
      if (this.timeline.animations.indexOf(this) === -1) {
        this.timeline.animations.push(this);
      }
      this.updatePromises();
    }
  }, {
    key: "pause",
    value: function pause() {
      this.updatePromises();
      if (this.currentTime) {
        this._holdTime = this.currentTime;
      }
      if (!this._isFinished && !this._paused && !this._idle) {
        this.currentTimePending = true;
      } else if (this._idle) {
        this.rewind();
        this._idle = false;
      }
      this._startTime = null;
      this._paused = true;
      this.updatePromises();
    }
  }, {
    key: "finish",
    value: function finish() {
      this.updatePromises();
      if (this._idle) return;
      this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
      this._startTime = this._totalDuration - this.currentTime;
      this.currentTimePending = false;
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
    }
  }, {
    key: "cancel",
    value: function cancel2() {
      var _this3 = this;
      this.updatePromises();
      if (!this._inEffect) return;
      this._inEffect = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = 0;
      this._startTime = null;
      this.effect.update(null);
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
      if (this.oncancel) {
        var event = new AnimationEvent(null, this, this.currentTime, null);
        setTimeout(function() {
          _this3.oncancel(event);
        });
      }
    }
  }, {
    key: "reverse",
    value: function reverse2() {
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this.playbackRate *= -1;
      this.play();
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
     */
  }, {
    key: "updatePlaybackRate",
    value: function updatePlaybackRate(playbackRate) {
      this.playbackRate = playbackRate;
    }
  }, {
    key: "targetAnimations",
    value: function targetAnimations() {
      var _this$effect2;
      var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
      return target.getAnimations();
    }
  }, {
    key: "markTarget",
    value: function markTarget() {
      var animations = this.targetAnimations();
      if (animations.indexOf(this) === -1) {
        animations.push(this);
      }
    }
  }, {
    key: "unmarkTarget",
    value: function unmarkTarget() {
      var animations = this.targetAnimations();
      var index3 = animations.indexOf(this);
      if (index3 !== -1) {
        animations.splice(index3, 1);
      }
    }
  }, {
    key: "tick",
    value: function tick3(timelineTime, isAnimationFrame) {
      if (!this._idle && !this._paused) {
        if (this._startTime === null) {
          if (isAnimationFrame) {
            this.startTime = timelineTime - this._currentTime / this.playbackRate;
          }
        } else if (!this._isFinished) {
          this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
        }
      }
      if (isAnimationFrame) {
        this.currentTimePending = false;
        this.fireEvents(timelineTime);
      }
    }
  }, {
    key: "rewind",
    value: function rewind() {
      if (this.playbackRate >= 0) {
        this.currentTime = 0;
      } else if (this._totalDuration < Infinity) {
        this.currentTime = this._totalDuration;
      } else {
        throw new Error("Unable to rewind negative playback rate animation with infinite duration");
      }
    }
  }, {
    key: "persist",
    value: function persist() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
  }, {
    key: "commitStyles",
    value: (
      // replaceState: AnimationReplaceState;
      function commitStyles() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    )
  }, {
    key: "ensureAlive",
    value: function ensureAlive() {
      if (this.playbackRate < 0 && this.currentTime === 0) {
        var _this$effect3;
        this._inEffect = !!((_this$effect3 = this.effect) !== null && _this$effect3 !== void 0 && _this$effect3.update(-1));
      } else {
        var _this$effect4;
        this._inEffect = !!((_this$effect4 = this.effect) !== null && _this$effect4 !== void 0 && _this$effect4.update(this.currentTime));
      }
      if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
        this._inTimeline = true;
        this.timeline.animations.push(this);
      }
    }
  }, {
    key: "tickCurrentTime",
    value: function tickCurrentTime(newTime, ignoreLimit) {
      if (newTime !== this._currentTime) {
        this._currentTime = newTime;
        if (this._isFinished && !ignoreLimit) {
          this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        }
        this.ensureAlive();
      }
    }
  }, {
    key: "fireEvents",
    value: function fireEvents(baseTime) {
      var _this4 = this;
      if (this._isFinished) {
        if (!this._finishedFlag) {
          if (this.onfinish) {
            var event = new AnimationEvent(null, this, this.currentTime, baseTime);
            setTimeout(function() {
              if (_this4.onfinish) {
                _this4.onfinish(event);
              }
            });
          }
          this._finishedFlag = true;
        }
      } else {
        if (this.onframe && this.playState === "running") {
          var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
          this.onframe(_event);
        }
        this._finishedFlag = false;
      }
    }
  }]);
}();
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
var A = function A2(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
};
var B = function B2(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
};
var C = function C2(aA1) {
  return 3 * aA1;
};
var calcBezier = function calcBezier2(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
};
var getSlope = function getSlope2(aT, aA1, aA2) {
  return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
};
var binarySubdivide = function binarySubdivide2(aX, aA, aB, mX1, mX2) {
  var currentX;
  var currentT;
  var i2 = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) aB = currentT;
    else aA = currentT;
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
};
var newtonRaphsonIterate = function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
  for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
};
var bezier2 = function bezier3(mX1, mY1, mX2, mY2) {
  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) throw new Error("bezier x values must be in [0, 1] range");
  if (mX1 === mY1 && mX2 === mY2) return function(t) {
    return t;
  };
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
  }
  var getTForX = function getTForX2(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
    --currentSample;
    var dist5 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist5 * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    if (initialSlope === 0) return guessForT;
    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
  };
  return function(t) {
    if (t === 0 || t === 1) return t;
    return calcBezier(getTForX(t), mY1, mY2);
  };
};
var convertToDash = function convertToDash2(str7) {
  str7 = str7.replace(/([A-Z])/g, function(letter) {
    return "-".concat(letter.toLowerCase());
  });
  return str7.charAt(0) === "-" ? str7.substring(1) : str7;
};
var Quad = function Quad2(t) {
  return Math.pow(t, 2);
};
var Cubic = function Cubic2(t) {
  return Math.pow(t, 3);
};
var Quart = function Quart2(t) {
  return Math.pow(t, 4);
};
var Quint = function Quint2(t) {
  return Math.pow(t, 5);
};
var Expo = function Expo2(t) {
  return Math.pow(t, 6);
};
var Sine = function Sine2(t) {
  return 1 - Math.cos(t * Math.PI / 2);
};
var Circ = function Circ2(t) {
  return 1 - Math.sqrt(1 - t * t);
};
var Back = function Back2(t) {
  return t * t * (3 * t - 2);
};
var Bounce = function Bounce2(t) {
  var pow22;
  var b = 4;
  while (t < ((pow22 = Math.pow(2, --b)) - 1) / 11) {
  }
  return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow22 * 3 - 2) / 22 - t, 2);
};
var Elastic = function Elastic2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _params = _slicedToArray(params, 2), _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
  var a5 = clamp_default(Number(amplitude), 1, 10);
  var p3 = clamp_default(Number(period), 0.1, 2);
  if (t === 0 || t === 1) return t;
  return -a5 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p3 / (Math.PI * 2) * Math.asin(1 / a5)) * (Math.PI * 2) / p3);
};
var Spring = function Spring2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var duration = arguments.length > 2 ? arguments[2] : void 0;
  var _params2 = _slicedToArray(params, 4), _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
  mass = clamp_default(mass, 0.1, 1e3);
  stiffness = clamp_default(stiffness, 0.1, 1e3);
  damping = clamp_default(damping, 0.1, 1e3);
  velocity = clamp_default(velocity, 0.1, 1e3);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a5 = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
  var progress = duration ? duration * t / 1e3 : t;
  if (zeta < 1) {
    progress = Math.exp(-progress * zeta * w0) * (a5 * Math.cos(wd * progress) + b * Math.sin(wd * progress));
  } else {
    progress = (a5 + b * progress) * Math.exp(-progress * w0);
  }
  if (t === 0 || t === 1) return t;
  return 1 - progress;
};
var Steps = function Steps2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _ref = params, _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], steps = _ref2$ === void 0 ? 10 : _ref2$, type = _ref2[1];
  var trunc = type === "start" ? Math.ceil : Math.floor;
  return trunc(clamp_default(t, 0, 1) * steps) / steps;
};
var Bezier = function Bezier2(t) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _params3 = _slicedToArray(params, 4), mX1 = _params3[0], mY1 = _params3[1], mX2 = _params3[2], mY2 = _params3[3];
  return bezier2(mX1, mY1, mX2, mY2)(t);
};
var easein = bezier2(0.42, 0, 1, 1);
var EaseOut = function EaseOut2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return 1 - ease2(1 - t, params, duration);
  };
};
var EaseInOut = function EaseInOut2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return t < 0.5 ? ease2(t * 2, params, duration) / 2 : 1 - ease2(t * -2 + 2, params, duration) / 2;
  };
};
var EaseOutIn = function EaseOutIn2(ease2) {
  return function(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    return t < 0.5 ? (1 - ease2(1 - t * 2, params, duration)) / 2 : (ease2(t * 2 - 1, params, duration) + 1) / 2;
  };
};
var EasingFunctions = {
  steps: Steps,
  "step-start": function stepStart(t) {
    return Steps(t, [1, "start"]);
  },
  "step-end": function stepEnd(t) {
    return Steps(t, [1, "end"]);
  },
  linear: function linear(t) {
    return t;
  },
  "cubic-bezier": Bezier,
  ease: function ease(t) {
    return Bezier(t, [0.25, 0.1, 0.25, 1]);
  },
  "in": easein,
  out: EaseOut(easein),
  "in-out": EaseInOut(easein),
  "out-in": EaseOutIn(easein),
  "in-quad": Quad,
  "out-quad": EaseOut(Quad),
  "in-out-quad": EaseInOut(Quad),
  "out-in-quad": EaseOutIn(Quad),
  "in-cubic": Cubic,
  "out-cubic": EaseOut(Cubic),
  "in-out-cubic": EaseInOut(Cubic),
  "out-in-cubic": EaseOutIn(Cubic),
  "in-quart": Quart,
  "out-quart": EaseOut(Quart),
  "in-out-quart": EaseInOut(Quart),
  "out-in-quart": EaseOutIn(Quart),
  "in-quint": Quint,
  "out-quint": EaseOut(Quint),
  "in-out-quint": EaseInOut(Quint),
  "out-in-quint": EaseOutIn(Quint),
  "in-expo": Expo,
  "out-expo": EaseOut(Expo),
  "in-out-expo": EaseInOut(Expo),
  "out-in-expo": EaseOutIn(Expo),
  "in-sine": Sine,
  "out-sine": EaseOut(Sine),
  "in-out-sine": EaseInOut(Sine),
  "out-in-sine": EaseOutIn(Sine),
  "in-circ": Circ,
  "out-circ": EaseOut(Circ),
  "in-out-circ": EaseInOut(Circ),
  "out-in-circ": EaseOutIn(Circ),
  "in-back": Back,
  "out-back": EaseOut(Back),
  "in-out-back": EaseInOut(Back),
  "out-in-back": EaseOutIn(Back),
  "in-bounce": Bounce,
  "out-bounce": EaseOut(Bounce),
  "in-out-bounce": EaseInOut(Bounce),
  "out-in-bounce": EaseOutIn(Bounce),
  "in-elastic": Elastic,
  "out-elastic": EaseOut(Elastic),
  "in-out-elastic": EaseInOut(Elastic),
  "out-in-elastic": EaseOutIn(Elastic),
  spring: Spring,
  "spring-in": Spring,
  "spring-out": EaseOut(Spring),
  "spring-in-out": EaseInOut(Spring),
  "spring-out-in": EaseOutIn(Spring)
};
var complexEasingSyntax = function complexEasingSyntax2(ease2) {
  return convertToDash(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
};
var getEasingFunction = function getEasingFunction2(ease2) {
  return EasingFunctions[complexEasingSyntax(ease2)] || EasingFunctions.linear;
};
var linear2 = function linear3(x3) {
  return x3;
};
var Start = 1;
var Middle = 0.5;
var End = 0;
function step(count4, pos) {
  return function(x3) {
    if (x3 >= 1) {
      return 1;
    }
    var stepSize = 1 / count4;
    x3 += pos * stepSize;
    return x3 - x3 % stepSize;
  };
}
var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
var cubicBezierRe = new RegExp("cubic-bezier\\(".concat(numberString, ",").concat(numberString, ",").concat(numberString, ",").concat(numberString, "\\)"));
var step1Re = /steps\(\s*(\d+)\s*\)/;
var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
function parseEasingFunction(normalizedEasing) {
  var cubicData = cubicBezierRe.exec(normalizedEasing);
  if (cubicData) {
    return bezier2.apply(void 0, _toConsumableArray(cubicData.slice(1).map(Number)));
  }
  var step1Data = step1Re.exec(normalizedEasing);
  if (step1Data) {
    return step(Number(step1Data[1]), End);
  }
  var step2Data = step2Re.exec(normalizedEasing);
  if (step2Data) {
    return step(Number(step2Data[1]), {
      start: Start,
      middle: Middle,
      end: End
    }[step2Data[2]]);
  }
  return getEasingFunction(normalizedEasing);
}
function calculateActiveDuration(timing) {
  return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
}
function repeatedDuration(timing) {
  var _timing$iterations;
  if (timing.duration === 0 || timing.iterations === 0) {
    return 0;
  }
  return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
}
var PhaseNone = 0;
var PhaseBefore = 1;
var PhaseAfter = 2;
var PhaseActive = 3;
function calculatePhase(activeDuration, localTime, timing) {
  if (localTime === null) {
    return PhaseNone;
  }
  var endTime = timing.endTime;
  if (localTime < Math.min(timing.delay, endTime)) {
    return PhaseBefore;
  }
  if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
    return PhaseAfter;
  }
  return PhaseActive;
}
function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
  switch (phase) {
    case PhaseBefore:
      if (fillMode === "backwards" || fillMode === "both") return 0;
      return null;
    case PhaseActive:
      return localTime - delay;
    case PhaseAfter:
      if (fillMode === "forwards" || fillMode === "both") return activeDuration;
      return null;
    case PhaseNone:
      return null;
  }
}
function calculateOverallProgress(iterationDuration, phase, iterations2, activeTime, iterationStart) {
  var overallProgress = iterationStart;
  if (iterationDuration === 0) {
    if (phase !== PhaseBefore) {
      overallProgress += iterations2;
    }
  } else {
    overallProgress += activeTime / iterationDuration;
  }
  return overallProgress;
}
function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations2, activeTime, iterationDuration) {
  var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
  if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations2 !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
    simpleIterationProgress = 1;
  }
  return simpleIterationProgress;
}
function calculateCurrentIteration(phase, iterations2, simpleIterationProgress, overallProgress) {
  if (phase === PhaseAfter && iterations2 === Infinity) {
    return Infinity;
  }
  if (simpleIterationProgress === 1) {
    return Math.floor(overallProgress) - 1;
  }
  return Math.floor(overallProgress);
}
function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
  var currentDirection = playbackDirection;
  if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
    var d4 = currentIteration;
    if (playbackDirection === "alternate-reverse") {
      d4 += 1;
    }
    currentDirection = "normal";
    if (d4 !== Infinity && d4 % 2 !== 0) {
      currentDirection = "reverse";
    }
  }
  if (currentDirection === "normal") {
    return simpleIterationProgress;
  }
  return 1 - simpleIterationProgress;
}
function calculateIterationProgress(activeDuration, localTime, timing) {
  var phase = calculatePhase(activeDuration, localTime, timing);
  var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
  if (activeTime === null) return null;
  var duration = timing.duration === "auto" ? 0 : timing.duration;
  var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
  var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
  var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
  var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
  timing.currentIteration = currentIteration;
  timing.progress = directedProgress;
  return timing.easingFunction(directedProgress);
}
function convertEffectInput(keyframes, timing, target) {
  var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
  var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
  return function(target2, fraction) {
    if (fraction !== null) {
      interpolations.filter(function(interpolation) {
        return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
      }).forEach(function(interpolation) {
        var offsetFraction = fraction - interpolation.startOffset;
        var localDuration = interpolation.endOffset - interpolation.startOffset;
        var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;
        target2.setAttribute(
          interpolation.property,
          interpolation.interpolation(scaledLocalTime),
          false,
          false
          // disable memoize
        );
      });
    } else {
      for (var property in propertySpecificKeyframeGroups) if (isNotReservedWord(property)) {
        target2.setAttribute(property, null);
      }
    }
  };
}
function isNotReservedWord(member) {
  return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
}
function makePropertySpecificKeyframeGroups(keyframes, timing) {
  var propertySpecificKeyframeGroups = {};
  for (var i2 = 0; i2 < keyframes.length; i2++) {
    for (var member in keyframes[i2]) {
      if (isNotReservedWord(member)) {
        var propertySpecificKeyframe = {
          offset: keyframes[i2].offset,
          computedOffset: keyframes[i2].computedOffset,
          easing: keyframes[i2].easing,
          easingFunction: parseEasingFunction(keyframes[i2].easing) || timing.easingFunction,
          value: keyframes[i2][member]
        };
        propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
        propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
      }
    }
  }
  return propertySpecificKeyframeGroups;
}
function makeInterpolations(propertySpecificKeyframeGroups, target) {
  var interpolations = [];
  for (var groupName in propertySpecificKeyframeGroups) {
    var keyframes = propertySpecificKeyframeGroups[groupName];
    for (var i2 = 0; i2 < keyframes.length - 1; i2++) {
      var startIndex = i2;
      var endIndex = i2 + 1;
      var startOffset = keyframes[startIndex].computedOffset;
      var endOffset = keyframes[endIndex].computedOffset;
      var applyFrom = startOffset;
      var applyTo = endOffset;
      if (i2 === 0) {
        applyFrom = -Infinity;
        if (endOffset === 0) {
          endIndex = startIndex;
        }
      }
      if (i2 === keyframes.length - 2) {
        applyTo = Infinity;
        if (startOffset === 1) {
          startIndex = endIndex;
        }
      }
      interpolations.push({
        applyFrom,
        applyTo,
        startOffset: keyframes[startIndex].computedOffset,
        endOffset: keyframes[endIndex].computedOffset,
        easingFunction: keyframes[startIndex].easingFunction,
        property: groupName,
        interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
      });
    }
  }
  interpolations.sort(function(leftInterpolation, rightInterpolation) {
    return leftInterpolation.startOffset - rightInterpolation.startOffset;
  });
  return interpolations;
}
var InterpolationFactory = function InterpolationFactory2(from, to, convertToString) {
  return function(f2) {
    var interpolated = interpolate2(from, to, f2);
    return isNumber(interpolated) ? interpolated : convertToString(interpolated);
  };
};
function propertyInterpolation(property, left2, right2, target) {
  var metadata = propertyMetadataCache[property];
  if (metadata && metadata.syntax && metadata["int"]) {
    var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
    if (propertyHandler) {
      var parser2 = propertyHandler.parser;
      var usedLeft = parser2 ? parser2(left2, target) : left2;
      var usedRight = parser2 ? parser2(right2, target) : right2;
      var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
      if (interpolationArgs) {
        var interp = InterpolationFactory.apply(void 0, _toConsumableArray(interpolationArgs));
        return function(t) {
          if (t === 0) return left2;
          if (t === 1) return right2;
          return interp(t);
        };
      }
    }
  }
  return InterpolationFactory(false, true, function(bool) {
    return bool ? right2 : left2;
  });
}
function interpolate2(from, to, f2) {
  if (typeof from === "number" && typeof to === "number") {
    return from * (1 - f2) + to * f2;
  }
  if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
    return f2 < 0.5 ? from : to;
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    var fromLength = from.length;
    var toLength = to.length;
    var length5 = Math.max(fromLength, toLength);
    var r2 = [];
    for (var i2 = 0; i2 < length5; i2++) {
      r2.push(interpolate2(from[i2 < fromLength ? i2 : fromLength - 1], to[i2 < toLength ? i2 : toLength - 1], f2));
    }
    return r2;
  }
  throw new Error("Mismatched interpolation arguments ".concat(from, ":").concat(to));
}
var AnimationEffectTiming = function() {
  function AnimationEffectTiming2() {
    _classCallCheck(this, AnimationEffectTiming2);
    this.delay = 0;
    this.direction = "normal";
    this.duration = "auto";
    this._easing = "linear";
    this.easingFunction = linear2;
    this.endDelay = 0;
    this.fill = "auto";
    this.iterationStart = 0;
    this.iterations = 1;
    this.currentIteration = null;
    this.progress = null;
  }
  return _createClass(AnimationEffectTiming2, [{
    key: "easing",
    get: function get4() {
      return this._easing;
    },
    set: function set10(value2) {
      this.easingFunction = parseEasingFunction(value2);
      this._easing = value2;
    }
  }]);
}();
function convertToArrayForm(effectInput) {
  var normalizedEffectInput = [];
  for (var property in effectInput) {
    if (property in ["easing", "offset", "composite"]) {
      continue;
    }
    var values4 = effectInput[property];
    if (!Array.isArray(values4)) {
      values4 = [values4];
    }
    var numKeyframes = values4.length;
    for (var i2 = 0; i2 < numKeyframes; i2++) {
      if (!normalizedEffectInput[i2]) {
        var keyframe = {};
        if ("offset" in effectInput) {
          keyframe.offset = Number(effectInput.offset);
        }
        if ("easing" in effectInput) {
          keyframe.easing = effectInput.easing;
        }
        if ("composite" in effectInput) {
          keyframe.composite = effectInput.composite;
        }
        normalizedEffectInput[i2] = keyframe;
      }
      if (values4[i2] !== void 0 && values4[i2] !== null) {
        normalizedEffectInput[i2][property] = values4[i2];
      }
    }
  }
  normalizedEffectInput.sort(function(a5, b) {
    return (a5.computedOffset || 0) - (b.computedOffset || 0);
  });
  return normalizedEffectInput;
}
function normalizeKeyframes(effectInput, timing) {
  if (effectInput === null) {
    return [];
  }
  if (!Array.isArray(effectInput)) {
    effectInput = convertToArrayForm(effectInput);
  }
  var keyframes = effectInput.map(function(originalKeyframe) {
    var keyframe = {};
    if (timing !== null && timing !== void 0 && timing.composite) {
      keyframe.composite = "auto";
    }
    for (var member in originalKeyframe) {
      var memberValue = originalKeyframe[member];
      if (member === "offset") {
        if (memberValue !== null) {
          memberValue = Number(memberValue);
          if (!isFinite(memberValue)) throw new Error("Keyframe offsets must be numbers.");
          if (memberValue < 0 || memberValue > 1) throw new Error("Keyframe offsets must be between 0 and 1.");
          keyframe.computedOffset = memberValue;
        }
      } else if (member === "composite") {
        if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
          throw new Error("".concat(memberValue, " compositing is not supported"));
        }
      } else ;
      keyframe[member] = memberValue;
    }
    if (keyframe.offset === void 0) {
      keyframe.offset = null;
    }
    if (keyframe.easing === void 0) {
      keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
    }
    if (keyframe.composite === void 0) {
      keyframe.composite = "auto";
    }
    return keyframe;
  });
  var everyFrameHasOffset = true;
  var previousOffset = -Infinity;
  for (var i2 = 0; i2 < keyframes.length; i2++) {
    var offset2 = keyframes[i2].offset;
    if (!isNil(offset2)) {
      if (offset2 < previousOffset) {
        throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
      }
      previousOffset = offset2;
    } else {
      everyFrameHasOffset = false;
    }
  }
  keyframes = keyframes.filter(function(keyframe) {
    return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
  });
  function spaceKeyframes() {
    var _keyframes$offset;
    var _keyframes = keyframes, length5 = _keyframes.length;
    keyframes[length5 - 1].computedOffset = Number((_keyframes$offset = keyframes[length5 - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
    if (length5 > 1) {
      var _keyframes$0$offset;
      keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
    }
    var previousIndex = 0;
    var previousOffset2 = Number(keyframes[0].computedOffset);
    for (var _i = 1; _i < length5; _i++) {
      var _offset = keyframes[_i].computedOffset;
      if (!isNil(_offset) && !isNil(previousOffset2)) {
        for (var j = 1; j < _i - previousIndex; j++) keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
        previousIndex = _i;
        previousOffset2 = Number(_offset);
      }
    }
  }
  if (!everyFrameHasOffset) spaceKeyframes();
  return keyframes;
}
var fills = "backwards|forwards|both|none".split("|");
var directions = "reverse|alternate|alternate-reverse".split("|");
function makeTiming(timingInput, forGroup) {
  var timing = new AnimationEffectTiming();
  if (forGroup) {
    timing.fill = "both";
    timing.duration = "auto";
  }
  if (typeof timingInput === "number" && !isNaN(timingInput)) {
    timing.duration = timingInput;
  } else if (timingInput !== void 0) {
    Object.keys(timingInput).forEach(function(property) {
      if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
        if (typeof timing[property] === "number" || property === "duration") {
          if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
            return;
          }
        }
        if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
          return;
        }
        if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
          return;
        }
        timing[property] = timingInput[property];
      }
    });
  }
  return timing;
}
function normalizeTimingInput(timingInput, forGroup) {
  timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : {
    duration: "auto"
  });
  return makeTiming(timingInput, forGroup);
}
function numericTimingToObject(timingInput) {
  if (typeof timingInput === "number") {
    if (isNaN(timingInput)) {
      timingInput = {
        duration: "auto"
      };
    } else {
      timingInput = {
        duration: timingInput
      };
    }
  }
  return timingInput;
}
var KeyframeEffect = function() {
  function KeyframeEffect2(target, effectInput, timingInput) {
    var _this2 = this;
    _classCallCheck(this, KeyframeEffect2);
    this.composite = "replace";
    this.iterationComposite = "replace";
    this.target = target;
    this.timing = normalizeTimingInput(timingInput, false);
    this.timing.effect = this;
    this.timing.activeDuration = calculateActiveDuration(this.timing);
    this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
    this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
    this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
    var Proxy2 = runtime.globalThis.Proxy;
    this.computedTiming = Proxy2 ? new Proxy2(this.timing, {
      get: function get4(target2, prop) {
        if (prop === "duration") {
          return target2.duration === "auto" ? 0 : target2.duration;
        }
        if (prop === "fill") {
          return target2.fill === "auto" ? "none" : target2.fill;
        }
        if (prop === "localTime") {
          return _this2.animation && _this2.animation.currentTime || null;
        }
        if (prop === "currentIteration") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.currentIteration || 0;
        }
        if (prop === "progress") {
          if (!_this2.animation || _this2.animation.playState !== "running") {
            return null;
          }
          return target2.progress || 0;
        }
        return target2[prop];
      },
      set: function set10() {
        return true;
      }
    }) : this.timing;
  }
  return _createClass(KeyframeEffect2, [{
    key: "applyInterpolations",
    value: function applyInterpolations() {
      this.interpolations(this.target, Number(this.timeFraction));
    }
  }, {
    key: "update",
    value: function update2(localTime) {
      if (localTime === null) {
        return false;
      }
      this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
      return this.timeFraction !== null;
    }
  }, {
    key: "getKeyframes",
    value: function getKeyframes() {
      return this.normalizedKeyframes;
    }
  }, {
    key: "setKeyframes",
    value: function setKeyframes(keyframes) {
      this.normalizedKeyframes = normalizeKeyframes(keyframes);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
     */
  }, {
    key: "getComputedTiming",
    value: function getComputedTiming() {
      return this.computedTiming;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
     */
  }, {
    key: "getTiming",
    value: function getTiming() {
      return this.timing;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
     */
  }, {
    key: "updateTiming",
    value: function updateTiming(timing) {
      var _this2 = this;
      Object.keys(timing || {}).forEach(function(name2) {
        _this2.timing[name2] = timing[name2];
      });
    }
  }]);
}();
function compareAnimations(leftAnimation, rightAnimation) {
  return Number(leftAnimation.id) - Number(rightAnimation.id);
}
var AnimationTimeline = function() {
  function AnimationTimeline2(document2) {
    var _this2 = this;
    _classCallCheck(this, AnimationTimeline2);
    this.animations = [];
    this.ticking = false;
    this.timelineTicking = false;
    this.hasRestartedThisFrame = false;
    this.animationsWithPromises = [];
    this.inTick = false;
    this.pendingEffects = [];
    this.currentTime = null;
    this.rafId = 0;
    this.rafCallbacks = [];
    this.webAnimationsNextTick = function(t) {
      _this2.currentTime = t;
      _this2.discardAnimations();
      if (_this2.animations.length === 0) {
        _this2.timelineTicking = false;
      } else {
        _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
      }
    };
    this.processRafCallbacks = function(t) {
      var processing = _this2.rafCallbacks;
      _this2.rafCallbacks = [];
      if (t < Number(_this2.currentTime)) t = Number(_this2.currentTime);
      _this2.animations.sort(compareAnimations);
      _this2.animations = _this2.tick(t, true, _this2.animations)[0];
      processing.forEach(function(entry) {
        entry[1](t);
      });
      _this2.applyPendingEffects();
    };
    this.document = document2;
  }
  return _createClass(AnimationTimeline2, [{
    key: "getAnimations",
    value: function getAnimations() {
      this.discardAnimations();
      return this.animations.slice();
    }
  }, {
    key: "isTicking",
    value: function isTicking() {
      return this.inTick;
    }
  }, {
    key: "play",
    value: function play(target, keyframes, options) {
      var effect = new KeyframeEffect(target, keyframes, options);
      var animation = new Animation(effect, this);
      this.animations.push(animation);
      this.restartWebAnimationsNextTick();
      animation.updatePromises();
      animation.play();
      animation.updatePromises();
      return animation;
    }
    // RAF is supposed to be the last script to occur before frame rendering but not
    // all browsers behave like this. This function is for synchonously updating an
    // animation's effects whenever its state is mutated by script to work around
    // incorrect script execution ordering by the browser.
  }, {
    key: "applyDirtiedAnimation",
    value: function applyDirtiedAnimation(animation) {
      var _this2 = this;
      if (this.inTick) {
        return;
      }
      animation.markTarget();
      var animations = animation.targetAnimations();
      animations.sort(compareAnimations);
      var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
      inactiveAnimations.forEach(function(animation2) {
        var index3 = _this2.animations.indexOf(animation2);
        if (index3 !== -1) {
          _this2.animations.splice(index3, 1);
        }
      });
      this.applyPendingEffects();
    }
  }, {
    key: "restart",
    value: function restart() {
      if (!this.ticking) {
        this.ticking = true;
        this.requestAnimationFrame(function() {
        });
        this.hasRestartedThisFrame = true;
      }
      return this.hasRestartedThisFrame;
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.document.defaultView.cancelAnimationFrame(this.frameId);
    }
  }, {
    key: "applyPendingEffects",
    value: function applyPendingEffects() {
      this.pendingEffects.forEach(function(effect) {
        effect === null || effect === void 0 || effect.applyInterpolations();
      });
      this.pendingEffects = [];
    }
  }, {
    key: "updateAnimationsPromises",
    value: function updateAnimationsPromises() {
      this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
        return animation.updatePromises();
      });
    }
  }, {
    key: "discardAnimations",
    value: function discardAnimations() {
      this.updateAnimationsPromises();
      this.animations = this.animations.filter(function(animation) {
        return animation.playState !== "finished" && animation.playState !== "idle";
      });
    }
  }, {
    key: "restartWebAnimationsNextTick",
    value: function restartWebAnimationsNextTick() {
      if (!this.timelineTicking) {
        this.timelineTicking = true;
        this.requestAnimationFrame(this.webAnimationsNextTick);
      }
    }
  }, {
    key: "rAF",
    value: function rAF(f2) {
      var id4 = this.rafId++;
      if (this.rafCallbacks.length === 0) {
        this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
      }
      this.rafCallbacks.push([id4, f2]);
      return id4;
    }
  }, {
    key: "requestAnimationFrame",
    value: function requestAnimationFrame3(f2) {
      var _this3 = this;
      return this.rAF(function(x3) {
        _this3.updateAnimationsPromises();
        f2(x3);
        _this3.updateAnimationsPromises();
      });
    }
  }, {
    key: "tick",
    value: function tick3(t, isAnimationFrame, updatingAnimations) {
      var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
      this.inTick = true;
      this.hasRestartedThisFrame = false;
      this.currentTime = t;
      this.ticking = false;
      var newPendingClears = [];
      var newPendingEffects = [];
      var activeAnimations = [];
      var inactiveAnimations = [];
      updatingAnimations.forEach(function(animation) {
        animation.tick(t, isAnimationFrame);
        if (!animation._inEffect) {
          newPendingClears.push(animation.effect);
          animation.unmarkTarget();
        } else {
          newPendingEffects.push(animation.effect);
          animation.markTarget();
        }
        if (animation._needsTick) _this4.ticking = true;
        var alive = animation._inEffect || animation._needsTick;
        animation._inTimeline = alive;
        if (alive) {
          activeAnimations.push(animation);
        } else {
          inactiveAnimations.push(animation);
        }
      });
      (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
      (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
      if (this.ticking) this.requestAnimationFrame(function() {
      });
      this.inTick = false;
      return [activeAnimations, inactiveAnimations];
    }
  }]);
}();
runtime.EasingFunction = parseEasingFunction;
runtime.AnimationTimeline = AnimationTimeline;

// node_modules/@antv/g2/esm/utils/selection.js
function select(node) {
  return new Selection([node], null, node, node.ownerDocument);
}
var Selection = class _Selection {
  constructor(elements = null, data2 = null, parent = null, document2 = null, selections = [
    null,
    null,
    null,
    null,
    null
  ], transitions = [], updateElements = []) {
    this._elements = Array.from(elements);
    this._data = data2;
    this._parent = parent;
    this._document = document2;
    this._enter = selections[0];
    this._update = selections[1];
    this._exit = selections[2];
    this._merge = selections[3];
    this._split = selections[4];
    this._transitions = transitions;
    this._facetElements = updateElements;
  }
  selectAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(elements, null, this._elements[0], this._document);
  }
  selectFacetAll(selector) {
    const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
    return new _Selection(this._elements, null, this._parent, this._document, void 0, void 0, elements);
  }
  /**
   * @todo Replace with querySelector which has bug now.
   */
  select(selector) {
    const element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
    return new _Selection([element], null, element, this._document);
  }
  append(node) {
    const callback = typeof node === "function" ? node : () => this.createElement(node);
    const elements = [];
    if (this._data !== null) {
      for (let i2 = 0; i2 < this._data.length; i2++) {
        const d4 = this._data[i2];
        const [datum, from] = Array.isArray(d4) ? d4 : [d4, null];
        const newElement = callback(datum, i2);
        newElement.__data__ = datum;
        if (from !== null)
          newElement.__fromElements__ = from;
        this._parent.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, this._parent, this._document);
    } else {
      for (let i2 = 0; i2 < this._elements.length; i2++) {
        const element = this._elements[i2];
        const datum = element.__data__;
        const newElement = callback(datum, i2);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _Selection(elements, null, elements[0], this._document);
    }
  }
  maybeAppend(id4, node, className2) {
    const element = this._elements[0];
    const child = element.getElementById(id4);
    if (child) {
      return new _Selection([child], null, this._parent, this._document);
    }
    const newChild = typeof node === "string" ? this.createElement(node) : node();
    newChild.id = id4;
    if (className2)
      newChild.className = className2;
    element.appendChild(newChild);
    return new _Selection([newChild], null, this._parent, this._document);
  }
  /**
   * Bind data to elements, and produce three selection:
   * Enter: Selection with empty elements and data to be bind to elements.
   * Update: Selection with elements to be updated.
   * Exit: Selection with elements to be removed.
   */
  data(data2, id4 = (d4) => d4, groupId = () => null) {
    const enter = [];
    const update2 = [];
    const exit = new Set(this._elements);
    const merge2 = [];
    const split = /* @__PURE__ */ new Set();
    const keyElement = new Map(this._elements.map((d4, i2) => [id4(d4.__data__, i2), d4]));
    const keyUpdateElement = new Map(this._facetElements.map((d4, i2) => [id4(d4.__data__, i2), d4]));
    const groupKeyElements = group(this._elements, (d4) => groupId(d4.__data__));
    for (let i2 = 0; i2 < data2.length; i2++) {
      const datum = data2[i2];
      const key = id4(datum, i2);
      const groupKey = groupId(datum, i2);
      if (keyElement.has(key)) {
        const element = keyElement.get(key);
        element.__data__ = datum;
        element.__facet__ = false;
        update2.push(element);
        exit.delete(element);
        keyElement.delete(key);
      } else if (keyUpdateElement.has(key)) {
        const element = keyUpdateElement.get(key);
        element.__data__ = datum;
        element.__facet__ = true;
        update2.push(element);
        keyUpdateElement.delete(key);
      } else if (groupKeyElements.has(key)) {
        const group3 = groupKeyElements.get(key);
        merge2.push([datum, group3]);
        for (const element of group3)
          exit.delete(element);
        groupKeyElements.delete(key);
      } else if (keyElement.has(groupKey)) {
        const element = keyElement.get(groupKey);
        if (element.__toData__)
          element.__toData__.push(datum);
        else
          element.__toData__ = [datum];
        split.add(element);
        exit.delete(element);
      } else {
        enter.push(datum);
      }
    }
    const S = [
      new _Selection([], enter, this._parent, this._document),
      new _Selection(update2, null, this._parent, this._document),
      new _Selection(exit, null, this._parent, this._document),
      new _Selection([], merge2, this._parent, this._document),
      new _Selection(split, null, this._parent, this._document)
    ];
    return new _Selection(this._elements, null, this._parent, this._document, S);
  }
  merge(other) {
    const elements = [...this._elements, ...other._elements];
    const transitions = [...this._transitions, ...other._transitions];
    return new _Selection(elements, null, this._parent, this._document, void 0, transitions);
  }
  createElement(type) {
    if (this._document) {
      return this._document.createElement(type, {});
    }
    const Ctor = _Selection.registry[type];
    if (Ctor)
      return new Ctor();
    return error(`Unknown node type: ${type}`);
  }
  /**
   * Apply callback for each selection(enter, update, exit)
   * and merge them into one selection.
   */
  join(enter = (d4) => d4, update2 = (d4) => d4, exit = (d4) => d4.remove(), merge2 = (d4) => d4, split = (d4) => d4.remove()) {
    const newEnter = enter(this._enter);
    const newUpdate = update2(this._update);
    const newExit = exit(this._exit);
    const newMerge = merge2(this._merge);
    const newSplit = split(this._split);
    return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
  }
  remove() {
    for (let i2 = 0; i2 < this._elements.length; i2++) {
      const transition2 = this._transitions[i2];
      if (transition2) {
        const T2 = Array.isArray(transition2) ? transition2 : [transition2];
        Promise.all(T2.map((d4) => d4.finished)).then(() => {
          const element = this._elements[i2];
          element.remove();
        });
      } else {
        const element = this._elements[i2];
        element.remove();
      }
    }
    return new _Selection([], null, this._parent, this._document, void 0, this._transitions);
  }
  each(callback) {
    for (let i2 = 0; i2 < this._elements.length; i2++) {
      const element = this._elements[i2];
      const datum = element.__data__;
      callback(datum, i2, element);
    }
    return this;
  }
  attr(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d4, i2, element) {
      if (value2 !== void 0)
        element[key] = callback(d4, i2, element);
    });
  }
  style(key, value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    return this.each(function(d4, i2, element) {
      if (value2 !== void 0)
        element.style[key] = callback(d4, i2, element);
    });
  }
  transition(value2) {
    const callback = typeof value2 !== "function" ? () => value2 : value2;
    const { _transitions: T2 } = this;
    return this.each(function(d4, i2, element) {
      T2[i2] = callback(d4, i2, element);
    });
  }
  on(event, handler) {
    this.each(function(d4, i2, element) {
      element.addEventListener(event, handler);
    });
    return this;
  }
  call(callback, ...args) {
    callback(this, ...args);
    return this;
  }
  node() {
    return this._elements[0];
  }
  nodes() {
    return this._elements;
  }
  transitions() {
    return this._transitions;
  }
  parent() {
    return this._parent;
  }
};
Selection.registry = {
  g: Group2,
  rect: Rect,
  circle: Circle,
  path: Path2,
  text: Text,
  ellipse: Ellipse,
  image: Image2,
  line: Line,
  polygon: Polygon,
  polyline: Polyline,
  html: HTML
};

// node_modules/@antv/g2/esm/utils/number.js
function clamp2(v, lower2, upper2) {
  return Math.max(lower2, Math.min(v, upper2));
}
function prettyNumber2(n2, precision = 10) {
  if (typeof n2 !== "number")
    return n2;
  return Math.abs(n2) < 1e-15 ? n2 : parseFloat(n2.toFixed(precision));
}

// node_modules/@antv/g2/esm/shape/utils.js
function applyStyle(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
function appendPolygon(path2, points) {
  points.forEach((p3, idx) => idx === 0 ? path2.moveTo(p3[0], p3[1]) : path2.lineTo(p3[0], p3[1]));
  path2.closePath();
  return path2;
}
function arrowPoints(from, to, options) {
  const { arrowSize } = options;
  const size3 = typeof arrowSize === "string" ? +parseFloat(arrowSize) / 100 * dist4(from, to) : arrowSize;
  const arrowAngle = Math.PI / 6;
  const angle4 = Math.atan2(to[1] - from[1], to[0] - from[0]);
  const arrowAngle1 = Math.PI / 2 - angle4 - arrowAngle;
  const arrow1 = [
    to[0] - size3 * Math.sin(arrowAngle1),
    to[1] - size3 * Math.cos(arrowAngle1)
  ];
  const arrowAngle2 = angle4 - arrowAngle;
  const arrow2 = [
    to[0] - size3 * Math.cos(arrowAngle2),
    to[1] - size3 * Math.sin(arrowAngle2)
  ];
  return [arrow1, arrow2];
}
function appendArc(path2, from, to, center2, radius) {
  const startAngle = angle3(sub6(center2, from)) + Math.PI;
  const endAngle = angle3(sub6(center2, to)) + Math.PI;
  path2.arc(center2[0], center2[1], radius, startAngle, endAngle, endAngle - startAngle < 0);
  return path2;
}
function computeGradient(C4, X, Y, from = "y", mode2 = "between", tpShape = false) {
  const getTheta = (from2, tpShape2) => {
    if (from2 === "y" || from2 === true) {
      if (tpShape2) {
        return 180;
      } else {
        return 90;
      }
    } else {
      if (tpShape2) {
        return 90;
      } else {
        return 0;
      }
    }
  };
  const P = from === "y" || from === true ? Y : X;
  const theta = getTheta(from, tpShape);
  const I = indexOf3(P);
  const [min10, max11] = extent(I, (i2) => P[i2]);
  const p3 = new Linear({
    domain: [min10, max11],
    range: [0, 100]
  });
  const percentage = (i2) => isNumber(P[i2]) && !Number.isNaN(P[i2]) ? p3.map(P[i2]) : 0;
  const gradientMode = {
    // Interpolate the colors for this segment.
    between: (i2) => `${C4[i2]} ${percentage(i2)}%`,
    // Use the color of the start point as the color for this segment.
    start: (i2) => i2 === 0 ? `${C4[i2]} ${percentage(i2)}%` : `${C4[i2 - 1]} ${percentage(i2)}%, ${C4[i2]} ${percentage(i2)}%`,
    // Use the color of the end point as the color for this segment.
    end: (i2) => i2 === C4.length - 1 ? `${C4[i2]} ${percentage(i2)}%` : `${C4[i2]} ${percentage(i2)}%, ${C4[i2 + 1]} ${percentage(i2)}%`
  };
  const gradient2 = I.sort((a5, b) => percentage(a5) - percentage(b)).map(gradientMode[mode2] || gradientMode["between"]).join(",");
  return `linear-gradient(${theta}deg, ${gradient2})`;
}
function reorder(points) {
  const [p0, p1, p22, p3] = points;
  return [p3, p0, p1, p22];
}
function getArcObject(coordinate, points, Y) {
  const [p0, p1, , p3] = isTranspose(coordinate) ? reorder(points) : points;
  const [y4, y12] = Y;
  const center2 = coordinate.getCenter();
  const a1 = angleWithQuadrant(sub6(p0, center2));
  const a22 = angleWithQuadrant(sub6(p1, center2));
  const a32 = a22 === a1 && y4 !== y12 ? a22 + Math.PI * 2 : a22;
  const epsilon4 = 1e-4;
  return {
    startAngle: a1 + epsilon4,
    endAngle: (a32 - a1 >= 0 ? a32 : Math.PI * 2 + a32) - epsilon4,
    innerRadius: dist4(p3, center2),
    outerRadius: dist4(p0, center2)
  };
}
function toOpacityKey(options) {
  const { colorAttribute, opacityAttribute = colorAttribute } = options;
  return `${opacityAttribute}Opacity`;
}
function getTransform(coordinate, value2) {
  if (!isPolar(coordinate))
    return "";
  const center2 = coordinate.getCenter();
  const { transform: suffix } = value2;
  return `translate(${center2[0]}, ${center2[1]}) ${suffix || ""}`;
}
function getOrigin(points) {
  if (points.length === 1)
    return points[0];
  const [[x05, y05, z0 = 0], [x22, y22, z2 = 0]] = points;
  return [(x05 + x22) / 2, (y05 + y22) / 2, (z0 + z2) / 2];
}

// node_modules/@antv/g2/esm/shape/interval/color.js
var __rest12 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function rect(document2, points, value2, coordinate, style = {}) {
  const { inset = 0, radius = 0, insetLeft = inset, insetTop = inset, insetRight = inset, insetBottom = inset, radiusBottomLeft = radius, radiusBottomRight = radius, radiusTopLeft = radius, radiusTopRight = radius, minWidth = -Infinity, maxWidth = Infinity, minHeight = -Infinity } = style, rest = __rest12(style, ["inset", "radius", "insetLeft", "insetTop", "insetRight", "insetBottom", "radiusBottomLeft", "radiusBottomRight", "radiusTopLeft", "radiusTopRight", "minWidth", "maxWidth", "minHeight"]);
  if (!isPolar(coordinate) && !isHelix(coordinate)) {
    const tpShape = !!isTranspose(coordinate);
    const [p0, , p22] = tpShape ? reorder(points) : points;
    const [x3, y5] = p0;
    const [width, height] = sub6(p22, p0);
    const absX = width > 0 ? x3 : x3 + width;
    const absY = height > 0 ? y5 : y5 + height;
    const absWidth = Math.abs(width);
    const absHeight = Math.abs(height);
    const finalX = absX + insetLeft;
    const finalY = absY + insetTop;
    const finalWidth = absWidth - (insetLeft + insetRight);
    const finalHeight = absHeight - (insetTop + insetBottom);
    const clampWidth = tpShape ? clamp2(finalWidth, minHeight, Infinity) : clamp2(finalWidth, minWidth, maxWidth);
    const clampHeight = tpShape ? clamp2(finalHeight, minWidth, maxWidth) : clamp2(finalHeight, minHeight, Infinity);
    const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;
    const clampY = tpShape ? finalY - (clampHeight - finalHeight) / 2 : finalY - (clampHeight - finalHeight);
    return select(document2.createElement("rect", {})).style("x", clampX).style("y", clampY).style("width", clampWidth).style("height", clampHeight).style("radius", [
      radiusTopLeft,
      radiusTopRight,
      radiusBottomRight,
      radiusBottomLeft
    ]).call(applyStyle, rest).node();
  }
  const { y: y4, y1: y12 } = value2;
  const center2 = coordinate.getCenter();
  const arcObject = getArcObject(coordinate, points, [y4, y12]);
  const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
  return select(document2.createElement("path", {})).style("d", path2(arcObject)).style("transform", `translate(${center2[0]}, ${center2[1]})`).style("radius", radius).style("inset", inset).call(applyStyle, rest).node();
}
var Color2 = (options, context) => {
  const { colorAttribute, opacityAttribute = "fill", first: first3 = true, last: last5 = true } = options, style = __rest12(options, ["colorAttribute", "opacityAttribute", "first", "last"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, radius: defaultRadius2 = 0 } = defaults4, restDefaults = __rest12(defaults4, ["color", "radius"]);
    const defaultLineWidth = restDefaults.lineWidth || 1;
    const { stroke: stroke2, radius = defaultRadius2, radiusTopLeft = radius, radiusTopRight = radius, radiusBottomRight = radius, radiusBottomLeft = radius, innerRadius = 0, innerRadiusTopLeft = innerRadius, innerRadiusTopRight = innerRadius, innerRadiusBottomRight = innerRadius, innerRadiusBottomLeft = innerRadius, lineWidth = colorAttribute === "stroke" || stroke2 ? defaultLineWidth : 0, inset = 0, insetLeft = inset, insetRight = inset, insetBottom = inset, insetTop = inset, minWidth, maxWidth, minHeight } = style, rest = __rest12(style, ["stroke", "radius", "radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft", "innerRadius", "innerRadiusTopLeft", "innerRadiusTopRight", "innerRadiusBottomRight", "innerRadiusBottomLeft", "lineWidth", "inset", "insetLeft", "insetRight", "insetBottom", "insetTop", "minWidth", "maxWidth", "minHeight"]);
    const { color: color3 = defaultColor, opacity } = value2;
    const standardDirRadius = [
      first3 ? radiusTopLeft : innerRadiusTopLeft,
      first3 ? radiusTopRight : innerRadiusTopRight,
      last5 ? radiusBottomRight : innerRadiusBottomRight,
      last5 ? radiusBottomLeft : innerRadiusBottomLeft
    ];
    const standardDir = [
      "radiusTopLeft",
      "radiusTopRight",
      "radiusBottomRight",
      "radiusBottomLeft"
    ];
    if (isTranspose(coordinate)) {
      standardDir.push(standardDir.shift());
    }
    const extendedStyle = Object.assign(Object.assign({ radius }, Object.fromEntries(standardDir.map((d4, i2) => [d4, standardDirRadius[i2]]))), {
      inset,
      insetLeft,
      insetRight,
      insetBottom,
      insetTop,
      minWidth,
      maxWidth,
      minHeight
    });
    return select(rect(document2, points, value2, coordinate, extendedStyle)).call(applyStyle, restDefaults).style("fill", "transparent").style(colorAttribute, color3).style(toOpacityKey(options), opacity).style("lineWidth", lineWidth).style("stroke", stroke2 === void 0 ? color3 : stroke2).call(applyStyle, rest).node();
  };
};
Color2.props = {
  defaultEnterAnimation: "scaleInY",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/interval/rect.js
var Rect2 = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "fill" }, options), context);
};
Rect2.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/interval/hollow.js
var Hollow = (options, context) => {
  return Color2(Object.assign({ colorAttribute: "stroke" }, options), context);
};
Hollow.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "hollowSquare" });

// node_modules/@antv/g2/esm/shape/interval/funnel.js
var __rest13 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getFunnelPoints(points, nextPoints, coordinate) {
  const [p0, p1, p22, p3] = points;
  if (isTranspose(coordinate)) {
    const newP12 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];
    const newP22 = [nextPoints ? nextPoints[3][0] : p22[0], p22[1]];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];
  const newP2 = [p22[0], nextPoints ? nextPoints[3][1] : p22[1]];
  return [p0, newP1, newP2, p3];
}
var Funnel = (options, context) => {
  const { adjustPoints = getFunnelPoints } = options, style = __rest13(options, ["adjustPoints"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4, point2d) => {
    const { index: index3 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest13(defaults4, ["color"]);
    const nextPoints = point2d[index3 + 1];
    const funnelPoints = adjustPoints(points, nextPoints, coordinate);
    const tpShape = !!isTranspose(coordinate);
    const [p0, p1, p22, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;
    const { color: color3 = defaultColor, opacity } = value2;
    const b = line_default().curve(linearClosed_default)([p0, p1, p22, p3]);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", b).style("fill", color3).style("fillOpacity", opacity).call(applyStyle, style).node();
  };
};
Funnel.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/shape/interval/pyramid.js
function getPyramidPoints(points, nextPoints, coordinate) {
  const [p0, p1, p22, p3] = points;
  if (isTranspose(coordinate)) {
    const newP12 = [
      nextPoints ? nextPoints[0][0] : (p1[0] + p22[0]) / 2,
      p1[1]
    ];
    const newP22 = [
      nextPoints ? nextPoints[3][0] : (p1[0] + p22[0]) / 2,
      p22[1]
    ];
    return [p0, newP12, newP22, p3];
  }
  const newP1 = [
    p1[0],
    nextPoints ? nextPoints[0][1] : (p1[1] + p22[1]) / 2
  ];
  const newP2 = [
    p22[0],
    nextPoints ? nextPoints[3][1] : (p1[1] + p22[1]) / 2
  ];
  return [p0, newP1, newP2, p3];
}
var Pyramid = (options, context) => {
  return Funnel(Object.assign({ adjustPoints: getPyramidPoints }, options), context);
};
Pyramid.props = {
  defaultMarker: "square"
};

// node_modules/@antv/g2/esm/utils/createElement.js
function createElement(descriptor) {
  const render3 = typeof descriptor === "function" ? descriptor : descriptor.render;
  return class extends CustomElement {
    connectedCallback() {
      this.draw();
    }
    attributeChangedCallback() {
      this.draw();
    }
    draw() {
      render3(this);
    }
  };
}

// node_modules/@antv/g2/esm/shape/line/curve.js
var __rest14 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var DoublePath = createElement((g) => {
  const { d1, d2: d22, style1, style2 } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("line", () => document2.createElement("path", {})).style("d", d1).call(applyStyle, style1);
  select(g).maybeAppend("line1", () => document2.createElement("path", {})).style("d", d22).call(applyStyle, style2);
});
function segmentation(points, defined4) {
  const definedPoints = [];
  const segments = [];
  let m3 = false;
  let dp = null;
  for (const p3 of points) {
    if (!defined4(p3[0]) || !defined4(p3[1]))
      m3 = true;
    else {
      definedPoints.push(p3);
      if (m3) {
        m3 = false;
        segments.push([dp, p3]);
      }
      dp = p3;
    }
  }
  return [definedPoints, segments];
}
var Curve = (options, context) => {
  const {
    curve,
    gradient: gradient2 = false,
    // The color for each segment.
    gradientColor = "between",
    defined: defined4 = (d4) => !Number.isNaN(d4) && d4 !== void 0 && d4 !== null,
    connect: connectNulls = false
  } = options, style = __rest14(options, ["curve", "gradient", "gradientColor", "defined", "connect"]);
  const { coordinate, document: document2 } = context;
  return (P, value2, defaults4) => {
    const { color: defaultColor, lineWidth: defaultSize } = defaults4, rest = __rest14(defaults4, ["color", "lineWidth"]);
    const { color: color3 = defaultColor, size: size3 = defaultSize, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const transform2 = getTransform(coordinate, value2);
    const tpShape = isTranspose(coordinate);
    const stroke2 = gradient2 && sc ? computeGradient(sc, sx, sy, gradient2, gradientColor, tpShape) : color3;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), stroke2 && { stroke: stroke2 }), size3 && { lineWidth: size3 }), transform2 && { transform: transform2 }), style);
    let linePath;
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      linePath = (points) => lineRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(points[idx], center2))).radius((_2, idx) => dist4(points[idx], center2)).defined(([x3, y4]) => defined4(x3) && defined4(y4)).curve(curve)(points);
    } else {
      linePath = line_default().x((d4) => d4[0]).y((d4) => d4[1]).defined(([x3, y4]) => defined4(x3) && defined4(y4)).curve(curve);
    }
    const [DP, MS] = segmentation(P, defined4);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    if (!missing || connectNulls && !Object.keys(connectStyle).length) {
      return select(document2.createElement("path", {})).style("d", linePath(DP) || []).call(applyStyle, finalStyle).node();
    }
    if (missing && !connectNulls) {
      return select(document2.createElement("path", {})).style("d", linePath(P)).call(applyStyle, finalStyle).node();
    }
    const connectPath = (segments) => segments.map(linePath).join(",");
    return select(new DoublePath()).style("style1", Object.assign(Object.assign({}, finalStyle), connectStyle)).style("style2", finalStyle).style("d1", connectPath(MS)).style("d2", linePath(P)).node();
  };
};
Curve.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/line/line.js
var Line2 = (options, context) => {
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
    return Curve(Object.assign({ curve }, options), context)(...params);
  };
};
Line2.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/shape/line/smooth.js
var __rest15 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Smooth = (options, context) => {
  const rest = __rest15(options, []);
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
    return Curve(Object.assign({ curve }, rest), context)(...params);
  };
};
Smooth.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/line/hv.js
var HV = (options, context) => {
  return Curve(Object.assign({ curve: stepAfter }, options), context);
};
HV.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/line/vh.js
var VH = (options, context) => {
  return Curve(Object.assign({ curve: stepBefore }, options), context);
};
VH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/line/hvh.js
var HVH = (options, context) => {
  return Curve(Object.assign({ curve: step_default }, options), context);
};
HVH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/line/trail.js
var __rest16 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function stroke(path2, p0, p1, s0, s1) {
  const v = sub6(p1, p0);
  const a5 = angle3(v);
  const a1 = a5 + Math.PI / 2;
  const r1 = [s0 / 2 * Math.cos(a1), s0 / 2 * Math.sin(a1)];
  const r2 = [s1 / 2 * Math.cos(a1), s1 / 2 * Math.sin(a1)];
  const r3 = [s1 / 2 * Math.cos(a5), s1 / 2 * Math.sin(a5)];
  const r4 = [s0 / 2 * Math.cos(a5), s0 / 2 * Math.sin(a5)];
  const x05 = add7(p0, r1);
  const x12 = add7(p1, r2);
  const x22 = add7(x12, r3);
  const x3 = add7(p1, r3);
  const x4 = sub6(x3, r2);
  const x5 = sub6(p1, r2);
  const x6 = sub6(p0, r1);
  const x7 = sub6(x6, r4);
  const x8 = sub6(p0, r4);
  const x9 = sub6(x05, r4);
  path2.moveTo(...x05);
  path2.lineTo(...x12);
  path2.arcTo(...x22, ...x3, s1 / 2);
  path2.arcTo(...x4, ...x5, s1 / 2);
  path2.lineTo(...x6);
  path2.arcTo(...x7, ...x8, s0 / 2);
  path2.arcTo(...x9, ...x05, s0 / 2);
  path2.closePath();
}
var Trail = (options, context) => {
  const { document: document2 } = context;
  return (P, value2, defaults4) => {
    const { seriesSize, color: color3 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest16(defaults4, ["color"]);
    const path2 = path();
    for (let i2 = 0; i2 < P.length - 1; i2++) {
      const p0 = P[i2];
      const p1 = P[i2 + 1];
      const s0 = seriesSize[i2];
      const s1 = seriesSize[i2 + 1];
      if ([...p0, ...p1].every(defined))
        stroke(path2, p0, p1, s0, s1);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("fill", color3 || defaultColor).style("d", path2.toString()).call(applyStyle, options).node();
  };
};
Trail.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

// node_modules/@antv/g2/esm/utils/marker.js
var __rest17 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var point5 = (x3, y4, r2) => {
  return [
    ["M", x3 - r2, y4],
    ["A", r2, r2, 0, 1, 0, x3 + r2, y4],
    ["A", r2, r2, 0, 1, 0, x3 - r2, y4],
    ["Z"]
  ];
};
point5.style = ["fill"];
var hollowPoint = point5.bind(void 0);
hollowPoint.style = ["stroke", "lineWidth"];
var square = (x3, y4, r2) => {
  return [
    ["M", x3 - r2, y4 - r2],
    ["L", x3 + r2, y4 - r2],
    ["L", x3 + r2, y4 + r2],
    ["L", x3 - r2, y4 + r2],
    ["Z"]
  ];
};
square.style = ["fill"];
var rect2 = square.bind(void 0);
rect2.style = ["fill"];
var hollowSquare = square.bind(void 0);
hollowSquare.style = ["stroke", "lineWidth"];
var diamond = (x3, y4, r2) => {
  const hr = r2 * 0.618;
  return [
    ["M", x3 - hr, y4],
    ["L", x3, y4 - r2],
    ["L", x3 + hr, y4],
    ["L", x3, y4 + r2],
    ["Z"]
  ];
};
diamond.style = ["fill"];
var hollowDiamond = diamond.bind(void 0);
hollowDiamond.style = ["stroke", "lineWidth"];
var triangle = (x3, y4, r2) => {
  const diffY = r2 * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x3 - r2, y4 + diffY],
    ["L", x3, y4 - diffY],
    ["L", x3 + r2, y4 + diffY],
    ["Z"]
  ];
};
triangle.style = ["fill"];
var hollowTriangle = triangle.bind(void 0);
hollowTriangle.style = ["stroke", "lineWidth"];
var triangleDown = (x3, y4, r2) => {
  const diffY = r2 * Math.sin(1 / 3 * Math.PI);
  return [
    ["M", x3 - r2, y4 - diffY],
    ["L", x3 + r2, y4 - diffY],
    ["L", x3, y4 + diffY],
    ["Z"]
  ];
};
triangleDown.style = ["fill"];
var hollowTriangleDown = triangleDown.bind(void 0);
hollowTriangleDown.style = ["stroke", "lineWidth"];
var hexagon = (x3, y4, r2) => {
  const diffX = r2 / 2 * Math.sqrt(3);
  return [
    ["M", x3, y4 - r2],
    ["L", x3 + diffX, y4 - r2 / 2],
    ["L", x3 + diffX, y4 + r2 / 2],
    ["L", x3, y4 + r2],
    ["L", x3 - diffX, y4 + r2 / 2],
    ["L", x3 - diffX, y4 - r2 / 2],
    ["Z"]
  ];
};
hexagon.style = ["fill"];
var hollowHexagon = hexagon.bind(void 0);
hollowHexagon.style = ["stroke", "lineWidth"];
var bowtie = (x3, y4, r2) => {
  const diffY = r2 - 1.5;
  return [
    ["M", x3 - r2, y4 - diffY],
    ["L", x3 + r2, y4 + diffY],
    ["L", x3 + r2, y4 - diffY],
    ["L", x3 - r2, y4 + diffY],
    ["Z"]
  ];
};
bowtie.style = ["fill"];
var hollowBowtie = bowtie.bind(void 0);
hollowBowtie.style = ["stroke", "lineWidth"];
var line = (x3, y4, r2) => {
  return [
    ["M", x3, y4 + r2],
    ["L", x3, y4 - r2]
  ];
};
line.style = ["stroke", "lineWidth"];
var cross5 = (x3, y4, r2) => {
  return [
    ["M", x3 - r2, y4 - r2],
    ["L", x3 + r2, y4 + r2],
    ["M", x3 + r2, y4 - r2],
    ["L", x3 - r2, y4 + r2]
  ];
};
cross5.style = ["stroke", "lineWidth"];
var tick = (x3, y4, r2) => {
  return [
    ["M", x3 - r2 / 2, y4 - r2],
    ["L", x3 + r2 / 2, y4 - r2],
    ["M", x3, y4 - r2],
    ["L", x3, y4 + r2],
    ["M", x3 - r2 / 2, y4 + r2],
    ["L", x3 + r2 / 2, y4 + r2]
  ];
};
tick.style = ["stroke", "lineWidth"];
var plus = (x3, y4, r2) => {
  return [
    ["M", x3 - r2, y4],
    ["L", x3 + r2, y4],
    ["M", x3, y4 - r2],
    ["L", x3, y4 + r2]
  ];
};
plus.style = ["stroke", "lineWidth"];
var hyphen = (x3, y4, r2) => {
  return [
    ["M", x3 - r2, y4],
    ["L", x3 + r2, y4]
  ];
};
hyphen.style = ["stroke", "lineWidth"];
var dot6 = (x3, y4, r2) => {
  return [
    ["M", x3 - r2, y4],
    ["L", x3 + r2, y4]
  ];
};
dot6.style = ["stroke", "lineWidth"];
var dash = dot6.bind(void 0);
dash.style = ["stroke", "lineWidth"];
var smooth = (x3, y4, r2) => {
  return [
    ["M", x3 - r2, y4],
    ["A", r2 / 2, r2 / 2, 0, 1, 1, x3, y4],
    ["A", r2 / 2, r2 / 2, 0, 1, 0, x3 + r2, y4]
  ];
};
smooth.style = ["stroke", "lineWidth"];
var hv = (x3, y4, r2) => {
  return [
    ["M", x3 - r2 - 1, y4 - 2.5],
    ["L", x3, y4 - 2.5],
    ["L", x3, y4 + 2.5],
    ["L", x3 + r2 + 1, y4 + 2.5]
  ];
};
hv.style = ["stroke", "lineWidth"];
var vh = (x3, y4, r2) => {
  return [
    ["M", x3 - r2 - 1, y4 + 2.5],
    ["L", x3, y4 + 2.5],
    ["L", x3, y4 - 2.5],
    ["L", x3 + r2 + 1, y4 - 2.5]
  ];
};
vh.style = ["stroke", "lineWidth"];
var hvh = (x3, y4, r2) => {
  return [
    ["M", x3 - (r2 + 1), y4 + 2.5],
    ["L", x3 - r2 / 2, y4 + 2.5],
    ["L", x3 - r2 / 2, y4 - 2.5],
    ["L", x3 + r2 / 2, y4 - 2.5],
    ["L", x3 + r2 / 2, y4 + 2.5],
    ["L", x3 + r2 + 1, y4 + 2.5]
  ];
};
hvh.style = ["stroke", "lineWidth"];
var vhv = (x3, y4, r2) => {
  return [
    ["M", x3 - 5, y4 + 2.5],
    ["L", x3 - 5, y4],
    ["L", x3, y4],
    ["L", x3, y4 - 3],
    ["L", x3, y4 + 3],
    ["L", x3 + 6.5, y4 + 3]
  ];
};
vhv.style = ["stroke", "lineWidth"];
var Symbols = /* @__PURE__ */ new Map([
  ["bowtie", bowtie],
  ["cross", cross5],
  ["dash", dash],
  ["diamond", diamond],
  ["dot", dot6],
  ["hexagon", hexagon],
  ["hollowBowtie", hollowBowtie],
  ["hollowDiamond", hollowDiamond],
  ["hollowHexagon", hollowHexagon],
  ["hollowPoint", hollowPoint],
  ["hollowSquare", hollowSquare],
  ["hollowTriangle", hollowTriangle],
  ["hollowTriangleDown", hollowTriangleDown],
  ["hv", hv],
  ["hvh", hvh],
  ["hyphen", hyphen],
  ["line", line],
  ["plus", plus],
  ["point", point5],
  ["rect", rect2],
  ["smooth", smooth],
  ["square", square],
  ["tick", tick],
  ["triangleDown", triangleDown],
  ["triangle", triangle],
  ["vh", vh],
  ["vhv", vhv]
]);
function useMarker(type, _a2) {
  var { d: d4, fill, lineWidth, path: path2, stroke: stroke2, color: color3 } = _a2, style = __rest17(_a2, ["d", "fill", "lineWidth", "path", "stroke", "color"]);
  const symbol = Symbols.get(type) || Symbols.get("point");
  return (...args) => {
    const path3 = new Path2({
      style: Object.assign(Object.assign({}, style), { d: symbol(...args), stroke: symbol.style.includes("stroke") ? color3 || stroke2 : "", fill: symbol.style.includes("fill") ? color3 || fill : "", lineWidth: symbol.style.includes("lineWidth") ? lineWidth || lineWidth || 2 : 0 })
    });
    return path3;
  };
}
function registerSymbol(type, marker) {
  Symbols.set(type, marker);
}

// node_modules/@antv/g2/esm/utils/string.js
function camelCase(s4) {
  return s4.replace(/-(\w)/g, function(_2, letter) {
    return letter.toUpperCase();
  });
}
function kebabCase(s4) {
  return s4.replace(/([A-Z])/g, "-$1").toLowerCase();
}

// node_modules/@antv/g2/esm/shape/point/color.js
var __rest18 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getRadius2(mode2, points, value2, coordinate) {
  if (points.length === 1)
    return void 0;
  const { size: size3 } = value2;
  if (mode2 === "fixed")
    return size3;
  if (mode2 === "normal" || isFisheye(coordinate)) {
    const [[x05, y05], [x22, y22]] = points;
    const a5 = Math.abs((x22 - x05) / 2);
    const b = Math.abs((y22 - y05) / 2);
    return Math.max(0, (a5 + b) / 2);
  }
  return size3;
}
var Color3 = (options, context) => {
  const { colorAttribute, symbol, mode: mode2 = "auto" } = options, style = __rest18(options, ["colorAttribute", "symbol", "mode"]);
  const path2 = Symbols.get(camelCase(symbol)) || Symbols.get("point");
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { lineWidth, color: defaultColor } = defaults4;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color: color3 = defaultColor, transform: transform2, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r2 = getRadius2(mode2, points, value2, coordinate);
    const finalRadius = r2 || style.r || defaults4.r;
    return select(document2.createElement("path", {})).call(applyStyle, defaults4).style("fill", "transparent").style("d", path2(cx, cy, finalRadius)).style("lineWidth", finalLineWidth).style("transform", transform2).style("transformOrigin", `${cx - finalRadius} ${cy - finalRadius}`).style("stroke", color3).style(toOpacityKey(options), opacity).style(colorAttribute, color3).call(applyStyle, style).node();
  };
};
Color3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowBowtie.js
var HollowBowtie = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "bowtie" }, options), context);
};
HollowBowtie.props = Object.assign({ defaultMarker: "hollowBowtie" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowDiamond.js
var HollowDiamond = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "diamond" }, options), context);
};
HollowDiamond.props = Object.assign({ defaultMarker: "hollowDiamond" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowHexagon.js
var HollowHexagon = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hexagon" }, options), context);
};
HollowHexagon.props = Object.assign({ defaultMarker: "hollowHexagon" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollow.js
var HollowPoint = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "point" }, options), context);
};
HollowPoint.props = Object.assign({ defaultMarker: "hollowPoint" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowSquare.js
var HollowSquare = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "square" }, options), context);
};
HollowSquare.props = Object.assign({ defaultMarker: "hollowSquare" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangle.js
var HollowTriangle = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle" }, options), context);
};
HollowTriangle.props = Object.assign({ defaultMarker: "hollowTriangle" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hollowTriangleDown.js
var HollowTriangleDown = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle-down" }, options), context);
};
HollowTriangleDown.props = Object.assign({ defaultMarker: "hollowTriangleDown" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/circle.js
var __rest19 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var BaseCircle = (options, context) => {
  const { colorAttribute, mode: mode2 = "auto" } = options, style = __rest19(options, ["colorAttribute", "mode"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { lineWidth, color: defaultColor } = defaults4;
    const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
    const { color: color3 = defaultColor, transform: transform2, opacity } = value2;
    const [cx, cy] = getOrigin(points);
    const r2 = getRadius2(mode2, points, value2, coordinate);
    const finalRadius = r2 || style.r || defaults4.r;
    return select(document2.createElement("circle", {})).call(applyStyle, defaults4).style("fill", "transparent").style("cx", cx).style("cy", cy).style("r", finalRadius).style("lineWidth", finalLineWidth).style("transform", transform2).style("transformOrigin", `${cx} ${cy}`).style("stroke", color3).style(toOpacityKey(options), opacity).style(colorAttribute, color3).call(applyStyle, style).node();
  };
};
var Circle2 = (options, context) => {
  return BaseCircle(Object.assign({ colorAttribute: "fill" }, options), context);
};
Circle2.props = {
  defaultMarker: "circle",
  defaultEnterAnimation: "fadeIn",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/point/hollowCircle.js
var HollowCircle = (options, context) => {
  return BaseCircle(Object.assign({ colorAttribute: "stroke" }, options), context);
};
HollowCircle.props = Object.assign({ defaultMarker: "hollowPoint" }, Circle2.props);

// node_modules/@antv/g2/esm/shape/point/bowtie.js
var Bowtie = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "bowtie" }, options), context);
};
Bowtie.props = Object.assign({ defaultMarker: "bowtie" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/cross.js
var Cross = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "cross" }, options), context);
};
Cross.props = Object.assign({ defaultMarker: "cross" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/diamond.js
var Diamond = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "diamond" }, options), context);
};
Diamond.props = Object.assign({ defaultMarker: "diamond" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hexagon.js
var Hexagon = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "hexagon" }, options), context);
};
Hexagon.props = Object.assign({ defaultMarker: "hexagon" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/hyphen.js
var Hyphen = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hyphen" }, options), context);
};
Hyphen.props = Object.assign({ defaultMarker: "hyphen" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/line.js
var Line3 = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "line" }, options), context);
};
Line3.props = Object.assign({ defaultMarker: "line" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/plus.js
var Plus = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "plus" }, options), context);
};
Plus.props = Object.assign({ defaultMarker: "plus" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/point.js
var Point3 = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "point" }, options), context);
};
Point3.props = Object.assign({ defaultMarker: "point" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/square.js
var Square = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "square" }, options), context);
};
Square.props = Object.assign({ defaultMarker: "square" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/tick.js
var Tick = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "stroke", symbol: "tick" }, options), context);
};
Tick.props = Object.assign({ defaultMarker: "tick" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/triangle.js
var Triangle = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle" }, options), context);
};
Triangle.props = Object.assign({ defaultMarker: "triangle" }, Color3.props);

// node_modules/@antv/g2/esm/shape/point/triangleDown.js
var TriangleDown = (options, context) => {
  return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle-down" }, options), context);
};
TriangleDown.props = Object.assign({ defaultMarker: "triangleDown" }, Color3.props);

// node_modules/@antv/g2/esm/shape/vector/vector.js
var __rest20 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Vector = (options, context) => {
  const { arrow: arrow2 = true, arrowSize = "40%" } = options, style = __rest20(options, ["arrow", "arrowSize"]);
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { defaultColor } = defaults4, rest = __rest20(defaults4, ["defaultColor"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(...from);
    path2.lineTo(...to);
    if (arrow2) {
      const [arrow1, arrow22] = arrowPoints(from, to, { arrowSize });
      path2.moveTo(...arrow1);
      path2.lineTo(...to);
      path2.lineTo(...arrow22);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("transform", transform2).call(applyStyle, style).node();
  };
};
Vector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/component/esm/util/traverse.js
function traverse(element, callback) {
  callback(element);
  if (element.children) {
    element.children.forEach(function(child) {
      if (child)
        traverse(child, callback);
    });
  }
}

// node_modules/@antv/component/esm/util/visibility.js
function show(element) {
  visibility(element, true);
}
function hide(element) {
  visibility(element, false);
}
function visibility(element, visible) {
  var value2 = visible ? "visible" : "hidden";
  traverse(element, function(node) {
    node.attr("visibility", value2);
  });
}

// node_modules/@antv/component/esm/util/offscreen.js
var OffscreenGroup = (
  /** @class */
  function(_super) {
    __extends(OffscreenGroup2, _super);
    function OffscreenGroup2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this2 = _super.apply(this, __spreadArray([], __read(args), false)) || this;
      _this2.isMutationObserved = true;
      _this2.addEventListener(ElementEvent.INSERTED, function() {
        hide(_this2);
      });
      return _this2;
    }
    return OffscreenGroup2;
  }(Group2)
);
function createOffscreenGroup(container) {
  var group3 = container.appendChild(new OffscreenGroup({
    class: "offscreen"
  }));
  hide(group3);
  return group3;
}
function isInOffscreenGroup(group3) {
  var ancestor = group3;
  while (ancestor) {
    if (ancestor.className === "offscreen") {
      return true;
    }
    ancestor = ancestor.parent;
  }
  return false;
}

// node_modules/@antv/component/esm/shapes/Text.js
var Text2 = (
  /** @class */
  function(_super) {
    __extends(Text6, _super);
    function Text6(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest(_a2, ["style"]);
      return _super.call(this, __assign({ style: __assign({ text: "", fill: "black", fontFamily: "sans-serif", fontSize: 16, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1, textAlign: "start", textBaseline: "middle" }, style) }, restOptions)) || this;
    }
    Object.defineProperty(Text6.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Text6.prototype.disconnectedCallback = function() {
      var _a2;
      (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    return Text6;
  }(Text)
);

// node_modules/@antv/component/esm/util/angle-converter.js
function degToRad(deg2) {
  return deg2 * Math.PI / 180;
}
function radToDeg(rad2) {
  return Number((rad2 * 180 / Math.PI).toPrecision(5));
}

// node_modules/@antv/component/esm/util/bbox.js
var BBox = (
  /** @class */
  function() {
    function BBox2(x3, y4, width, height) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y4 === void 0) {
        y4 = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.x = x3;
      this.y = y4;
      this.width = width;
      this.height = height;
    }
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    BBox2.fromRect = function(other) {
      return new BBox2(other.x, other.y, other.width, other.height);
    };
    BBox2.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
        top: this.top,
        right: this.right,
        bottom: this.bottom,
        left: this.left
      };
    };
    BBox2.prototype.isPointIn = function(x3, y4) {
      return x3 >= this.left && x3 <= this.right && y4 >= this.top && y4 <= this.bottom;
    };
    return BBox2;
  }()
);

// node_modules/@antv/component/esm/util/callback.js
function getCallbackValue(value2, params) {
  return isFunction(value2) ? value2.apply(void 0, __spreadArray([], __read(params), false)) : value2;
}

// node_modules/@antv/component/esm/util/classnames.js
var classNames = function(cls, prefix) {
  var PREFIX = function(str7) {
    return "".concat(prefix, "-").concat(str7);
  };
  var obj = Object.fromEntries(Object.entries(cls).map(function(_a2) {
    var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
    var name2 = PREFIX(v);
    return [
      k2,
      {
        name: name2,
        class: ".".concat(name2),
        id: "#".concat(name2),
        toString: function() {
          return name2;
        }
      }
    ];
  }));
  Object.assign(obj, { prefix: PREFIX });
  return obj;
};

// node_modules/@antv/component/esm/util/deep-assign.js
var MAX_MIX_LEVEL2 = 5;
var deep = function(dist5, src, level, maxLevel) {
  if (level === void 0) {
    level = 0;
  }
  if (maxLevel === void 0) {
    maxLevel = MAX_MIX_LEVEL2;
  }
  Object.entries(src).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    var res = dist5;
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      if (!value2) {
        res[key] = value2;
      } else if (is_plain_object_default(value2)) {
        if (!is_plain_object_default(dist5[key])) {
          res[key] = {};
        }
        if (level < maxLevel) {
          deep(dist5[key], value2, level + 1, maxLevel);
        } else {
          res[key] = src[key];
        }
      } else if (isArray(value2)) {
        res[key] = [];
        res[key] = res[key].concat(value2);
      } else {
        res[key] = value2;
      }
    }
  });
};
var deepAssign2 = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    deep(rst, args[i2]);
  }
  return rst;
};

// node_modules/@antv/component/esm/util/defined.js
var defined2 = function(x3) {
  return x3 !== void 0 && x3 != null && !Number.isNaN(x3);
};

// node_modules/@antv/component/esm/util/text.js
var ctx;
var mockMeasureTextWidth;
var measureTextWidth = memoize(function(text, font) {
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (mockMeasureTextWidth) {
    return mockMeasureTextWidth(text, fontSize);
  }
  if (!ctx) {
    ctx = runtime.offscreenCanvasCreator.getOrCreateContext(void 0);
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx.measureText(text).width;
}, function(text, font) {
  return [text, Object.values(font || getFont(text)).join()].join("");
}, 4096);
var getFont = function(textShape) {
  var fontFamily = textShape.style.fontFamily || "sans-serif";
  var fontWeight = textShape.style.fontWeight || "normal";
  var fontStyle = textShape.style.fontStyle || "normal";
  var fontVariant = textShape.style.fontVariant;
  var fontSize = textShape.style.fontSize;
  fontSize = typeof fontSize === "object" ? fontSize.value : fontSize;
  return { fontSize, fontFamily, fontWeight, fontStyle, fontVariant };
};
function textOf(node) {
  if (node.nodeName === "text") {
    return node;
  }
  if (node.nodeName === "g" && node.children.length === 1 && node.children[0].nodeName === "text") {
    return node.children[0];
  }
  return null;
}
function applyToText(node, style) {
  var text = textOf(node);
  if (text)
    text.attr(style);
}

// node_modules/@antv/component/esm/util/ellipsis.js
function ellipsisIt(node, w2, suffix) {
  if (suffix === void 0) {
    suffix = "...";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth: w2, maxLines: 1, textOverflow: suffix });
}

// node_modules/@antv/component/esm/util/wrap.js
function wrapIt(node, wordWrapWidth, maxLines, textBaseline) {
  if (maxLines === void 0) {
    maxLines = 2;
  }
  if (textBaseline === void 0) {
    textBaseline = "top";
  }
  applyToText(node, { wordWrap: true, wordWrapWidth, maxLines, textBaseline });
}

// node_modules/@antv/component/esm/util/event.js
function getEventPos(e3) {
  var canvas = e3.canvas, touches = e3.touches, offsetX = e3.offsetX, offsetY = e3.offsetY;
  if (canvas) {
    var x3 = canvas.x, y4 = canvas.y;
    return [x3, y4];
  }
  if (touches) {
    var _a2 = touches[0], clientX = _a2.clientX, clientY = _a2.clientY;
    return [clientX, clientY];
  }
  if (offsetX && offsetY)
    return [offsetX, offsetY];
  return [0, 0];
}

// node_modules/@antv/component/esm/util/extend-display-object.js
function renderExtDo(el) {
  if (typeof el === "function")
    return el();
  return isString(el) || isNumber(el) ? new Text2({ style: { text: String(el) } }) : el;
}

// node_modules/@antv/component/esm/util/geometry/lines-intersection.js
function inside(x12, x22, y12, y22, xk, yk) {
  return (x12 === x22 || Math.min(x12, x22) <= xk && xk <= Math.max(x12, x22)) && (y12 === y22 || Math.min(y12, y22) <= yk && yk <= Math.max(y12, y22));
}
function update(ans, x3, y4) {
  var out = ans;
  if (!ans.length || x3 < ans[0] || x3 === ans[0] && y4 < ans[1]) {
    out[0] = x3;
    out[1] = y4;
  }
}
function intersection2(_a2, _b, _c, _d) {
  var _e = __read(_a2, 2), x12 = _e[0], y12 = _e[1];
  var _f = __read(_b, 2), x22 = _f[0], y22 = _f[1];
  var _g = __read(_c, 2), x3 = _g[0], y32 = _g[1];
  var _h = __read(_d, 2), x4 = _h[0], y4 = _h[1];
  var ans = [];
  if ((y4 - y32) * (x22 - x12) === (y22 - y12) * (x4 - x3)) {
    if ((y22 - y12) * (x3 - x12) === (y32 - y12) * (x22 - x12)) {
      if (inside(x12, x22, y12, y22, x3, y32)) {
        update(ans, x3, y32);
      }
      if (inside(x12, x22, y12, y22, x4, y4)) {
        update(ans, x4, y4);
      }
      if (inside(x3, x4, y32, y4, x12, y12)) {
        update(ans, x12, y12);
      }
      if (inside(x3, x4, y32, y4, x22, y22)) {
        update(ans, x22, y22);
      }
    }
  } else {
    var t12 = (x3 * (y4 - y32) + y12 * (x4 - x3) - y32 * (x4 - x3) - x12 * (y4 - y32)) / ((x22 - x12) * (y4 - y32) - (x4 - x3) * (y22 - y12));
    var t22 = (x12 * (y22 - y12) + y32 * (x22 - x12) - y12 * (x22 - x12) - x3 * (y22 - y12)) / ((x4 - x3) * (y22 - y12) - (x22 - x12) * (y4 - y32));
    if (t12 >= 0 && t12 <= 1 && t22 >= 0 && t22 <= 1) {
      ans[0] = x12 + t12 * (x22 - x12);
      ans[1] = y12 + t12 * (y22 - y12);
    }
  }
  return ans;
}

// node_modules/@antv/component/esm/util/geometry/line-length.js
function lineLen(_a2, _b) {
  var _c = __read(_a2, 2), x12 = _c[0], y12 = _c[1];
  var _d = __read(_b, 2), x22 = _d[0], y22 = _d[1];
  return Math.pow(Math.pow(x12 - x22, 2) + Math.pow(y12 - y22, 2), 0.5);
}

// node_modules/@antv/component/esm/util/group-by.js
function groupBy(source, by) {
  return source.reduce(function(acc, curr) {
    (acc[curr[by]] = acc[curr[by]] || []).push(curr);
    return acc;
  }, {});
}

// node_modules/@antv/component/esm/util/if-show.js
function ifShow(show3, container, creator, removeChildren, removeHandler) {
  if (removeChildren === void 0) {
    removeChildren = true;
  }
  if (removeHandler === void 0) {
    removeHandler = function(g) {
      g.node().removeChildren();
    };
  }
  if (show3) {
    return creator(container);
  }
  if (removeChildren)
    removeHandler(container);
  return null;
}

// node_modules/@antv/component/esm/util/in-range.js
function inRange(n2, start, end, includeLeft, includeRight) {
  if (includeLeft === void 0) {
    includeLeft = true;
  }
  if (includeRight === void 0) {
    includeRight = false;
  }
  if (includeLeft && n2 === start || includeRight && n2 === end)
    return true;
  return n2 > start && n2 < end;
}

// node_modules/@antv/component/esm/util/interpolate.js
var numberInterpolate = function(from, to) {
  return function(t) {
    return from * (1 - t) + to * t;
  };
};
function arrayInterpolate(from, to) {
  var nb = to ? to.length : 0;
  var na = from ? Math.min(nb, from.length) : 0;
  return function(t) {
    var x3 = new Array(na);
    var c6 = new Array(nb);
    var i2 = 0;
    for (i2 = 0; i2 < na; ++i2)
      x3[i2] = interpolate3(from[i2], to[i2]);
    for (; i2 < nb; ++i2)
      c6[i2] = to[i2];
    for (i2 = 0; i2 < na; ++i2)
      c6[i2] = x3[i2](t);
    return c6;
  };
}
function objectInterpolate(from, to) {
  if (from === void 0) {
    from = {};
  }
  if (to === void 0) {
    to = {};
  }
  var i2 = {};
  var c6 = {};
  Object.entries(to).forEach(function(_a2) {
    var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
    if (k2 in from)
      i2[k2] = interpolate3(from[k2], v);
    else
      c6[k2] = v;
  });
  return function(t) {
    Object.entries(i2).forEach(function(_a2) {
      var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
      return c6[k2] = v(t);
    });
    return c6;
  };
}
function interpolate3(from, to) {
  if (typeof from === "number" && typeof to === "number") {
    return numberInterpolate(from, to);
  }
  if (Array.isArray(from) && Array.isArray(to)) {
    return arrayInterpolate(from, to);
  }
  if (typeof from === "object" && typeof to === "object") {
    return objectInterpolate(from, to);
  }
  return function(t) {
    return from;
  };
}

// node_modules/@antv/component/esm/util/keyframe-interpolate.js
function keyframeInterpolate(element, from, to, options) {
  if (!options) {
    element.attr("__keyframe_data__", to);
    return null;
  }
  var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2;
  var int = interpolate3(from, to);
  var count4 = Math.ceil(+duration / 16);
  var keyframes = new Array(count4).fill(0).map(function(datum, index3, array2) {
    return { __keyframe_data__: int(index3 / (array2.length - 1)) };
  });
  return element.animate(keyframes, __assign({ fill: "both" }, options));
}

// node_modules/@antv/component/esm/util/layout/utils/helper.js
function getItemsBBox(items) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY2 = -Infinity;
  for (var i2 = 0; i2 < items.length; i2++) {
    var _a2 = items[i2], x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
    var _b = __read([x3 + width, y4 + height], 2), X = _b[0], Y = _b[1];
    if (x3 < minX)
      minX = x3;
    if (y4 < minY)
      minY = y4;
    if (X > maxX)
      maxX = X;
    if (Y > maxY2)
      maxY2 = Y;
  }
  return new BBox(minX, minY, maxX - minX, maxY2 - minY);
}

// node_modules/@antv/component/esm/util/layout/flex/index.js
var flex = function(container, children, config) {
  var width = container.width, height = container.height;
  var _a2 = config.flexDirection, flexDirection = _a2 === void 0 ? "row" : _a2, _b = config.flexWrap, flexWrap = _b === void 0 ? "nowrap" : _b, _c = config.justifyContent, justifyContent = _c === void 0 ? "flex-start" : _c, _d = config.alignContent, alignContent = _d === void 0 ? "flex-start" : _d, _e = config.alignItems, alignItems = _e === void 0 ? "flex-start" : _e;
  var isHorizontalFlow = flexDirection === "row";
  var isLeftToRightFlow = flexDirection === "row" || flexDirection === "column";
  var direction3 = isHorizontalFlow ? isLeftToRightFlow ? [1, 0] : [-1, 0] : isLeftToRightFlow ? [0, 1] : [0, -1];
  var _f = __read([0, 0], 2), offsetX = _f[0], offsetY = _f[1];
  var itemsFromDirection = children.map(function(child) {
    var _a3;
    var width2 = child.width, height2 = child.height;
    var _b2 = __read([offsetX, offsetY], 2), x3 = _b2[0], y4 = _b2[1];
    _a3 = __read([offsetX + width2 * direction3[0], offsetY + height2 * direction3[1]], 2), offsetX = _a3[0], offsetY = _a3[1];
    return new BBox(x3, y4, width2, height2);
  });
  var itemsForJustifyContentBBox = getItemsBBox(itemsFromDirection);
  var justifyContentOffset = {
    "flex-start": 0,
    "flex-end": isHorizontalFlow ? width - itemsForJustifyContentBBox.width : height - itemsForJustifyContentBBox.height,
    center: isHorizontalFlow ? (width - itemsForJustifyContentBBox.width) / 2 : (height - itemsForJustifyContentBBox.height) / 2
  };
  var itemsFromJustifyContent = itemsFromDirection.map(function(item) {
    var x3 = item.x, y4 = item.y;
    var itemBox = BBox.fromRect(item);
    itemBox.x = isHorizontalFlow ? x3 + justifyContentOffset[justifyContent] : x3;
    itemBox.y = isHorizontalFlow ? y4 : y4 + justifyContentOffset[justifyContent];
    return itemBox;
  });
  var itemsForAlignItemsBBox = getItemsBBox(itemsFromJustifyContent);
  var calcAlignItemsOffset = function(box2) {
    var _a3 = __read(isHorizontalFlow ? ["height", height] : ["width", width], 2), key = _a3[0], size3 = _a3[1];
    switch (alignItems) {
      case "flex-start":
        return 0;
      case "flex-end":
        return size3 - box2[key];
      case "center":
        return size3 / 2 - box2[key] / 2;
      default:
        return 0;
    }
  };
  var itemsFromAlignItems = itemsFromJustifyContent.map(function(item) {
    var x3 = item.x, y4 = item.y;
    var itemBox = BBox.fromRect(item);
    itemBox.x = isHorizontalFlow ? x3 : x3 + calcAlignItemsOffset(itemBox);
    itemBox.y = isHorizontalFlow ? y4 + calcAlignItemsOffset(itemBox) : y4;
    return itemBox;
  });
  var finalItems = itemsFromAlignItems.map(function(item) {
    var _a3, _b2;
    var itemBox = BBox.fromRect(item);
    itemBox.x += (_a3 = container.x) !== null && _a3 !== void 0 ? _a3 : 0;
    itemBox.y += (_b2 = container.y) !== null && _b2 !== void 0 ? _b2 : 0;
    return itemBox;
  });
  return finalItems;
};

// node_modules/@antv/component/esm/util/layout/grid/index.js
var grid = function(container, children, config) {
  return [];
};

// node_modules/@antv/component/esm/util/layout/executer.js
var executer_default = function(container, children, config) {
  if (children.length === 0)
    return [];
  var callers = { flex, grid };
  var caller = config.display in callers ? callers[config.display] : null;
  return (caller === null || caller === void 0 ? void 0 : caller.call(null, container, children, config)) || [];
};

// node_modules/@antv/component/esm/util/matrix.js
function scale8(vec, s4) {
  return [vec[0] * s4, vec[1] * s4];
}
function add8(vec1, vec2) {
  return [vec1[0] + vec2[0], vec1[1] + vec2[1]];
}
function sub7(vec1, vec2) {
  return [vec1[0] - vec2[0], vec1[1] - vec2[1]];
}
function min8(vec1, vec2) {
  return [Math.min(vec1[0], vec2[0]), Math.min(vec1[1], vec2[1])];
}
function max9(vec1, vec2) {
  return [Math.max(vec1[0], vec2[0]), Math.max(vec1[1], vec2[1])];
}
function distance5(vec1, vec2) {
  return Math.sqrt(Math.pow(vec1[0] - vec2[0], 2) + Math.pow(vec1[1] - vec2[1], 2));
}
function normalize7(vec) {
  if (vec[0] === 0 && vec[1] === 0)
    return [0, 0];
  var len5 = Math.sqrt(Math.pow(vec[0], 2) + Math.pow(vec[1], 2));
  return [vec[0] / len5, vec[1] / len5];
}
function rotate5(vec, origin, angle4) {
  var _a2 = __read(vec, 2), x3 = _a2[0], y4 = _a2[1];
  var _b = __read(origin, 2), ox = _b[0], oy = _b[1];
  var dx = x3 - ox;
  var dy = y4 - oy;
  var sin3 = Math.sin(angle4);
  var cos3 = Math.cos(angle4);
  return [dx * cos3 - dy * sin3 + ox, dx * sin3 + dy * cos3 + oy];
}
function vertical2(vec, flag) {
  return flag ? [vec[1], -vec[0]] : [-vec[1], vec[0]];
}

// node_modules/@antv/component/esm/util/number.js
function toPrecision(num, precision) {
  return +num.toPrecision(precision);
}

// node_modules/@antv/component/esm/util/omit.js
function omit(obj, keys2) {
  var res = {};
  var innerKeys = Array.isArray(keys2) ? keys2 : [keys2];
  for (var key in obj) {
    if (!innerKeys.includes(key)) {
      res[key] = obj[key];
    }
  }
  return res;
}

// node_modules/@antv/component/esm/util/path.js
function smoothBezier(points, smooth3, isLoop, constraint) {
  var _a2;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min10 = [Infinity, Infinity];
  var max11 = [-Infinity, -Infinity];
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a2 = __read(constraint, 2), min10 = _a2[0], max11 = _a2[1];
    for (var i2 = 0, l2 = points.length; i2 < l2; i2 += 1) {
      var point7 = points[i2];
      min10 = min8(min10, point7);
      max11 = max9(max11, point7);
    }
  }
  for (var i2 = 0, len5 = points.length; i2 < len5; i2 += 1) {
    var point7 = points[i2];
    if (i2 === 0 && !isLoop) {
      cp0 = point7;
    } else if (i2 === len5 - 1 && !isLoop) {
      cp1 = point7;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i2 ? i2 - 1 : len5 - 1, i2 - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i2 + 1) % len5 : i2 + 1];
      var v = [0, 0];
      v = sub7(nextPoint, prevPoint);
      v = scale8(v, smooth3);
      var d0 = distance5(point7, prevPoint);
      var d1 = distance5(point7, nextPoint);
      var sum4 = d0 + d1;
      if (sum4 !== 0) {
        d0 /= sum4;
        d1 /= sum4;
      }
      var v1 = scale8(v, -d0);
      var v2 = scale8(v, d1);
      cp1 = add8(point7, v1);
      nextCp0 = add8(point7, v2);
      nextCp0 = min8(nextCp0, max9(nextPoint, point7));
      nextCp0 = max9(nextCp0, min8(nextPoint, point7));
      v1 = sub7(nextCp0, point7);
      v1 = scale8(v1, -d0 / d1);
      cp1 = add8(point7, v1);
      cp1 = min8(cp1, max9(prevPoint, point7));
      cp1 = max9(cp1, min8(prevPoint, point7));
      v2 = sub7(point7, cp1);
      v2 = scale8(v2, d1 / d0);
      nextCp0 = add8(point7, v2);
      if (hasConstraint) {
        cp1 = max9(cp1, min10);
        cp1 = min8(cp1, max11);
        nextCp0 = max9(nextCp0, min10);
        nextCp0 = min8(nextCp0, max11);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  var _a2;
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i2 = 0, l2 = crp.length; i2 < l2; i2 += 2) {
    pointList.push([crp[i2], crp[i2 + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len5 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p3;
  for (var i2 = 0; i2 < len5 - 1; i2 += 1) {
    cp1 = controlPointList[i2 * 2];
    cp2 = controlPointList[i2 * 2 + 1];
    p3 = pointList[i2 + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p3[0], p3[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len5];
    cp2 = controlPointList[len5 + 1];
    _a2 = __read(pointList, 1), p3 = _a2[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p3[0], p3[1]]);
  }
  return d1;
}

// node_modules/@antv/component/esm/util/primitive.js
var PRIMILTIVE_ATTRIBUTES = [
  "$el",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "fill",
  "fillOpacity",
  "filter",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "height",
  "img",
  "increasedLineWidthForHitTesting",
  "innerHTML",
  "isBillboard",
  "billboardRotation",
  "isSizeAttenuation",
  "isClosed",
  "isOverflowing",
  "leading",
  "letterSpacing",
  "lineDash",
  "lineHeight",
  "lineWidth",
  "markerEnd",
  "markerEndOffset",
  "markerMid",
  "markerStart",
  "markerStartOffset",
  "maxLines",
  "metrics",
  "miterLimit",
  "offsetX",
  "offsetY",
  "opacity",
  "path",
  "points",
  "r",
  "radius",
  "rx",
  "ry",
  "shadowColor",
  "src",
  "stroke",
  "strokeOpacity",
  "text",
  "textAlign",
  "textBaseline",
  "textDecorationColor",
  "textDecorationLine",
  "textDecorationStyle",
  "textOverflow",
  "textPath",
  "textPathSide",
  "textPathStartOffset",
  "transform",
  "transformOrigin",
  "visibility",
  "width",
  "wordWrap",
  "wordWrapWidth",
  "x",
  "x1",
  "x2",
  "y",
  "y1",
  "y2",
  "z1",
  "z2",
  "zIndex"
];
function isPrimitiveAttribute(key) {
  return PRIMILTIVE_ATTRIBUTES.includes(key);
}
function getPrimitiveAttributes(attributes) {
  var object = {};
  for (var key in attributes) {
    if (isPrimitiveAttribute(key))
      object[key] = attributes[key];
  }
  return object;
}

// node_modules/@antv/component/esm/util/sampling.js
function sampling(data2, size3) {
  if (data2.length <= size3)
    return data2;
  var step2 = Math.floor(data2.length / size3);
  var result = [];
  for (var i2 = 0; i2 < data2.length; i2 += step2) {
    result.push(data2[i2]);
  }
  return result;
}

// node_modules/@antv/component/esm/util/scale-to-pixel.js
function scaleToPixel(el, size3, applyScale2) {
  if (applyScale2 === void 0) {
    applyScale2 = false;
  }
  var _a2 = el.getBBox(), width = _a2.width, height = _a2.height;
  var scale12 = size3 / Math.max(width, height);
  if (applyScale2) {
    el.style.transform = "scale(".concat(scale12, ")");
  }
  return scale12;
}

// node_modules/@antv/component/esm/util/group.js
function group2(array2, keyFunc) {
  var grouped = /* @__PURE__ */ new Map();
  array2.forEach(function(item) {
    var key = keyFunc(item);
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key).push(item);
  });
  return grouped;
}

// node_modules/@antv/component/esm/util/selection.js
function error2(msg) {
  throw new Error(msg);
}
var Selection2 = (
  /** @class */
  function() {
    function Selection3(elements, data2, parent, document2, selections, transitions, updateElements) {
      if (elements === void 0) {
        elements = null;
      }
      if (data2 === void 0) {
        data2 = null;
      }
      if (parent === void 0) {
        parent = null;
      }
      if (document2 === void 0) {
        document2 = null;
      }
      if (selections === void 0) {
        selections = [null, null, null, null, null];
      }
      if (transitions === void 0) {
        transitions = [];
      }
      if (updateElements === void 0) {
        updateElements = [];
      }
      _Selection_instances.add(this);
      this._elements = Array.from(elements);
      this._data = data2;
      this._parent = parent;
      this._document = document2;
      this._enter = selections[0];
      this._update = selections[1];
      this._exit = selections[2];
      this._merge = selections[3];
      this._split = selections[4];
      this._transitions = transitions;
      this._facetElements = updateElements;
    }
    Selection3.prototype.selectAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a2(elements, null, this._elements[0], this._document);
    };
    Selection3.prototype.selectFacetAll = function(selector) {
      var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _a2(this._elements, null, this._parent, this._document, void 0, void 0, elements);
    };
    Selection3.prototype.select = function(selector) {
      var element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
      return new _a2([element], null, element, this._document);
    };
    Selection3.prototype.append = function(node) {
      var _this2 = this;
      var callback = typeof node === "function" ? node : function() {
        return _this2.createElement(node);
      };
      var elements = [];
      if (this._data !== null) {
        for (var i2 = 0; i2 < this._data.length; i2++) {
          var d4 = this._data[i2];
          var _b = __read(Array.isArray(d4) ? d4 : [d4, null], 2), datum = _b[0], from = _b[1];
          var newElement = callback(datum, i2);
          newElement.__data__ = datum;
          if (from !== null)
            newElement.__fromElements__ = from;
          this._parent.appendChild(newElement);
          elements.push(newElement);
        }
        return new _a2(elements, null, this._parent, this._document);
      }
      for (var i2 = 0; i2 < this._elements.length; i2++) {
        var element = this._elements[i2];
        var datum = element.__data__;
        var newElement = callback(datum, i2);
        element.appendChild(newElement);
        elements.push(newElement);
      }
      return new _a2(elements, null, elements[0], this._document);
    };
    Selection3.prototype.maybeAppend = function(id4, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, id4[0] === "#" ? id4 : "#".concat(id4), node);
      element.attr("id", id4);
      return element;
    };
    Selection3.prototype.maybeAppendByClassName = function(className2, node) {
      var cls = className2.toString();
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, cls[0] === "." ? cls : ".".concat(cls), node);
      element.attr("className", cls);
      return element;
    };
    Selection3.prototype.maybeAppendByName = function(name2, node) {
      var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, '[name="'.concat(name2, '"]'), node);
      element.attr("name", name2);
      return element;
    };
    Selection3.prototype.data = function(data2, id4, groupId) {
      var e_1, _b;
      if (id4 === void 0) {
        id4 = function(d4) {
          return d4;
        };
      }
      if (groupId === void 0) {
        groupId = function() {
          return null;
        };
      }
      var enter = [];
      var update2 = [];
      var exit = new Set(this._elements);
      var merge2 = [];
      var split = /* @__PURE__ */ new Set();
      var keyElement = new Map(this._elements.map(function(d4, i3) {
        return [id4(d4.__data__, i3), d4];
      }));
      var keyUpdateElement = new Map(this._facetElements.map(function(d4, i3) {
        return [id4(d4.__data__, i3), d4];
      }));
      var groupKeyElements = group2(this._elements, function(d4) {
        return groupId(d4.__data__);
      });
      for (var i2 = 0; i2 < data2.length; i2++) {
        var datum = data2[i2];
        var key = id4(datum, i2);
        var groupKey = groupId(datum, i2);
        if (keyElement.has(key)) {
          var element = keyElement.get(key);
          element.__data__ = datum;
          element.__facet__ = false;
          update2.push(element);
          exit.delete(element);
          keyElement.delete(key);
        } else if (keyUpdateElement.has(key)) {
          var element = keyUpdateElement.get(key);
          element.__data__ = datum;
          element.__facet__ = true;
          update2.push(element);
          keyUpdateElement.delete(key);
        } else if (groupKeyElements.has(key)) {
          var group_2 = groupKeyElements.get(key);
          merge2.push([datum, group_2]);
          try {
            for (var group_1 = (e_1 = void 0, __values(group_2)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
              var element = group_1_1.value;
              exit.delete(element);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (group_1_1 && !group_1_1.done && (_b = group_1.return)) _b.call(group_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          groupKeyElements.delete(key);
        } else if (keyElement.has(groupKey)) {
          var element = keyElement.get(groupKey);
          if (element.__toData__)
            element.__toData__.push(datum);
          else
            element.__toData__ = [datum];
          split.add(element);
          exit.delete(element);
        } else {
          enter.push(datum);
        }
      }
      var S = [
        new _a2([], enter, this._parent, this._document),
        new _a2(update2, null, this._parent, this._document),
        new _a2(exit, null, this._parent, this._document),
        new _a2([], merge2, this._parent, this._document),
        new _a2(split, null, this._parent, this._document)
      ];
      return new _a2(this._elements, null, this._parent, this._document, S);
    };
    Selection3.prototype.merge = function(other) {
      var elements = __spreadArray(__spreadArray([], __read(this._elements), false), __read(other._elements), false);
      var transitions = __spreadArray(__spreadArray([], __read(this._transitions), false), __read(other._transitions), false);
      return new _a2(elements, null, this._parent, this._document, void 0, transitions);
    };
    Selection3.prototype.createElement = function(type) {
      if (this._document) {
        return this._document.createElement(type, {});
      }
      var Ctor = _a2.registry[type];
      if (Ctor)
        return new Ctor();
      return error2("Unknown node type: ".concat(type));
    };
    Selection3.prototype.join = function(enter, update2, exit, merge2, split) {
      if (enter === void 0) {
        enter = function(d4) {
          return d4;
        };
      }
      if (update2 === void 0) {
        update2 = function(d4) {
          return d4;
        };
      }
      if (exit === void 0) {
        exit = function(d4) {
          return d4.remove();
        };
      }
      if (merge2 === void 0) {
        merge2 = function(d4) {
          return d4;
        };
      }
      if (split === void 0) {
        split = function(d4) {
          return d4.remove();
        };
      }
      var newEnter = enter(this._enter);
      var newUpdate = update2(this._update);
      var newExit = exit(this._exit);
      var newMerge = merge2(this._merge);
      var newSplit = split(this._split);
      return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
    };
    Selection3.prototype.remove = function() {
      var _loop_1 = function(i3) {
        var element = this_1._elements[i3];
        var transition2 = this_1._transitions[i3];
        if (transition2) {
          transition2.then(function() {
            return element.remove();
          });
        } else {
          element.remove();
        }
      };
      var this_1 = this;
      for (var i2 = 0; i2 < this._elements.length; i2++) {
        _loop_1(i2);
      }
      return new _a2([], null, this._parent, this._document, void 0, this._transitions);
    };
    Selection3.prototype.each = function(callback) {
      for (var i2 = 0; i2 < this._elements.length; i2++) {
        var element = this._elements[i2];
        var datum = element.__data__;
        callback.call(element, datum, i2);
      }
      return this;
    };
    Selection3.prototype.attr = function(key, value2) {
      var callback = typeof value2 !== "function" ? function() {
        return value2;
      } : value2;
      return this.each(function(d4, i2) {
        if (value2 !== void 0)
          this[key] = callback.call(this, d4, i2);
      });
    };
    Selection3.prototype.style = function(key, value2, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof value2 !== "function" || !callable ? function() {
        return value2;
      } : value2;
      return this.each(function(d4, i2) {
        if (value2 !== void 0)
          this.style[key] = callback.call(this, d4, i2);
      });
    };
    Selection3.prototype.styles = function(style, callable) {
      if (style === void 0) {
        style = {};
      }
      if (callable === void 0) {
        callable = true;
      }
      return this.each(function(d4, i2) {
        var _this2 = this;
        Object.entries(style).forEach(function(_b) {
          var _c = __read(_b, 2), key = _c[0], value2 = _c[1];
          var callback = typeof value2 !== "function" || !callable ? function() {
            return value2;
          } : value2;
          if (value2 !== void 0)
            _this2.attr(key, callback.call(_this2, d4, i2));
        });
      });
    };
    Selection3.prototype.update = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d4, i2) {
        if (option && this.update)
          this.update(callback.call(this, d4, i2));
      });
    };
    Selection3.prototype.maybeUpdate = function(option, callable) {
      if (callable === void 0) {
        callable = true;
      }
      var callback = typeof option !== "function" || !callable ? function() {
        return option;
      } : option;
      return this.each(function(d4, i2) {
        if (option && this.update)
          this.update(callback.call(this, d4, i2));
      });
    };
    Selection3.prototype.transition = function(callback) {
      var T2 = this._transitions;
      var newTransitions = new Array(this._elements.length);
      this.each(function(d4, i2) {
        newTransitions[i2] = callback.call(this, d4, i2);
      });
      this._transitions = flatten_default(newTransitions);
      return this;
    };
    Selection3.prototype.on = function(event, handler) {
      this.each(function() {
        this.addEventListener(event, handler);
      });
      return this;
    };
    Selection3.prototype.call = function(callback) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      callback.call.apply(callback, __spreadArray([this._parent, this], __read(args), false));
      return this;
    };
    Selection3.prototype.node = function() {
      return this._elements[0];
    };
    Selection3.prototype.nodes = function() {
      return this._elements;
    };
    Selection3.prototype.transitions = function() {
      return this._transitions.filter(function(t) {
        return !!t;
      });
    };
    Selection3.prototype.parent = function() {
      return this._parent;
    };
    var _Selection_instances, _a2, _Selection_maybeAppend;
    _a2 = Selection3, _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_maybeAppend = function _Selection_maybeAppend2(selector, node) {
      var element = this._elements[0];
      var child = element.querySelector(selector);
      if (child)
        return new _a2([child], null, this._parent, this._document);
      var newChild = typeof node === "string" ? this.createElement(node) : node();
      element.appendChild(newChild);
      return new _a2([newChild], null, this._parent, this._document);
    };
    Selection3.registry = {
      g: Group2,
      rect: Rect,
      circle: Circle,
      path: Path2,
      text: Text2,
      ellipse: Ellipse,
      image: Image2,
      line: Line,
      polygon: Polygon,
      polyline: Polyline,
      html: HTML
    };
    return Selection3;
  }()
);
function select2(node) {
  return new Selection2([node], null, node, node.ownerDocument);
}
function maybeAppend(parent, selector, node) {
  if (!parent.querySelector(selector)) {
    return select2(parent).append(node);
  }
  return select2(parent).select(selector);
}

// node_modules/@antv/component/esm/util/series.js
function parseSeriesAttr(series) {
  if (isNumber(series)) {
    return [series, series, series, series];
  }
  if (isArray(series)) {
    var len5 = series.length;
    if (len5 === 1) {
      return [series[0], series[0], series[0], series[0]];
    }
    if (len5 === 2) {
      return [series[0], series[1], series[0], series[1]];
    }
    if (len5 === 3) {
      return [series[0], series[1], series[2], series[1]];
    }
    if (len5 === 4) {
      return series;
    }
  }
  return [0, 0, 0, 0];
}

// node_modules/@antv/component/esm/util/shape.js
function getShapeSpace(shape23) {
  var bounds = shape23 && shape23.getRenderBounds();
  if (!bounds)
    return {
      width: 0,
      height: 0
    };
  var max11 = bounds.getMax();
  var min10 = bounds.getMin();
  return {
    width: max11[0] - min10[0],
    height: max11[1] - min10[1]
  };
}
function getLocalBBox(shape23) {
  var _a2 = shape23.getLocalBounds(), min10 = _a2.min, max11 = _a2.max;
  var _b = __read([min10, max11], 2), _c = __read(_b[0], 2), x12 = _c[0], y12 = _c[1], _d = __read(_b[1], 2), x22 = _d[0], y22 = _d[1];
  return { x: x12, y: y12, width: x22 - x12, height: y22 - y12, left: x12, bottom: y22, top: y12, right: x22 };
}
function isHorizontal(p1, p22) {
  var _a2 = __read(p1, 2), x12 = _a2[0], y12 = _a2[1];
  var _b = __read(p22, 2), x22 = _b[0], y22 = _b[1];
  return x12 !== x22 && y12 === y22;
}
function copyAttributes2(target, source) {
  var e_1, _a2;
  var attributes = source.attributes;
  try {
    for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), key = _d[0], value2 = _d[1];
      if (key !== "id" && key !== "className")
        target.attr(key, value2);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
}

// node_modules/@antv/component/esm/util/string.js
function toUppercaseFirstLetter(string) {
  return string.toString().charAt(0).toUpperCase() + string.toString().slice(1);
}
function toLowercaseFirstLetter(string) {
  return string.toString().charAt(0).toLowerCase() + string.toString().slice(1);
}
function addPrefix(string, prefix) {
  return "".concat(prefix).concat(toUppercaseFirstLetter(string));
}
function removePrefix(string, prefix, lowercaseFirstLetter) {
  var _a2;
  if (lowercaseFirstLetter === void 0) {
    lowercaseFirstLetter = true;
  }
  var inferPrefix = prefix || ((_a2 = string.match(/^([a-z][a-z0-9]+)/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
  var withoutPrefix = string.replace(new RegExp("^(".concat(inferPrefix, ")")), "");
  return lowercaseFirstLetter ? toLowercaseFirstLetter(withoutPrefix) : withoutPrefix;
}

// node_modules/@antv/component/esm/util/style.js
function applyStyleSheet(element, style) {
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), selector = _b[0], styleString = _b[1];
    __spreadArray([element], __read(element.querySelectorAll(selector)), false).filter(function(el) {
      return el.matches(selector);
    }).forEach(function(target) {
      if (!target)
        return;
      var temp = target;
      temp.style.cssText += Object.entries(styleString).reduce(function(total, currVal) {
        return "".concat(total).concat(currVal.join(":"), ";");
      }, "");
    });
  });
}
var startsWith = function(text, prefix) {
  if (!(text === null || text === void 0 ? void 0 : text.startsWith(prefix)))
    return false;
  var nextChart = text[prefix.length];
  return nextChart >= "A" && nextChart <= "Z";
};
function subStyleProps(style, prefix, invert5) {
  if (invert5 === void 0) {
    invert5 = false;
  }
  var result = {};
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    if (key === "className" || key === "class") {
    } else if (startsWith(key, "show") && startsWith(removePrefix(key, "show"), prefix) !== invert5) {
      if (key === addPrefix(prefix, "show"))
        result[key] = value2;
      else
        result[key.replace(new RegExp(toUppercaseFirstLetter(prefix)), "")] = value2;
    } else if (!startsWith(key, "show") && startsWith(key, prefix) !== invert5) {
      var name_1 = removePrefix(key, prefix);
      if (name_1 === "filter" && typeof value2 === "function") {
      } else
        result[name_1] = value2;
    }
  });
  return result;
}
function superStyleProps(style, prefix) {
  return Object.entries(style).reduce(function(acc, _a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    if (key.startsWith("show"))
      acc["show".concat(prefix).concat(key.slice(4))] = value2;
    else
      acc["".concat(prefix).concat(toUppercaseFirstLetter(key))] = value2;
    return acc;
  }, {});
}
function splitStyle(style, ignoreStyleDict) {
  if (ignoreStyleDict === void 0) {
    ignoreStyleDict = ["x", "y", "class", "className"];
  }
  var groupStyleDict = [
    "transform",
    "transformOrigin",
    "anchor",
    "visibility",
    "pointerEvents",
    "zIndex",
    "cursor",
    "clipPath",
    "clipPathTargets",
    "offsetPath",
    "offsetPathTargets",
    "offsetDistance",
    "draggable",
    "droppable"
  ];
  var output = {};
  var groupStyle = {};
  Object.entries(style).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], val = _b[1];
    if (ignoreStyleDict.includes(key)) {
    } else if (groupStyleDict.indexOf(key) !== -1)
      groupStyle[key] = val;
    else
      output[key] = val;
  });
  return [output, groupStyle];
}

// node_modules/@antv/component/esm/util/svg2marker.js
var import_svg_path_parser = __toESM(require_svg_path_parser());

// node_modules/@antv/component/esm/util/time.js
function formatTime(date, mask) {
  var timeMap = {
    YYYY: date.getFullYear(),
    MM: date.getMonth() + 1,
    DD: date.getDate(),
    HH: date.getHours(),
    mm: date.getMinutes(),
    ss: date.getSeconds()
  };
  var strftime = mask;
  Object.keys(timeMap).forEach(function(key) {
    var val = timeMap[key];
    strftime = strftime.replace(key, key === "YYYY" ? "".concat(val) : "".concat(val).padStart(2, "0"));
  });
  return strftime;
}

// node_modules/@antv/component/esm/util/transform.js
function getTranslate(node, x3, y4) {
  var _a2 = node.getBBox(), width = _a2.width, height = _a2.height;
  var _b = __read([x3, y4].map(function(v, i2) {
    var _a3;
    return v.includes("%") ? parseFloat(((_a3 = v.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || _a3 === void 0 ? void 0 : _a3[0]) || "0") / 100 * (i2 === 0 ? width : height) : v;
  }), 2), tx = _b[0], ty = _b[1];
  return [tx, ty];
}
function percentTransform(node, val) {
  if (!val)
    return;
  try {
    var reg = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g;
    var computedVal = val.replace(reg, function(match, x3, y4) {
      return "translate(".concat(getTranslate(node, x3, y4), ")");
    });
    node.attr("transform", computedVal);
  } catch (e3) {
  }
}

// node_modules/@antv/component/esm/util/transpose.js
function transpose4(m3) {
  var _a2;
  return ((_a2 = m3[0]) === null || _a2 === void 0 ? void 0 : _a2.map(function(x3, i2) {
    return m3.map(function(x4) {
      return x4[i2];
    });
  })) || [];
}

// node_modules/@antv/component/esm/util/replace-children.js
var replaceChildren = function(el, content) {
  if (content == null) {
    el.innerHTML = "";
    return;
  }
  if (el.replaceChildren) {
    if (Array.isArray(content)) {
      el.replaceChildren.apply(el, __spreadArray([], __read(content), false));
    } else {
      el.replaceChildren(content);
    }
  } else {
    el.innerHTML = "";
    if (Array.isArray(content)) {
      content.forEach(function(child) {
        return el.appendChild(child);
      });
    } else {
      el.appendChild(content);
    }
  }
};

// node_modules/@antv/component/esm/core/component.js
function applyVisibility() {
  visibility(this, this.attributes.visibility !== "hidden");
}
var Component = (
  /** @class */
  function(_super) {
    __extends(Component2, _super);
    function Component2(options, defaultStyleProps) {
      if (defaultStyleProps === void 0) {
        defaultStyleProps = {};
      }
      var _this2 = _super.call(this, deepAssign2({}, { style: defaultStyleProps }, options)) || this;
      _this2.initialized = false;
      _this2._defaultOptions = defaultStyleProps;
      return _this2;
    }
    Object.defineProperty(Component2.prototype, "offscreenGroup", {
      get: function() {
        if (!this._offscreen)
          this._offscreen = createOffscreenGroup(this);
        return this._offscreen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Component2.prototype, "defaultOptions", {
      get: function() {
        return this._defaultOptions;
      },
      enumerable: false,
      configurable: true
    });
    Component2.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
      this.initialized = true;
    };
    Component2.prototype.disconnectedCallback = function() {
      var _a2;
      (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    Component2.prototype.attributeChangedCallback = function(name2) {
      if (name2 === "visibility") {
        applyVisibility.call(this);
      }
    };
    Component2.prototype.update = function(attr2, animate2) {
      var _a2;
      this.attr(deepAssign2({}, this.attributes, attr2 || {}));
      return (_a2 = this.render) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.attributes, this, animate2);
    };
    Component2.prototype.clear = function() {
      this.removeChildren();
    };
    Component2.prototype.bindEvents = function(attributes, container) {
    };
    Component2.prototype.getSubShapeStyle = function(attributes) {
      var x3 = attributes.x, y4 = attributes.y, transform2 = attributes.transform, transformOrigin = attributes.transformOrigin, _class = attributes.class, className2 = attributes.className, zIndex = attributes.zIndex, style = __rest(attributes, ["x", "y", "transform", "transformOrigin", "class", "className", "zIndex"]);
      return style;
    };
    return Component2;
  }(CustomElement)
);

// node_modules/@antv/component/esm/ui/marker/symbol.js
var circle = function(x3, y4, r2) {
  return [["M", x3 - r2, y4], ["A", r2, r2, 0, 1, 0, x3 + r2, y4], ["A", r2, r2, 0, 1, 0, x3 - r2, y4], ["Z"]];
};
var point6 = circle;
var square2 = function(x3, y4, r2) {
  return [["M", x3 - r2, y4 - r2], ["L", x3 + r2, y4 - r2], ["L", x3 + r2, y4 + r2], ["L", x3 - r2, y4 + r2], ["Z"]];
};
var diamond2 = function(x3, y4, r2) {
  return [["M", x3 - r2, y4], ["L", x3, y4 - r2], ["L", x3 + r2, y4], ["L", x3, y4 + r2], ["Z"]];
};
var triangle2 = function(x3, y4, r2) {
  var diffY = r2 * Math.sin(1 / 3 * Math.PI);
  return [["M", x3 - r2, y4 + diffY], ["L", x3, y4 - diffY], ["L", x3 + r2, y4 + diffY], ["Z"]];
};
var triangleDown2 = function(x3, y4, r2) {
  var diffY = r2 * Math.sin(1 / 3 * Math.PI);
  return [["M", x3 - r2, y4 - diffY], ["L", x3 + r2, y4 - diffY], ["L", x3, y4 + diffY], ["Z"]];
};
var hexagon2 = function(x3, y4, r2) {
  var diffX = r2 / 2 * Math.sqrt(3);
  return [
    ["M", x3, y4 - r2],
    ["L", x3 + diffX, y4 - r2 / 2],
    ["L", x3 + diffX, y4 + r2 / 2],
    ["L", x3, y4 + r2],
    ["L", x3 - diffX, y4 + r2 / 2],
    ["L", x3 - diffX, y4 - r2 / 2],
    ["Z"]
  ];
};
var bowtie2 = function(x3, y4, r2) {
  var diffY = r2 - 1.5;
  return [["M", x3 - r2, y4 - diffY], ["L", x3 + r2, y4 + diffY], ["L", x3 + r2, y4 - diffY], ["L", x3 - r2, y4 + diffY], ["Z"]];
};
var line2 = function(x3, y4, r2) {
  return [
    ["M", x3, y4 + r2],
    ["L", x3, y4 - r2]
  ];
};
var cross6 = function(x3, y4, r2) {
  return [
    ["M", x3 - r2, y4 - r2],
    ["L", x3 + r2, y4 + r2],
    ["M", x3 + r2, y4 - r2],
    ["L", x3 - r2, y4 + r2]
  ];
};
var tick2 = function(x3, y4, r2) {
  return [
    ["M", x3 - r2 / 2, y4 - r2],
    ["L", x3 + r2 / 2, y4 - r2],
    ["M", x3, y4 - r2],
    ["L", x3, y4 + r2],
    ["M", x3 - r2 / 2, y4 + r2],
    ["L", x3 + r2 / 2, y4 + r2]
  ];
};
var plus2 = function(x3, y4, r2) {
  return [
    ["M", x3 - r2, y4],
    ["L", x3 + r2, y4],
    ["M", x3, y4 - r2],
    ["L", x3, y4 + r2]
  ];
};
var hyphen2 = function(x3, y4, r2) {
  return [
    ["M", x3 - r2, y4],
    ["L", x3 + r2, y4]
  ];
};
var dot7 = function(x3, y4, r2) {
  return [
    ["M", x3 - r2, y4],
    ["L", x3 + r2, y4]
  ];
};
var dash2 = dot7;
var smooth2 = function(x3, y4, r2) {
  return [
    ["M", x3 - r2, y4],
    ["A", r2 / 2, r2 / 2, 0, 1, 1, x3, y4],
    ["A", r2 / 2, r2 / 2, 0, 1, 0, x3 + r2, y4]
  ];
};
var hv2 = function(x3, y4, r2) {
  return [
    ["M", x3 - r2 - 1, y4 - 2.5],
    ["L", x3, y4 - 2.5],
    ["L", x3, y4 + 2.5],
    ["L", x3 + r2 + 1, y4 + 2.5]
  ];
};
var vh2 = function(x3, y4, r2) {
  return [
    ["M", x3 - r2 - 1, y4 + 2.5],
    ["L", x3, y4 + 2.5],
    ["L", x3, y4 - 2.5],
    ["L", x3 + r2 + 1, y4 - 2.5]
  ];
};
var hvh2 = function(x3, y4, r2) {
  return [
    ["M", x3 - (r2 + 1), y4 + 2.5],
    ["L", x3 - r2 / 2, y4 + 2.5],
    ["L", x3 - r2 / 2, y4 - 2.5],
    ["L", x3 + r2 / 2, y4 - 2.5],
    ["L", x3 + r2 / 2, y4 + 2.5],
    ["L", x3 + r2 + 1, y4 + 2.5]
  ];
};
function vhv2(x3, y4) {
  return [
    ["M", x3 - 5, y4 + 2.5],
    ["L", x3 - 5, y4],
    ["L", x3, y4],
    ["L", x3, y4 - 3],
    ["L", x3, y4 + 3],
    ["L", x3 + 6.5, y4 + 3]
  ];
}
var button = function(x3, y4, r2) {
  return [["M", x3 - r2, y4 - r2], ["L", x3 + r2, y4], ["L", x3 - r2, y4 + r2], ["Z"]];
};

// node_modules/@antv/component/esm/ui/marker/utils.js
function parseMarker(icon) {
  var type = "default";
  if (is_object_default(icon) && icon instanceof Image)
    type = "image";
  else if (isFunction(icon))
    type = "symbol";
  else if (isString(icon)) {
    var dataURLsPattern = new RegExp("data:(image|text)");
    if (icon.match(dataURLsPattern)) {
      type = "base64";
    } else if (/^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(icon)) {
      type = "url";
    } else {
      type = "symbol";
    }
  }
  return type;
}

// node_modules/@antv/component/esm/ui/marker/index.js
function getType(symbol) {
  var markerType = parseMarker(symbol);
  if (["base64", "url", "image"].includes(markerType)) {
    return "image";
  }
  if (symbol && markerType === "symbol") {
    return "path";
  }
  return null;
}
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker2, _super);
    function Marker2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker2.prototype.render = function(attributes, container) {
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y4 = _b === void 0 ? 0 : _b;
      var _c = this.getSubShapeStyle(attributes), symbol = _c.symbol, _d = _c.size, size3 = _d === void 0 ? 16 : _d, style = __rest(_c, ["symbol", "size"]);
      var type = getType(symbol);
      ifShow(!!type, select2(container), function(group3) {
        group3.maybeAppendByClassName("marker", type).attr("className", "marker ".concat(type, "-marker")).call(function(selection) {
          if (type === "image") {
            var r2 = size3 * 2;
            selection.styles({
              img: symbol,
              width: r2,
              height: r2,
              x: x3 - size3,
              y: y4 - size3
            });
          } else {
            var r2 = size3 / 2;
            var symbolFn = isFunction(symbol) ? symbol : Marker2.getSymbol(symbol);
            selection.styles(__assign({ d: symbolFn === null || symbolFn === void 0 ? void 0 : symbolFn(x3, y4, r2) }, style));
          }
        });
      });
    };
    Marker2.MARKER_SYMBOL_MAP = /* @__PURE__ */ new Map();
    Marker2.registerSymbol = function(type, symbol) {
      Marker2.MARKER_SYMBOL_MAP.set(type, symbol);
    };
    Marker2.getSymbol = function(type) {
      return Marker2.MARKER_SYMBOL_MAP.get(type);
    };
    Marker2.getSymbols = function() {
      return Array.from(Marker2.MARKER_SYMBOL_MAP.keys());
    };
    return Marker2;
  }(Component)
);
Marker.registerSymbol("cross", cross6);
Marker.registerSymbol("hyphen", hyphen2);
Marker.registerSymbol("line", line2);
Marker.registerSymbol("plus", plus2);
Marker.registerSymbol("tick", tick2);
Marker.registerSymbol("circle", circle);
Marker.registerSymbol("point", point6);
Marker.registerSymbol("bowtie", bowtie2);
Marker.registerSymbol("hexagon", hexagon2);
Marker.registerSymbol("square", square2);
Marker.registerSymbol("diamond", diamond2);
Marker.registerSymbol("triangle", triangle2);
Marker.registerSymbol("triangle-down", triangleDown2);
Marker.registerSymbol("line", line2);
Marker.registerSymbol("dot", dot7);
Marker.registerSymbol("dash", dash2);
Marker.registerSymbol("smooth", smooth2);
Marker.registerSymbol("hv", hv2);
Marker.registerSymbol("vh", vh2);
Marker.registerSymbol("hvh", hvh2);
Marker.registerSymbol("vhv", vhv2);

// node_modules/@antv/component/esm/ui/tag/index.js
function adjust(container, paddingLeft, paddingTop, align, baseline) {
  var bounds = container.getLocalBounds();
  var x3 = 0;
  var y4 = 0;
  if (align === "start")
    x3 = paddingLeft;
  if (align === "center")
    x3 = -bounds.halfExtents[0];
  if (align === "end")
    x3 = -paddingLeft - bounds.halfExtents[0] * 2;
  if (baseline === "top")
    y4 = paddingTop + bounds.halfExtents[1];
  if (baseline === "middle")
    y4 = 0;
  if (baseline === "bottom")
    y4 = paddingTop - bounds.halfExtents[1] * 2;
  container.setLocalPosition([x3, y4]);
}
function getTextPosition(markerShape, spacing) {
  var bounds = markerShape.getLocalBounds();
  return {
    x: bounds.halfExtents[0] ? bounds.max[0] + (spacing || 0) : markerShape.style.x,
    y: bounds.halfExtents[1] ? (bounds.min[1] + bounds.max[1]) / 2 : markerShape.style.y
  };
}
var Tag = (
  /** @class */
  function(_super) {
    __extends(Tag3, _super);
    function Tag3(options) {
      return _super.call(this, options, {
        padding: 4,
        spacing: 4
      }) || this;
    }
    Tag3.prototype.render = function(attributes, container) {
      var _a2 = attributes.padding, padding = _a2 === void 0 ? 0 : _a2, marker = attributes.marker, text = attributes.text, radius = attributes.radius, spacing = attributes.spacing, align = attributes.align, verticalAlign = attributes.verticalAlign;
      var labelStyle = subStyleProps(attributes, "label");
      var backgroundStyle = subStyleProps(attributes, "background");
      var _b = __read(parseSeriesAttr(padding), 4), pt = _b[0], pr = _b[1], pb = _b[2], pl = _b[3];
      var group3 = maybeAppend(container, ".tag-content", "g").attr("className", "tag-content").style("zIndex", 0).node();
      var markerStyle = marker || { symbol: "triangle", size: 0 };
      var markerShape = maybeAppend(group3, ".tag-marker", function() {
        return new Marker({ style: markerStyle });
      }).attr("className", "tag-marker").update(markerStyle).node();
      var _c = getTextPosition(markerShape, spacing), x3 = _c.x, y4 = _c.y;
      select2(group3).maybeAppendByClassName("tag-text", function() {
        return new Text2();
      }).styles(__assign(__assign({ fontSize: 12, text: isNil(text) ? "" : "".concat(text), x: x3, y: y4 }, labelStyle), { textBaseline: "middle" })).call(function(selection) {
        if (!text)
          selection.remove();
      });
      adjust(group3, pl, pt, align || "start", verticalAlign || "top");
      var bounds = group3.getLocalBounds();
      select2(container).maybeAppendByClassName("tag-background", "rect").styles(__assign({ zIndex: -1, y: bounds.min[1] - pt, x: bounds.min[0] - pl, width: backgroundStyle !== null ? pl + pr + bounds.halfExtents[0] * 2 : 0, height: backgroundStyle !== null ? pt + pb + bounds.halfExtents[1] * 2 : 0, radius: radius !== null && radius !== void 0 ? radius : 2, fill: "#fafafa", stroke: "#d9d9d9", lineWidth: 1 }, backgroundStyle));
    };
    Tag3.tag = "tag";
    return Tag3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/button/constant.js
var SIZE_STYLE = {
  small: {
    textFontSize: 10,
    buttonWidth: 40,
    buttonHeight: 20,
    markerSize: 8
  },
  middle: {
    textFontSize: 12,
    buttonWidth: 60,
    buttonHeight: 30,
    markerSize: 12
  },
  large: {
    textFontSize: 16,
    buttonWidth: 80,
    buttonHeight: 40,
    markerSize: 16
  }
};
var TYPE_STYLE = {
  primary: {
    default: { textFill: "#fff", buttonFill: "#1890ff", buttonLineWidth: 0, markerFill: "#1890ff" },
    active: {
      buttonFill: "#40a9ff",
      markerFill: "#40a9ff"
    },
    disabled: {}
  },
  dashed: {
    default: {
      buttonFill: "transparent",
      buttonStroke: "#bbb",
      buttonLineDash: [5, 5]
    },
    active: {},
    disabled: {}
  },
  link: {
    default: { textFill: "#1890ff", buttonFill: "transparent", buttonLineWidth: 0, markerFill: "#1890ff" },
    active: {},
    disabled: {}
  },
  text: {
    default: { textFill: "#000", buttonFill: "transparent", buttonLineWidth: 0, markerFill: "#000" },
    active: {},
    disabled: {}
  },
  default: {
    default: { textFill: "#000", buttonFill: "transparent", buttonStroke: "#bbb", markerFill: "#bbb" },
    active: { textFill: "#1890ff", buttonStroke: "#1890ff", markerStroke: "#1890ff" },
    disabled: {}
  }
};
var DISABLED_STYLE = {
  // 
  strict: {
    textFill: "#b8b8b8"
  },
  buttonStroke: "#d9d9d9",
  buttonFill: "#f5f5f5",
  markerStroke: "#d9d9d9"
};

// node_modules/@antv/component/esm/ui/button/index.js
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2(options) {
      var _this2 = _super.call(this, options, {
        cursor: "pointer",
        padding: 10,
        size: "middle",
        type: "default",
        text: "",
        state: "default",
        markerAlign: "left",
        markerSpacing: 5,
        default: {
          buttonLineWidth: 1,
          buttonRadius: 5
        },
        active: {}
      }) || this;
      _this2.state = "default";
      _this2.clickEvents = function() {
        var _a2 = _this2.attributes, onClick = _a2.onClick, state = _a2.state;
        if (state !== "disabled")
          onClick === null || onClick === void 0 ? void 0 : onClick.call(_this2, _this2);
      };
      _this2.mouseenterEvent = function() {
        var state = _this2.attributes.state;
        if (state !== "disabled") {
          _this2.state = "active";
          _this2.render(_this2.attributes, _this2);
        }
      };
      _this2.mouseleaveEvent = function() {
        var state = _this2.attributes.state;
        _this2.state = state;
        _this2.render(_this2.attributes, _this2);
      };
      return _this2;
    }
    Object.defineProperty(Button2.prototype, "markerSize", {
      get: function() {
        var markerSymbol = this.attributes.markerSymbol;
        var markerStyle = this.getStyle("marker");
        var markerSize = !markerSymbol ? 0 : (markerStyle === null || markerStyle === void 0 ? void 0 : markerStyle.size) || 2;
        return markerSize;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "textAvailableWidth", {
      /*  */
      get: function() {
        var _a2 = this.attributes, markerSymbol = _a2.markerSymbol, padding = _a2.padding, ellipsis = _a2.ellipsis, bWidth = _a2.width, spacing = _a2.markerSpacing;
        if (!ellipsis)
          return Infinity;
        var width = is_undefined_default(bWidth) ? this.getStyle("button").width : bWidth;
        if (markerSymbol)
          return width - padding * 2 - spacing - this.markerSize;
        return width - padding * 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Button2.prototype, "buttonHeight", {
      get: function() {
        var height = this.attributes.height;
        if (height)
          return +height;
        return +this.getStyle("button").height;
      },
      enumerable: false,
      configurable: true
    });
    Button2.prototype.getStyle = function(name2) {
      var _a2 = this.attributes, size3 = _a2.size, type = _a2.type;
      var state = this.state;
      var mixedStyle = deep_mix_default({}, SIZE_STYLE[size3], TYPE_STYLE[type][state], this.attributes.default, this.attributes[state]);
      if (state === "disabled") {
        Object.keys(mixedStyle).forEach(function(key) {
          if (key in DISABLED_STYLE) {
            mixedStyle[key] = DISABLED_STYLE[key];
          }
        });
        Object.keys(DISABLED_STYLE.strict).forEach(function(key) {
          mixedStyle[key] = DISABLED_STYLE.strict[key];
        });
        deep_mix_default(mixedStyle, this.attributes.disabled || {});
      }
      return subStyleProps(mixedStyle, name2);
    };
    Button2.prototype.render = function(attributes, container) {
      var _a2 = attributes.text, text = _a2 === void 0 ? "" : _a2, _b = attributes.padding, padding = _b === void 0 ? 0 : _b, markerSymbol = attributes.markerSymbol, _c = attributes.markerSpacing, markerSpacing = _c === void 0 ? 0 : _c, _d = attributes.x, x3 = _d === void 0 ? 0 : _d, _e = attributes.y, y4 = _e === void 0 ? 0 : _e;
      container.attr({
        cursor: this.state === "disabled" ? "not-allowed" : "pointer"
      });
      var _f = __read(parseSeriesAttr(padding), 4), pt = _f[0], pr = _f[1], pb = _f[2], pl = _f[3];
      var height = this.buttonHeight;
      var markerStyle = this.getStyle("marker");
      var markerSize = this.markerSize;
      var style = __assign(__assign({}, markerStyle), { symbol: markerSymbol, x: x3 + pl + markerSize / 2, y: y4 + height / 2, size: markerSize });
      var markerShape = maybeAppend(container, ".marker", function() {
        return new Marker({ className: "marker", style });
      }).update({ style }).node();
      var bounds = markerShape.getLocalBounds();
      var textStyle = this.getStyle("text");
      this.textShape = maybeAppend(container, ".text", "text").attr("className", "text").styles(__assign(__assign({ x: x3 + (markerSize ? bounds.max[0] + markerSpacing : pl), y: y4 + height / 2 }, textStyle), { text, textAlign: "left", textBaseline: "middle", wordWrap: true, wordWrapWidth: this.textAvailableWidth, maxLines: 1, textOverflow: "..." })).node();
      var textBounds = this.textShape.getLocalBounds();
      var buttonStyle = this.getStyle("button");
      select2(container).maybeAppendByClassName(".background", "rect").styles(__assign(__assign({ zIndex: -1 }, buttonStyle), { x: x3, y: y4, height, width: pl + (markerSize ? markerSize + markerSpacing : 0) + textBounds.halfExtents[0] * 2 + pr }));
    };
    Button2.prototype.update = function(attr2) {
      if (attr2 === void 0) {
        attr2 = {};
      }
      this.attr(deep_mix_default({}, this.attributes, attr2));
      var state = this.attributes.state;
      this.state = state;
      this.render(this.attributes, this);
    };
    Button2.prototype.setState = function(state) {
      this.update({ state });
    };
    Button2.prototype.hide = function() {
      this.style.visibility = "hidden";
    };
    Button2.prototype.show = function() {
      this.style.visibility = "visible";
    };
    Button2.prototype.bindEvents = function() {
      this.addEventListener("click", this.clickEvents);
      this.addEventListener("mouseenter", this.mouseenterEvent);
      this.addEventListener("mouseleave", this.mouseleaveEvent);
    };
    Button2.tag = "button";
    return Button2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/breadcrumb/index.js
var Breadcrumb = (
  /** @class */
  function(_super) {
    __extends(Breadcrumb2, _super);
    function Breadcrumb2(options) {
      return _super.call(this, deep_mix_default({}, Breadcrumb2.defaultOptions, options)) || this;
    }
    Breadcrumb2.prototype.render = function(attributes, container) {
      var x3 = attributes.x, y4 = attributes.y, items = attributes.items, textStyle = attributes.textStyle, _a2 = attributes.padding, padding = _a2 === void 0 ? 0 : _a2, width = attributes.width, separator = attributes.separator;
      var _b = __read(parseSeriesAttr(padding), 3), top = _b[0], right2 = _b[1], left2 = _b[2];
      var tagStyle = subStyleProps(attributes, "tag");
      var selection = maybeAppend(container, ".container", "g").styles({
        className: "container",
        x: x3 + left2,
        y: y4 + top
      });
      var cursorX = 0;
      var cursorY = 0;
      selection.node().removeChildren();
      var _loop_1 = function(i3) {
        var datum = items[i3];
        var shape23 = new Tag({
          className: "breadcrumb-item",
          style: __assign(__assign(__assign(__assign({ transform: "translate(".concat(cursorX, ", ").concat(cursorY, ")") }, tagStyle), { text: isNil(datum.text) ? datum.id : datum.text }), pick_default(datum, ["marker"])), {
            // 
            padding: 0
          })
        });
        selection.append(function() {
          return shape23;
        });
        var bounds = shape23.getLocalBounds();
        var shapeW = bounds.halfExtents[0] * 2;
        var shapeH = bounds.halfExtents[1] * 2;
        cursorX += shapeW;
        if (!isNil(width)) {
          var avaliableWidth = width - right2;
          if (cursorX > avaliableWidth) {
            shape23.attr({ transform: "translateY(".concat(cursorY + shapeH, ")") });
            cursorX = shapeW;
            cursorY += shapeH;
          }
        }
        this_1.bindInnerEvents(shape23, datum);
        var _c = separator || {}, _d = _c.spacing, spacing = _d === void 0 ? 0 : _d, _e = _c.text, text = _e === void 0 ? "/" : _e, style = _c.style;
        if (i3 !== items.length - 1) {
          var shape_1 = new Text2({
            className: "".concat(Breadcrumb2.tag, "-separator"),
            id: "".concat(Breadcrumb2.tag, "-separator-").concat(i3),
            style: __assign(__assign({ x: cursorX + spacing, y: cursorY + shapeH / 2 }, style), { text, textAlign: "end", textBaseline: "middle" })
          });
          selection.append(function() {
            return shape_1;
          });
          var bounds_1 = shape_1.getLocalBounds();
          cursorX += bounds_1.halfExtents[0] * 2 + spacing;
        }
      };
      var this_1 = this;
      for (var i2 = 0; i2 < items.length; i2++) {
        _loop_1(i2);
      }
    };
    Breadcrumb2.prototype.update = function(cfg) {
      this.attr(deep_mix_default({}, this.attributes, cfg));
      this.render(this.attributes, this);
    };
    Breadcrumb2.prototype.bindInnerEvents = function(shape23, item) {
      var _a2 = this.attributes, items = _a2.items, onClick = _a2.onClick;
      if (onClick) {
        shape23.addEventListener("click", function() {
          onClick.call(shape23, item.id, item, items);
        });
      }
    };
    Breadcrumb2.tag = "breadcrumb";
    Breadcrumb2.defaultOptions = {
      style: {
        separator: {
          text: "/",
          style: {
            fontSize: 14,
            fill: "rgba(0, 0, 0, 0.45)"
          },
          spacing: 8
        },
        textStyle: {
          default: {
            fontSize: 14,
            fill: "rgba(0, 0, 0, 0.45)"
          },
          active: {
            fill: "#5468ff",
            cursor: "pointer"
          }
        },
        padding: [8, 8, 8, 8]
      }
    };
    return Breadcrumb2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/sparkline/columns.js
var Columns = (
  /** @class */
  function(_super) {
    __extends(Columns2, _super);
    function Columns2(_a2) {
      var _this2 = this;
      var style = _a2.style, rest = __rest(_a2, ["style"]);
      _this2 = _super.call(this, deep_mix_default({}, { type: "column" }, __assign({ style }, rest))) || this;
      _this2.columnsGroup = new Group2({ name: "columns" });
      _this2.appendChild(_this2.columnsGroup);
      _this2.render();
      return _this2;
    }
    Columns2.prototype.render = function() {
      var _a2 = this.attributes, columns = _a2.columns, x3 = _a2.x, y4 = _a2.y;
      this.columnsGroup.style.transform = "translate(".concat(x3, ", ").concat(y4, ")");
      select2(this.columnsGroup).selectAll(".column").data(columns.flat()).join(function(enter) {
        return enter.append("rect").attr("className", "column").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Columns2.prototype.update = function(attr2) {
      this.attr(deepAssign2({}, this.attributes, attr2));
      this.render();
    };
    Columns2.prototype.clear = function() {
      this.removeChildren();
    };
    return Columns2;
  }(DisplayObject)
);

// node_modules/@antv/component/esm/ui/sparkline/lines.js
var Lines = (
  /** @class */
  function(_super) {
    __extends(Lines2, _super);
    function Lines2(_a2) {
      var _this2 = this;
      var style = _a2.style, rest = __rest(_a2, ["style"]);
      _this2 = _super.call(this, deep_mix_default({}, { type: "lines" }, __assign({ style }, rest))) || this;
      _this2.linesGroup = _this2.appendChild(new Group2());
      _this2.areasGroup = _this2.appendChild(new Group2());
      _this2.render();
      return _this2;
    }
    Lines2.prototype.render = function() {
      var _a2 = this.attributes, lines = _a2.lines, areas = _a2.areas, x3 = _a2.x, y4 = _a2.y;
      this.style.transform = "translate(".concat(x3, ", ").concat(y4, ")");
      if (lines)
        this.renderLines(lines);
      if (areas)
        this.renderAreas(areas);
    };
    Lines2.prototype.clear = function() {
      this.linesGroup.removeChildren();
      this.areasGroup.removeChildren();
    };
    Lines2.prototype.update = function(attr2) {
      this.attr(deepAssign2({}, this.attributes, attr2));
      this.render();
    };
    Lines2.prototype.renderLines = function(lines) {
      select2(this.linesGroup).selectAll(".line").data(lines).join(function(enter) {
        return enter.append("path").attr("className", "line").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.attr(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    Lines2.prototype.renderAreas = function(areas) {
      select2(this.linesGroup).selectAll(".area").data(areas).join(function(enter) {
        return enter.append("path").attr("className", "area").each(function(style) {
          this.attr(style);
        });
      }, function(update2) {
        return update2.each(function(style) {
          this.style(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    return Lines2;
  }(DisplayObject)
);

// node_modules/@antv/component/esm/ui/sparkline/path.js
function dataToLines(data2, scales) {
  var _a2;
  var x3 = scales.x, y4 = scales.y;
  var _b = __read(y4.getOptions().range || [0, 0], 2), max11 = _b[0], min10 = _b[1];
  if (min10 > max11)
    _a2 = __read([max11, min10], 2), min10 = _a2[0], max11 = _a2[1];
  return data2.map(function(points) {
    var lines = points.map(function(val, idx) {
      return [x3.map(idx), clamp_default(y4.map(val), min10, max11)];
    });
    return lines;
  });
}
function lineToLinePath(line4, reverse2) {
  if (reverse2 === void 0) {
    reverse2 = false;
  }
  var M2 = reverse2 ? line4.length - 1 : 0;
  var linePath = line4.map(function(point7, idx) {
    return __spreadArray([idx === M2 ? "M" : "L"], __read(point7), false);
  });
  return reverse2 ? linePath.reverse() : linePath;
}
function lineToCurvePath(line4, reverse2) {
  if (reverse2 === void 0) {
    reverse2 = false;
  }
  if (line4.length <= 2) {
    return lineToLinePath(line4);
  }
  var data2 = [];
  var len5 = line4.length;
  for (var idx = 0; idx < len5; idx += 1) {
    var point7 = reverse2 ? line4[len5 - idx - 1] : line4[idx];
    if (!is_equal_default(point7, data2.slice(-2))) {
      data2.push.apply(data2, __spreadArray([], __read(point7), false));
    }
  }
  var path2 = catmullRom2Bezier(data2, false);
  if (reverse2) {
    path2.unshift(__spreadArray(["M"], __read(line4[len5 - 1]), false));
  } else {
    path2.unshift(__spreadArray(["M"], __read(line4[0]), false));
  }
  return path2;
}
function closePathByBaseLine(path2, width, baseline) {
  var closedPath = clone_default(path2);
  closedPath.push(["L", width, baseline], ["L", 0, baseline], ["Z"]);
  return closedPath;
}
function linesToAreaPaths(lines, smooth3, width, baseline) {
  return lines.map(function(line4) {
    return closePathByBaseLine(smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4), width, baseline);
  });
}
function linesToStackAreaPaths(lines, width, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToLinePath(currLine);
    var path2 = void 0;
    if (idx === 0) {
      path2 = closePathByBaseLine(currCurvePath, width, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToLinePath(belowLine, true);
      belowCurvePath[0][0] = "L";
      path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [["Z"]], false);
    }
    paths.push(path2);
  }
  return paths;
}
function linesToStackCurveAreaPaths(lines, width, baseline) {
  var paths = [];
  for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
    var currLine = lines[idx];
    var currCurvePath = lineToCurvePath(currLine);
    var path2 = void 0;
    if (idx === 0) {
      path2 = closePathByBaseLine(currCurvePath, width, baseline);
    } else {
      var belowLine = lines[idx - 1];
      var belowCurvePath = lineToCurvePath(belowLine, true);
      var A6 = currLine[0];
      belowCurvePath[0][0] = "L";
      path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(["M"], __read(A6), false), ["Z"]], false);
    }
    paths.push(path2);
  }
  return paths;
}

// node_modules/@antv/component/esm/ui/sparkline/utils.js
function getRange(data2) {
  if (data2.length === 0)
    return [0, 0];
  return [
    min_default(min_by_default(data2, function(arr) {
      return min_default(arr) || 0;
    })),
    max(max_by_default(data2, function(arr) {
      return max(arr) || 0;
    }))
  ];
}
function getStackedData(_2) {
  var data2 = clone_default(_2);
  var datumLen = data2[0].length;
  var _a2 = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2), positivePrev = _a2[0], negativePrev = _a2[1];
  for (var i2 = 0; i2 < data2.length; i2 += 1) {
    var datum = data2[i2];
    for (var j = 0; j < datumLen; j += 1) {
      if (datum[j] >= 0) {
        datum[j] += positivePrev[j];
        positivePrev[j] = datum[j];
      } else {
        datum[j] += negativePrev[j];
        negativePrev[j] = datum[j];
      }
    }
  }
  return data2;
}

// node_modules/@antv/component/esm/ui/sparkline/index.js
var Sparkline = (
  /** @class */
  function(_super) {
    __extends(Sparkline2, _super);
    function Sparkline2(options) {
      return _super.call(this, options, {
        type: "line",
        x: 0,
        y: 0,
        width: 200,
        height: 20,
        isStack: false,
        color: ["#83daad", "#edbf45", "#d2cef9", "#e290b3", "#6f63f4"],
        smooth: true,
        lineLineWidth: 1,
        areaOpacity: 0,
        isGroup: false,
        columnLineWidth: 1,
        columnStroke: "#fff",
        scale: 1,
        spacing: 0
      }) || this;
    }
    Object.defineProperty(Sparkline2.prototype, "rawData", {
      /**
       * data
       * 
       */
      get: function() {
        var rawData = this.attributes.data;
        if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
          return [[]];
        var data2 = clone_default(rawData);
        return isNumber(data2[0]) ? [data2] : data2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "data", {
      get: function() {
        if (this.attributes.isStack)
          return getStackedData(this.rawData);
        return this.rawData;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "scales", {
      get: function() {
        return this.createScales(this.data);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "baseline", {
      /**
       *  0
       */
      get: function() {
        var y4 = this.scales.y;
        var _a2 = __read(y4.getOptions().domain || [0, 0], 2), y12 = _a2[0], y22 = _a2[1];
        if (y22 < 0) {
          return y4.map(y22);
        }
        return y4.map(y12 < 0 ? 0 : y12);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "containerShape", {
      get: function() {
        var _a2 = this.attributes, width = _a2.width, height = _a2.height;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "linesStyle", {
      get: function() {
        var _this2 = this;
        var _a2 = this.attributes, type = _a2.type, isStack = _a2.isStack, smooth3 = _a2.smooth;
        if (type !== "line")
          throw new Error("linesStyle can only be used in line type");
        var areaStyle = subStyleProps(this.attributes, "area");
        var lineStyle = subStyleProps(this.attributes, "line");
        var width = this.containerShape.width;
        var data2 = this.data;
        if (data2[0].length === 0)
          return { lines: [], areas: [] };
        var _b = this.scales, x3 = _b.x, y4 = _b.y;
        var lines = dataToLines(data2, { type: "line", x: x3, y: y4 });
        var areas = [];
        if (areaStyle) {
          var baseline = this.baseline;
          if (isStack) {
            areas = smooth3 ? linesToStackCurveAreaPaths(lines, width, baseline) : linesToStackAreaPaths(lines, width, baseline);
          } else {
            areas = linesToAreaPaths(lines, smooth3, width, baseline);
          }
        }
        return {
          lines: lines.map(function(line4, idx) {
            return __assign({ stroke: _this2.getColor(idx), d: smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4) }, lineStyle);
          }),
          areas: areas.map(function(path2, idx) {
            return __assign({ d: path2, fill: _this2.getColor(idx) }, areaStyle);
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sparkline2.prototype, "columnsStyle", {
      get: function() {
        var _this2 = this;
        var columnStyle = subStyleProps(this.attributes, "column");
        var _a2 = this.attributes, isStack = _a2.isStack, type = _a2.type, scale12 = _a2.scale;
        if (type !== "column")
          throw new Error("columnsStyle can only be used in column type");
        var height = this.containerShape.height;
        var data2 = this.rawData;
        if (!data2)
          return { columns: [] };
        if (isStack)
          data2 = getStackedData(data2);
        var _b = this.createScales(data2), x3 = _b.x, y4 = _b.y;
        var _c = __read(getRange(data2), 2), minVal = _c[0], maxVal = _c[1];
        var heightScale = new Linear({
          domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
          range: [0, height * scale12]
        });
        var bandWidth3 = x3.getBandWidth();
        var rawData = this.rawData;
        return {
          columns: data2.map(function(column2, i2) {
            return column2.map(function(val, j) {
              var barWidth = bandWidth3 / data2.length;
              var getShape2 = function() {
                return {
                  x: x3.map(j) + barWidth * i2,
                  y: val >= 0 ? y4.map(val) : y4.map(0),
                  width: barWidth,
                  height: heightScale.map(Math.abs(val))
                };
              };
              var getStackShape = function() {
                return {
                  x: x3.map(j),
                  y: y4.map(val),
                  width: bandWidth3,
                  height: heightScale.map(rawData[i2][j])
                };
              };
              return __assign(__assign({ fill: _this2.getColor(i2) }, columnStyle), isStack ? getStackShape() : getShape2());
            });
          })
        };
      },
      enumerable: false,
      configurable: true
    });
    Sparkline2.prototype.render = function(attributes, container) {
      maybeAppend(container, ".container", "rect").attr("className", "container").node();
      var type = attributes.type, x3 = attributes.x, y4 = attributes.y;
      var className2 = "spark".concat(type);
      var style = __assign({ x: x3, y: y4 }, type === "line" ? this.linesStyle : this.columnsStyle);
      select2(container).selectAll(".spark").data([type]).join(function(enter) {
        return enter.append(function(type2) {
          if (type2 === "line")
            return new Lines({ className: className2, style });
          return new Columns({ className: className2, style });
        }).attr("className", "spark ".concat(className2));
      }, function(update2) {
        return update2.update(style);
      }, function(exit) {
        return exit.remove();
      });
    };
    Sparkline2.prototype.getColor = function(index3) {
      var color3 = this.attributes.color;
      if (isArray(color3)) {
        return color3[index3 % color3.length];
      }
      if (isFunction(color3)) {
        return color3.call(null, index3);
      }
      return color3;
    };
    Sparkline2.prototype.createScales = function(data2) {
      var _a2, _b;
      var _c = this.attributes, type = _c.type, scale12 = _c.scale, _d = _c.range, range3 = _d === void 0 ? [] : _d, spacing = _c.spacing;
      var _e = this.containerShape, width = _e.width, height = _e.height;
      var _f = __read(getRange(data2), 2), minVal = _f[0], maxVal = _f[1];
      var yScale = new Linear({
        domain: [(_a2 = range3[0]) !== null && _a2 !== void 0 ? _a2 : minVal, (_b = range3[1]) !== null && _b !== void 0 ? _b : maxVal],
        range: [height, height * (1 - scale12)]
      });
      if (type === "line") {
        return {
          type,
          x: new Linear({
            domain: [0, data2[0].length - 1],
            range: [0, width]
          }),
          y: yScale
        };
      }
      return {
        type,
        x: new Band({
          domain: data2[0].map(function(val, idx) {
            return idx;
          }),
          range: [0, width],
          paddingInner: spacing,
          paddingOuter: spacing / 2,
          align: 0.5
        }),
        y: yScale
      };
    };
    Sparkline2.tag = "sparkline";
    return Sparkline2;
  }(Component)
);

// node_modules/@antv/component/esm/animation/utils.js
function isStandardAnimationOption(option) {
  if (typeof option === "boolean")
    return false;
  return "enter" in option && "update" in option && "exit" in option;
}
function parseAnimationOption(option) {
  if (!option)
    return { enter: false, update: false, exit: false };
  var keys2 = ["enter", "update", "exit"];
  var baseOption = Object.fromEntries(Object.entries(option).filter(function(_a2) {
    var _b = __read(_a2, 1), k2 = _b[0];
    return !keys2.includes(k2);
  }));
  return Object.fromEntries(keys2.map(function(k2) {
    if (isStandardAnimationOption(option)) {
      if (option[k2] === false)
        return [k2, false];
      return [k2, __assign(__assign({}, option[k2]), baseOption)];
    }
    return [k2, baseOption];
  }));
}
function onAnimateFinished(animation, callback) {
  if (!animation)
    callback();
  else
    animation.finished.then(callback);
}
function onAnimatesFinished(animations, callback) {
  if (animations.length === 0)
    callback();
  else
    Promise.all(animations.map(function(a5) {
      return a5 === null || a5 === void 0 ? void 0 : a5.finished;
    })).then(callback);
}
function attr(target, value2) {
  if ("update" in target)
    target.update(value2);
  else
    target.attr(value2);
}
function animate(target, keyframes, options) {
  if (keyframes.length === 0)
    return null;
  if (!options) {
    var state = keyframes.slice(-1)[0];
    attr(target, { style: state });
    return null;
  }
  return target.animate(keyframes, options);
}
function identicalTextNode(source, target) {
  if (source.nodeName !== "text" || target.nodeName !== "text")
    return false;
  if (source.attributes.text !== target.attributes.text)
    return false;
  return true;
}
function transitionShape(source, target, options, after) {
  if (after === void 0) {
    after = "destroy";
  }
  if (identicalTextNode(source, target)) {
    source.remove();
    return [null];
  }
  var afterTransition = function() {
    if (after === "destroy")
      source.destroy();
    else if (after === "hide")
      hide(source);
    if (target.isVisible())
      show(target);
  };
  if (!options) {
    afterTransition();
    return [null];
  }
  var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2, _b = options.delay, delay = _b === void 0 ? 0 : _b;
  var middle = Math.ceil(+duration / 2);
  var offset2 = +duration / 4;
  var _c = __read(source.getGeometryBounds().center, 2), sx = _c[0], sy = _c[1];
  var _d = __read(target.getGeometryBounds().center, 2), ex = _d[0], ey = _d[1];
  var _e = __read([(sx + ex) / 2 - sx, (sy + ey) / 2 - sy], 2), mx = _e[0], my = _e[1];
  var _f = source.style.opacity, so = _f === void 0 ? 1 : _f;
  var _g = target.style.opacity, to = _g === void 0 ? 1 : _g;
  var st = source.style.transform || "";
  var tt = target.style.transform || "";
  var sourceAnimation = source.animate([
    { opacity: so, transform: "translate(0, 0) ".concat(st) },
    { opacity: 0, transform: "translate(".concat(mx, ", ").concat(my, ") ").concat(st) }
  ], __assign(__assign({ fill: "both" }, options), { duration: delay + middle + offset2 }));
  var targetAnimation = target.animate([
    { opacity: 0, transform: "translate(".concat(-mx, ", ").concat(-my, ") ").concat(tt), offset: 0.01 },
    { opacity: to, transform: "translate(0, 0) ".concat(tt) }
  ], __assign(__assign({ fill: "both" }, options), { duration: middle + offset2, delay: delay + middle - offset2 }));
  onAnimateFinished(targetAnimation, afterTransition);
  return [sourceAnimation, targetAnimation];
}
function transition(target, state, options) {
  var from = {};
  var to = {};
  Object.entries(state).forEach(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], tarStyle = _b[1];
    if (!isNil(tarStyle)) {
      var currStyle = target.style[key] || target.parsedStyle[key] || 0;
      if (currStyle !== tarStyle) {
        from[key] = currStyle;
        to[key] = tarStyle;
      }
    }
  });
  if (!options) {
    attr(target, to);
    return null;
  }
  return animate(target, [from, to], __assign({ fill: "both" }, options));
}

// node_modules/@antv/component/esm/animation/fadeOut.js
function fadeOut_default(element, options) {
  if (!element.style.opacity)
    element.style.opacity = 1;
  return transition(element, { opacity: 0 }, options);
}

// node_modules/@antv/component/esm/ui/slider/constant.js
var HANDLE_ICON_DEFAULT_CFG = {
  fill: "#fff",
  lineWidth: 1,
  radius: 2,
  size: 10,
  stroke: "#bfbfbf",
  strokeOpacity: 1,
  zIndex: 0
};
var HANDLE_LABEL_DEFAULT_CFG = {
  fill: "#000",
  fillOpacity: 0.45,
  fontSize: 12,
  textAlign: "center",
  textBaseline: "middle",
  zIndex: 1
};
var HANDLE_DEFAULT_CFG = {
  x: 0,
  y: 0,
  orientation: "horizontal",
  showLabel: true,
  type: "start"
};
var CLASS_NAMES = classNames({
  foreground: "foreground",
  handle: "handle",
  selection: "selection",
  sparkline: "sparkline",
  sparklineGroup: "sparkline-group",
  track: "track",
  brushArea: "brush-area"
}, "slider");

// node_modules/@antv/component/esm/ui/slider/handle.js
var CLASS_NAMES2 = classNames({
  labelGroup: "label-group",
  label: "label",
  iconGroup: "icon-group",
  icon: "icon",
  iconRect: "icon-rect",
  iconLine: "icon-line"
}, "handle");
var HandleIcon = (
  /** @class */
  function(_super) {
    __extends(HandleIcon2, _super);
    function HandleIcon2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HandleIcon2.prototype.render = function(attributes, container) {
      var x3 = attributes.x, y4 = attributes.y, _a2 = attributes.size, size3 = _a2 === void 0 ? 10 : _a2, _b = attributes.radius, radius = _b === void 0 ? size3 / 4 : _b, orientation = attributes.orientation, iconStyle = __rest(attributes, ["x", "y", "size", "radius", "orientation"]);
      var width = size3;
      var height = width * 2.4;
      var rect4 = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconRect, "rect").styles(__assign(__assign({}, iconStyle), { width, height, radius, x: x3 - width / 2, y: y4 - height / 2, transformOrigin: "center" }));
      var x12 = x3 + 1 / 3 * width - width / 2;
      var x22 = x3 + 2 / 3 * width - width / 2;
      var y12 = y4 + 1 / 4 * height - height / 2;
      var y22 = y4 + 3 / 4 * height - height / 2;
      rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-1"), "line").styles(__assign({ x1: x12, x2: x12, y1: y12, y2: y22 }, iconStyle));
      rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-2"), "line").styles(__assign({ x1: x22, x2: x22, y1: y12, y2: y22 }, iconStyle));
      if (orientation === "vertical")
        rect4.node().style.transform = "rotate(90)";
    };
    return HandleIcon2;
  }(Component)
);
var Handle = (
  /** @class */
  function(_super) {
    __extends(Handle3, _super);
    function Handle3(options) {
      return _super.call(this, options, HANDLE_DEFAULT_CFG) || this;
    }
    Handle3.prototype.renderLabel = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, showLabel = _a2.showLabel;
      var _b = subStyleProps(this.attributes, "label"), _c = _b.x, labelX = _c === void 0 ? 0 : _c, _d = _b.y, labelY = _d === void 0 ? 0 : _d, transform2 = _b.transform, transformOrigin = _b.transformOrigin, style = __rest(_b, ["x", "y", "transform", "transformOrigin"]);
      var _e = __read(splitStyle(style, []), 2), labelStyle = _e[0], groupStyle = _e[1];
      var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.labelGroup, "g").styles(groupStyle);
      var _f = __assign(__assign({}, HANDLE_LABEL_DEFAULT_CFG), labelStyle), text = _f.text, rest = __rest(_f, ["text"]);
      ifShow(!!showLabel, labelGroup, function(group3) {
        _this2.label = group3.maybeAppendByClassName(CLASS_NAMES2.label, "text").styles(__assign(__assign({}, rest), { x: x3 + labelX, y: y4 + labelY, transform: transform2, transformOrigin, text: "".concat(text) }));
        _this2.label.on("mousedown", function(e3) {
          e3.stopPropagation();
        });
        _this2.label.on("touchstart", function(e3) {
          e3.stopPropagation();
        });
      });
    };
    Handle3.prototype.renderIcon = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, orientation = _a2.orientation, type = _a2.type;
      var iconStyle = __assign(__assign({ x: x3, y: y4, orientation }, HANDLE_ICON_DEFAULT_CFG), subStyleProps(this.attributes, "icon"));
      var _b = this.attributes.iconShape, iconShape = _b === void 0 ? function() {
        return new HandleIcon({ style: iconStyle });
      } : _b;
      var iconGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconGroup, "g");
      iconGroup.selectAll(CLASS_NAMES2.icon.class).data([iconShape]).join(function(enter) {
        return enter.append(typeof iconShape === "string" ? iconShape : function() {
          return iconShape(type);
        }).attr("className", CLASS_NAMES2.icon.name);
      }, function(update2) {
        return update2.update(iconStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Handle3.prototype.render = function(attributes, container) {
      this.renderIcon(container);
      this.renderLabel(container);
    };
    return Handle3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/slider/index.js
var Slider = (
  /** @class */
  function(_super) {
    __extends(Slider3, _super);
    function Slider3(options) {
      var _this2 = _super.call(this, options, __assign(__assign(__assign({ x: 0, y: 0, animate: { duration: 100, fill: "both" }, brushable: true, formatter: function(val) {
        return val.toString();
      }, handleSpacing: 2, orientation: "horizontal", padding: 0, autoFitLabel: true, scrollable: true, selectionFill: "#5B8FF9", selectionFillOpacity: 0.45, selectionZIndex: 2, showHandle: true, showLabel: true, slidable: true, trackFill: "#416180", trackLength: 200, trackOpacity: 0.05, trackSize: 20, trackZIndex: -1, values: [0, 1], type: "range", selectionType: "select", handleIconOffset: 0 }, superStyleProps(HANDLE_DEFAULT_CFG, "handle")), superStyleProps(HANDLE_ICON_DEFAULT_CFG, "handleIcon")), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, "handleLabel"))) || this;
      _this2.range = [0, 1];
      _this2.onDragStart = function(target) {
        return function(e3) {
          e3.stopPropagation();
          _this2.target = target;
          _this2.prevPos = _this2.getOrientVal(getEventPos(e3));
          var _a2 = _this2.availableSpace, x3 = _a2.x, y4 = _a2.y;
          var _b = _this2.getBBox(), X = _b.x, Y = _b.y;
          _this2.selectionStartPos = _this2.getRatio(_this2.prevPos - _this2.getOrientVal([x3, y4]) - _this2.getOrientVal([+X, +Y]));
          _this2.selectionWidth = 0;
          document.addEventListener("pointermove", _this2.onDragging);
          document.addEventListener("pointerup", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e3) {
        var _a2 = _this2.attributes, slidable = _a2.slidable, brushable = _a2.brushable, type = _a2.type;
        e3.stopPropagation();
        var currPos = _this2.getOrientVal(getEventPos(e3));
        var diffPos = currPos - _this2.prevPos;
        if (!diffPos)
          return;
        var deltaVal = _this2.getRatio(diffPos);
        switch (_this2.target) {
          case "start":
            if (slidable)
              _this2.setValuesOffset(deltaVal);
            break;
          case "end":
            if (slidable)
              _this2.setValuesOffset(0, deltaVal);
            break;
          case "selection":
            if (slidable)
              _this2.setValuesOffset(deltaVal, deltaVal);
            break;
          case "track":
            if (!brushable)
              return;
            _this2.selectionWidth += deltaVal;
            if (type === "range") {
              _this2.innerSetValues([_this2.selectionStartPos, _this2.selectionStartPos + _this2.selectionWidth].sort(), true);
            } else
              _this2.innerSetValues([0, _this2.selectionStartPos + _this2.selectionWidth], true);
            break;
          default:
            break;
        }
        _this2.prevPos = currPos;
      };
      _this2.onDragEnd = function() {
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointermove", _this2.onDragging);
        document.removeEventListener("pointerup", _this2.onDragEnd);
        _this2.target = "";
        _this2.updateHandlesPosition(false);
      };
      _this2.onValueChange = function(oldValue) {
        var _a2 = _this2.attributes, onChange = _a2.onChange, type = _a2.type;
        var internalOldValue = type === "range" ? oldValue : oldValue[1];
        var value2 = type === "range" ? _this2.getValues() : _this2.getValues()[1];
        var evt = new CustomEvent("valuechange", {
          detail: { oldValue: internalOldValue, value: value2 }
        });
        _this2.dispatchEvent(evt);
        onChange === null || onChange === void 0 ? void 0 : onChange(value2);
      };
      _this2.selectionStartPos = 0;
      _this2.selectionWidth = 0;
      _this2.prevPos = 0;
      _this2.target = "";
      return _this2;
    }
    Object.defineProperty(Slider3.prototype, "values", {
      get: function() {
        return this.attributes.values;
      },
      set: function(values4) {
        this.attributes.values = this.clampValues(values4);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "sparklineStyle", {
      get: function() {
        var orientation = this.attributes.orientation;
        if (orientation !== "horizontal")
          return null;
        var attr2 = subStyleProps(this.attributes, "sparkline");
        return __assign(__assign({ zIndex: 0 }, this.availableSpace), attr2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "shape", {
      get: function() {
        var _a2 = this.attributes, trackLength = _a2.trackLength, trackSize = _a2.trackSize;
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width = _b[0], height = _b[1];
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Slider3.prototype, "availableSpace", {
      get: function() {
        var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, padding = _a2.padding;
        var _b = __read(parseSeriesAttr(padding), 4), top = _b[0], right2 = _b[1], bottom = _b[2], left2 = _b[3];
        var _c = this.shape, width = _c.width, height = _c.height;
        return {
          x: left2,
          y: top,
          width: width - (left2 + right2),
          height: height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Slider3.prototype.getValues = function() {
      return this.values;
    };
    Slider3.prototype.setValues = function(values4, animate2) {
      if (values4 === void 0) {
        values4 = [0, 0];
      }
      if (animate2 === void 0) {
        animate2 = false;
      }
      this.attributes.values = values4;
      var animation = animate2 === false ? false : this.attributes.animate;
      this.updateSelectionArea(animation);
      this.updateHandlesPosition(animation);
    };
    Slider3.prototype.updateSelectionArea = function(animation) {
      var newSelectionArea = this.calcSelectionArea();
      this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).each(function(datum, index3) {
        transition(this, newSelectionArea[index3], animation);
      });
    };
    Slider3.prototype.updateHandlesPosition = function(animation) {
      if (!this.attributes.showHandle)
        return;
      this.startHandle && transition(this.startHandle, this.getHandleStyle("start"), animation);
      this.endHandle && transition(this.endHandle, this.getHandleStyle("end"), animation);
    };
    Slider3.prototype.innerSetValues = function(values4, trigger) {
      if (values4 === void 0) {
        values4 = [0, 0];
      }
      if (trigger === void 0) {
        trigger = false;
      }
      var oldValues = this.values;
      var newValues = this.clampValues(values4);
      this.attributes.values = newValues;
      this.setValues(newValues);
      if (trigger) {
        this.onValueChange(oldValues);
      }
    };
    Slider3.prototype.renderTrack = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y;
      var style = subStyleProps(this.attributes, "track");
      this.trackShape = select2(container).maybeAppendByClassName(CLASS_NAMES.track, "rect").styles(__assign(__assign({ x: x3, y: y4 }, this.shape), style));
    };
    Slider3.prototype.renderBrushArea = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, brushable = _a2.brushable;
      this.brushArea = select2(container).maybeAppendByClassName(CLASS_NAMES.brushArea, "rect").styles(__assign({ x: x3, y: y4, fill: "transparent", cursor: brushable ? "crosshair" : "default" }, this.shape));
    };
    Slider3.prototype.renderSparkline = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, orientation = _a2.orientation;
      var sparklineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.sparklineGroup, "g");
      ifShow(orientation === "horizontal", sparklineGroup, function(group3) {
        var style = __assign(__assign({}, _this2.sparklineStyle), { x: x3, y: y4 });
        group3.maybeAppendByClassName(CLASS_NAMES.sparkline, function() {
          return new Sparkline({ style });
        }).update(style);
      });
    };
    Slider3.prototype.renderHandles = function() {
      var _this2 = this;
      var _a2;
      var _b = this.attributes, showHandle = _b.showHandle, type = _b.type;
      var availableHandle = type === "range" ? ["start", "end"] : ["end"];
      var data2 = showHandle ? availableHandle : [];
      var that = this;
      (_a2 = this.foregroundGroup) === null || _a2 === void 0 ? void 0 : _a2.selectAll(CLASS_NAMES.handle.class).data(data2.map(function(type2) {
        return { type: type2 };
      }), function(d4) {
        return d4.type;
      }).join(function(enter) {
        return enter.append(function(_a3) {
          var type2 = _a3.type;
          return new Handle({ style: _this2.getHandleStyle(type2) });
        }).each(function(_a3) {
          var type2 = _a3.type;
          this.attr("class", "".concat(CLASS_NAMES.handle.name, " ").concat(type2, "-handle"));
          var name2 = "".concat(type2, "Handle");
          that[name2] = this;
          this.addEventListener("pointerdown", that.onDragStart(type2));
        });
      }, function(update2) {
        return update2.each(function(_a3) {
          var type2 = _a3.type;
          this.update(that.getHandleStyle(type2));
        });
      }, function(exit) {
        return exit.each(function(_a3) {
          var type2 = _a3.type;
          var name2 = "".concat(type2, "Handle");
          that[name2] = void 0;
        }).remove();
      });
    };
    Slider3.prototype.renderSelection = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, type = _a2.type, selectionType = _a2.selectionType;
      this.foregroundGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.foreground, "g");
      var selectionStyle = subStyleProps(this.attributes, "selection");
      var applyStyle4 = function(selection) {
        return selection.style("visibility", function(d4) {
          return d4.show ? "visible" : "hidden";
        }).style("cursor", function(d4) {
          if (selectionType === "select")
            return "grab";
          if (selectionType === "invert")
            return "crosshair";
          return "default";
        }).styles(__assign(__assign({}, selectionStyle), { transform: "translate(".concat(x3, ", ").concat(y4, ")") }));
      };
      var that = this;
      this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).data(type === "value" ? [] : this.calcSelectionArea().map(function(area2, index3) {
        return {
          style: __assign({}, area2),
          index: index3,
          // 
          show: selectionType === "select" ? index3 === 1 : index3 !== 1
        };
      }), function(d4) {
        return d4.index;
      }).join(function(enter) {
        return enter.append("rect").attr("className", CLASS_NAMES.selection.name).call(applyStyle4).each(function(datum, index3) {
          var _this2 = this;
          if (index3 === 1) {
            that.selectionShape = select2(this);
            this.on("pointerdown", function(e3) {
              _this2.attr("cursor", "grabbing");
              that.onDragStart("selection")(e3);
            });
            that.dispatchCustomEvent(this, "pointerenter", "selectionMouseenter");
            that.dispatchCustomEvent(this, "pointerleave", "selectionMouseleave");
            that.dispatchCustomEvent(this, "click", "selectionClick");
            this.addEventListener("pointerdown", function() {
              _this2.attr("cursor", "grabbing");
            });
            this.addEventListener("pointerup", function() {
              _this2.attr("cursor", "pointer");
            });
            this.addEventListener("pointerover", function() {
              _this2.attr("cursor", "pointer");
            });
          } else {
            this.on("pointerdown", that.onDragStart("track"));
          }
        });
      }, function(update2) {
        return update2.call(applyStyle4);
      }, function(exit) {
        return exit.remove();
      });
      this.updateSelectionArea(false);
      this.renderHandles();
    };
    Slider3.prototype.render = function(attributes, container) {
      this.renderTrack(container);
      this.renderSparkline(container);
      this.renderBrushArea(container);
      this.renderSelection(container);
    };
    Slider3.prototype.clampValues = function(values4, precision) {
      var _a2;
      if (precision === void 0) {
        precision = 4;
      }
      var _b = __read(this.range, 2), min10 = _b[0], max11 = _b[1];
      var _c = __read(this.getValues().map(function(num) {
        return toPrecision(num, precision);
      }), 2), prevStart = _c[0], prevEnd = _c[1];
      var internalValues = Array.isArray(values4) ? values4 : [prevStart, values4 !== null && values4 !== void 0 ? values4 : prevEnd];
      var _d = __read((internalValues || [prevStart, prevEnd]).map(function(num) {
        return toPrecision(num, precision);
      }), 2), startVal = _d[0], endVal = _d[1];
      if (this.attributes.type === "value")
        return [0, clamp_default(endVal, min10, max11)];
      if (startVal > endVal) {
        _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
      }
      var range3 = endVal - startVal;
      if (range3 > max11 - min10)
        return [min10, max11];
      if (startVal < min10) {
        if (prevStart === min10 && prevEnd === endVal)
          return [min10, endVal];
        return [min10, range3 + min10];
      }
      if (endVal > max11) {
        if (prevEnd === max11 && prevStart === startVal)
          return [startVal, max11];
        return [max11 - range3, max11];
      }
      return [startVal, endVal];
    };
    Slider3.prototype.calcSelectionArea = function(values4) {
      var _a2 = __read(this.clampValues(values4), 2), start = _a2[0], end = _a2[1];
      var _b = this.availableSpace, x3 = _b.x, y4 = _b.y, width = _b.width, height = _b.height;
      return this.getOrientVal([
        [
          { y: y4, height, x: x3, width: start * width },
          { y: y4, height, x: start * width + x3, width: (end - start) * width },
          { y: y4, height, x: end * width, width: (1 - end) * width }
        ],
        [
          { x: x3, width, y: y4, height: start * height },
          { x: x3, width, y: start * height + y4, height: (end - start) * height },
          { x: x3, width, y: end * height, height: (1 - end) * height }
        ]
      ]);
    };
    Slider3.prototype.calcHandlePosition = function(handleType) {
      var handleIconOffset = this.attributes.handleIconOffset;
      var _a2 = this.availableSpace, x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
      var _b = __read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
      var offset2 = handleType === "start" ? -handleIconOffset : handleIconOffset;
      var L = (handleType === "start" ? stVal : endVal) * this.getOrientVal([width, height]) + offset2;
      return {
        x: x3 + this.getOrientVal([L, width / 2]),
        y: y4 + this.getOrientVal([height / 2, L])
      };
    };
    Slider3.prototype.inferTextStyle = function(handleType) {
      var orientation = this.attributes.orientation;
      if (orientation === "horizontal")
        return {};
      if (handleType === "start")
        return { transformOrigin: "left center", transform: "rotate(90)", textAlign: "start" };
      if (handleType === "end")
        return { transformOrigin: "right center", transform: "rotate(90)", textAlign: "end" };
      return {};
    };
    Slider3.prototype.calcHandleText = function(handleType) {
      var _a2;
      var _b = this.attributes, type = _b.type, orientation = _b.orientation, formatter2 = _b.formatter, autoFitLabel = _b.autoFitLabel;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var labelStyle = subStyleProps(handleStyle, "label");
      var spacing = handleStyle.spacing;
      var size3 = this.getHandleSize();
      var values4 = this.clampValues();
      var value2 = handleType === "start" ? values4[0] : values4[1];
      var text = formatter2(value2);
      var temp = new Text2({
        style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), { text })
      });
      var _c = temp.getBBox(), textWidth = _c.width, textHeight = _c.height;
      temp.destroy();
      if (!autoFitLabel) {
        if (type === "value")
          return { text, x: 0, y: -textHeight - spacing };
        var finaleWidth = spacing + size3 + (orientation === "horizontal" ? textWidth / 2 : 0);
        return _a2 = { text }, _a2[orientation === "horizontal" ? "x" : "y"] = handleType === "start" ? -finaleWidth : finaleWidth, _a2;
      }
      var x3 = 0;
      var y4 = 0;
      var _d = this.availableSpace, iW = _d.width, iH = _d.height;
      var _e = this.calcSelectionArea()[1], fX = _e.x, fY = _e.y, fW = _e.width, fH = _e.height;
      var totalSpacing = spacing + size3;
      if (orientation === "horizontal") {
        var finalWidth = totalSpacing + textWidth / 2;
        if (handleType === "start") {
          var left2 = fX - totalSpacing - textWidth;
          x3 = left2 > 0 ? -finalWidth : finalWidth;
        } else {
          var sign3 = iW - fX - fW - totalSpacing > textWidth;
          x3 = sign3 ? finalWidth : -finalWidth;
        }
      } else {
        var positiveSize = totalSpacing;
        var negativeSize = textHeight + totalSpacing;
        if (handleType === "start") {
          y4 = fY - size3 > textHeight ? -negativeSize : positiveSize;
        } else {
          y4 = iH - (fY + fH) - size3 > textHeight ? negativeSize : -positiveSize;
        }
      }
      return { x: x3, y: y4, text };
    };
    Slider3.prototype.getHandleLabelStyle = function(handleType) {
      var style = subStyleProps(this.attributes, "handleLabel");
      return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));
    };
    Slider3.prototype.getHandleIconStyle = function() {
      var shape23 = this.attributes.handleIconShape;
      var style = subStyleProps(this.attributes, "handleIcon");
      var cursor = this.getOrientVal(["ew-resize", "ns-resize"]);
      var size3 = this.getHandleSize();
      return __assign({ cursor, shape: shape23, size: size3 }, style);
    };
    Slider3.prototype.getHandleStyle = function(handleType) {
      var _a2 = this.attributes, ox = _a2.x, oy = _a2.y, showLabel = _a2.showLabel, showLabelOnInteraction = _a2.showLabelOnInteraction, orientation = _a2.orientation;
      var _b = this.calcHandlePosition(handleType), x3 = _b.x, y4 = _b.y;
      var textStyle = this.calcHandleText(handleType);
      var internalShowLabel = showLabel;
      if (!showLabel && showLabelOnInteraction) {
        if (this.target)
          internalShowLabel = true;
        else
          internalShowLabel = false;
      }
      return __assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), "icon")), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), "label")), { transform: "translate(".concat(x3 + ox, ", ").concat(y4 + oy, ")"), orientation, showLabel: internalShowLabel, type: handleType, zIndex: 3 });
    };
    Slider3.prototype.getHandleSize = function() {
      var _a2 = this.attributes, size3 = _a2.handleIconSize, width = _a2.width, height = _a2.height;
      if (size3)
        return size3;
      return Math.floor((this.getOrientVal([+height, +width]) + 4) / 2.4);
    };
    Slider3.prototype.getOrientVal = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y4 = _b[1];
      var orientation = this.attributes.orientation;
      return orientation === "horizontal" ? x3 : y4;
    };
    Slider3.prototype.setValuesOffset = function(stOffset, endOffset, animate2) {
      if (endOffset === void 0) {
        endOffset = 0;
      }
      if (animate2 === void 0) {
        animate2 = false;
      }
      var type = this.attributes.type;
      var _a2 = __read(this.getValues(), 2), oldStartVal = _a2[0], oldEndVal = _a2[1];
      var internalStartOffset = type === "range" ? stOffset : 0;
      var values4 = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();
      if (animate2)
        this.setValues(values4);
      else
        this.innerSetValues(values4, true);
    };
    Slider3.prototype.getRatio = function(val) {
      var _a2 = this.availableSpace, width = _a2.width, height = _a2.height;
      return val / this.getOrientVal([width, height]);
    };
    Slider3.prototype.dispatchCustomEvent = function(target, event, name2) {
      var _this2 = this;
      target.on(event, function(e3) {
        e3.stopPropagation();
        _this2.dispatchEvent(new CustomEvent(name2, { detail: e3 }));
      });
    };
    Slider3.prototype.bindEvents = function() {
      this.addEventListener("wheel", this.onScroll);
      var brushArea = this.brushArea;
      this.dispatchCustomEvent(brushArea, "click", "trackClick");
      this.dispatchCustomEvent(brushArea, "pointerenter", "trackMouseenter");
      this.dispatchCustomEvent(brushArea, "pointerleave", "trackMouseleave");
      brushArea.on("pointerdown", this.onDragStart("track"));
    };
    Slider3.prototype.onScroll = function(event) {
      var scrollable = this.attributes.scrollable;
      if (scrollable) {
        var deltaX = event.deltaX, deltaY = event.deltaY;
        var offset2 = deltaY || deltaX;
        var deltaVal = this.getRatio(offset2);
        this.setValuesOffset(deltaVal, deltaVal, true);
      }
    };
    Slider3.tag = "slider";
    return Slider3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/scrollbar/index.js
var Scrollbar = (
  /** @class */
  function(_super) {
    __extends(Scrollbar3, _super);
    function Scrollbar3(options) {
      var _this2 = _super.call(this, options, {
        x: 0,
        y: 0,
        isRound: true,
        orientation: "vertical",
        padding: [2, 2, 2, 2],
        scrollable: true,
        slidable: true,
        thumbCursor: "default",
        trackSize: 10,
        value: 0
      }) || this;
      _this2.range = [0, 1];
      _this2.onValueChange = function(oldValue) {
        var newValue = _this2.attributes.value;
        if (oldValue === newValue)
          return;
        var evtVal = {
          detail: {
            oldValue,
            value: newValue
          }
        };
        _this2.dispatchEvent(new CustomEvent("scroll", evtVal));
        _this2.dispatchEvent(new CustomEvent("valuechange", evtVal));
      };
      _this2.onTrackClick = function(e3) {
        var slidable = _this2.attributes.slidable;
        if (!slidable)
          return;
        var _a2 = __read(_this2.getLocalPosition(), 2), x3 = _a2[0], y4 = _a2[1];
        var _b = __read(_this2.padding, 4), top = _b[0], left2 = _b[3];
        var basePos = _this2.getOrientVal([x3 + left2, y4 + top]);
        var clickPos = _this2.getOrientVal(getEventPos(e3));
        var value2 = (clickPos - basePos) / _this2.trackLength;
        _this2.setValue(value2, true);
      };
      _this2.onThumbMouseenter = function(e3) {
        _this2.dispatchEvent(new CustomEvent("thumbMouseenter", { detail: e3.detail }));
      };
      _this2.onTrackMouseenter = function(e3) {
        _this2.dispatchEvent(new CustomEvent("trackMouseenter", { detail: e3.detail }));
      };
      _this2.onThumbMouseleave = function(e3) {
        _this2.dispatchEvent(new CustomEvent("thumbMouseleave", { detail: e3.detail }));
      };
      _this2.onTrackMouseleave = function(e3) {
        _this2.dispatchEvent(new CustomEvent("trackMouseleave", { detail: e3.detail }));
      };
      return _this2;
    }
    Object.defineProperty(Scrollbar3.prototype, "padding", {
      get: function() {
        var padding = this.attributes.padding;
        return parseSeriesAttr(padding);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "value", {
      get: function() {
        var value2 = this.attributes.value;
        var _a2 = __read(this.range, 2), min10 = _a2[0], max11 = _a2[1];
        return clamp_default(value2, min10, max11);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "trackLength", {
      get: function() {
        var _a2 = this.attributes, viewportLength = _a2.viewportLength, _b = _a2.trackLength, trackLength = _b === void 0 ? viewportLength : _b;
        return trackLength;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "availableSpace", {
      get: function() {
        var trackSize = this.attributes.trackSize;
        var trackLength = this.trackLength;
        var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
        var _b = __read(this.getOrientVal([
          [trackLength, trackSize],
          [trackSize, trackLength]
        ]), 2), width = _b[0], height = _b[1];
        return {
          x: left2,
          y: top,
          width: +width - (left2 + right2),
          height: +height - (top + bottom)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "trackRadius", {
      get: function() {
        var _a2 = this.attributes, isRound = _a2.isRound, trackSize = _a2.trackSize;
        if (!isRound)
          return 0;
        return trackSize / 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Scrollbar3.prototype, "thumbRadius", {
      get: function() {
        var _a2 = this.attributes, isRound = _a2.isRound, thumbRadius = _a2.thumbRadius;
        if (!isRound)
          return 0;
        var _b = this.availableSpace, width = _b.width, height = _b.height;
        return thumbRadius || this.getOrientVal([height, width]) / 2;
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar3.prototype.getValues = function(value2) {
      if (value2 === void 0) {
        value2 = this.value;
      }
      var _a2 = this.attributes, viewportLength = _a2.viewportLength, contentLength = _a2.contentLength;
      var unit = viewportLength / contentLength;
      var _b = __read(this.range, 2), min10 = _b[0], max11 = _b[1];
      var start = value2 * (max11 - min10 - unit);
      return [start, start + unit];
    };
    Scrollbar3.prototype.getValue = function() {
      return this.value;
    };
    Scrollbar3.prototype.renderSlider = function(container) {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, orientation = _a2.orientation, trackSize = _a2.trackSize, padding = _a2.padding, slidable = _a2.slidable;
      var trackStyle = subStyleProps(this.attributes, "track");
      var selectionStyle = subStyleProps(this.attributes, "thumb");
      var style = __assign(__assign({ x: x3, y: y4, brushable: false, orientation, padding, selectionRadius: this.thumbRadius, showHandle: false, slidable, trackLength: this.trackLength, trackRadius: this.trackRadius, trackSize, values: this.getValues() }, superStyleProps(trackStyle, "track")), superStyleProps(selectionStyle, "selection"));
      this.slider = select2(container).maybeAppendByClassName("scrollbar", function() {
        return new Slider({ style });
      }).update(style).node();
    };
    Scrollbar3.prototype.render = function(attributes, container) {
      this.renderSlider(container);
    };
    Scrollbar3.prototype.setValue = function(value2, animate2) {
      if (animate2 === void 0) {
        animate2 = false;
      }
      var oldValue = this.attributes.value;
      var _a2 = __read(this.range, 2), min10 = _a2[0], max11 = _a2[1];
      this.slider.setValues(this.getValues(clamp_default(value2, min10, max11)), animate2);
      this.onValueChange(oldValue);
    };
    Scrollbar3.prototype.bindEvents = function() {
      var _this2 = this;
      this.slider.addEventListener("trackClick", function(e3) {
        e3.stopPropagation();
        _this2.onTrackClick(e3.detail);
      });
      this.onHover();
    };
    Scrollbar3.prototype.getOrientVal = function(values4) {
      var orientation = this.attributes.orientation;
      return orientation === "horizontal" ? values4[0] : values4[1];
    };
    Scrollbar3.prototype.onHover = function() {
      this.slider.addEventListener("selectionMouseenter", this.onThumbMouseenter);
      this.slider.addEventListener("trackMouseenter", this.onTrackMouseenter);
      this.slider.addEventListener("selectionMouseleave", this.onThumbMouseleave);
      this.slider.addEventListener("trackMouseleave", this.onTrackMouseleave);
    };
    Scrollbar3.tag = "scrollbar";
    return Scrollbar3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/constant.js
var AXIS_BASE_DEFAULT_ATTR = {
  data: [],
  animate: {
    enter: false,
    update: {
      duration: 100,
      easing: "ease-in-out-sine",
      fill: "both"
    },
    exit: {
      duration: 100,
      fill: "both"
    }
  },
  showArrow: true,
  showGrid: true,
  showLabel: true,
  showLine: true,
  showTick: true,
  showTitle: true,
  showTrunc: false,
  dataThreshold: 100,
  lineLineWidth: 1,
  lineStroke: "black",
  crossPadding: 10,
  titleFill: "black",
  titleFontSize: 12,
  titlePosition: "lb",
  titleSpacing: 0,
  titleTextAlign: "center",
  titleTextBaseline: "middle",
  lineArrow: function() {
    return new Path2({
      style: {
        d: [["M", 10, 10], ["L", -10, 0], ["L", 10, -10], ["L", 0, 0], ["L", 10, 10], ["Z"]],
        fill: "black",
        transformOrigin: "center"
      }
    });
  },
  labelAlign: "parallel",
  labelDirection: "positive",
  labelFontSize: 12,
  labelSpacing: 0,
  gridConnect: "line",
  gridControlAngles: [],
  gridDirection: "positive",
  gridLength: 0,
  gridType: "segment",
  lineArrowOffset: 15,
  lineArrowSize: 10,
  tickDirection: "positive",
  tickLength: 5,
  tickLineWidth: 1,
  tickStroke: "black",
  labelOverlap: [
    // { type: 'rotate', optionalAngles: [0, 45, 90] },
    // { type: 'ellipsis', suffix: '...', minLength: 14, maxLength: 160 },
    // { type: 'hide' },
  ]
};
var ARC_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {
    type: "arc"
  }
});
var HELIX_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
  style: {}
});
var CLASS_NAMES3 = classNames({
  mainGroup: "main-group",
  gridGroup: "grid-group",
  grid: "grid",
  lineGroup: "line-group",
  line: "line",
  tickGroup: "tick-group",
  tick: "tick",
  tickItem: "tick-item",
  labelGroup: "label-group",
  label: "label",
  labelItem: "label-item",
  titleGroup: "title-group",
  title: "title",
  lineFirst: "line-first",
  lineSecond: "line-second"
}, "axis");

// node_modules/@antv/component/esm/ui/grid/index.js
var CLASS_NAMES4 = classNames({
  lineGroup: "line-group",
  line: "line",
  regionGroup: "region-group",
  region: "region"
}, "grid");
function getStraightPath(points) {
  return points.reduce(function(acc, curr, idx) {
    acc.push(__spreadArray([idx === 0 ? "M" : "L"], __read(curr), false));
    return acc;
  }, []);
}
function getSurroundPath(points, attr2, reversed) {
  var _a2 = attr2.connect, connect = _a2 === void 0 ? "line" : _a2, center2 = attr2.center;
  if (connect === "line")
    return getStraightPath(points);
  if (!center2)
    return [];
  var radius = distance5(points[0], center2);
  var sweepFlag = reversed ? 0 : 1;
  return points.reduce(function(r2, p3, idx) {
    if (idx === 0)
      r2.push(__spreadArray(["M"], __read(p3), false));
    else
      r2.push(__spreadArray(["A", radius, radius, 0, 0, sweepFlag], __read(p3), false));
    return r2;
  }, []);
}
function getLinePath(points, cfg, reversed) {
  if (cfg.type === "surround")
    return getSurroundPath(points, cfg, reversed);
  return getStraightPath(points);
}
function connectPaths(from, to, cfg) {
  var type = cfg.type, connect = cfg.connect, center2 = cfg.center, closed = cfg.closed;
  var closeFlag = closed ? [["Z"]] : [];
  var _a2 = __read([getLinePath(from, cfg), getLinePath(to.slice().reverse(), cfg, true)], 2), path1 = _a2[0], path2 = _a2[1];
  var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
  var createPath = function(insertA, insertB) {
    return [path1, insertA, path2, insertB, closeFlag].flat();
  };
  if (connect === "line" || type === "surround") {
    return createPath([__spreadArray(["L"], __read(endOfTo), false)], [__spreadArray(["L"], __read(startOfFrom), false)]);
  }
  if (!center2)
    throw new Error("Arc grid need to specified center");
  var _c = __read([distance5(endOfTo, center2), distance5(startOfFrom, center2)], 2), raduis1 = _c[0], radius2 = _c[1];
  return createPath([
    __spreadArray(["A", raduis1, raduis1, 0, 0, 1], __read(endOfTo), false),
    __spreadArray(["L"], __read(endOfTo), false)
  ], [
    __spreadArray(["A", radius2, radius2, 0, 0, 0], __read(startOfFrom), false),
    __spreadArray(["L"], __read(startOfFrom), false)
  ]);
}
function renderGridLine(container, data2, attr2, style) {
  var animate2 = attr2.animate, isBillboard = attr2.isBillboard;
  var lines = data2.map(function(item, idx) {
    return {
      id: item.id || "grid-line-".concat(idx),
      d: getLinePath(item.points, attr2)
    };
  });
  return container.selectAll(CLASS_NAMES4.line.class).data(lines, function(d4) {
    return d4.id;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index3) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index3, lines]);
      this.attr(__assign({ class: CLASS_NAMES4.line.name, stroke: "#D9D9D9", lineWidth: 1, lineDash: [4, 4], isBillboard }, lineStyle));
    });
  }, function(update2) {
    return update2.transition(function(datum, index3) {
      var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index3, lines]);
      return transition(this, lineStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function renderAlternateRegion(container, data2, style) {
  var animate2 = style.animate, connect = style.connect, areaFill = style.areaFill;
  if (data2.length < 2 || !areaFill || !connect)
    return [];
  var colors = Array.isArray(areaFill) ? areaFill : [areaFill, "transparent"];
  var getColor3 = function(idx2) {
    return colors[idx2 % colors.length];
  };
  var regions = [];
  for (var idx = 0; idx < data2.length - 1; idx++) {
    var _a2 = __read([data2[idx].points, data2[idx + 1].points], 2), prev = _a2[0], curr = _a2[1];
    var path2 = connectPaths(prev, curr, style);
    regions.push({ d: path2, fill: getColor3(idx) });
  }
  return container.selectAll(CLASS_NAMES4.region.class).data(regions, function(_2, i2) {
    return i2;
  }).join(function(enter) {
    return enter.append("path").each(function(datum, index3) {
      var regionStyle = getCallbackValue(datum, [datum, index3, regions]);
      this.attr(regionStyle);
    }).attr("className", CLASS_NAMES4.region.name);
  }, function(update2) {
    return update2.transition(function(datum, index3) {
      var regionStyle = getCallbackValue(datum, [datum, index3, regions]);
      return transition(this, regionStyle, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this, animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}
function getData(attr2) {
  var _a2 = attr2.data, data2 = _a2 === void 0 ? [] : _a2, closed = attr2.closed;
  if (!closed)
    return data2;
  return data2.map(function(datum) {
    var points = datum.points;
    var _a3 = __read(points, 1), start = _a3[0];
    return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start], false) });
  });
}
var Grid = (
  /** @class */
  function(_super) {
    __extends(Grid2, _super);
    function Grid2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Grid2.prototype.render = function(attributes, container) {
      var type = attributes.type, center2 = attributes.center, areaFill = attributes.areaFill, closed = attributes.closed, style = __rest(attributes, ["type", "center", "areaFill", "closed"]);
      var data2 = getData(attributes);
      var lineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.lineGroup, "g");
      var regionGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.regionGroup, "g");
      var lineTransitions = renderGridLine(lineGroup, data2, attributes, style);
      var reigionTransitions = renderAlternateRegion(regionGroup, data2, attributes);
      return __spreadArray(__spreadArray([], __read(lineTransitions), false), __read(reigionTransitions), false);
    };
    return Grid2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/guides/utils.js
function getCallbackStyle(style, params) {
  return Object.fromEntries(Object.entries(style).map(function(_a2) {
    var _b = __read(_a2, 2), key = _b[0], val = _b[1];
    return [key, getCallbackValue(val, params)];
  }));
}
function filterExec(data2, filter3) {
  return !!filter3 && isFunction(filter3) ? data2.filter(filter3) : data2;
}
function getLineAngle(value2, attr2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle;
  return (endAngle - startAngle) * value2 + startAngle;
}
function getLineTangentVector(value2, attr2) {
  if (attr2.type === "linear") {
    var _a2 = __read(attr2.startPos, 2), startX = _a2[0], startY = _a2[1], _b = __read(attr2.endPos, 2), endX = _b[0], endY = _b[1];
    var _c = __read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
    return normalize7([dx, dy]);
  }
  var angle4 = degToRad(getLineAngle(value2, attr2));
  return [-Math.sin(angle4), Math.cos(angle4)];
}
function getDirectionVector(value2, direction3, attr2) {
  var tangentVector = getLineTangentVector(value2, attr2);
  return vertical2(tangentVector, direction3 !== "positive");
}
function getLabelVector(value2, attr2) {
  return getDirectionVector(value2, attr2.labelDirection, attr2);
}

// node_modules/@antv/component/esm/ui/axis/guides/line.js
function getLinearValuePos(value2, attr2) {
  var _a2 = __read(attr2.startPos, 2), sx = _a2[0], sy = _a2[1], _b = __read(attr2.endPos, 2), ex = _b[0], ey = _b[1];
  var _c = __read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
  return [sx + dx * value2, sy + dy * value2];
}
function getArcValuePos(value2, attr2) {
  var radius = attr2.radius, _a2 = __read(attr2.center, 2), cx = _a2[0], cy = _a2[1];
  var angle4 = degToRad(getLineAngle(value2, attr2));
  return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
}
function getValuePos(value2, attr2) {
  if (attr2.type === "linear")
    return getLinearValuePos(value2, attr2);
  return getArcValuePos(value2, attr2);
}
function isAxisHorizontal(attr2) {
  return getLineTangentVector(0, attr2)[1] === 0;
}
function isAxisVertical(attr2) {
  return getLineTangentVector(0, attr2)[0] === 0;
}
function isCircle(startAngle, endAngle) {
  return endAngle - startAngle === 360;
}
function getArcPath(startAngle, endAngle, cx, cy, radius) {
  var diffAngle = endAngle - startAngle;
  var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
  var _b = __read([degToRad(startAngle), degToRad(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
  var getPosByAngle = function(angle4) {
    return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
  };
  var _c = __read(getPosByAngle(startAngleRadians), 2), x12 = _c[0], y12 = _c[1];
  var _d = __read(getPosByAngle(endAngleRadians), 2), x22 = _d[0], y22 = _d[1];
  if (isCircle(startAngle, endAngle)) {
    var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
    var _e = __read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
    return [
      ["M", x12, y12],
      ["A", rx, ry, 0, 1, 0, xm, ym],
      ["A", rx, ry, 0, 1, 0, x22, y22]
    ];
  }
  var large = diffAngle > 180 ? 1 : 0;
  var sweep = startAngle > endAngle ? 0 : 1;
  var isClosePath = false;
  return isClosePath ? "M".concat(cx, ",").concat(cy, ",L").concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22, ",L").concat(cx, ",").concat(cy) : "M".concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22);
}
function getArcAttr(arc) {
  var _a2 = arc.attributes, startAngle = _a2.startAngle, endAngle = _a2.endAngle, center2 = _a2.center, radius = _a2.radius;
  return __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false);
}
function renderArc(container, attr2, style, animate2) {
  var startAngle = attr2.startAngle, endAngle = attr2.endAngle, center2 = attr2.center, radius = attr2.radius;
  return container.selectAll(CLASS_NAMES3.line.class).data([{ d: getArcPath.apply(void 0, __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false)) }], function(d4, i2) {
    return i2;
  }).join(function(enter) {
    return enter.append("path").attr("className", CLASS_NAMES3.line.name).styles(attr2).styles({ d: function(d4) {
      return d4.d;
    } });
  }, function(update2) {
    return update2.transition(function() {
      var _this2 = this;
      var animation = keyframeInterpolate(this, getArcAttr(this), __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false), animate2.update);
      if (animation) {
        var layout = function() {
          var data2 = get_default(_this2.attributes, "__keyframe_data__");
          _this2.style.d = getArcPath.apply(void 0, __spreadArray([], __read(data2), false));
        };
        animation.onframe = layout;
        animation.onfinish = layout;
      }
      return animation;
    }).styles(attr2);
  }, function(exit) {
    return exit.remove();
  }).styles(style).transitions();
}
function renderTruncation(container, _a2) {
  var truncRange = _a2.truncRange, truncShape = _a2.truncShape, lineExtension = _a2.lineExtension;
}
function extendLine(startPos, endPos, range3) {
  if (range3 === void 0) {
    range3 = [0, 0];
  }
  var _a2 = __read([startPos, endPos, range3], 3), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1], _d = __read(_a2[2], 2), l1 = _d[0], l2 = _d[1];
  var _e = __read([x22 - x12, y22 - y12], 2), x3 = _e[0], y4 = _e[1];
  var L = Math.sqrt(Math.pow(x3, 2) + Math.pow(y4, 2));
  var _f = __read([-l1 / L, l2 / L], 2), s1 = _f[0], s22 = _f[1];
  return [s1 * x3, s1 * y4, s22 * x3, s22 * y4];
}
function getLinePath2(points) {
  var _a2 = __read(points, 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  return { x1: x12, y1: y12, x2: x22, y2: y22 };
}
function renderLinear(container, attr2, style, animate2) {
  var showTrunc = attr2.showTrunc, startPos = attr2.startPos, endPos = attr2.endPos, truncRange = attr2.truncRange, lineExtension = attr2.lineExtension;
  var _a2 = __read([startPos, endPos], 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  var _d = __read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
  var renderLine = function(data2) {
    return container.selectAll(CLASS_NAMES3.line.class).data(data2, function(d4, i2) {
      return i2;
    }).join(function(enter) {
      return enter.append("line").attr("className", function(d4) {
        return "".concat(CLASS_NAMES3.line.name, " ").concat(d4.className);
      }).styles(style).transition(function(d4) {
        return transition(this, getLinePath2(d4.line), false);
      });
    }, function(update2) {
      return update2.styles(style).transition(function(_a3) {
        var line4 = _a3.line;
        return transition(this, getLinePath2(line4), animate2.update);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  };
  if (!showTrunc || !truncRange) {
    return renderLine([
      {
        line: [
          [x12 + ox1, y12 + oy1],
          [x22 + ox2, y22 + oy2]
        ],
        className: CLASS_NAMES3.line.name
      }
    ]);
  }
  var _e = __read(truncRange, 2), r1 = _e[0], r2 = _e[1];
  var dx = x22 - x12;
  var dy = y22 - y12;
  var _f = __read([x12 + dx * r1, y12 + dy * r1], 2), x3 = _f[0], y32 = _f[1];
  var _g = __read([x12 + dx * r2, y12 + dy * r2], 2), x4 = _g[0], y4 = _g[1];
  var animation = renderLine([
    {
      line: [
        [x12 + ox1, y12 + oy1],
        [x3, y32]
      ],
      className: CLASS_NAMES3.lineFirst.name
    },
    {
      line: [
        [x4, y4],
        [x22 + ox2, y22 + oy2]
      ],
      className: CLASS_NAMES3.lineSecond.name
    }
  ]);
  renderTruncation(container, attr2);
  return animation;
}
function renderAxisArrow(container, type, attr2, style) {
  var showArrow = attr2.showArrow, showTrunc = attr2.showTrunc, lineArrow = attr2.lineArrow, lineArrowOffset = attr2.lineArrowOffset, lineArrowSize = attr2.lineArrowSize;
  var shapeToAddArrow;
  if (type === "arc")
    shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
  else if (showTrunc)
    shapeToAddArrow = container.select(CLASS_NAMES3.lineSecond.class);
  else
    shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
  if (!showArrow || !lineArrow || attr2.type === "arc" && isCircle(attr2.startAngle, attr2.endAngle)) {
    var node = shapeToAddArrow.node();
    if (node)
      node.style.markerEnd = void 0;
    return;
  }
  var arrow2 = renderExtDo(lineArrow);
  arrow2.attr(style);
  scaleToPixel(arrow2, lineArrowSize, true);
  shapeToAddArrow.style("markerEnd", arrow2).style("markerEndOffset", -lineArrowOffset);
}
function renderAxisLine(container, attr2, animate2) {
  var type = attr2.type;
  var animation;
  var style = subStyleProps(attr2, "line");
  if (type === "linear")
    animation = renderLinear(container, attr2, omit(style, "arrow"), animate2);
  else
    animation = renderArc(container, attr2, omit(style, "arrow"), animate2);
  renderAxisArrow(container, type, attr2, style);
  return animation;
}

// node_modules/@antv/component/esm/ui/axis/guides/grid.js
function getGridVector(value2, attr2) {
  return getDirectionVector(value2, attr2.gridDirection, attr2);
}
function getGridCenter(attr2) {
  var type = attr2.type, gridCenter = attr2.gridCenter;
  if (type === "linear")
    return gridCenter;
  return gridCenter || attr2.center;
}
function renderStraight(data2, attr2) {
  var gridLength = attr2.gridLength;
  return data2.map(function(_a2, index3) {
    var value2 = _a2.value;
    var _b = __read(getValuePos(value2, attr2), 2), x3 = _b[0], y4 = _b[1];
    var _c = __read(scale8(getGridVector(value2, attr2), gridLength), 2), dx = _c[0], dy = _c[1];
    return {
      id: index3,
      points: [
        [x3, y4],
        [x3 + dx, y4 + dy]
      ]
    };
  });
}
function renderSurround(data2, attr2) {
  var controlAngles = attr2.gridControlAngles;
  var center2 = getGridCenter(attr2);
  if (!center2)
    throw new Error("grid center is not provide");
  if (data2.length < 2)
    throw new Error("Invalid grid data");
  if (!controlAngles || controlAngles.length === 0)
    throw new Error("Invalid gridControlAngles");
  var _a2 = __read(center2, 2), cx = _a2[0], cy = _a2[1];
  return data2.map(function(_a3, index3) {
    var value2 = _a3.value;
    var _b = __read(getValuePos(value2, attr2), 2), sx = _b[0], sy = _b[1];
    var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
    var points = [];
    controlAngles.forEach(function(angle4) {
      var angleInRad = degToRad(angle4);
      var _a4 = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a4[0], sina = _a4[1];
      var x3 = dx * cosa - dy * sina + cx;
      var y4 = dx * sina + dy * cosa + cy;
      points.push([x3, y4]);
    });
    return { points, id: index3 };
  });
}
function renderGrid(container, data2, attr2, animate2) {
  var gridAttr = subStyleProps(attr2, "grid");
  var type = gridAttr.type, areaFill = gridAttr.areaFill;
  var center2 = getGridCenter(attr2);
  var finalData = filterExec(data2, attr2.gridFilter);
  var gridItems = type === "segment" ? renderStraight(finalData, attr2) : renderSurround(finalData, attr2);
  var style = __assign(__assign({}, gridAttr), { center: center2, areaFill: isFunction(areaFill) ? finalData.map(function(datum, index3) {
    return getCallbackValue(areaFill, [datum, index3, finalData]);
  }) : areaFill, animate: animate2, data: gridItems });
  return container.selectAll(CLASS_NAMES3.grid.class).data([1]).join(function(enter) {
    return enter.append(function() {
      return new Grid({ style });
    }).attr("className", CLASS_NAMES3.grid.name);
  }, function(update2) {
    return update2.transition(function() {
      return this.update(style);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/utils/bounds.js
var Bounds = (
  /** @class */
  function() {
    function Bounds2(x12, y12, x22, y22) {
      this.set(x12, y12, x22, y22);
    }
    Object.defineProperty(Bounds2.prototype, "left", {
      get: function() {
        return this.x1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "top", {
      get: function() {
        return this.y1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "right", {
      get: function() {
        return this.x2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "bottom", {
      get: function() {
        return this.y2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "width", {
      get: function() {
        return this.defined("x2") && this.defined("x1") ? this.x2 - this.x1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Bounds2.prototype, "height", {
      get: function() {
        return this.defined("y2") && this.defined("y1") ? this.y2 - this.y1 : void 0;
      },
      enumerable: false,
      configurable: true
    });
    Bounds2.prototype.rotatedPoints = function(radian2, x3, y4) {
      var _a2 = this, x12 = _a2.x1, y12 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
      var cos3 = Math.cos(radian2);
      var sin3 = Math.sin(radian2);
      var cx = x3 - x3 * cos3 + y4 * sin3;
      var cy = y4 - x3 * sin3 - y4 * cos3;
      var points = [
        [cos3 * x12 - sin3 * y22 + cx, sin3 * x12 + cos3 * y22 + cy],
        [cos3 * x22 - sin3 * y22 + cx, sin3 * x22 + cos3 * y22 + cy],
        [cos3 * x12 - sin3 * y12 + cx, sin3 * x12 + cos3 * y12 + cy],
        [cos3 * x22 - sin3 * y12 + cx, sin3 * x22 + cos3 * y12 + cy]
      ];
      return points;
    };
    Bounds2.prototype.set = function(x12, y12, x22, y22) {
      if (x22 < x12) {
        this.x2 = x12;
        this.x1 = x22;
      } else {
        this.x1 = x12;
        this.x2 = x22;
      }
      if (y22 < y12) {
        this.y2 = y12;
        this.y1 = y22;
      } else {
        this.y1 = y12;
        this.y2 = y22;
      }
      return this;
    };
    Bounds2.prototype.defined = function(key) {
      return this[key] !== Number.MAX_VALUE && this[key] !== -Number.MAX_VALUE;
    };
    return Bounds2;
  }()
);
function getBounds(item, margin) {
  var angle4 = item.getEulerAngles() || 0;
  item.setEulerAngles(0);
  var _a2 = item.getBounds(), _b = __read(_a2.min, 2), x3 = _b[0], y4 = _b[1], _c = __read(_a2.max, 2), right2 = _c[0], bottom = _c[1];
  var _d = item.getBBox(), w2 = _d.width, h2 = _d.height;
  var height = h2;
  var dx = 0;
  var dy = 0;
  var anchorX = x3;
  var anchorY = y4;
  var text = textOf(item);
  if (text) {
    height -= 1.5;
    var a5 = text.style.textAlign;
    var b_1 = text.style.textBaseline;
    if (a5 === "center") {
      anchorX = (x3 + right2) / 2;
    } else if (a5 === "right" || a5 === "end") {
      anchorX = right2;
    } else {
    }
    if (b_1 === "middle") {
      anchorY = (y4 + bottom) / 2;
    } else if (b_1 === "bottom") {
      anchorY = bottom;
    }
  }
  var _e = __read(parseSeriesAttr(margin), 4), _f = _e[0], t = _f === void 0 ? 0 : _f, _g = _e[1], r2 = _g === void 0 ? 0 : _g, _h = _e[2], b = _h === void 0 ? t : _h, _j = _e[3], l2 = _j === void 0 ? r2 : _j;
  var bounds = new Bounds((dx += x3) - l2, (dy += y4) - t, dx + w2 + r2, dy + height + b);
  item.setEulerAngles(angle4);
  return bounds.rotatedPoints(degToRad(angle4), anchorX, anchorY);
}

// node_modules/@antv/component/esm/ui/axis/utils/contain.js
function onLine(line4, point7) {
  return point7[0] <= Math.max(line4[0][0], line4[1][0]) && point7[0] <= Math.min(line4[0][0], line4[1][0]) && point7[1] <= Math.max(line4[0][1], line4[1][1]) && point7[1] <= Math.min(line4[0][1], line4[1][1]);
}
function direction2(a5, b, c6) {
  var val = (b[1] - a5[1]) * (c6[0] - b[0]) - (b[0] - a5[0]) * (c6[1] - b[1]);
  if (val === 0)
    return 0;
  return val < 0 ? 2 : 1;
}
function isIntersect(line1, line22) {
  var dir1 = direction2(line1[0], line1[1], line22[0]);
  var dir2 = direction2(line1[0], line1[1], line22[1]);
  var dir3 = direction2(line22[0], line22[1], line1[0]);
  var dir4 = direction2(line22[0], line22[1], line1[1]);
  if (dir1 !== dir2 && dir3 !== dir4)
    return true;
  if (dir1 === 0 && onLine(line1, line22[0]))
    return true;
  if (dir2 === 0 && onLine(line1, line22[1]))
    return true;
  if (dir3 === 0 && onLine(line22, line1[0]))
    return true;
  if (dir4 === 0 && onLine(line22, line1[1]))
    return true;
  return false;
}
function isPointInsideRectangle(polygon, point7) {
  var n2 = polygon.length;
  if (n2 < 3)
    return false;
  var lineToInfinity = [point7, [9999, point7[1]]];
  var count4 = 0;
  var i2 = 0;
  do {
    var side = [polygon[i2], polygon[(i2 + 1) % n2]];
    if (isIntersect(side, lineToInfinity)) {
      if (direction2(side[0], point7, side[1]) === 0)
        return onLine(side, point7);
      count4++;
    }
    i2 = (i2 + 1) % n2;
  } while (i2 !== 0);
  return !!(count4 & 1);
}
function isRectangleBInsideA(rectA, rectB) {
  return rectB.every(function(point7) {
    return isPointInsideRectangle(rectA, point7);
  });
}
function contain(container, child, margin) {
  var x12 = container.x1, x22 = container.x2, y12 = container.y1, y22 = container.y2;
  var parent = [
    [x12, y12],
    [x22, y12],
    [x22, y22],
    [x12, y22]
  ];
  var element = getBounds(child, margin);
  return isRectangleBInsideA(parent, element);
}

// node_modules/@antv/component/esm/ui/axis/utils/intersect.js
function lineToLine(line1, line22) {
  var _a2 = __read(line1, 4), x05 = _a2[0], y05 = _a2[1], x12 = _a2[2], y12 = _a2[3];
  var _b = __read(line22, 4), x22 = _b[0], y22 = _b[1], x3 = _b[2], y32 = _b[3];
  var s10x = x12 - x05;
  var s10y = y12 - y05;
  var s32x = x3 - x22;
  var s32y = y32 - y22;
  var denom = s10x * s32y - s32x * s10y;
  if (denom === 0)
    return false;
  var denomPositive = denom > 0;
  var s02x = x05 - x22;
  var s02y = y05 - y22;
  var sNum = s10x * s02y - s10y * s02x;
  if (sNum < 0 === denomPositive)
    return false;
  var tNum = s32x * s02y - s32y * s02x;
  if (tNum < 0 === denomPositive)
    return false;
  if (sNum > denom === denomPositive || tNum > denom === denomPositive)
    return false;
  return true;
}
function intersectBoxLine(box2, line4) {
  var lines = [
    [box2[0], box2[1], box2[2], box2[3]],
    [box2[2], box2[3], box2[4], box2[5]],
    [box2[4], box2[5], box2[6], box2[7]],
    [box2[6], box2[7], box2[0], box2[1]]
  ];
  return lines.some(function(boxLine) {
    return lineToLine(line4, boxLine);
  });
}
function intersect2(a5, b, margin) {
  var e_1, _a2;
  var p3 = getBounds(a5, margin).flat(1);
  var q = getBounds(b, margin).flat(1);
  var linesP = [
    [p3[0], p3[1], p3[2], p3[3]],
    [p3[0], p3[1], p3[4], p3[5]],
    [p3[4], p3[5], p3[6], p3[7]],
    [p3[2], p3[3], p3[6], p3[7]]
  ];
  try {
    for (var linesP_1 = __values(linesP), linesP_1_1 = linesP_1.next(); !linesP_1_1.done; linesP_1_1 = linesP_1.next()) {
      var line4 = linesP_1_1.value;
      if (intersectBoxLine(q, line4))
        return true;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (linesP_1_1 && !linesP_1_1.done && (_a2 = linesP_1.return)) _a2.call(linesP_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}

// node_modules/@antv/component/esm/ui/axis/utils/test.js
function createCrossBBox(attr2, padding) {
  var type = attr2.type, labelDirection = attr2.labelDirection, crossSize = attr2.crossSize;
  if (!crossSize)
    return false;
  if (type === "arc") {
    var center2 = attr2.center, radius = attr2.radius;
    var _a2 = __read(center2, 2), cx = _a2[0], cy = _a2[1];
    var size3 = labelDirection === "negative" ? 0 : crossSize;
    var dMin = -radius - size3;
    var dMax = radius + size3;
    var _b = __read(parseSeriesAttr(padding), 4), top_1 = _b[0], right_1 = _b[1], bottom_1 = _b[2], left_1 = _b[3];
    return new Bounds(cx + dMin - left_1, cy + dMin - top_1, cx + dMax + right_1, cy + dMax + bottom_1);
  }
  var _c = __read(attr2.startPos, 2), sx = _c[0], sy = _c[1], _d = __read(attr2.endPos, 2), ex = _d[0], ey = _d[1];
  var _e = __read(isAxisVertical(attr2) ? [-padding, 0, padding, 0] : [0, padding, 0, -padding], 4), top = _e[0], right2 = _e[1], bottom = _e[2], left2 = _e[3];
  var labelVector = getLabelVector(0, attr2);
  var diff = scale8(labelVector, crossSize);
  var bbox = new Bounds(sx, sy, ex, ey);
  bbox.x1 += left2;
  bbox.y1 += top;
  bbox.x2 += right2 + diff[0];
  bbox.y2 += bottom + diff[1];
  return bbox;
}
function boundTest(items, attr2, margin) {
  var e_1, _a2;
  var crossPadding = attr2.crossPadding;
  var resultSet = /* @__PURE__ */ new Set();
  var prev = null;
  var crossBBox = createCrossBBox(attr2, crossPadding);
  var testContain = function(item) {
    if (crossBBox)
      return contain(crossBBox, item);
    return true;
  };
  var testIntersect = function(prevItem, currItem) {
    if (!prevItem || !prevItem.firstChild)
      return true;
    return !intersect2(prevItem.firstChild, currItem.firstChild, parseSeriesAttr(margin));
  };
  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var curr = items_1_1.value;
      if (!testContain(curr)) {
        resultSet.add(curr);
      } else if (!prev || testIntersect(prev, curr)) {
        prev = curr;
      } else {
        resultSet.add(prev);
        resultSet.add(curr);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a2 = items_1.return)) _a2.call(items_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return Array.from(resultSet);
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoEllipsis.js
function parseLengthString(str7, font) {
  if (font === void 0) {
    font = {};
  }
  if (isNil(str7))
    return 0;
  if (typeof str7 === "number")
    return str7;
  return Math.floor(measureTextWidth(str7, font));
}
function ellipseLabels(labels, overlapCfg, attr2, utils) {
  if (labels.length <= 0)
    return;
  var _a2 = overlapCfg.suffix, suffix = _a2 === void 0 ? "..." : _a2, minLength = overlapCfg.minLength, _b = overlapCfg.maxLength, maxLength = _b === void 0 ? Infinity : _b, _c = overlapCfg.step, ellipsisStep = _c === void 0 ? " " : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var font = getFont(utils.getTextShape(labels[0]));
  var step2 = parseLengthString(ellipsisStep, font);
  var min10 = minLength ? parseLengthString(minLength, font) : step2;
  var max11 = parseLengthString(maxLength, font);
  if (isNil(max11) || max11 === Infinity) {
    max11 = Math.max.apply(null, labels.map(function(d4) {
      return d4.getBBox().width;
    }));
  }
  var source = labels.slice();
  var _e = __read(margin, 4), _f = _e[0], top = _f === void 0 ? 0 : _f, _g = _e[1], right2 = _g === void 0 ? 0 : _g, _h = _e[2], bottom = _h === void 0 ? top : _h, _j = _e[3], left2 = _j === void 0 ? right2 : _j;
  var _loop_1 = function(allowedLength2) {
    source.forEach(function(label) {
      utils.ellipsis(utils.getTextShape(label), allowedLength2, suffix);
    });
    source = boundTest(labels, attr2, margin);
    if (source.length < 1)
      return { value: void 0 };
  };
  for (var allowedLength = max11; allowedLength > min10 + step2; allowedLength -= step2) {
    var state_1 = _loop_1(allowedLength);
    if (typeof state_1 === "object")
      return state_1.value;
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoHide.js
var methods = {
  parity: function(items, _a2) {
    var _b = _a2.seq, seq = _b === void 0 ? 2 : _b;
    return items.filter(function(item, i2) {
      return i2 % seq ? (hide(item), false) : true;
    });
  }
};
var filterDefined = function(arr) {
  return arr.filter(defined2);
};
function hideLabels(labels, overlapCfg, attr2, utils) {
  var count4 = labels.length;
  var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
  if (count4 <= 1 || count4 === 2 && keepHeader && keepTail)
    return;
  var parityHide = methods.parity;
  var reset = function(els) {
    return els.forEach(utils.show), els;
  };
  var seq = 2;
  var source = labels.slice();
  var target = labels.slice();
  var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function(d4) {
    return d4.getBBox().width;
  })), false));
  if (attr2.type === "linear" && (isAxisHorizontal(attr2) || isAxisVertical(attr2))) {
    var minX = getLocalBBox(labels[0]).left;
    var maxX = getLocalBBox(labels[count4 - 1]).right;
    var distance7 = Math.abs(maxX - minX) || 1;
    seq = Math.max(Math.floor(count4 * minLabelWidth / distance7), seq);
  }
  var first3;
  var last5;
  if (keepHeader)
    first3 = source.splice(0, 1)[0];
  if (keepTail) {
    last5 = source.splice(-1, 1)[0];
    source.reverse();
  }
  reset(source);
  while (seq < labels.length && boundTest(filterDefined(last5 ? __spreadArray(__spreadArray([last5], __read(target), false), [first3], false) : __spreadArray([first3], __read(target), false)), attr2, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
    if (last5 && !first3 && seq % 2 === 0) {
      var rest = source.splice(0, 1);
      rest.forEach(utils.hide);
    } else if (last5 && first3) {
      var rest = source.splice(0, 1);
      rest.forEach(utils.hide);
    }
    target = parityHide(reset(source), { seq });
    seq++;
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoRotate.js
function rotateLabels(labels, overlapCfg, attr2, utils) {
  var e_1, _a2;
  var _b = overlapCfg.optionalAngles, optionalAngles = _b === void 0 ? [0, 45, 90] : _b, margin = overlapCfg.margin, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c;
  var defaultAngles = labels.map(function(label) {
    return label.getLocalEulerAngles();
  });
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var setLabelsRotate = function(angle5) {
    return labels.forEach(function(label, index3) {
      var rotate7 = Array.isArray(angle5) ? angle5[index3] : angle5;
      utils.rotate(label, +rotate7);
    });
  };
  try {
    for (var optionalAngles_1 = __values(optionalAngles), optionalAngles_1_1 = optionalAngles_1.next(); !optionalAngles_1_1.done; optionalAngles_1_1 = optionalAngles_1.next()) {
      var angle4 = optionalAngles_1_1.value;
      setLabelsRotate(angle4);
      if (runAndPassed())
        return;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (optionalAngles_1_1 && !optionalAngles_1_1.done && (_a2 = optionalAngles_1.return)) _a2.call(optionalAngles_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  if (recoverWhenFailed) {
    setLabelsRotate(defaultAngles);
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/autoWrap.js
function inferTextBaseline(attr2) {
  var type = attr2.type, labelDirection = attr2.labelDirection;
  if (type === "linear" && isAxisHorizontal(attr2)) {
    return labelDirection === "negative" ? "bottom" : "top";
  }
  return "middle";
}
function wrapLabels(labels, overlapCfg, attr2, utils, main) {
  var _a2;
  var _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
  var wordWrapWidth = getCallbackValue((_a2 = overlapCfg.wordWrapWidth) !== null && _a2 !== void 0 ? _a2 : 50, [main]);
  var defaultLines = labels.map(function(label) {
    return label.attr("maxLines") || 1;
  });
  var minLines = Math.min.apply(Math, __spreadArray([], __read(defaultLines), false));
  var runAndPassed = function() {
    return boundTest(labels, attr2, margin).length < 1;
  };
  var textBaseline = inferTextBaseline(attr2);
  var setLabelsWrap = function(lines2) {
    return labels.forEach(function(label, index3) {
      var maxLines2 = Array.isArray(lines2) ? lines2[index3] : lines2;
      utils.wrap(label, wordWrapWidth, maxLines2, textBaseline);
    });
  };
  if (minLines > maxLines)
    return;
  if (attr2.type === "linear" && isAxisHorizontal(attr2)) {
    setLabelsWrap(maxLines);
    if (runAndPassed()) {
      return;
    }
  } else {
    for (var lines = minLines; lines <= maxLines; lines++) {
      setLabelsWrap(lines);
      if (runAndPassed())
        return;
    }
  }
  if (recoverWhenFailed) {
    setLabelsWrap(defaultLines);
  }
}

// node_modules/@antv/component/esm/ui/axis/overlap/index.js
var OverlapUtils = /* @__PURE__ */ new Map([
  ["hide", hideLabels],
  ["rotate", rotateLabels],
  ["ellipsis", ellipseLabels],
  ["wrap", wrapLabels]
]);
function canProcessOverlap(labels, attr2, type) {
  if (attr2.labelOverlap.length < 1)
    return false;
  if (type === "hide")
    return !isInOffscreenGroup(labels[0]);
  if (type === "rotate")
    return !labels.some(function(label) {
      var _a2;
      return !!((_a2 = label.attr("transform")) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate"));
    });
  if (type === "ellipsis" || type === "wrap")
    return labels.filter(function(item) {
      return item.querySelector("text");
    }).length >= 1;
  return true;
}
function processOverlap(labels, attr2, main, utils) {
  var _a2 = attr2.labelOverlap, labelOverlap = _a2 === void 0 ? [] : _a2;
  if (!labelOverlap.length)
    return;
  labelOverlap.forEach(function(overlapCfg) {
    var type = overlapCfg.type;
    var util = OverlapUtils.get(type);
    if (canProcessOverlap(labels, attr2, type))
      util === null || util === void 0 ? void 0 : util(labels, overlapCfg, attr2, utils, main);
  });
}

// node_modules/@antv/component/esm/ui/axis/utils/index.js
function getFactor() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var fn = function(str7) {
    return str7 === "positive" ? -1 : 1;
  };
  return args.reduce(function(acc, cur) {
    return acc * fn(cur);
  }, 1);
}

// node_modules/@antv/component/esm/ui/axis/guides/labels.js
function angleNormalizer(angle4) {
  var normalizedAngle = angle4;
  while (normalizedAngle < 0)
    normalizedAngle += 360;
  return Math.round(normalizedAngle % 360);
}
function getAngle3(v1, v2) {
  var _a2 = __read(v1, 2), x12 = _a2[0], y12 = _a2[1];
  var _b = __read(v2, 2), x22 = _b[0], y22 = _b[1];
  var _c = __read([x12 * x22 + y12 * y22, x12 * y22 - y12 * x22], 2), dot9 = _c[0], det = _c[1];
  return Math.atan2(det, dot9);
}
function correctLabelRotation(_rotate) {
  var rotate7 = (_rotate + 360) % 180;
  if (!inRange(rotate7, -90, 90))
    rotate7 += 180;
  return rotate7;
}
function getLabelRotation(datum, label, attr2) {
  var _a2;
  var labelAlign = attr2.labelAlign;
  var customRotate = (_a2 = label.style.transform) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate");
  if (customRotate)
    return label.getLocalEulerAngles();
  var rotate7 = 0;
  var labelVector = getLabelVector(datum.value, attr2);
  var tangentVector = getLineTangentVector(datum.value, attr2);
  if (labelAlign === "horizontal")
    return 0;
  if (labelAlign === "perpendicular")
    rotate7 = getAngle3([1, 0], labelVector);
  else
    rotate7 = getAngle3([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
  return correctLabelRotation(radToDeg(rotate7));
}
function getLabelStyle(value2, rotate7, attr2) {
  var type = attr2.type, labelAlign = attr2.labelAlign;
  var labelVector = getLabelVector(value2, attr2);
  var labelAngle = angleNormalizer(rotate7);
  var tickAngle = angleNormalizer(radToDeg(getAngle3([1, 0], labelVector)));
  var textAlign = "center";
  var textBaseline = "middle";
  if (type === "linear") {
    if ([90, 270].includes(tickAngle) && labelAngle === 0) {
      textAlign = "center";
      textBaseline = labelVector[1] === 1 ? "top" : "bottom";
    } else if (!(tickAngle % 180) && [90, 270].includes(labelAngle)) {
      textAlign = "center";
    } else if (tickAngle === 0) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign = "start";
      }
    } else if (tickAngle === 90) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "start";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign = "end";
      }
    } else if (tickAngle === 270) {
      if (inRange(labelAngle, 0, 90, false, true)) {
        textAlign = "end";
      } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
        textAlign = "start";
      }
    } else if (tickAngle === 180) {
      if (labelAngle === 90) {
        textAlign = "start";
      } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
        textAlign = "end";
      }
    }
  } else {
    if (labelAlign === "parallel") {
      if (inRange(tickAngle, 0, 180, true)) {
        textBaseline = "top";
      } else {
        textBaseline = "bottom";
      }
    } else if (labelAlign === "horizontal") {
      if (inRange(tickAngle, 90, 270, false)) {
        textAlign = "end";
      } else if (inRange(tickAngle, 270, 360, false) || inRange(tickAngle, 0, 90)) {
        textAlign = "start";
      }
    } else if (labelAlign === "perpendicular") {
      if (inRange(tickAngle, 90, 270)) {
        textAlign = "end";
      } else {
        textAlign = "start";
      }
    }
  }
  return { textAlign, textBaseline };
}
function setRotateAndAdjustLabelAlign(rotate7, group3, attr2) {
  group3.setLocalEulerAngles(rotate7);
  var value2 = group3.__data__.value;
  var textStyle = getLabelStyle(value2, rotate7, attr2);
  var label = group3.querySelector(CLASS_NAMES3.labelItem.class);
  if (label)
    applyTextStyle(label, textStyle);
}
function getLabelPos(datum, data2, attr2) {
  var showTick = attr2.showTick, tickLength = attr2.tickLength, tickDirection = attr2.tickDirection, labelDirection = attr2.labelDirection, labelSpacing = attr2.labelSpacing;
  var index3 = data2.indexOf(datum);
  var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index3, data2]);
  var _a2 = __read([getLabelVector(datum.value, attr2), getFactor(labelDirection, tickDirection)], 2), labelVector = _a2[0], unionFactor = _a2[1];
  var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index3, data2]) : 0;
  var _b = __read(add8(scale8(labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, attr2)), 2), x3 = _b[0], y4 = _b[1];
  return { x: x3, y: y4 };
}
function formatter(datum, index3, data2, attr2) {
  var labelFormatter2 = attr2.labelFormatter;
  var element = isFunction(labelFormatter2) ? function() {
    return renderExtDo(getCallbackValue(labelFormatter2, [datum, index3, data2, getLabelVector(datum.value, attr2)]));
  } : function() {
    return renderExtDo(datum.label || "");
  };
  return element;
}
function applyTextStyle(node, style) {
  if (node.nodeName === "text")
    node.attr(style);
}
function overlapHandler(attr2, main) {
  processOverlap(this.node().childNodes, attr2, main, {
    hide,
    show,
    rotate: function(label, angle4) {
      setRotateAndAdjustLabelAlign(+angle4, label, attr2);
    },
    ellipsis: function(label, len5, suffix) {
      label && ellipsisIt(label, len5 || Infinity, suffix);
    },
    wrap: function(label, width, lines) {
      label && wrapIt(label, width, lines);
    },
    getTextShape: function(label) {
      return label.querySelector("text");
    }
  });
}
function renderLabel(container, datum, data2, style, attr2) {
  var index3 = data2.indexOf(datum);
  var label = select2(container).append(formatter(datum, index3, data2, attr2)).attr("className", CLASS_NAMES3.labelItem.name).node();
  var _a2 = __read(splitStyle(getCallbackStyle(style, [datum, index3, data2])), 2), labelStyle = _a2[0], _b = _a2[1], transform2 = _b.transform, groupStyle = __rest(_b, ["transform"]);
  percentTransform(label, transform2);
  var rotate7 = getLabelRotation(datum, label, attr2);
  if (!label.getLocalEulerAngles()) {
    label.setLocalEulerAngles(rotate7);
  }
  applyTextStyle(label, __assign(__assign({}, getLabelStyle(datum.value, rotate7, attr2)), labelStyle));
  container.attr(groupStyle);
  return label;
}
function renderLabels(container, data2, attr2, animate2, main) {
  var finalData = filterExec(data2, attr2.labelFilter);
  var style = subStyleProps(attr2, "label");
  var _exit;
  var transitions = container.selectAll(CLASS_NAMES3.label.class).data(finalData, function(d4, i2) {
    return i2;
  }).join(function(enter) {
    return enter.append("g").attr("className", CLASS_NAMES3.label.name).transition(function(datum) {
      renderLabel(this, datum, data2, style, attr2);
      var _a2 = getLabelPos(datum, data2, attr2), x3 = _a2.x, y4 = _a2.y;
      this.style.transform = "translate(".concat(x3, ", ").concat(y4, ")");
      return null;
    });
  }, function(update2) {
    return update2.transition(function(datum) {
      var prevLabel = this.querySelector(CLASS_NAMES3.labelItem.class);
      var label = renderLabel(this, datum, data2, style, attr2);
      var shapeAnimation = transitionShape(prevLabel, label, animate2.update);
      var _a2 = getLabelPos(datum, data2, attr2), x3 = _a2.x, y4 = _a2.y;
      var animation = transition(this, { transform: "translate(".concat(x3, ", ").concat(y4, ")") }, animate2.update);
      return __spreadArray(__spreadArray([], __read(shapeAnimation), false), [animation], false);
    });
  }, function(exit) {
    _exit = exit;
    exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return select2(_this2).remove();
      });
      return animation;
    });
    return _exit;
  }).transitions();
  onAnimatesFinished(transitions, function() {
    overlapHandler.call(container, attr2, main);
  });
  return transitions;
}

// node_modules/@antv/component/esm/ui/axis/guides/ticks.js
function getTickVector(value2, attr2) {
  return getDirectionVector(value2, attr2.tickDirection, attr2);
}
function getTickPoints(unitVector, tickLength) {
  var _a2 = __read(unitVector, 2), dx = _a2[0], dy = _a2[1];
  return [
    [0, 0],
    [dx * tickLength, dy * tickLength]
  ];
}
function getTickLineLayout(datum, index3, data2, tickVector, attr2) {
  var tickLength = attr2.tickLength;
  var _a2 = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index3, data2])), 2), _b = __read(_a2[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
  return { x1: x12, x2: x22, y1: y12, y2: y22 };
}
function createTickEl(container, datum, index3, data2, attr2) {
  var formatter2 = attr2.tickFormatter;
  var tickVector = getTickVector(datum.value, attr2);
  var el = "line";
  if (isFunction(formatter2))
    el = function() {
      return getCallbackValue(formatter2, [datum, index3, data2, tickVector]);
    };
  return container.append(el).attr("className", CLASS_NAMES3.tickItem.name);
}
function applyTickStyle(datum, index3, data2, tick3, group3, attr2, style) {
  var tickVector = getTickVector(datum.value, attr2);
  var _a2 = getTickLineLayout(datum, index3, data2, tickVector, attr2), x12 = _a2.x1, x22 = _a2.x2, y12 = _a2.y1, y22 = _a2.y2;
  var _b = __read(splitStyle(getCallbackStyle(style, [datum, index3, data2, tickVector])), 2), tickStyle = _b[0], groupStyle = _b[1];
  tick3.node().nodeName === "line" && tick3.styles(__assign({ x1: x12, x2: x22, y1: y12, y2: y22 }, tickStyle));
  group3.attr(groupStyle);
  tick3.styles(tickStyle);
}
function createTick(datum, index3, data2, attr2, tickAttr, animate2) {
  var tick3 = createTickEl(select2(this), datum, index3, data2, attr2);
  applyTickStyle(datum, index3, data2, tick3, this, attr2, tickAttr);
  var _a2 = __read(getValuePos(datum.value, attr2), 2), x3 = _a2[0], y4 = _a2[1];
  return transition(this, { transform: "translate(".concat(x3, ", ").concat(y4, ")") }, animate2);
}
function renderTicks(container, axisData, attr2, animate2) {
  var finalData = filterExec(axisData, attr2.tickFilter);
  var tickAttr = subStyleProps(attr2, "tick");
  return container.selectAll(CLASS_NAMES3.tick.class).data(finalData, function(d4) {
    return d4.id || d4.label;
  }).join(function(enter) {
    return enter.append("g").attr("className", CLASS_NAMES3.tick.name).transition(function(datum, index3) {
      return createTick.call(this, datum, index3, finalData, attr2, tickAttr, false);
    });
  }, function(update2) {
    return update2.transition(function(datum, index3) {
      this.removeChildren();
      return createTick.call(this, datum, index3, finalData, attr2, tickAttr, animate2.update);
    });
  }, function(exit) {
    return exit.transition(function() {
      var _this2 = this;
      var animation = fadeOut_default(this.childNodes[0], animate2.exit);
      onAnimateFinished(animation, function() {
        return _this2.remove();
      });
      return animation;
    });
  }).transitions();
}

// node_modules/@antv/component/esm/ui/title/index.js
var CLASS_NAMES5 = classNames({
  text: "text"
}, "title");
function parsePosition(position) {
  if (!/\S+-\S+/g.test(position))
    return position.length > 2 ? [position[0]] : position.split("");
  return position.split("-").map(function(str7) {
    return str7[0];
  });
}
function getBBox(title, content) {
  var _a2 = title.attributes, position = _a2.position, spacing = _a2.spacing, inset = _a2.inset, text = _a2.text;
  var titleBBox = title.getBBox();
  var contentBBox = content.getBBox();
  var pos = parsePosition(position);
  var _b = __read(parseSeriesAttr(text ? spacing : 0), 4), spacingTop = _b[0], spacingRight = _b[1], spacingBottom = _b[2], spacingLeft = _b[3];
  var _c = __read(parseSeriesAttr(inset), 4), insetTop = _c[0], insetRight = _c[1], insetBottom = _c[2], insetLeft = _c[3];
  var _d = __read([spacingLeft + spacingRight, spacingTop + spacingBottom], 2), spacingWidth = _d[0], spacingHeight = _d[1];
  var _e = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _e[0], insetHeight = _e[1];
  if (pos[0] === "l") {
    return new BBox(titleBBox.x, titleBBox.y, contentBBox.width + titleBBox.width + spacingWidth + insetWidth, Math.max(contentBBox.height + insetHeight, titleBBox.height));
  }
  if (pos[0] === "t") {
    return new BBox(titleBBox.x, titleBBox.y, Math.max(contentBBox.width + insetWidth, titleBBox.width), contentBBox.height + titleBBox.height + spacingHeight + insetHeight);
  }
  var _f = __read([
    content.attributes.width || contentBBox.width,
    content.attributes.height || contentBBox.height
  ], 2), contentWidth = _f[0], contentHeight = _f[1];
  return new BBox(contentBBox.x, contentBBox.y, contentWidth + titleBBox.width + spacingWidth + insetWidth, contentHeight + titleBBox.height + spacingHeight + insetHeight);
}
function mayApplyStyle(el, style) {
  var finalStyle = Object.entries(style).reduce(function(acc, _a2) {
    var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
    var currAttr = el.node().attr(key);
    if (!currAttr)
      acc[key] = value2;
    return acc;
  }, {});
  el.styles(finalStyle);
}
function getTitleLayout(cfg) {
  var _a2, _b, _c, _d;
  var _e = cfg, width = _e.width, height = _e.height, position = _e.position;
  var _f = __read([+width / 2, +height / 2], 2), hW = _f[0], hH = _f[1];
  var _g = __read([+hW, +hH, "center", "middle"], 4), x3 = _g[0], y4 = _g[1], textAlign = _g[2], textBaseline = _g[3];
  var pos = parsePosition(position);
  if (pos.includes("l"))
    _a2 = __read([0, "start"], 2), x3 = _a2[0], textAlign = _a2[1];
  if (pos.includes("r"))
    _b = __read([+width, "end"], 2), x3 = _b[0], textAlign = _b[1];
  if (pos.includes("t"))
    _c = __read([0, "top"], 2), y4 = _c[0], textBaseline = _c[1];
  if (pos.includes("b"))
    _d = __read([+height, "bottom"], 2), y4 = _d[0], textBaseline = _d[1];
  return { x: x3, y: y4, textAlign, textBaseline };
}
var Title = (
  /** @class */
  function(_super) {
    __extends(Title3, _super);
    function Title3(options) {
      return _super.call(this, options, {
        text: "",
        width: 0,
        height: 0,
        fill: "#4a505a",
        fontWeight: "bold",
        fontSize: 12,
        fontFamily: "sans-serif",
        inset: 0,
        spacing: 0,
        position: "top-left"
      }) || this;
    }
    Title3.prototype.getAvailableSpace = function() {
      var container = this;
      var _a2 = this.attributes, containerWidth = _a2.width, containerHeight = _a2.height, position = _a2.position, spacing = _a2.spacing, inset = _a2.inset;
      var title = container.querySelector(CLASS_NAMES5.text.class);
      if (!title)
        return new BBox(0, 0, +containerWidth, +containerHeight);
      var _b = title.getBBox(), titleWidth = _b.width, titleHeight = _b.height;
      var _c = __read(parseSeriesAttr(spacing), 4), spacingTop = _c[0], spacingRight = _c[1], spacingBottom = _c[2], spacingLeft = _c[3];
      var _d = __read([0, 0, +containerWidth, +containerHeight], 4), x3 = _d[0], y4 = _d[1], width = _d[2], height = _d[3];
      var pos = parsePosition(position);
      if (pos.includes("i"))
        return new BBox(x3, y4, width, height);
      pos.forEach(function(p3, i2) {
        var _a3, _b2, _c2, _d2;
        if (p3 === "t")
          _a3 = __read(i2 === 0 ? [titleHeight + spacingBottom, +containerHeight - titleHeight - spacingBottom] : [0, +containerHeight], 2), y4 = _a3[0], height = _a3[1];
        if (p3 === "r")
          _b2 = __read([+containerWidth - titleWidth - spacingLeft], 1), width = _b2[0];
        if (p3 === "b")
          _c2 = __read([+containerHeight - titleHeight - spacingTop], 1), height = _c2[0];
        if (p3 === "l")
          _d2 = __read(i2 === 0 ? [titleWidth + spacingRight, +containerWidth - titleWidth - spacingRight] : [0, +containerWidth], 2), x3 = _d2[0], width = _d2[1];
      });
      var _e = __read(parseSeriesAttr(inset), 4), insetTop = _e[0], insetRight = _e[1], insetBottom = _e[2], insetLeft = _e[3];
      var _f = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _f[0], insetHeight = _f[1];
      return new BBox(x3 + insetLeft, y4 + insetTop, width - insetWidth, height - insetHeight);
    };
    Title3.prototype.getBBox = function() {
      if (this.title)
        return this.title.getBBox();
      return new BBox(0, 0, 0, 0);
    };
    Title3.prototype.render = function(attributes, container) {
      var _this2 = this;
      var width = attributes.width, height = attributes.height, position = attributes.position, spacing = attributes.spacing, restStyle = __rest(attributes, ["width", "height", "position", "spacing"]);
      var _a2 = __read(splitStyle(restStyle), 1), titleStyle = _a2[0];
      var _b = getTitleLayout(attributes), x3 = _b.x, y4 = _b.y, textAlign = _b.textAlign, textBaseline = _b.textBaseline;
      ifShow(!!restStyle.text, select2(container), function(group3) {
        _this2.title = group3.maybeAppendByClassName(CLASS_NAMES5.text, "text").styles(titleStyle).call(mayApplyStyle, { x: x3, y: y4, textAlign, textBaseline }).node();
      });
    };
    return Title3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/axis/guides/title.js
function getTitlePosition(mainGroup, titleGroup, attr2) {
  var _a2 = attr2.titlePosition, position = _a2 === void 0 ? "lb" : _a2, spacing = attr2.titleSpacing;
  var pos = parsePosition(position);
  var _b = mainGroup.node().getLocalBounds(), _c = __read(_b.min, 2), mainX = _c[0], mainY = _c[1], _d = __read(_b.halfExtents, 2), mainHalfWidth = _d[0], mainHalfHeight = _d[1];
  var _e = __read(titleGroup.node().getLocalBounds().halfExtents, 2), titleHalfWidth = _e[0], titleHalfHeight = _e[1];
  var _f = __read([mainX + mainHalfWidth, mainY + mainHalfHeight], 2), x3 = _f[0], y4 = _f[1];
  var _g = __read(parseSeriesAttr(spacing), 4), spacingTop = _g[0], spacingRight = _g[1], spacingBottom = _g[2], spacingLeft = _g[3];
  if (["start", "end"].includes(position) && attr2.type === "linear") {
    var startPos = attr2.startPos, endPos = attr2.endPos;
    var _h = __read(position === "start" ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
    var direction3 = normalize7([-to[0] + from[0], -to[1] + from[1]]);
    var _j = __read(scale8(direction3, spacingTop), 2), dx = _j[0], dy = _j[1];
    return { x: from[0] + dx, y: from[1] + dy };
  }
  if (pos.includes("t"))
    y4 -= mainHalfHeight + titleHalfHeight + spacingTop;
  if (pos.includes("r"))
    x3 += mainHalfWidth + titleHalfWidth + spacingRight;
  if (pos.includes("l"))
    x3 -= mainHalfWidth + titleHalfWidth + spacingLeft;
  if (pos.includes("b"))
    y4 += mainHalfHeight + titleHalfHeight + spacingBottom;
  return { x: x3, y: y4 };
}
function inferTransform(n2, direction3, position) {
  var halfExtents = n2.getGeometryBounds().halfExtents;
  var height = halfExtents[1] * 2;
  if (direction3 === "vertical") {
    if (position === "left")
      return "rotate(-90) translate(0, ".concat(height / 2, ")");
    if (position === "right")
      return "rotate(-90) translate(0, -".concat(height / 2, ")");
  }
  return "";
}
function applyTitleStyle(title, group3, axis, attr2, animate2) {
  var style = subStyleProps(attr2, "title");
  var _a2 = __read(splitStyle(style), 2), titleStyle = _a2[0], _b = _a2[1], specified = _b.transform, transformOrigin = _b.transformOrigin, groupStyle = __rest(_b, ["transform", "transformOrigin"]);
  group3.styles(groupStyle);
  var transform2 = specified || inferTransform(title.node(), titleStyle.direction, titleStyle.position);
  title.styles(__assign(__assign({}, titleStyle), { transformOrigin }));
  percentTransform(title.node(), transform2);
  var _c = getTitlePosition(
    // @ts-ignore
    select2(axis._offscreen || axis.querySelector(CLASS_NAMES3.mainGroup.class)),
    group3,
    attr2
  ), x3 = _c.x, y4 = _c.y;
  var animation = transition(group3.node(), { transform: "translate(".concat(x3, ", ").concat(y4, ")") }, animate2);
  return animation;
}
function renderTitle(container, axis, attr2, animate2) {
  var titleText = attr2.titleText;
  return container.selectAll(CLASS_NAMES3.title.class).data([{ title: titleText }].filter(function(d4) {
    return !!d4.title;
  }), function(d4, i2) {
    return d4.title;
  }).join(function(enter) {
    return enter.append(function() {
      return renderExtDo(titleText);
    }).attr("className", CLASS_NAMES3.title.name).transition(function() {
      return applyTitleStyle(select2(this), container, axis, attr2, animate2.enter);
    });
  }, function(update2) {
    return update2.transition(function() {
      return applyTitleStyle(select2(this), container, axis, attr2, animate2.update);
    });
  }, function(exit) {
    return exit.remove();
  }).transitions();
}

// node_modules/@antv/component/esm/ui/axis/axis.js
function renderAxisMain(attributes, container, data2, animation) {
  var showLine = attributes.showLine, showTick = attributes.showTick, showLabel = attributes.showLabel;
  var lineGroup = container.maybeAppendByClassName(CLASS_NAMES3.lineGroup, "g");
  var lineTransitions = ifShow(showLine, lineGroup, function(group3) {
    return renderAxisLine(group3, attributes, animation);
  }) || [];
  var tickGroup = container.maybeAppendByClassName(CLASS_NAMES3.tickGroup, "g");
  var tickTransitions = ifShow(showTick, tickGroup, function(group3) {
    return renderTicks(group3, data2, attributes, animation);
  }) || [];
  var labelGroup = container.maybeAppendByClassName(CLASS_NAMES3.labelGroup, "g");
  var labelTransitions = ifShow(showLabel, labelGroup, function(group3) {
    return renderLabels(group3, data2, attributes, animation, container.node());
  }) || [];
  return __spreadArray(__spreadArray(__spreadArray([], __read(lineTransitions), false), __read(tickTransitions), false), __read(labelTransitions), false).filter(function(t) {
    return !!t;
  });
}
var Axis = (
  /** @class */
  function(_super) {
    __extends(Axis2, _super);
    function Axis2(options) {
      return _super.call(this, options, AXIS_BASE_DEFAULT_ATTR) || this;
    }
    Axis2.prototype.render = function(attributes, container, specificAnimation) {
      var _this2 = this;
      var titleText = attributes.titleText, data2 = attributes.data, animate2 = attributes.animate, showTitle = attributes.showTitle, showGrid = attributes.showGrid, dataThreshold = attributes.dataThreshold, truncRange = attributes.truncRange;
      var sampledData = sampling(data2, dataThreshold).filter(function(_a2) {
        var value2 = _a2.value;
        if (truncRange && value2 > truncRange[0] && value2 < truncRange[1])
          return false;
        return true;
      });
      var finalAnimation = parseAnimationOption(specificAnimation === void 0 ? animate2 : specificAnimation);
      var gridGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.gridGroup, "g");
      var gridTransitions = ifShow(showGrid, gridGroup, function(group3) {
        return renderGrid(group3, sampledData, attributes, finalAnimation);
      }) || [];
      var mainGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.mainGroup, "g");
      if (titleText && (!this.initialized && finalAnimation.enter || this.initialized && finalAnimation.update)) {
        renderAxisMain(attributes, select2(this.offscreenGroup), sampledData, parseAnimationOption(false));
      }
      var mainTransitions = renderAxisMain(attributes, select2(mainGroup.node()), sampledData, finalAnimation);
      var titleGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.titleGroup, "g");
      var titleTransitions = ifShow(showTitle, titleGroup, function(group3) {
        return renderTitle(group3, _this2, attributes, finalAnimation);
      }) || [];
      return __spreadArray(__spreadArray(__spreadArray([], __read(gridTransitions), false), __read(mainTransitions), false), __read(titleTransitions), false).flat().filter(function(t) {
        return !!t;
      });
    };
    return Axis2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/navigator/index.js
var CLASS_NAMES6 = classNames({
  prevBtnGroup: "prev-btn-group",
  prevBtn: "prev-btn",
  nextBtnGroup: "next-btn-group",
  nextBtn: "next-btn",
  pageInfoGroup: "page-info-group",
  pageInfo: "page-info",
  playWindow: "play-window",
  contentGroup: "content-group",
  controller: "controller",
  clipPath: "clip-path"
}, "navigator");
var Navigator = (
  /** @class */
  function(_super) {
    __extends(Navigator2, _super);
    function Navigator2(options) {
      var _this2 = _super.call(this, options, {
        x: 0,
        y: 0,
        animate: {
          easing: "linear",
          duration: 200,
          fill: "both"
        },
        buttonCursor: "pointer",
        buttonFill: "black",
        buttonD: button(0, 0, 6),
        buttonSize: 12,
        controllerPadding: 5,
        controllerSpacing: 5,
        formatter: function(curr, total) {
          return "".concat(curr, "/").concat(total);
        },
        defaultPage: 0,
        loop: false,
        orientation: "horizontal",
        pageNumFill: "black",
        pageNumFontSize: 12,
        pageNumTextAlign: "start",
        pageNumTextBaseline: "middle"
      }) || this;
      _this2.playState = "idle";
      _this2.contentGroup = _this2.appendChild(new Group2({ class: CLASS_NAMES6.contentGroup.name }));
      _this2.playWindow = _this2.contentGroup.appendChild(new Group2({ class: CLASS_NAMES6.playWindow.name }));
      _this2.innerCurrPage = _this2.defaultPage;
      return _this2;
    }
    Object.defineProperty(Navigator2.prototype, "defaultPage", {
      get: function() {
        var defaultPage = this.attributes.defaultPage;
        return clamp_default(defaultPage, 0, Math.max(this.pageViews.length - 1, 0));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageViews", {
      get: function() {
        return this.playWindow.children;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "controllerShape", {
      // todo fixme
      get: function() {
        return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "pageShape", {
      get: function() {
        var pageViews = this.pageViews;
        var _a2 = __read(transpose4(pageViews.map(function(pageView) {
          var _a3 = pageView.getBBox(), width = _a3.width, height = _a3.height;
          return [width, height];
        })).map(function(arr) {
          return Math.max.apply(Math, __spreadArray([], __read(arr), false));
        }), 2), maxWidth = _a2[0], maxHeight = _a2[1];
        var _b = this.attributes, _c = _b.pageWidth, pageWidth = _c === void 0 ? maxWidth : _c, _d = _b.pageHeight, pageHeight = _d === void 0 ? maxHeight : _d;
        return { pageWidth, pageHeight };
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getContainer = function() {
      return this.playWindow;
    };
    Object.defineProperty(Navigator2.prototype, "totalPages", {
      get: function() {
        return this.pageViews.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Navigator2.prototype, "currPage", {
      get: function() {
        return this.innerCurrPage;
      },
      enumerable: false,
      configurable: true
    });
    Navigator2.prototype.getBBox = function() {
      var _a2 = _super.prototype.getBBox.call(this), x3 = _a2.x, y4 = _a2.y;
      var controllerShape = this.controllerShape;
      var _b = this.pageShape, pageWidth = _b.pageWidth, pageHeight = _b.pageHeight;
      return new BBox(x3, y4, pageWidth + controllerShape.width, pageHeight);
    };
    Navigator2.prototype.goTo = function(pageNum) {
      var _this2 = this;
      var animateOptions = this.attributes.animate;
      var _a2 = this, currPage = _a2.currPage, playState = _a2.playState, playWindow = _a2.playWindow, pageViews = _a2.pageViews;
      if (playState !== "idle" || pageNum < 0 || pageViews.length <= 0 || pageNum >= pageViews.length)
        return null;
      pageViews[currPage].setLocalPosition(0, 0);
      this.prepareFollowingPage(pageNum);
      var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
      this.playState = "running";
      var animation = animate(playWindow, [{ transform: "translate(0, 0)" }, { transform: "translate(".concat(-dx, ", ").concat(-dy, ")") }], animateOptions);
      onAnimateFinished(animation, function() {
        _this2.innerCurrPage = pageNum;
        _this2.playState = "idle";
        _this2.setVisiblePages([pageNum]);
        _this2.updatePageInfo();
      });
      return animation;
    };
    Navigator2.prototype.prev = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page <= 0)
        return null;
      var following = loop ? (page - 1 + pages) % pages : clamp_default(page - 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.next = function() {
      var loop = this.attributes.loop;
      var pages = this.pageViews.length;
      var page = this.currPage;
      if (!loop && page >= pages - 1)
        return null;
      var following = loop ? (page + 1) % pages : clamp_default(page + 1, 0, pages);
      return this.goTo(following);
    };
    Navigator2.prototype.renderClipPath = function(container) {
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      if (!pageWidth || !pageHeight) {
        this.contentGroup.style.clipPath = void 0;
        return;
      }
      this.clipPath = container.maybeAppendByClassName(CLASS_NAMES6.clipPath, "rect").styles({
        width: pageWidth,
        height: pageHeight
      });
      this.contentGroup.attr("clipPath", this.clipPath.node());
    };
    Navigator2.prototype.setVisiblePages = function(pages) {
      this.playWindow.children.forEach(function(page, index3) {
        if (pages.includes(index3))
          show(page);
        else
          hide(page);
      });
    };
    Navigator2.prototype.adjustControllerLayout = function() {
      var _a2 = this, prevBtn = _a2.prevBtnGroup, nextBtn = _a2.nextBtnGroup, pageNum = _a2.pageInfoGroup;
      var _b = this.attributes, orientation = _b.orientation, padding = _b.controllerPadding;
      var _c = pageNum.getBBox(), pW = _c.width, pH = _c.height;
      var _d = __read(orientation === "horizontal" ? [-180, 0] : [-90, 90], 2), r1 = _d[0], r2 = _d[1];
      prevBtn.setLocalEulerAngles(r1);
      nextBtn.setLocalEulerAngles(r2);
      var _e = prevBtn.getBBox(), bpW = _e.width, bpH = _e.height;
      var _f = nextBtn.getBBox(), bnW = _f.width, bnH = _f.height;
      var maxWidth = Math.max(bpW, pW, bnW);
      var _g = orientation === "horizontal" ? {
        offset: [
          [0, 0],
          [bpW / 2 + padding, 0],
          [bpW + pW + padding * 2, 0]
        ],
        textAlign: "start"
      } : {
        offset: [
          [maxWidth / 2, -bpH - padding],
          [maxWidth / 2, 0],
          [maxWidth / 2, bnH + padding]
        ],
        textAlign: "center"
      }, _h = __read(_g.offset, 3), _j = __read(_h[0], 2), o1x = _j[0], o1y = _j[1], _k = __read(_h[1], 2), o2x = _k[0], o2y = _k[1], _l = __read(_h[2], 2), o3x = _l[0], o3y = _l[1], textAlign = _g.textAlign;
      var pageNumText = pageNum.querySelector("text");
      pageNumText && (pageNumText.style.textAlign = textAlign);
      prevBtn.setLocalPosition(o1x, o1y);
      pageNum.setLocalPosition(o2x, o2y);
      nextBtn.setLocalPosition(o3x, o3y);
    };
    Navigator2.prototype.updatePageInfo = function() {
      var _a2;
      var _b = this, currPage = _b.currPage, pageViews = _b.pageViews, formatter2 = _b.attributes.formatter;
      if (pageViews.length < 2)
        return;
      (_a2 = this.pageInfoGroup.querySelector(CLASS_NAMES6.pageInfo.class)) === null || _a2 === void 0 ? void 0 : _a2.attr("text", formatter2(currPage + 1, pageViews.length));
      this.adjustControllerLayout();
    };
    Navigator2.prototype.getFollowingPageDiff = function(pageNum) {
      var currPage = this.currPage;
      if (currPage === pageNum)
        return [0, 0];
      var orientation = this.attributes.orientation;
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      var sign3 = pageNum < currPage ? -1 : 1;
      return orientation === "horizontal" ? [sign3 * pageWidth, 0] : [0, sign3 * pageHeight];
    };
    Navigator2.prototype.prepareFollowingPage = function(pageNum) {
      var _a2 = this, currPage = _a2.currPage, pageViews = _a2.pageViews;
      this.setVisiblePages([pageNum, currPage]);
      if (pageNum !== currPage) {
        var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
        pageViews[pageNum].setLocalPosition(dx, dy);
      }
    };
    Navigator2.prototype.renderController = function(container) {
      var _this2 = this;
      var spacing = this.attributes.controllerSpacing;
      var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      var visible = this.pageViews.length >= 2;
      var group3 = container.maybeAppendByClassName(CLASS_NAMES6.controller, "g");
      visibility(group3.node(), visible);
      if (!visible)
        return;
      var style = subStyleProps(this.attributes, "button");
      var textStyle = subStyleProps(this.attributes, "pageNum");
      var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], size3 = _c.size, pathStyle = __rest(_c, ["size"]);
      var whetherToAddEventListener = !group3.select(CLASS_NAMES6.prevBtnGroup.class).node();
      var prevBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.prevBtnGroup, "g").styles(groupStyle);
      this.prevBtnGroup = prevBtnGroup.node();
      var prevBtn = prevBtnGroup.maybeAppendByClassName(CLASS_NAMES6.prevBtn, "path");
      var nextBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.nextBtnGroup, "g").styles(groupStyle);
      this.nextBtnGroup = nextBtnGroup.node();
      var nextBtn = nextBtnGroup.maybeAppendByClassName(CLASS_NAMES6.nextBtn, "path");
      [prevBtn, nextBtn].forEach(function(btn) {
        btn.styles(__assign(__assign({}, pathStyle), { transformOrigin: "center" }));
        scaleToPixel(btn.node(), size3, true);
      });
      var pageInfoGroup = group3.maybeAppendByClassName(CLASS_NAMES6.pageInfoGroup, "g");
      this.pageInfoGroup = pageInfoGroup.node();
      pageInfoGroup.maybeAppendByClassName(CLASS_NAMES6.pageInfo, "text").styles(textStyle);
      this.updatePageInfo();
      group3.node().setLocalPosition(pageWidth + spacing, pageHeight / 2);
      if (whetherToAddEventListener) {
        this.prevBtnGroup.addEventListener("click", function() {
          _this2.prev();
        });
        this.nextBtnGroup.addEventListener("click", function() {
          _this2.next();
        });
      }
    };
    Navigator2.prototype.render = function(attributes, container) {
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y4 = _b === void 0 ? 0 : _b;
      this.attr("transform", "translate(".concat(x3, ", ").concat(y4, ")"));
      var containerSelection = select2(container);
      this.renderClipPath(containerSelection);
      this.renderController(containerSelection);
      this.setVisiblePages([this.defaultPage]);
      this.goTo(this.defaultPage);
    };
    Navigator2.prototype.bindEvents = function() {
      var _this2 = this;
      var render3 = debounce_default(function() {
        return _this2.render(_this2.attributes, _this2);
      }, 50);
      this.playWindow.addEventListener(ElementEvent.INSERTED, render3);
      this.playWindow.addEventListener(ElementEvent.REMOVED, render3);
    };
    return Navigator2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/utils.js
function getStepValueByValue(value2, step2, min10) {
  var count4 = Math.round((value2 - min10) / step2);
  return min10 + count4 * step2;
}
function hiddenHandle(x3, y4, r2) {
  var ratio = 1.4;
  var diffY = ratio * r2;
  return [["M", x3 - r2, y4 - diffY], ["L", x3 + r2, y4 - diffY], ["L", x3 + r2, y4 + diffY], ["L", x3 - r2, y4 + diffY], ["Z"]];
}
var HANDLE_HEIGHT_RATIO = 1.4;
var HANDLE_TRIANGLE_RATIO = 0.4;
function verticalHandle(x3, y4, r2) {
  var width = r2;
  var height = width * HANDLE_HEIGHT_RATIO;
  var halfWidth = width / 2;
  var oneSixthWidth = width / 6;
  var triangleX = x3 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x3, y4],
    ["L", triangleX, y4 + halfWidth],
    ["L", x3 + height, y4 + halfWidth],
    ["L", x3 + height, y4 - halfWidth],
    ["L", triangleX, y4 - halfWidth],
    ["Z"],
    // 
    ["M", triangleX, y4 + oneSixthWidth],
    ["L", x3 + height - 2, y4 + oneSixthWidth],
    ["M", triangleX, y4 - oneSixthWidth],
    ["L", x3 + height - 2, y4 - oneSixthWidth]
  ];
}
function horizontalHandle(x3, y4, r2) {
  var width = r2;
  var height = width * HANDLE_HEIGHT_RATIO;
  var halfWidth = width / 2;
  var oneSixthWidth = width / 6;
  var triangleY = y4 + height * HANDLE_TRIANGLE_RATIO;
  return [
    ["M", x3, y4],
    ["L", x3 - halfWidth, triangleY],
    ["L", x3 - halfWidth, y4 + height],
    ["L", x3 + halfWidth, y4 + height],
    ["L", x3 + halfWidth, triangleY],
    ["Z"],
    // 
    ["M", x3 - oneSixthWidth, triangleY],
    ["L", x3 - oneSixthWidth, y4 + height - 2],
    ["M", x3 + oneSixthWidth, triangleY],
    ["L", x3 + oneSixthWidth, y4 + height - 2]
  ];
}
Marker.registerSymbol("hiddenHandle", hiddenHandle);
Marker.registerSymbol("verticalHandle", verticalHandle);
Marker.registerSymbol("horizontalHandle", horizontalHandle);
function getSafetySelections(domain, newSelection, oldSelection, precision) {
  var _a2;
  if (precision === void 0) {
    precision = 4;
  }
  var _b = __read(domain, 2), min10 = _b[0], max11 = _b[1];
  var _c = __read(newSelection, 2), start = _c[0], end = _c[1];
  var _d = __read(oldSelection, 2), prevStart = _d[0], prevEnd = _d[1];
  var _e = __read([start, end], 2), startVal = _e[0], endVal = _e[1];
  var range3 = endVal - startVal;
  if (startVal > endVal) {
    _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
  }
  if (range3 > max11 - min10) {
    return [min10, max11];
  }
  if (startVal < min10) {
    if (prevStart === min10 && prevEnd === endVal) {
      return [min10, endVal];
    }
    return [min10, range3 + min10];
  }
  if (endVal > max11) {
    if (prevEnd === max11 && prevStart === startVal) {
      return [startVal, max11];
    }
    return [max11 - range3, max11];
  }
  return [startVal, endVal];
}
function ifHorizontal(orientation, a5, b) {
  if (orientation === void 0) {
    orientation = "horizontal";
  }
  return orientation === "horizontal" ? a5 : b;
}

// node_modules/@antv/component/esm/ui/poptip/constant.js
var _a;
var POPTIP_ID = "component-poptip";
var CLASS_NAME = {
  CONTAINER: "component-poptip",
  ARROW: "component-poptip-arrow",
  TEXT: "component-poptip-text"
};
var POPTIP_STYLE = (_a = {}, //   style
_a[".".concat(CLASS_NAME.CONTAINER)] = {
  visibility: "visible",
  position: "absolute",
  "background-color": "rgba(0, 0, 0)",
  "box-shadow": "0px 0px 10px #aeaeae",
  "border-radius": "3px",
  color: "#fff",
  opacity: 0.8,
  "font-size": "12px",
  padding: "4px 6px",
  display: "flex",
  "justify-content": "center",
  "align-items": "center",
  "z-index": 8,
  transition: "visibility 50ms"
}, //   style
_a[".".concat(CLASS_NAME.TEXT)] = {
  "text-align": "center"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(-100%, -50%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(0, -50%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0,-100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%,-100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(-100%, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(-100%, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(0, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(0, -100%)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 0)"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 0)"
}, _a[".".concat(CLASS_NAME.ARROW)] = {
  width: "4px",
  height: "4px",
  transform: "rotate(45deg)",
  "background-color": "rgba(0, 0, 0)",
  position: "absolute",
  "z-index": -1
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
  transform: "translate(-50%, calc(-100% - 5px))"
}, _a["[data-position='top'] .".concat(CLASS_NAME.ARROW)] = {
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
  transform: "translate(calc(-100% - 5px), -50%)"
}, _a["[data-position='left'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
  transform: "translate(5px, -50%)"
}, _a["[data-position='right'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
  transform: "translate(-50%, 5px)"
}, _a["[data-position='bottom'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
  transform: "translate(0, calc(-100% - 5px))"
}, _a["[data-position='top-left'] .".concat(CLASS_NAME.ARROW)] = {
  left: "10px",
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
  transform: "translate(-100%, calc(-100% - 5px))"
}, _a["[data-position='top-right'] .".concat(CLASS_NAME.ARROW)] = {
  right: "10px",
  bottom: "-2px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
  transform: "translate(calc(-100% - 5px), 0)"
}, _a["[data-position='left-top'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  top: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
  transform: "translate(calc(-100% - 5px), -100%)"
}, _a["[data-position='left-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  right: "-2px",
  bottom: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
  transform: "translate(5px, 0)"
}, _a["[data-position='right-top'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  top: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
  transform: "translate(5px, -100%)"
}, _a["[data-position='right-bottom'] .".concat(CLASS_NAME.ARROW)] = {
  left: "-2px",
  bottom: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
  transform: "translate(0, 5px)"
}, _a["[data-position='bottom-left'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  left: "8px"
}, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
  transform: "translate(-100%, 5px)"
}, _a["[data-position='bottom-right'] .".concat(CLASS_NAME.ARROW)] = {
  top: "-2px",
  right: "8px"
}, _a);

// node_modules/@antv/component/esm/ui/poptip/utils.js
var _this = void 0;
function getPositionXY(clientX, clientY, target, position, arrowPointAtCenter, follow) {
  if (arrowPointAtCenter === void 0) {
    arrowPointAtCenter = false;
  }
  if (follow === void 0) {
    follow = false;
  }
  if (follow)
    return [clientX, clientY];
  var _a2 = target.getBoundingClientRect(), x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
  switch (position) {
    case "top":
      return arrowPointAtCenter ? [x3 + width / 2, y4] : [clientX, y4];
    case "left":
      return arrowPointAtCenter ? [x3, y4 + height / 2] : [x3, clientY];
    case "bottom":
      return arrowPointAtCenter ? [x3 + width / 2, y4 + height] : [clientX, y4 + height];
    case "right":
      return arrowPointAtCenter ? [x3 + width, y4 + height / 2] : [x3 + width, clientY];
    case "top-right":
    case "right-top":
      return [x3 + width, y4];
    case "left-bottom":
    case "bottom-left":
      return [x3, y4 + height];
    case "right-bottom":
    case "bottom-right":
      return [x3 + width, y4 + height];
    case "top-left":
    case "left-top":
    default:
      return [x3, y4];
  }
}
var getSingleTon = function(fn) {
  var instance;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!instance)
      instance = fn.apply(_this, args);
    return instance;
  };
};
function createElement2(id4) {
  var div4 = id4 && document.getElementById(id4);
  if (!div4) {
    div4 = document.createElement("div");
    div4.setAttribute("id", id4);
    document.body.appendChild(div4);
  }
  return div4;
}
function getSingleTonElement(id4) {
  var element = getSingleTon(createElement2)(id4);
  return element;
}

// node_modules/@antv/component/esm/ui/poptip/index.js
var Poptip = (
  /** @class */
  function(_super) {
    __extends(Poptip3, _super);
    function Poptip3(options) {
      var _this2 = _super.call(this, deep_mix_default({ style: { id: POPTIP_ID } }, Poptip3.defaultOptions, options)) || this;
      _this2.visibility = "visible";
      _this2.map = /* @__PURE__ */ new Map();
      _this2.domStyles = "";
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Poptip3.prototype, "visible", {
      get: function() {
        return this.visibility === "visible";
      },
      enumerable: false,
      configurable: true
    });
    Poptip3.prototype.render = function(attributes, container) {
      this.visibility = this.style.visibility;
      this.updatePoptipElement();
    };
    Poptip3.prototype.update = function(cfg) {
      this.attr(deep_mix_default({}, this.style, cfg));
      this.render(this.attributes, this);
    };
    Poptip3.prototype.bind = function(element, callback) {
      var _this2 = this;
      if (!element)
        return;
      var defaultText = this.style.text;
      var onmousemove = function(e3) {
        var target = element;
        var options = _this2.style;
        var text = defaultText;
        if (callback) {
          var _a2 = typeof callback === "function" ? callback.call(null, e3) : callback, html = _a2.html, ele = _a2.target, restOptions = __rest(_a2, ["html", "target"]);
          options = mix({}, _this2.style, restOptions);
          if (ele || ele === false)
            target = ele;
          if (typeof html === "string")
            text = html;
        }
        var position = options.position, arrowPointAtCenter = options.arrowPointAtCenter, follow = options.follow, offset2 = options.offset;
        if (target) {
          var _b = e3, clientX = _b.clientX, clientY = _b.clientY;
          var _c = __read(getPositionXY(clientX, clientY, target, position, arrowPointAtCenter, follow), 2), x3 = _c[0], y4 = _c[1];
          _this2.showTip(x3, y4, { text, position, offset: offset2 });
        } else {
          _this2.hideTip();
        }
      };
      var onmouseleave = function() {
        _this2.hideTip();
      };
      element.addEventListener("mousemove", onmousemove);
      element.addEventListener("mouseleave", onmouseleave);
      this.map.set(element, [onmousemove, onmouseleave]);
    };
    Poptip3.prototype.unbind = function(element) {
      if (this.map.has(element)) {
        var _a2 = __read(this.map.get(element) || [], 2), listener1 = _a2[0], listener2 = _a2[1];
        listener1 && element.removeEventListener("mousemove", listener1);
        listener2 && element.removeEventListener("mouseleave", listener2);
        this.map.delete(element);
      }
    };
    Poptip3.prototype.clear = function() {
      this.container.innerHTML = "";
    };
    Poptip3.prototype.destroy = function() {
      var _this2 = this;
      var _a2;
      __spreadArray([], __read(this.map.keys()), false).forEach(function(ele) {
        return _this2.unbind(ele);
      });
      (_a2 = this.container) === null || _a2 === void 0 ? void 0 : _a2.remove();
      _super.prototype.destroy.call(this);
    };
    Poptip3.prototype.showTip = function(x3, y4, options) {
      var text = get_default(options, "text");
      if (text && typeof text !== "string")
        return;
      this.applyStyles();
      if (x3 && y4 && options) {
        var offset2 = options.offset, position = options.position;
        position && this.container.setAttribute("data-position", position);
        this.setOffsetPosition(x3, y4, offset2);
        if (typeof text === "string") {
          var textElement = this.container.querySelector(".".concat(CLASS_NAME.TEXT));
          if (textElement) {
            textElement.innerHTML = text;
          }
        }
        this.visibility = "visible";
        this.container.style.visibility = "visible";
      }
    };
    Poptip3.prototype.hideTip = function() {
      this.visibility = "hidden";
      this.container.style.visibility = "hidden";
    };
    Poptip3.prototype.getContainer = function() {
      return this.container;
    };
    Poptip3.prototype.getClassName = function() {
      var containerClassName = this.style.containerClassName;
      return "".concat(CLASS_NAME.CONTAINER).concat(containerClassName ? " ".concat(containerClassName) : "");
    };
    Poptip3.prototype.initShape = function() {
      var _this2 = this;
      var id4 = this.style.id;
      this.container = getSingleTonElement(id4);
      this.container.className = this.getClassName();
      this.container.addEventListener("mousemove", function() {
        return _this2.showTip();
      });
      this.container.addEventListener("mouseleave", function() {
        return _this2.hideTip();
      });
    };
    Poptip3.prototype.updatePoptipElement = function() {
      var container = this.container;
      this.clear();
      var _a2 = this.style, id4 = _a2.id, template = _a2.template, text = _a2.text;
      this.container.setAttribute("id", id4);
      this.container.className = this.getClassName();
      var arrowNode = '<span class="'.concat(CLASS_NAME.ARROW, '"></span>');
      container.innerHTML = arrowNode;
      if (isString(template)) {
        container.innerHTML += template;
      } else if (template && isElement(template)) {
        container.appendChild(template);
      }
      if (text) {
        container.getElementsByClassName(CLASS_NAME.TEXT)[0].textContent = text;
      }
      this.applyStyles();
      this.container.style.visibility = this.visibility;
    };
    Poptip3.prototype.applyStyles = function() {
      var styles = deepAssign2({}, POPTIP_STYLE, this.style.domStyles);
      var styleStr = Object.entries(styles).reduce(function(r2, _a2) {
        var _b = __read(_a2, 2), key = _b[0], value2 = _b[1];
        var styleStr2 = Object.entries(value2).reduce(function(r3, _a3) {
          var _b2 = __read(_a3, 2), k2 = _b2[0], v = _b2[1];
          return "".concat(r3).concat(k2, ": ").concat(v, ";");
        }, "");
        return "".concat(r2).concat(key, "{").concat(styleStr2, "}");
      }, "");
      if (this.domStyles !== styleStr) {
        this.domStyles = styleStr;
        var styleDOM = this.container.querySelector("style");
        if (styleDOM)
          this.container.removeChild(styleDOM);
        styleDOM = document.createElement("style");
        styleDOM.innerHTML = styleStr;
        this.container.appendChild(styleDOM);
      }
    };
    Poptip3.prototype.setOffsetPosition = function(x3, y4, offset2) {
      if (offset2 === void 0) {
        offset2 = this.style.offset;
      }
      var _a2 = __read(offset2, 2), _b = _a2[0], offsetX = _b === void 0 ? 0 : _b, _c = _a2[1], offsetY = _c === void 0 ? 0 : _c;
      this.container.style.left = "".concat(x3 + offsetX, "px");
      this.container.style.top = "".concat(y4 + offsetY, "px");
    };
    Poptip3.tag = "poptip";
    Poptip3.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        target: null,
        visibility: "hidden",
        text: "",
        position: "top",
        follow: false,
        offset: [0, 0],
        domStyles: POPTIP_STYLE,
        template: '<div class="'.concat(CLASS_NAME.TEXT, '"></div>')
      }
    };
    return Poptip3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/category/item.js
var CLASS_NAMES7 = classNames({
  layout: "flex",
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label",
  valueGroup: "value-group",
  value: "value",
  backgroundGroup: "background-group",
  background: "background"
}, "legend-category-item");
var DEFAULT_POPTIP_PROPS = {
  offset: [0, 20],
  domStyles: {
    ".component-poptip": {
      opacity: "1",
      padding: "8px 12px",
      background: "#fff",
      boxShadow: "0 2px 8px rgba(0, 0, 0, 0.15)"
    },
    ".component-poptip-arrow": {
      display: "none"
    },
    ".component-poptip-text": {
      color: "#000",
      lineHeight: "20px"
    }
  }
};
function styleOfMarker(group3) {
  var marker = group3.querySelector(CLASS_NAMES7.marker.class);
  if (marker)
    return marker.style;
  return {};
}
var CategoryItem = (
  /** @class */
  function(_super) {
    __extends(CategoryItem2, _super);
    function CategoryItem2(options) {
      return _super.call(this, options, {
        span: [1, 1],
        marker: function() {
          return new Circle({ style: { r: 6 } });
        },
        markerSize: 10,
        labelFill: "#646464",
        valueFill: "#646464",
        labelFontSize: 12,
        valueFontSize: 12,
        labelTextBaseline: "middle",
        valueTextBaseline: "middle"
      }) || this;
    }
    Object.defineProperty(CategoryItem2.prototype, "showValue", {
      get: function() {
        var valueText = this.attributes.valueText;
        if (!valueText)
          return false;
        if (typeof valueText === "string" || typeof valueText === "number")
          return valueText !== "";
        if (typeof valueText === "function")
          return true;
        return valueText.attr("text") !== "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "actualSpace", {
      get: function() {
        var label = this.labelGroup;
        var value2 = this.valueGroup;
        var markerSize = this.attributes.markerSize;
        var _a2 = label.node().getBBox(), labelWidth = _a2.width, labelHeight = _a2.height;
        var _b = value2.node().getBBox(), valueWidth = _b.width, valueHeight = _b.height;
        return {
          markerWidth: markerSize,
          labelWidth,
          valueWidth,
          height: Math.max(markerSize, labelHeight, valueHeight)
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "span", {
      get: function() {
        var span = this.attributes.span;
        if (!span)
          return [1, 1];
        var _a2 = __read(parseSeriesAttr(span), 2), span1 = _a2[0], innerSpan = _a2[1];
        var span2 = this.showValue ? innerSpan : 0;
        var basis2 = span1 + span2;
        return [span1 / basis2, span2 / basis2];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "shape", {
      get: function() {
        var _a2;
        var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
        var actualSpace = this.actualSpace;
        var markerWidth = actualSpace.markerWidth, height = actualSpace.height;
        var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
        var _d = __read(this.spacing, 2), spacing1 = _d[0], spacing2 = _d[1];
        if (fullWidth) {
          var width_1 = fullWidth - markerSize - spacing1 - spacing2;
          var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
          _a2 = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a2[0], valueWidth = _a2[1];
        }
        var width = markerWidth + labelWidth + valueWidth + spacing1 + spacing2;
        return { width, height, markerWidth, labelWidth, valueWidth };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "spacing", {
      get: function() {
        var spacing = this.attributes.spacing;
        if (!spacing)
          return [0, 0];
        var _a2 = __read(parseSeriesAttr(spacing), 2), spacing1 = _a2[0], spacing2 = _a2[1];
        if (this.showValue)
          return [spacing1, spacing2];
        return [spacing1, 0];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "layout", {
      get: function() {
        var _a2 = this.shape, markerWidth = _a2.markerWidth, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, width = _a2.width, height = _a2.height;
        var _b = __read(this.spacing, 2), spacing1 = _b[0], spacing2 = _b[1];
        return {
          height,
          width,
          markerWidth,
          labelWidth,
          valueWidth,
          position: [markerWidth / 2, markerWidth + spacing1, markerWidth + labelWidth + spacing1 + spacing2]
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItem2.prototype, "scaleSize", {
      get: function() {
        var markerShapeStyle = styleOfMarker(this.markerGroup.node());
        var _a2 = this.attributes, markerSize = _a2.markerSize, _b = _a2.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a2.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a2.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
        var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
        var _e = this.markerGroup.node().getBBox(), width = _e.width, height = _e.height;
        return (1 - strokeWidth / Math.max(width, height)) * markerSize;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItem2.prototype.renderMarker = function(container) {
      var _this2 = this;
      var marker = this.attributes.marker;
      var style = subStyleProps(this.attributes, "marker");
      this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES7.markerGroup, "g").style("zIndex", 0);
      ifShow(!!marker, this.markerGroup, function() {
        var _a2;
        var parent = _this2.markerGroup.node();
        var oldMarker = (_a2 = parent.childNodes) === null || _a2 === void 0 ? void 0 : _a2[0];
        var newMarker = typeof marker === "string" ? new Marker({ style: { symbol: marker }, className: CLASS_NAMES7.marker.name }) : marker();
        if (!oldMarker) {
          if (!(newMarker instanceof Marker))
            select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
          parent.appendChild(newMarker);
        } else if (newMarker.nodeName === oldMarker.nodeName) {
          if (oldMarker instanceof Marker)
            oldMarker.update(__assign(__assign({}, style), { symbol: marker }));
          else {
            copyAttributes2(oldMarker, newMarker);
            select2(oldMarker).styles(style);
          }
        } else {
          oldMarker.remove();
          select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
          parent.appendChild(newMarker);
        }
        _this2.markerGroup.node().scale(1 / _this2.markerGroup.node().getScale()[0]);
        var scale12 = scaleToPixel(_this2.markerGroup.node(), _this2.scaleSize, true);
        _this2.markerGroup.node().style._transform = "scale(".concat(scale12, ")");
      });
    };
    CategoryItem2.prototype.renderLabel = function(container) {
      var _a2 = subStyleProps(this.attributes, "label"), label = _a2.text, style = __rest(_a2, ["text"]);
      this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES7.labelGroup, "g").style("zIndex", 0);
      this.labelGroup.maybeAppendByClassName(CLASS_NAMES7.label, function() {
        return renderExtDo(label);
      }).styles(style);
    };
    CategoryItem2.prototype.renderValue = function(container) {
      var _this2 = this;
      var _a2 = subStyleProps(this.attributes, "value"), value2 = _a2.text, style = __rest(_a2, ["text"]);
      this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES7.valueGroup, "g").style("zIndex", 0);
      ifShow(this.showValue, this.valueGroup, function() {
        _this2.valueGroup.maybeAppendByClassName(CLASS_NAMES7.value, function() {
          return renderExtDo(value2);
        }).styles(style);
      });
    };
    CategoryItem2.prototype.createPoptip = function() {
      var poptip = this.attributes.poptip;
      var _a2 = poptip || {}, render3 = _a2.render, poptipStyle = __rest(_a2, ["render"]);
      var poptipGroup = new Poptip({ style: deepAssign2(DEFAULT_POPTIP_PROPS, poptipStyle) });
      this.poptipGroup = poptipGroup;
      return poptipGroup;
    };
    CategoryItem2.prototype.bindPoptip = function(node) {
      var _this2 = this;
      var poptip = this.attributes.poptip;
      if (!poptip)
        return;
      var poptipGroup = this.poptipGroup || this.createPoptip();
      poptipGroup.bind(node, function() {
        var _a2 = _this2.attributes, labelText = _a2.labelText, valueText = _a2.valueText, markerFill = _a2.markerFill;
        var label = typeof labelText === "string" ? labelText : labelText === null || labelText === void 0 ? void 0 : labelText.attr("text");
        var value2 = typeof valueText === "string" ? valueText : valueText === null || valueText === void 0 ? void 0 : valueText.attr("text");
        if (typeof poptip.render === "function") {
          return { html: poptip.render({ label, value: value2, color: markerFill }) };
        }
        var html = "";
        if (typeof label === "string" || typeof label === "number") {
          html += '<div class="component-poptip-label">'.concat(label, "</div>");
        }
        if (typeof value2 === "string" || typeof value2 === "number") {
          html += '<div class="component-poptip-value">'.concat(value2, "</div>");
        }
        return { html };
      });
    };
    CategoryItem2.prototype.renderPoptip = function(ctn) {
      var _this2 = this;
      var poptip = this.attributes.poptip;
      if (!poptip)
        return;
      var valueNode = ctn.maybeAppendByClassName(CLASS_NAMES7.value, "g").node();
      var labelNode = ctn.maybeAppendByClassName(CLASS_NAMES7.label, "g").node();
      [valueNode, labelNode].forEach(function(node) {
        if (node) {
          _this2.bindPoptip(node);
        }
      });
    };
    CategoryItem2.prototype.renderBackground = function(container) {
      var _a2 = this.shape, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "background");
      this.background = container.maybeAppendByClassName(CLASS_NAMES7.backgroundGroup, "g").style("zIndex", -1);
      this.background.maybeAppendByClassName(CLASS_NAMES7.background, "rect").styles(__assign({ width, height }, style));
    };
    CategoryItem2.prototype.adjustLayout = function() {
      var _a2 = this.layout, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, height = _a2.height, _b = __read(_a2.position, 3), markerX = _b[0], labelX = _b[1], valueX = _b[2];
      var halfHeight = height / 2;
      this.markerGroup.styles({
        transform: "translate(".concat(markerX, ", ").concat(halfHeight, ")").concat(this.markerGroup.node().style._transform)
      });
      this.labelGroup.styles({ transform: "translate(".concat(labelX, ", ").concat(halfHeight, ")") });
      ellipsisIt(this.labelGroup.select(CLASS_NAMES7.label.class).node(), Math.ceil(labelWidth));
      if (this.showValue) {
        this.valueGroup.styles({ transform: "translate(".concat(valueX, ", ").concat(halfHeight, ")") });
        ellipsisIt(this.valueGroup.select(CLASS_NAMES7.value.class).node(), Math.ceil(valueWidth));
      }
    };
    CategoryItem2.prototype.render = function(attributes, container) {
      var ctn = select2(container);
      var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y4 = _b === void 0 ? 0 : _b;
      ctn.styles({ transform: "translate(".concat(x3, ", ").concat(y4, ")") });
      this.renderMarker(ctn);
      this.renderLabel(ctn);
      this.renderValue(ctn);
      this.renderBackground(ctn);
      this.renderPoptip(ctn);
      this.adjustLayout();
    };
    return CategoryItem2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/category/items.js
var CLASS_NAMES8 = classNames({
  page: "item-page",
  navigator: "navigator",
  item: "item"
}, "items");
var ifSatisfied = function(value2, rule, defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = true;
  }
  if (value2) {
    return rule(value2);
  }
  return defaultValue;
};
var CategoryItems = (
  /** @class */
  function(_super) {
    __extends(CategoryItems2, _super);
    function CategoryItems2(options) {
      var _this2 = _super.call(this, options, {
        data: [],
        gridRow: Infinity,
        gridCol: void 0,
        padding: 0,
        width: 1e3,
        height: 100,
        rowPadding: 0,
        colPadding: 0,
        layout: "flex",
        orientation: "horizontal",
        click: noop_default,
        mouseenter: noop_default,
        mouseleave: noop_default
      }) || this;
      _this2.navigatorShape = [0, 0];
      return _this2;
    }
    Object.defineProperty(CategoryItems2.prototype, "pageViews", {
      get: function() {
        return this.navigator.getContainer();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "grid", {
      get: function() {
        var _a2 = this.attributes, gridRow = _a2.gridRow, gridCol = _a2.gridCol, data2 = _a2.data;
        if (!gridRow && !gridCol)
          throw new Error("gridRow and gridCol can not be set null at the same time");
        if (!!gridRow && !!gridCol)
          return [gridRow, gridCol];
        if (gridRow)
          return [gridRow, data2.length];
        return [data2.length, gridCol];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CategoryItems2.prototype, "renderData", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, layout = _a2.layout, poptip = _a2.poptip;
        var style = subStyleProps(this.attributes, "item");
        var d4 = data2.map(function(datum, index3) {
          var _a3 = datum.id, id4 = _a3 === void 0 ? index3 : _a3, labelText = datum.label, valueText = datum.value;
          return {
            id: "".concat(id4),
            index: index3,
            style: __assign({ layout, labelText, valueText, poptip }, Object.fromEntries(Object.entries(style).map(function(_a4) {
              var _b = __read(_a4, 2), key = _b[0], val = _b[1];
              return [key, getCallbackValue(val, [datum, index3, data2])];
            })))
          };
        });
        return d4;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.getGridLayout = function() {
      var _this2 = this;
      var _a2 = this.attributes, orientation = _a2.orientation, width = _a2.width, rowPadding = _a2.rowPadding, colPadding = _a2.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var pageSize = gridCol * gridRow;
      var prevOffset = 0;
      return this.pageViews.children.map(function(item, index3) {
        var _a3, _b2;
        var page = Math.floor(index3 / pageSize);
        var pageIndex = index3 % pageSize;
        var dir = _this2.ifHorizontal(gridCol, gridRow);
        var pos = [Math.floor(pageIndex / dir), pageIndex % dir];
        if (orientation === "vertical")
          pos.reverse();
        var _c2 = __read(pos, 2), row2 = _c2[0], col = _c2[1];
        var colWidth = (width - navWidth - (gridCol - 1) * colPadding) / gridCol;
        var rowHeight = item.getBBox().height;
        var _d = __read([0, 0], 2), x3 = _d[0], y4 = _d[1];
        if (orientation === "horizontal") {
          _a3 = __read([prevOffset, row2 * (rowHeight + rowPadding)], 2), x3 = _a3[0], y4 = _a3[1];
          prevOffset = col === gridCol - 1 ? 0 : prevOffset + colWidth + colPadding;
        } else {
          _b2 = __read([col * (colWidth + colPadding), prevOffset], 2), x3 = _b2[0], y4 = _b2[1];
          prevOffset = row2 === gridRow - 1 ? 0 : prevOffset + rowHeight + rowPadding;
        }
        return { page, index: index3, row: row2, col, pageIndex, width: colWidth, height: rowHeight, x: x3, y: y4 };
      });
    };
    CategoryItems2.prototype.getFlexLayout = function() {
      var _a2 = this.attributes, maxWidth = _a2.width, maxHeight = _a2.height, rowPadding = _a2.rowPadding, cP = _a2.colPadding;
      var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
      var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
      var _d = __read([maxWidth - navWidth, maxHeight], 2), limitWidth = _d[0], limitHeight = _d[1];
      var _e = __read([0, 0, 0, 0, 0, 0, 0, 0], 8), x3 = _e[0], y4 = _e[1], page = _e[2], pageIndex = _e[3], col = _e[4], row2 = _e[5], prevWidth = _e[6], prevHeight = _e[7];
      return this.pageViews.children.map(function(item, index3) {
        var _a3, _b2, _c2, _d2;
        var _e2 = item.getBBox(), width = _e2.width, height = _e2.height;
        var colPadding = prevWidth === 0 ? 0 : cP;
        var nextWidth = prevWidth + colPadding + width;
        if (nextWidth <= limitWidth && ifSatisfied(col, function(c6) {
          return c6 < gridCol;
        })) {
          _a3 = __read([prevWidth + colPadding, prevHeight, nextWidth], 3), x3 = _a3[0], y4 = _a3[1], prevWidth = _a3[2];
          return { width, height, x: x3, y: y4, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _b2 = __read([row2 + 1, 0, 0, prevHeight + height + rowPadding], 4), row2 = _b2[0], col = _b2[1], prevWidth = _b2[2], prevHeight = _b2[3];
        var nextHeight = prevHeight + height;
        if (nextHeight <= limitHeight && ifSatisfied(row2, function(r2) {
          return r2 < gridRow;
        })) {
          _c2 = __read([prevWidth, prevHeight, width], 3), x3 = _c2[0], y4 = _c2[1], prevWidth = _c2[2];
          return { width, height, x: x3, y: y4, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
        }
        _d2 = __read([0, 0, width, 0, page + 1, 0, 0, 0], 8), x3 = _d2[0], y4 = _d2[1], prevWidth = _d2[2], prevHeight = _d2[3], page = _d2[4], pageIndex = _d2[5], row2 = _d2[6], col = _d2[7];
        return { width, height, x: x3, y: y4, page, index: index3, pageIndex: pageIndex++, row: row2, col: col++ };
      });
    };
    Object.defineProperty(CategoryItems2.prototype, "itemsLayout", {
      get: function() {
        this.navigatorShape = [0, 0];
        var cb = this.attributes.layout === "grid" ? this.getGridLayout : this.getFlexLayout;
        var layout = cb.call(this);
        if (layout.slice(-1)[0].page > 0) {
          this.navigatorShape = [55, 0];
          return cb.call(this);
        }
        return layout;
      },
      enumerable: false,
      configurable: true
    });
    CategoryItems2.prototype.ifHorizontal = function(a5, b) {
      var orientation = this.attributes.orientation;
      return ifHorizontal(orientation, a5, b);
    };
    CategoryItems2.prototype.flattenPage = function(container) {
      container.querySelectorAll(CLASS_NAMES8.item.class).forEach(function(item) {
        container.appendChild(item);
      });
      container.querySelectorAll(CLASS_NAMES8.page.class).forEach(function(page) {
        var removedPage = container.removeChild(page);
        removedPage.destroy();
      });
    };
    CategoryItems2.prototype.renderItems = function(container) {
      var _a2 = this.attributes, click = _a2.click, mouseenter = _a2.mouseenter, mouseleave = _a2.mouseleave;
      this.flattenPage(container);
      var dispatchCustomEvent = this.dispatchCustomEvent.bind(this);
      select2(container).selectAll(CLASS_NAMES8.item.class).data(this.renderData, function(d4) {
        return d4.id;
      }).join(function(enter) {
        return enter.append(function(_a3) {
          var style = _a3.style;
          return new CategoryItem({ style });
        }).attr("className", CLASS_NAMES8.item.name).on("click", function() {
          click === null || click === void 0 ? void 0 : click(this);
          dispatchCustomEvent("itemClick", { item: this });
        }).on("pointerenter", function() {
          mouseenter === null || mouseenter === void 0 ? void 0 : mouseenter(this);
          dispatchCustomEvent("itemMouseenter", { item: this });
        }).on("pointerleave", function() {
          mouseleave === null || mouseleave === void 0 ? void 0 : mouseleave(this);
          dispatchCustomEvent("itemMouseleave", { item: this });
        });
      }, function(update2) {
        return update2.each(function(_a3) {
          var style = _a3.style;
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
    };
    CategoryItems2.prototype.relayoutNavigator = function() {
      var _a2;
      var _b = this.attributes, layout = _b.layout, width = _b.width;
      var height = ((_a2 = this.pageViews.children[0]) === null || _a2 === void 0 ? void 0 : _a2.getBBox().height) || 0;
      var _c = __read(this.navigatorShape, 2), navWidth = _c[0], navHeight = _c[1];
      this.navigator.update(layout === "grid" ? { pageWidth: width - navWidth, pageHeight: height - navHeight } : {});
    };
    CategoryItems2.prototype.adjustLayout = function() {
      var _this2 = this;
      var itemsLayouts = Object.entries(groupBy(this.itemsLayout, "page")).map(function(_a2) {
        var _b = __read(_a2, 2), page = _b[0], layouts = _b[1];
        return {
          page,
          layouts
        };
      });
      var categoryItems = __spreadArray([], __read(this.navigator.getContainer().children), false);
      itemsLayouts.forEach(function(_a2) {
        var layouts = _a2.layouts;
        var page = _this2.pageViews.appendChild(new Group2({ className: CLASS_NAMES8.page.name }));
        layouts.forEach(function(layout) {
          var x3 = layout.x, y4 = layout.y, index3 = layout.index, width = layout.width, height = layout.height;
          var item = categoryItems[index3];
          page.appendChild(item);
          set_default(item, "__layout__", layout);
          item.update({ x: x3, y: y4, width, height });
        });
      });
      this.relayoutNavigator();
    };
    CategoryItems2.prototype.renderNavigator = function(container) {
      var orientation = this.attributes.orientation;
      var navStyle = subStyleProps(this.attributes, "nav");
      var style = deepAssign2({ orientation }, navStyle);
      var that = this;
      container.selectAll(CLASS_NAMES8.navigator.class).data(["nav"]).join(function(enter) {
        return enter.append(function() {
          return new Navigator({ style });
        }).attr("className", CLASS_NAMES8.navigator.name).each(function() {
          that.navigator = this;
        });
      }, function(update2) {
        return update2.each(function() {
          this.update(style);
        });
      }, function(exit) {
        return exit.remove();
      });
      return this.navigator;
    };
    CategoryItems2.prototype.getBBox = function() {
      return this.navigator.getBBox();
    };
    CategoryItems2.prototype.render = function(attributes, container) {
      var data2 = this.attributes.data;
      if (!data2 || data2.length === 0)
        return;
      var navigator = this.renderNavigator(select2(container));
      this.renderItems(navigator.getContainer());
      this.adjustLayout();
    };
    CategoryItems2.prototype.dispatchCustomEvent = function(type, payload) {
      var evt = new CustomEvent(type, {
        detail: payload
      });
      this.dispatchEvent(evt);
    };
    return CategoryItems2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous/handle.js
var CLASS_NAMES9 = classNames({
  markerGroup: "marker-group",
  marker: "marker",
  labelGroup: "label-group",
  label: "label"
}, "handle");
var DEFAULT_HANDLE_CFG = {
  showLabel: true,
  formatter: function(val) {
    return val.toString();
  },
  markerSize: 25,
  markerStroke: "#c5c5c5",
  markerFill: "#fff",
  markerLineWidth: 1,
  labelFontSize: 12,
  labelFill: "#c5c5c5",
  labelText: "",
  orientation: "vertical",
  spacing: 0
};
var Handle2 = (
  /** @class */
  function(_super) {
    __extends(Handle3, _super);
    function Handle3(options) {
      return _super.call(this, options, DEFAULT_HANDLE_CFG) || this;
    }
    Handle3.prototype.render = function(attributes, container) {
      var markerGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.markerGroup, "g");
      this.renderMarker(markerGroup);
      var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.labelGroup, "g");
      this.renderLabel(labelGroup);
    };
    Handle3.prototype.renderMarker = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, orientation = _a2.orientation, _b = _a2.markerSymbol, markerSymbol = _b === void 0 ? ifHorizontal(orientation, "horizontalHandle", "verticalHandle") : _b;
      ifShow(!!markerSymbol, container, function(group3) {
        var handleStyle = subStyleProps(_this2.attributes, "marker");
        var markerStyle = __assign({ symbol: markerSymbol }, handleStyle);
        _this2.marker = group3.maybeAppendByClassName(CLASS_NAMES9.marker, function() {
          return new Marker({ style: markerStyle });
        }).update(markerStyle);
      });
    };
    Handle3.prototype.renderLabel = function(container) {
      var _this2 = this;
      var _a2 = this.attributes, showLabel = _a2.showLabel, orientation = _a2.orientation, _b = _a2.spacing, spacing = _b === void 0 ? 0 : _b, formatter2 = _a2.formatter;
      ifShow(showLabel, container, function(group3) {
        var _a3;
        var _b2 = subStyleProps(_this2.attributes, "label"), text = _b2.text, labelStyle = __rest(_b2, ["text"]);
        var _c = ((_a3 = group3.select(CLASS_NAMES9.marker.class)) === null || _a3 === void 0 ? void 0 : _a3.node().getBBox()) || {}, _d = _c.width, width = _d === void 0 ? 0 : _d, _e = _c.height, height = _e === void 0 ? 0 : _e;
        var _f = __read(ifHorizontal(orientation, [0, height + spacing, "center", "top"], [width + spacing, 0, "start", "middle"]), 4), x3 = _f[0], y4 = _f[1], textAlign = _f[2], textBaseline = _f[3];
        group3.maybeAppendByClassName(CLASS_NAMES9.label, "text").styles(__assign(__assign({}, labelStyle), { x: x3, y: y4, text: formatter2(text).toString(), textAlign, textBaseline }));
      });
    };
    return Handle3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/constant.js
var LEGEND_BASE_DEFAULT_OPTIONS = {
  showTitle: true,
  padding: 0,
  orientation: "horizontal",
  backgroundFill: "transparent",
  titleText: "",
  titleSpacing: 4,
  titlePosition: "top-left",
  titleFill: "#2C3542",
  titleFontWeight: "bold",
  titleFontFamily: "sans-serif",
  titleFontSize: 12
};
var CATEGORY_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, {});
var CONTINUOUS_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, superStyleProps(DEFAULT_HANDLE_CFG, "handle"), {
  color: [
    "#d0e3fa",
    "#acc7f6",
    "#8daaf2",
    "#6d8eea",
    "#4d73cd",
    "#325bb1",
    "#5a3e75",
    "#8c3c79",
    "#e23455",
    "#e7655b"
  ],
  indicatorBackgroundFill: "#262626",
  indicatorLabelFill: "white",
  indicatorLabelFontSize: 12,
  indicatorVisibility: "hidden",
  labelAlign: "value",
  labelDirection: "positive",
  labelSpacing: 5,
  showHandle: true,
  showIndicator: true,
  showLabel: true,
  slidable: true,
  titleText: "",
  type: "continuous"
});
var STEP_RATIO = 0.01;
var CLASS_NAMES10 = classNames({
  title: "title",
  titleGroup: "title-group",
  items: "items",
  itemsGroup: "items-group",
  contentGroup: "content-group",
  ribbonGroup: "ribbon-group",
  ribbon: "ribbon",
  handlesGroup: "handles-group",
  handle: "handle",
  startHandle: "start-handle",
  endHandle: "end-handle",
  labelGroup: "label-group",
  label: "label",
  indicator: "indicator"
}, "legend");

// node_modules/@antv/component/esm/ui/legend/category.js
var Category = (
  /** @class */
  function(_super) {
    __extends(Category2, _super);
    function Category2(options) {
      return _super.call(this, options, CATEGORY_DEFAULT_OPTIONS) || this;
    }
    Category2.prototype.renderTitle = function(container, width, height) {
      var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText;
      var style = subStyleProps(this.attributes, "title");
      var _b = __read(splitStyle(style), 2), titleStyle = _b[0], groupStyle = _b[1];
      this.titleGroup = container.maybeAppendByClassName(CLASS_NAMES10.titleGroup, "g").styles(groupStyle);
      var finalTitleStyle = __assign(__assign({ width, height }, titleStyle), { text: showTitle ? titleText : "" });
      this.title = this.titleGroup.maybeAppendByClassName(CLASS_NAMES10.title, function() {
        return new Title({ style: finalTitleStyle });
      }).update(finalTitleStyle);
    };
    Category2.prototype.renderItems = function(container, bbox) {
      var x3 = bbox.x, y4 = bbox.y, width = bbox.width, height = bbox.height;
      var style = subStyleProps(this.attributes, "title", true);
      var _a2 = __read(splitStyle(style), 2), partialItemStyle = _a2[0], groupStyle = _a2[1];
      var itemStyle = __assign(__assign({}, partialItemStyle), { width, height, x: 0, y: 0 });
      this.itemsGroup = container.maybeAppendByClassName(CLASS_NAMES10.itemsGroup, "g").styles(__assign(__assign({}, groupStyle), { transform: "translate(".concat(x3, ", ").concat(y4, ")") }));
      var that = this;
      this.itemsGroup.selectAll(CLASS_NAMES10.items.class).data(["items"]).join(function(enter) {
        return enter.append(function() {
          return new CategoryItems({ style: itemStyle });
        }).attr("className", CLASS_NAMES10.items.name).each(function() {
          that.items = select2(this);
        });
      }, function(update2) {
        return update2.update(itemStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Category2.prototype.adjustLayout = function() {
      var showTitle = this.attributes.showTitle;
      if (showTitle) {
        var _a2 = this.title.node().getAvailableSpace(), x3 = _a2.x, y4 = _a2.y;
        this.itemsGroup.node().style.transform = "translate(".concat(x3, ", ").concat(y4, ")");
      }
    };
    Object.defineProperty(Category2.prototype, "availableSpace", {
      get: function() {
        var _a2 = this.attributes, showTitle = _a2.showTitle, width = _a2.width, height = _a2.height;
        if (!showTitle)
          return new BBox(0, 0, width, height);
        return this.title.node().getAvailableSpace();
      },
      enumerable: false,
      configurable: true
    });
    Category2.prototype.getBBox = function() {
      var _a2, _b;
      var title = (_a2 = this.title) === null || _a2 === void 0 ? void 0 : _a2.node();
      var items = (_b = this.items) === null || _b === void 0 ? void 0 : _b.node();
      if (!title || !items)
        return _super.prototype.getBBox.call(this);
      return getBBox(title, items);
    };
    Category2.prototype.render = function(attributes, container) {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y4 = _c === void 0 ? 0 : _c;
      var ctn = select2(container);
      container.style.transform = "translate(".concat(x3, ", ").concat(y4, ")");
      this.renderTitle(ctn, width, height);
      this.renderItems(ctn, this.availableSpace);
      this.adjustLayout();
    };
    return Category2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/indicator/constant.js
var DEFAULT_INDICATOR_STYLE_PROPS = {
  backgroundFill: "#262626",
  backgroundLineCap: "round",
  backgroundLineWidth: 1,
  backgroundStroke: "#333",
  backgroundZIndex: -1,
  formatter: function(val) {
    return val.toString();
  },
  labelFill: "#fff",
  labelFontSize: 12,
  labelTextBaseline: "middle",
  padding: [2, 4],
  position: "right",
  radius: 0,
  zIndex: 999
};

// node_modules/@antv/component/esm/ui/indicator/indicator.js
var CLASS_NAMES11 = classNames({
  background: "background",
  labelGroup: "label-group",
  label: "label"
}, "indicator");
var Indicator = (
  /** @class */
  function(_super) {
    __extends(Indicator2, _super);
    function Indicator2(options) {
      var _this2 = _super.call(this, options, DEFAULT_INDICATOR_STYLE_PROPS) || this;
      _this2.point = [0, 0];
      _this2.group = _this2.appendChild(new Group2({}));
      _this2.isMutationObserved = true;
      return _this2;
    }
    Indicator2.prototype.renderBackground = function() {
      if (!this.label)
        return;
      var _a2 = this.attributes, position = _a2.position, padding = _a2.padding;
      var _b = __read(parseSeriesAttr(padding), 4), t = _b[0], r2 = _b[1], b = _b[2], l2 = _b[3];
      var _c = this.label.node().getLocalBounds(), min10 = _c.min, max11 = _c.max;
      var bbox = new BBox(min10[0] - l2, min10[1] - t, max11[0] + r2 - min10[0] + l2, max11[1] + b - min10[1] + t);
      var path2 = this.getPath(position, bbox);
      var style = subStyleProps(this.attributes, "background");
      this.background = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.background, "path").styles(__assign(__assign({}, style), { d: path2 }));
      this.group.appendChild(this.label.node());
    };
    Indicator2.prototype.renderLabel = function() {
      var _a2 = this.attributes, formatter2 = _a2.formatter, labelText = _a2.labelText;
      var style = subStyleProps(this.attributes, "label");
      var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], rawText = _c.text, textStyle = __rest(_c, ["text"]);
      this.label = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.labelGroup, "g").styles(groupStyle);
      if (!labelText)
        return;
      var text = this.label.maybeAppendByClassName(CLASS_NAMES11.label, function() {
        return renderExtDo(formatter2(labelText));
      }).style("text", formatter2(labelText).toString());
      text.selectAll("text").styles(textStyle);
    };
    Indicator2.prototype.adjustLayout = function() {
      var _a2 = __read(this.point, 2), dx = _a2[0], dy = _a2[1];
      var _b = this.attributes, x3 = _b.x, y4 = _b.y;
      this.group.attr("transform", "translate(".concat(x3 - dx, ", ").concat(y4 - dy, ")"));
    };
    Indicator2.prototype.getPath = function(position, bbox) {
      var r2 = this.attributes.radius;
      var x3 = bbox.x, y4 = bbox.y, width = bbox.width, height = bbox.height;
      var pathArray = [
        // 0 
        ["M", x3 + r2, y4],
        // 1 
        ["L", x3 + width - r2, y4],
        // 2 
        ["A", r2, r2, 0, 0, 1, x3 + width, y4 + r2],
        // 3 
        ["L", x3 + width, y4 + height - r2],
        // 4 
        ["A", r2, r2, 0, 0, 1, x3 + width - r2, y4 + height],
        // 5 
        ["L", x3 + r2, y4 + height],
        // 6 
        ["A", r2, r2, 0, 0, 1, x3, y4 + height - r2],
        // 7 
        ["L", x3, y4 + r2],
        // 8 
        ["A", r2, r2, 0, 0, 1, x3 + r2, y4],
        // 9 
        ["Z"]
      ];
      var revertPositionMap = { top: 4, right: 6, bottom: 0, left: 2 };
      var index3 = revertPositionMap[position];
      var newPath = this.createCorner([pathArray[index3].slice(-2), pathArray[index3 + 1].slice(-2)]);
      pathArray.splice.apply(pathArray, __spreadArray([index3 + 1, 1], __read(newPath), false));
      pathArray[0][0] = "M";
      return pathArray;
    };
    Indicator2.prototype.createCorner = function(edge, size3) {
      if (size3 === void 0) {
        size3 = 10;
      }
      var cornerScale = 0.8;
      var isH = isHorizontal.apply(void 0, __spreadArray([], __read(edge), false));
      var _a2 = __read(edge, 2), _b = __read(_a2[0], 2), x05 = _b[0], y05 = _b[1], _c = __read(_a2[1], 2), x12 = _c[0], y12 = _c[1];
      var _d = __read(isH ? [x12 - x05, [x05, x12]] : [y12 - y05, [y05, y12]], 2), len5 = _d[0], _e = __read(_d[1], 2), b0 = _e[0], b1 = _e[1];
      var hL = len5 / 2;
      var sign3 = len5 / Math.abs(len5);
      var cL = size3 * sign3;
      var hCL = cL / 2;
      var cS = cL * Math.sqrt(3) / 2 * cornerScale;
      var _f = __read([b0, b0 + hL - hCL, b0 + hL, b0 + hL + hCL, b1], 5), a0 = _f[0], a1 = _f[1], a22 = _f[2], a32 = _f[3], a42 = _f[4];
      if (isH) {
        this.point = [a22, y05 - cS];
        return [
          ["L", a0, y05],
          ["L", a1, y05],
          ["L", a22, y05 - cS],
          ["L", a32, y05],
          ["L", a42, y05]
        ];
      }
      this.point = [x05 + cS, a22];
      return [
        ["L", x05, a0],
        ["L", x05, a1],
        ["L", x05 + cS, a22],
        ["L", x05, a32],
        ["L", x05, a42]
      ];
    };
    Indicator2.prototype.applyVisibility = function() {
      var visibility2 = this.attributes.visibility;
      if (visibility2 === "hidden")
        hide(this);
      else
        show(this);
    };
    Indicator2.prototype.bindEvents = function() {
      this.label.on(ElementEvent.BOUNDS_CHANGED, this.renderBackground);
    };
    Indicator2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
      this.adjustLayout();
      this.applyVisibility();
    };
    return Indicator2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous/utils.js
function search(array2, value2) {
  for (var i2 = 1; i2 < array2.length; i2 += 1) {
    var st = array2[i2 - 1];
    var end = array2[i2];
    if (value2 >= st && value2 <= end) {
      return [st, end];
    }
  }
  return [value2, value2];
}
function getBlockColor(partition2, color3, orientation) {
  var colors = Array.from(color3);
  var count4 = partition2.length;
  return new Array(count4).fill(0).reduce(function(r2, v, idx) {
    var c6 = colors[idx % colors.length];
    return r2 += " ".concat(partition2[idx], ":").concat(c6).concat(idx < count4 - 1 ? " ".concat(partition2[idx + 1], ":").concat(c6) : "");
  }, "l(".concat(orientation === "horizontal" ? "0" : "270", ")"));
}
function getNextTickValue(ticks2, value2) {
  var _a2 = __read(search(ticks2, value2), 2), v1 = _a2[0], v2 = _a2[1];
  return { tick: value2 > (v1 + v2) / 2 ? v2 : v1, range: [v1, v2] };
}

// node_modules/@antv/component/esm/ui/legend/continuous/ribbon.js
var CLASS_NAMES12 = classNames({
  trackGroup: "background-group",
  track: "background",
  selectionGroup: "ribbon-group",
  selection: "ribbon",
  clipPath: "clip-path"
}, "ribbon");
function getShape(attr2) {
  var orientation = attr2.orientation, size3 = attr2.size, length5 = attr2.length;
  return ifHorizontal(orientation, [length5, size3], [size3, length5]);
}
function getTrackPath(attr2) {
  var type = attr2.type;
  var _a2 = __read(getShape(attr2), 2), cw2 = _a2[0], ch2 = _a2[1];
  if (type === "size") {
    return [["M", 0, ch2], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
  }
  return [["M", 0, ch2], ["L", 0, 0], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
}
function getSelectionPath(attr2) {
  return getTrackPath(attr2);
}
function getColor(attr2) {
  var orientation = attr2.orientation, color3 = attr2.color, block = attr2.block, partition2 = attr2.partition;
  var colors;
  if (isFunction(color3)) {
    var len5 = 20;
    colors = new Array(len5).fill(0).map(function(_2, index3, arr) {
      return color3(index3 / (arr.length - 1));
    });
  } else
    colors = color3;
  var count4 = colors.length;
  var genericColor = colors.map(function(c6) {
    return parseColor(c6).toString();
  });
  if (!count4)
    return "";
  if (count4 === 1)
    return genericColor[0];
  if (block)
    return getBlockColor(partition2, genericColor, orientation);
  return genericColor.reduce(function(r2, c6, idx) {
    return r2 += " ".concat(idx / (count4 - 1), ":").concat(c6);
  }, "l(".concat(ifHorizontal(orientation, "0", "270"), ")"));
}
function getClipPath(attr2) {
  var orientation = attr2.orientation, range3 = attr2.range;
  if (!range3)
    return [];
  var _a2 = __read(getShape(attr2), 2), width = _a2[0], height = _a2[1];
  var _b = __read(range3, 2), st = _b[0], et = _b[1];
  var x3 = ifHorizontal(orientation, st * width, 0);
  var y4 = ifHorizontal(orientation, 0, st * height);
  var w2 = ifHorizontal(orientation, et * width, width);
  var h2 = ifHorizontal(orientation, height, et * height);
  return [["M", x3, y4], ["L", x3, h2], ["L", w2, h2], ["L", w2, y4], ["Z"]];
}
function renderTrack(container, attr2) {
  var style = subStyleProps(attr2, "track");
  container.maybeAppendByClassName(CLASS_NAMES12.track, "path").styles(__assign({ d: getTrackPath(attr2) }, style));
}
function renderSelection(container, attr2) {
  var style = subStyleProps(attr2, "selection");
  var fill = getColor(attr2);
  var ribbon = container.maybeAppendByClassName(CLASS_NAMES12.selection, "path").styles(__assign({ d: getSelectionPath(attr2), fill }, style));
  var clipPath = ribbon.maybeAppendByClassName(CLASS_NAMES12.clipPath, "path").styles({ d: getClipPath(attr2) }).node();
  ribbon.style("clipPath", clipPath);
}
var Ribbon = (
  /** @class */
  function(_super) {
    __extends(Ribbon3, _super);
    function Ribbon3(options) {
      return _super.call(this, options, {
        type: "color",
        orientation: "horizontal",
        size: 30,
        range: [0, 1],
        length: 200,
        block: false,
        partition: [],
        color: ["#fff", "#000"],
        trackFill: "#e5e5e5"
      }) || this;
    }
    Ribbon3.prototype.render = function(attribute, container) {
      var trackGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.trackGroup, "g");
      renderTrack(trackGroup, attribute);
      var ribbonGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.selectionGroup, "g");
      renderSelection(ribbonGroup, attribute);
    };
    return Ribbon3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/legend/continuous.js
function getMinMax(data2) {
  return {
    min: Math.min.apply(Math, __spreadArray([], __read(data2.map(function(d4) {
      return d4.value;
    })), false)),
    max: Math.max.apply(Math, __spreadArray([], __read(data2.map(function(d4) {
      return d4.value;
    })), false))
  };
}
var Continuous2 = (
  /** @class */
  function(_super) {
    __extends(Continuous3, _super);
    function Continuous3(options) {
      var _this2 = _super.call(this, options, CONTINUOUS_DEFAULT_OPTIONS) || this;
      _this2.eventToOffsetScale = new Linear({});
      _this2.innerRibbonScale = new Linear({});
      _this2.cacheLabelBBox = null;
      _this2.cacheHandleBBox = null;
      _this2.onHovering = function(e3) {
        var _a2 = _this2.attributes, data2 = _a2.data, block = _a2.block;
        e3.stopPropagation();
        var value2 = _this2.getValueByCanvasPoint(e3);
        if (block) {
          var range3 = getNextTickValue(data2.map(function(_a3) {
            var value3 = _a3.value;
            return value3;
          }), value2).range;
          var selection = _this2.getRealSelection(range3);
          _this2.showIndicator((range3[0] + range3[1]) / 2, "".concat(selection[0], "-").concat(selection[1]));
          _this2.dispatchIndicated(value2, range3);
        } else {
          var safetyValue = _this2.getTickValue(value2);
          _this2.showIndicator(safetyValue, "".concat(_this2.getRealValue(safetyValue)));
          _this2.dispatchIndicated(safetyValue);
        }
      };
      _this2.onDragStart = function(target) {
        return function(e3) {
          e3.stopPropagation();
          if (!_this2.attributes.slidable)
            return;
          _this2.target = target;
          _this2.prevValue = _this2.getTickValue(_this2.getValueByCanvasPoint(e3));
          document.addEventListener("mousemove", _this2.onDragging);
          document.addEventListener("touchmove", _this2.onDragging);
          document.addEventListener("mouseleave", _this2.onDragEnd);
          document.addEventListener("mouseup", _this2.onDragEnd);
          document.addEventListener("mouseup", _this2.onDragEnd);
          document.addEventListener("touchend", _this2.onDragEnd);
        };
      };
      _this2.onDragging = function(e3) {
        var target = _this2.target;
        _this2.updateMouse();
        var _a2 = __read(_this2.selection, 2), start = _a2[0], end = _a2[1];
        var currValue = _this2.getTickValue(_this2.getValueByCanvasPoint(e3));
        var diffValue = currValue - _this2.prevValue;
        if (target === "start")
          start !== currValue && _this2.updateSelection(currValue, end);
        else if (target === "end")
          end !== currValue && _this2.updateSelection(start, currValue);
        else if (target === "ribbon" && diffValue !== 0) {
          _this2.prevValue = currValue;
          _this2.updateSelection(diffValue, diffValue, true);
        }
      };
      _this2.onDragEnd = function() {
        _this2.style.cursor = "pointer";
        document.removeEventListener("mousemove", _this2.onDragging);
        document.removeEventListener("touchmove", _this2.onDragging);
        document.removeEventListener("mouseup", _this2.onDragEnd);
        document.removeEventListener("touchend", _this2.onDragEnd);
      };
      return _this2;
    }
    Object.defineProperty(Continuous3.prototype, "handleOffsetRatio", {
      get: function() {
        return this.ifHorizontal(0.5, 0.5);
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.getBBox = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      return new BBox(0, 0, width, height);
    };
    Continuous3.prototype.render = function(attributes, container) {
      var _this2 = this;
      var showLabel = attributes.showLabel;
      this.renderTitle(select2(container));
      var _a2 = this.availableSpace, x3 = _a2.x, y4 = _a2.y;
      var contentGroup = select2(container).maybeAppendByClassName(CLASS_NAMES10.contentGroup, "g").styles({ transform: "translate(".concat(x3, ", ").concat(y4, ")") });
      var labelGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.labelGroup, "g").styles({ zIndex: 1 });
      ifShow(!!showLabel, labelGroup, function(group3) {
        _this2.renderLabel(group3);
      });
      var ribbonGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.ribbonGroup, "g").styles({ zIndex: 0 });
      this.handlesGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.handlesGroup, "g").styles({ zIndex: 2 });
      this.renderHandles();
      this.renderRibbon(ribbonGroup);
      this.renderIndicator(contentGroup);
      this.adjustLabel();
      this.adjustHandles();
    };
    Object.defineProperty(Continuous3.prototype, "range", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, domain = _a2.domain;
        return domain ? { min: domain[0], max: domain[1] } : getMinMax(data2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonScale", {
      get: function() {
        var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
        this.innerRibbonScale.update({
          domain: [min10, max11],
          range: [0, 1]
        });
        return this.innerRibbonScale;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonRange", {
      get: function() {
        var _a2 = __read(this.selection, 2), min10 = _a2[0], max11 = _a2[1];
        var scale12 = this.ribbonScale;
        return [scale12.map(min10), scale12.map(max11)];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "selection", {
      get: function() {
        var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
        var _b = this.attributes.defaultValue, _c = _b === void 0 ? [min10, max11] : _b, _d = __read(_c, 2), start = _d[0], end = _d[1];
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.ifHorizontal = function(a5, b) {
      return ifHorizontal(this.attributes.orientation, typeof a5 === "function" ? a5() : a5, typeof b === "function" ? b() : b);
    };
    Continuous3.prototype.renderTitle = function(container) {
      var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "title");
      var finalTitleStyle = __assign(__assign({}, style), { width, height, text: titleText });
      var that = this;
      container.selectAll(CLASS_NAMES10.title.class).data(showTitle ? [titleText] : []).join(function(enter) {
        return enter.append(function() {
          return new Title({ style: finalTitleStyle });
        }).attr("className", CLASS_NAMES10.title.name).each(function() {
          that.title = this;
        });
      }, function(update2) {
        return update2.update(finalTitleStyle);
      }, function(exit) {
        return exit.each(function() {
          that.title = void 0;
        }).remove();
      });
    };
    Object.defineProperty(Continuous3.prototype, "availableSpace", {
      get: function() {
        if (this.title)
          return this.title.getAvailableSpace();
        var _a2 = this.attributes, width = _a2.width, height = _a2.height;
        return new BBox(0, 0, width, height);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelFixedSpacing", {
      get: function() {
        var showTick = this.attributes.showTick;
        return showTick ? 5 : 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelPosition", {
      get: function() {
        var _a2 = this.attributes, orientation = _a2.orientation, labelDirection = _a2.labelDirection;
        var positions = {
          vertical: { positive: "right", negative: "left" },
          horizontal: { positive: "bottom", negative: "top" }
        };
        return positions[orientation][labelDirection];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelBBox", {
      get: function() {
        var _a2;
        var showLabel = this.attributes.showLabel;
        if (!showLabel)
          return new BBox(0, 0, 0, 0);
        if (this.cacheLabelBBox)
          return this.cacheLabelBBox;
        var _b = ((_a2 = this.label.querySelector(CLASS_NAMES3.labelGroup.class)) === null || _a2 === void 0 ? void 0 : _a2.children.slice(-1)[0]).getBBox(), width = _b.width, height = _b.height;
        this.cacheLabelBBox = new BBox(0, 0, width, height);
        return this.cacheLabelBBox;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelShape", {
      get: function() {
        var _a2 = this.attributes, showLabel = _a2.showLabel, _b = _a2.labelSpacing, labelSpacing = _b === void 0 ? 0 : _b;
        if (!showLabel)
          return { width: 0, height: 0, size: 0, length: 0 };
        var _c = this.labelBBox, width = _c.width, height = _c.height;
        var size3 = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;
        var length5 = this.ifHorizontal(width, height);
        return { width, height, size: size3, length: length5 };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonBBox", {
      get: function() {
        var _a2 = this.attributes, showHandle = _a2.showHandle, userDefinedRibbonSize = _a2.ribbonSize;
        var _b = this.availableSpace, availableWidth = _b.width, availableHeight = _b.height;
        var _c = this.labelShape, labelSize = _c.size, labelLength = _c.length;
        var _d = __read(this.ifHorizontal([availableHeight, availableWidth], [availableWidth, availableHeight]), 2), availableSize = _d[0], availableLength = _d[1];
        var _e = showHandle ? this.handleShape : { size: 0, length: 0 }, handleSize = _e.size, handleLength = _e.length;
        var handleRatio = this.handleOffsetRatio;
        var ribbonSize = 0;
        var labelPosition = this.labelPosition;
        if (userDefinedRibbonSize) {
          ribbonSize = userDefinedRibbonSize;
        } else if (["bottom", "right"].includes(labelPosition)) {
          ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);
        } else if (availableSize * (1 - handleRatio) > handleSize) {
          ribbonSize = Math.max(availableSize - labelSize, 0);
        } else
          ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);
        var edgeLength = Math.max(handleLength, labelLength);
        var ribbonLength = availableLength - edgeLength;
        var _f = __read(this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]), 2), width = _f[0], height = _f[1];
        var finalLabelOccupy = ["top", "left"].includes(labelPosition) ? labelSize : 0;
        var _g = __read(this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]), 2), x3 = _g[0], y4 = _g[1];
        return new BBox(x3, y4, width, height);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "ribbonShape", {
      get: function() {
        var _a2 = this.ribbonBBox, width = _a2.width, height = _a2.height;
        return this.ifHorizontal({ size: height, length: width }, { size: width, length: height });
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.renderRibbon = function(container) {
      var _a2 = this.attributes, data2 = _a2.data, type = _a2.type, orientation = _a2.orientation, color3 = _a2.color, block = _a2.block;
      var ribbonStyle = subStyleProps(this.attributes, "ribbon");
      var _b = this.range, min10 = _b.min, max11 = _b.max;
      var _c = this.ribbonBBox, x3 = _c.x, y4 = _c.y;
      var _d = this.ribbonShape, length5 = _d.length, size3 = _d.size;
      var style = deepAssign2({
        transform: "translate(".concat(x3, ", ").concat(y4, ")"),
        length: length5,
        size: size3,
        type,
        orientation,
        color: color3,
        block,
        partition: data2.map(function(d4) {
          return (d4.value - min10) / (max11 - min10);
        }),
        range: this.ribbonRange
      }, ribbonStyle);
      this.ribbon = container.maybeAppendByClassName(CLASS_NAMES10.ribbon, function() {
        return new Ribbon({ style });
      }).update(style);
    };
    Continuous3.prototype.getHandleClassName = function(type) {
      return "".concat(CLASS_NAMES10.prefix("".concat(type, "-handle")));
    };
    Continuous3.prototype.renderHandles = function() {
      var _a2 = this.attributes, showHandle = _a2.showHandle, orientation = _a2.orientation;
      var handleStyle = subStyleProps(this.attributes, "handle");
      var _b = __read(this.selection, 2), min10 = _b[0], max11 = _b[1];
      var style = __assign(__assign({}, handleStyle), { orientation });
      var _c = handleStyle.shape, shape23 = _c === void 0 ? "slider" : _c;
      var HandleCtor = shape23 === "basic" ? Handle2 : Handle;
      var that = this;
      this.handlesGroup.selectAll(CLASS_NAMES10.handle.class).data(showHandle ? [
        { value: min10, type: "start" },
        { value: max11, type: "end" }
      ] : [], function(d4) {
        return d4.type;
      }).join(function(enter) {
        return enter.append(function() {
          return new HandleCtor({ style });
        }).attr("className", function(_a3) {
          var type = _a3.type;
          return "".concat(CLASS_NAMES10.handle, " ").concat(that.getHandleClassName(type));
        }).each(function(_a3) {
          var type = _a3.type, labelText = _a3.value;
          this.update({ labelText });
          var name2 = "".concat(type, "Handle");
          that[name2] = this;
          this.addEventListener("pointerdown", that.onDragStart(type));
        });
      }, function(update2) {
        return update2.update(style).each(function(_a3) {
          var labelText = _a3.value;
          this.update({ labelText });
        });
      }, function(exit) {
        return exit.each(function(_a3) {
          var type = _a3.type;
          var name2 = "".concat(type, "Handle");
          that[name2] = void 0;
        }).remove();
      });
    };
    Continuous3.prototype.adjustHandles = function() {
      var _a2 = __read(this.selection, 2), min10 = _a2[0], max11 = _a2[1];
      this.setHandlePosition("start", min10);
      this.setHandlePosition("end", max11);
    };
    Object.defineProperty(Continuous3.prototype, "handleBBox", {
      get: function() {
        if (this.cacheHandleBBox)
          return this.cacheHandleBBox;
        if (!this.attributes.showHandle)
          return new BBox(0, 0, 0, 0);
        var _a2 = this.startHandle.getBBox(), startHandleWidth = _a2.width, startHandleHeight = _a2.height;
        var _b = this.endHandle.getBBox(), endHandleWidth = _b.width, endHandleHeight = _b.height;
        var _c = __read([Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)], 2), width = _c[0], height = _c[1];
        this.cacheHandleBBox = new BBox(0, 0, width, height);
        return this.cacheHandleBBox;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "handleShape", {
      /**
       *   handle label  handle bbox  bbox
       */
      get: function() {
        var _a2 = this.handleBBox, width = _a2.width, height = _a2.height;
        var _b = __read(this.ifHorizontal([height, width], [width, height]), 2), size3 = _b[0], length5 = _b[1];
        return { width, height, size: size3, length: length5 };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.setHandlePosition = function(type, value2) {
      var handleFormatter = this.attributes.handleFormatter;
      var _a2 = this.ribbonBBox, ribbonX = _a2.x, ribbonY = _a2.y;
      var ribbonSize = this.ribbonShape.size;
      var offset2 = this.getOffset(value2);
      var _b = __read(this.ifHorizontal([ribbonX + offset2, ribbonY + ribbonSize * this.handleOffsetRatio], [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset2]), 2), x3 = _b[0], y4 = _b[1];
      var handle = this.handlesGroup.select(".".concat(this.getHandleClassName(type))).node();
      handle === null || handle === void 0 ? void 0 : handle.update({ transform: "translate(".concat(x3, ", ").concat(y4, ")"), formatter: handleFormatter });
    };
    Continuous3.prototype.renderIndicator = function(container) {
      var style = subStyleProps(this.attributes, "indicator");
      this.indicator = container.maybeAppendByClassName(CLASS_NAMES10.indicator, function() {
        return new Indicator({});
      }).update(style);
    };
    Object.defineProperty(Continuous3.prototype, "labelData", {
      get: function() {
        var _this2 = this;
        var data2 = this.attributes.data;
        return data2.reduce(function(acc, curr, index3, arr) {
          var _a2, _b;
          var id4 = (_a2 = curr === null || curr === void 0 ? void 0 : curr.id) !== null && _a2 !== void 0 ? _a2 : index3.toString();
          acc.push(__assign(__assign({}, curr), { id: id4, index: index3, type: "value", label: (_b = curr === null || curr === void 0 ? void 0 : curr.label) !== null && _b !== void 0 ? _b : curr.value.toString(), value: _this2.ribbonScale.map(curr.value) }));
          if (index3 < arr.length - 1) {
            var next = arr[index3 + 1];
            var _c = __read([curr.value, next.value], 2), cr = _c[0], nx = _c[1];
            var midVal = (cr + nx) / 2;
            acc.push(__assign(__assign({}, curr), { id: id4, index: index3, type: "range", range: [cr, nx], label: [cr, nx].join("~"), value: _this2.ribbonScale.map(midVal) }));
          }
          return acc;
        }, []);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Continuous3.prototype, "labelStyle", {
      get: function() {
        var _a2 = __read(["center", "middle"], 2), labelTextAlign = _a2[0], labelTextBaseline = _a2[1];
        var labelPosition = this.labelPosition;
        if (labelPosition === "top")
          labelTextBaseline = "bottom";
        else if (labelPosition === "bottom")
          labelTextBaseline = "top";
        else if (labelPosition === "left")
          labelTextAlign = "end";
        else if (labelPosition === "right")
          labelTextAlign = "start";
        return {
          labelTextAlign,
          labelTextBaseline
        };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.renderLabel = function(container) {
      var _a2 = this.attributes, _b = _a2.showTick, showTick = _b === void 0 ? false : _b, labelFilter = _a2.labelFilter, labelFormatter2 = _a2.labelFormatter;
      var tickStyle = subStyleProps(this.attributes, "tick");
      var labelStyle = subStyleProps(this.attributes, "label");
      var align = labelStyle.align;
      var style = deepAssign2(__assign({ showLine: false, showGrid: false, showTick, type: "linear", startPos: [0, 0], endPos: [0, 0], tickDirection: "negative", labelTransform: "rotate(0)" }, this.labelStyle), superStyleProps(tickStyle, "tick"), superStyleProps(labelStyle, "label"), { data: this.labelData });
      var functionStyle = {
        tickFilter: function(datum, index3, data2) {
          if ((datum === null || datum === void 0 ? void 0 : datum.type) !== "value")
            return false;
          if (labelFilter)
            return labelFilter(datum, datum.index, data2.filter(function(d4) {
              return d4.type !== "value";
            }));
          return true;
        },
        labelFilter: function(datum, index3, data2) {
          if ((datum === null || datum === void 0 ? void 0 : datum.type) !== align)
            return false;
          if (labelFilter)
            return labelFilter(datum, datum.index, data2.filter(function(d4) {
              return d4.type === align;
            }));
          return true;
        },
        labelFormatter: labelFormatter2
      };
      var finalLabelStyle = __assign(__assign(__assign({}, style), functionStyle), { labelOverlap: [{ type: "hide" }] });
      this.label = container.maybeAppendByClassName(CLASS_NAMES10.label, function() {
        return new Axis({ style: finalLabelStyle });
      }).node();
      this.label.update(finalLabelStyle, false);
    };
    Object.defineProperty(Continuous3.prototype, "labelAxisStyle", {
      get: function() {
        var _a2 = this.attributes, showTick = _a2.showTick, labelDirection = _a2.labelDirection, labelSpacing = _a2.labelSpacing, definedTickLength = _a2.tickLength;
        var ribbonSize = this.ribbonShape.size;
        var labelPosition = this.labelPosition;
        var labelFixedSpacing = this.labelFixedSpacing;
        var _b = __read([0, 0, 0], 3), offset2 = _b[0], spacing = _b[1], tickLength = _b[2];
        var internalVal = definedTickLength !== null && definedTickLength !== void 0 ? definedTickLength : ribbonSize;
        if (showTick) {
          tickLength = internalVal;
          spacing = labelFixedSpacing;
          if (labelDirection === "positive") {
            if (labelPosition === "right") {
              offset2 = internalVal;
              tickLength = internalVal;
            } else if (labelPosition === "bottom")
              offset2 = tickLength;
          } else if (labelDirection === "negative") {
            if (labelPosition === "top")
              offset2 = ribbonSize;
            else if (labelPosition === "left")
              offset2 = ribbonSize;
          }
        } else if (labelDirection === "positive") {
          if (labelPosition === "right")
            spacing = internalVal;
          else if (labelPosition === "bottom") {
            offset2 = ribbonSize + labelFixedSpacing;
            spacing = labelSpacing;
          }
        } else if (labelDirection === "negative") {
          if (labelPosition === "left")
            spacing = labelSpacing;
          else if (labelPosition === "top")
            spacing = labelSpacing;
        }
        return { offset: offset2, spacing, tickLength };
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.adjustLabel = function() {
      var showLabel = this.attributes.showLabel;
      if (!showLabel)
        return;
      var _a2 = this.ribbonBBox, x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
      var _b = this.labelAxisStyle, axisOffset = _b.offset, axisSpacing = _b.spacing, axisTickLength = _b.tickLength;
      var _c = __read(this.ifHorizontal([
        [x3, y4 + axisOffset],
        [x3 + width, y4 + axisOffset]
      ], [
        [x3 + axisOffset, y4 + height],
        [x3 + axisOffset, y4]
      ]), 2), startPos = _c[0], endPos = _c[1];
      this.label.update({
        startPos,
        endPos,
        tickLength: axisTickLength,
        labelSpacing: axisSpacing
      }, false);
    };
    Continuous3.prototype.bindEvents = function() {
      this.style.cursor = "pointer";
      this.ribbon.on("pointerdown", this.onDragStart("ribbon"));
      this.ribbon.on("pointermove", this.onHovering);
      this.addEventListener("pointerout", this.hideIndicator);
    };
    Continuous3.prototype.showIndicator = function(value2, text) {
      if (text === void 0) {
        text = "".concat(value2);
      }
      var showIndicator = this.attributes.showIndicator;
      if (!showIndicator || typeof value2 !== "number") {
        this.hideIndicator();
        return;
      }
      var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
      var _b = this.ribbonBBox, x3 = _b.x, y4 = _b.y;
      var safeValue = clamp_default(value2, min10, max11);
      var offset2 = this.getOffset(safeValue);
      var pos = this.ifHorizontal([offset2 + x3, y4], [x3, offset2 + y4]);
      this.indicator.update({
        x: pos[0],
        y: pos[1],
        position: this.ifHorizontal("top", "left"),
        labelText: text
      });
      show(this.indicator.node());
    };
    Continuous3.prototype.hideIndicator = function() {
      hide(this.indicator.node());
    };
    Continuous3.prototype.updateMouse = function() {
      if (this.attributes.slidable)
        this.style.cursor = "grabbing";
    };
    Continuous3.prototype.setSelection = function(start, end) {
      this.updateSelection(start, end);
    };
    Continuous3.prototype.updateSelection = function(stVal, endVal, isOffset) {
      var _a2;
      if (isOffset === void 0) {
        isOffset = false;
      }
      var _b = __read(this.selection, 2), currSt = _b[0], currEnd = _b[1];
      var _c = __read([stVal, endVal], 2), start = _c[0], end = _c[1];
      if (isOffset) {
        start += currSt;
        end += currEnd;
      }
      var _d = this.range, min10 = _d.min, max11 = _d.max;
      _a2 = __read(getSafetySelections([min10, max11], [start, end], this.selection), 2), start = _a2[0], end = _a2[1];
      this.update({ defaultValue: [start, end] });
      this.dispatchSelection();
    };
    Object.defineProperty(Continuous3.prototype, "step", {
      get: function() {
        var _a2 = this.attributes.step, step2 = _a2 === void 0 ? 1 : _a2;
        var _b = this.range, min10 = _b.min, max11 = _b.max;
        if (is_undefined_default(step2))
          return toPrecision((max11 - min10) * STEP_RATIO, 0);
        return step2;
      },
      enumerable: false,
      configurable: true
    });
    Continuous3.prototype.getTickValue = function(value2) {
      var _a2 = this.attributes, data2 = _a2.data, block = _a2.block;
      var min10 = this.range.min;
      if (block)
        return getNextTickValue(data2.map(function(_a3) {
          var value3 = _a3.value;
          return value3;
        }), value2).tick;
      return getStepValueByValue(value2, this.step, min10);
    };
    Continuous3.prototype.getValueByCanvasPoint = function(e3) {
      var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
      var _b = __read(this.ribbon.node().getPosition(), 2), x3 = _b[0], y4 = _b[1];
      var startPos = this.ifHorizontal(x3, y4);
      var currValue = this.ifHorizontal.apply(this, __spreadArray([], __read(getEventPos(e3)), false));
      var offset2 = currValue - startPos;
      var value2 = clamp_default(this.getOffset(offset2, true), min10, max11);
      return value2;
    };
    Continuous3.prototype.getOffset = function(value2, reverse2) {
      if (reverse2 === void 0) {
        reverse2 = false;
      }
      var _a2 = this.range, min10 = _a2.min, max11 = _a2.max;
      var ribbonLen = this.ribbonShape.length;
      var scale12 = this.eventToOffsetScale;
      scale12.update({ domain: [min10, max11], range: [0, ribbonLen] });
      if (reverse2)
        return scale12.invert(value2);
      return scale12.map(value2);
    };
    Continuous3.prototype.getRealSelection = function(range3) {
      var max11 = this.range.max;
      var _a2 = __read(range3, 2), start = _a2[0], end = _a2[1];
      return this.ifHorizontal([start, end], [max11 - end, max11 - start]);
    };
    Continuous3.prototype.getRealValue = function(value2) {
      var max11 = this.range.max;
      return this.ifHorizontal(value2, max11 - value2);
    };
    Continuous3.prototype.dispatchSelection = function() {
      var selection = this.getRealSelection(this.selection);
      var evt = new CustomEvent("valuechange", {
        detail: {
          value: selection
        }
      });
      this.dispatchEvent(evt);
    };
    Continuous3.prototype.dispatchIndicated = function(value2, range3) {
      var _this2 = this;
      var max11 = this.range.max;
      var detail = this.ifHorizontal(function() {
        return {
          value: value2,
          range: range3
        };
      }, function() {
        return {
          value: max11 - value2,
          range: range3 ? _this2.getRealSelection(range3) : void 0
        };
      });
      var evt = new CustomEvent("indicate", {
        detail
      });
      this.dispatchEvent(evt);
    };
    return Continuous3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/tooltip/constant.js
function getClassNames(prefixCls) {
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  return {
    CONTAINER: "".concat(prefixCls, "tooltip"),
    TITLE: "".concat(prefixCls, "tooltip-title"),
    LIST: "".concat(prefixCls, "tooltip-list"),
    LIST_ITEM: "".concat(prefixCls, "tooltip-list-item"),
    NAME: "".concat(prefixCls, "tooltip-list-item-name"),
    MARKER: "".concat(prefixCls, "tooltip-list-item-marker"),
    NAME_LABEL: "".concat(prefixCls, "tooltip-list-item-name-label"),
    VALUE: "".concat(prefixCls, "tooltip-list-item-value"),
    CROSSHAIR_X: "".concat(prefixCls, "tooltip-crosshair-x"),
    CROSSHAIR_Y: "".concat(prefixCls, "tooltip-crosshair-y")
  };
}
var TEXT_OVERFLOW_STYLE = {
  overflow: "hidden",
  "white-space": "nowrap",
  "text-overflow": "ellipsis"
};
function getDefaultTooltipStyle(prefixCls) {
  var _a2;
  if (prefixCls === void 0) {
    prefixCls = "";
  }
  var CLASS_NAME2 = getClassNames(prefixCls);
  return _a2 = {}, _a2[".".concat(CLASS_NAME2.CONTAINER)] = {
    position: "absolute",
    visibility: "visible",
    // 'white-space': 'nowrap',
    "z-index": 8,
    transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
    "background-color": "rgba(255, 255, 255, 0.96)",
    "box-shadow": "0 6px 12px 0 rgba(0, 0, 0, 0.12)",
    "border-radius": "4px",
    color: "rgba(0, 0, 0, 0.65)",
    "font-size": "12px",
    // 'font-family': ,
    "line-height": "20px",
    padding: "12px",
    "min-width": "120px",
    "max-width": "360px",
    "font-family": "Roboto-Regular"
  }, _a2[".".concat(CLASS_NAME2.TITLE)] = {
    color: "rgba(0, 0, 0, 0.45)"
  }, _a2[".".concat(CLASS_NAME2.LIST)] = {
    margin: "0px",
    "list-style-type": "none",
    padding: "0px"
  }, _a2[".".concat(CLASS_NAME2.LIST_ITEM)] = {
    "list-style-type": "none",
    display: "flex",
    "line-height": "2em",
    "align-items": "center",
    "justify-content": "space-between",
    "white-space": "nowrap"
  }, _a2[".".concat(CLASS_NAME2.MARKER)] = {
    width: "8px",
    height: "8px",
    "border-radius": "50%",
    display: "inline-block",
    "margin-right": "4px"
  }, _a2[".".concat(CLASS_NAME2.NAME)] = {
    display: "flex",
    "align-items": "center",
    "max-width": "216px"
  }, _a2[".".concat(CLASS_NAME2.NAME_LABEL)] = __assign({ flex: 1 }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.VALUE)] = __assign({ display: "inline-block", float: "right", flex: 1, "text-align": "right", "min-width": "28px", "margin-left": "30px", color: "rgba(0, 0, 0, 0.85)" }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.CROSSHAIR_X)] = {
    position: "absolute",
    width: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a2[".".concat(CLASS_NAME2.CROSSHAIR_Y)] = {
    position: "absolute",
    height: "1px",
    "background-color": "rgba(0, 0, 0, 0.25)"
  }, _a2;
}

// node_modules/@antv/component/esm/ui/tooltip/index.js
var Tooltip = (
  /** @class */
  function(_super) {
    __extends(Tooltip3, _super);
    function Tooltip3(options) {
      var _this2 = this;
      var _a2, _b;
      var prefixCls = (_b = (_a2 = options.style) === null || _a2 === void 0 ? void 0 : _a2.template) === null || _b === void 0 ? void 0 : _b.prefixCls;
      var CLASS_NAME2 = getClassNames(prefixCls);
      _this2 = _super.call(this, options, {
        data: [],
        x: 0,
        y: 0,
        visibility: "visible",
        title: "",
        position: "bottom-right",
        offset: [5, 5],
        enterable: false,
        container: {
          x: 0,
          y: 0
        },
        bounding: null,
        template: {
          prefixCls: "",
          container: '<div class="'.concat(CLASS_NAME2.CONTAINER, '"></div>'),
          title: '<div class="'.concat(CLASS_NAME2.TITLE, '"></div>'),
          item: '<li class="'.concat(CLASS_NAME2.LIST_ITEM, '" data-index={index}>\n        <span class="').concat(CLASS_NAME2.NAME, '">\n          <span class="').concat(CLASS_NAME2.MARKER, '" style="background:{color}"></span>\n          <span class="').concat(CLASS_NAME2.NAME_LABEL, '" title="{name}">{name}</span>\n        </span>\n        <span class="').concat(CLASS_NAME2.VALUE, '" title="{value}">{value}</span>\n      </li>')
        },
        style: getDefaultTooltipStyle(prefixCls)
      }) || this;
      _this2.timestamp = -1;
      _this2.prevCustomContentKey = _this2.attributes.contentKey;
      _this2.initShape();
      _this2.render(_this2.attributes, _this2);
      return _this2;
    }
    Object.defineProperty(Tooltip3.prototype, "HTMLTooltipElement", {
      get: function() {
        return this.element;
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.getContainer = function() {
      return this.element;
    };
    Object.defineProperty(Tooltip3.prototype, "elementSize", {
      get: function() {
        var width = this.element.offsetWidth;
        var height = this.element.offsetHeight;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Tooltip3.prototype, "HTMLTooltipItemsElements", {
      get: function() {
        var _a2 = this.attributes, data2 = _a2.data, template = _a2.template;
        return data2.map(function(_a3, idx) {
          var _b = _a3.name, name2 = _b === void 0 ? "" : _b, _c = _a3.color, color3 = _c === void 0 ? "black" : _c, index3 = _a3.index, rest = __rest(_a3, ["name", "color", "index"]);
          var datum = __assign({ name: name2, color: color3, index: index3 !== null && index3 !== void 0 ? index3 : idx }, rest);
          return createDOM(substitute_default(template.item, datum));
        });
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.render = function(attributes, container) {
      this.renderHTMLTooltipElement();
      this.updatePosition();
    };
    Tooltip3.prototype.destroy = function() {
      var _a2;
      (_a2 = this.element) === null || _a2 === void 0 ? void 0 : _a2.remove();
      _super.prototype.destroy.call(this);
    };
    Tooltip3.prototype.show = function(x3, y4) {
      var _this2 = this;
      if (x3 !== void 0 && y4 !== void 0) {
        var isToggle = this.element.style.visibility === "hidden";
        var setPosition = function() {
          _this2.attributes.x = x3 !== null && x3 !== void 0 ? x3 : _this2.attributes.x;
          _this2.attributes.y = y4 !== null && y4 !== void 0 ? y4 : _this2.attributes.y;
          _this2.updatePosition();
        };
        isToggle ? this.closeTransition(setPosition) : setPosition();
      }
      this.element.style.visibility = "visible";
    };
    Tooltip3.prototype.hide = function(x3, y4) {
      if (x3 === void 0) {
        x3 = 0;
      }
      if (y4 === void 0) {
        y4 = 0;
      }
      var enterable = this.attributes.enterable;
      if (enterable && this.isCursorEntered(x3, y4))
        return;
      this.element.style.visibility = "hidden";
    };
    Tooltip3.prototype.initShape = function() {
      var template = this.attributes.template;
      this.element = createDOM(template.container);
      if (this.id)
        this.element.setAttribute("id", this.id);
    };
    Tooltip3.prototype.renderCustomContent = function() {
      if (this.prevCustomContentKey !== void 0 && this.prevCustomContentKey === this.attributes.contentKey)
        return;
      this.prevCustomContentKey = this.attributes.contentKey;
      var content = this.attributes.content;
      if (!content)
        return;
      if (typeof content === "string")
        this.element.innerHTML = content;
      else
        replaceChildren(this.element, content);
    };
    Tooltip3.prototype.renderHTMLTooltipElement = function() {
      var _a2, _b;
      var _c = this.attributes, template = _c.template, title = _c.title, enterable = _c.enterable, style = _c.style, content = _c.content;
      var CLASS_NAME2 = getClassNames(template.prefixCls);
      var container = this.element;
      this.element.style.pointerEvents = enterable ? "auto" : "none";
      if (content)
        this.renderCustomContent();
      else {
        if (title) {
          container.innerHTML = template.title;
          container.getElementsByClassName(CLASS_NAME2.TITLE)[0].innerHTML = title;
        } else
          (_b = (_a2 = container.getElementsByClassName(CLASS_NAME2.TITLE)) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.remove();
        var itemsElements = this.HTMLTooltipItemsElements;
        var ul = document.createElement("ul");
        ul.className = CLASS_NAME2.LIST;
        replaceChildren(ul, itemsElements);
        var list = this.element.querySelector(".".concat(CLASS_NAME2.LIST));
        if (list)
          list.replaceWith(ul);
        else
          container.appendChild(ul);
      }
      applyStyleSheet(container, style);
    };
    Tooltip3.prototype.getRelativeOffsetFromCursor = function(assignPosition) {
      var _a2 = this.attributes, position = _a2.position, offset2 = _a2.offset;
      var interPosition = assignPosition || position;
      var finalPosition = interPosition.split("-");
      var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
      var _b = this.elementSize, width = _b.width, height = _b.height;
      var absolutelyOffset = [-width / 2, -height / 2];
      finalPosition.forEach(function(pos) {
        var _a3 = __read(absolutelyOffset, 2), abs1 = _a3[0], abs22 = _a3[1];
        var _b2 = __read(positionScore[pos], 2), pos1 = _b2[0], pos2 = _b2[1];
        absolutelyOffset = [abs1 + (width / 2 + offset2[0]) * pos1, abs22 + (height / 2 + offset2[1]) * pos2];
      });
      return absolutelyOffset;
    };
    Tooltip3.prototype.setOffsetPosition = function(_a2) {
      var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, _d = _c.x, x3 = _d === void 0 ? 0 : _d, _e = _c.y, y4 = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
      this.element.style.left = "".concat(+x3 + cx + offsetX, "px");
      this.element.style.top = "".concat(+y4 + cy + offsetY, "px");
    };
    Tooltip3.prototype.updatePosition = function() {
      var _a2 = this.attributes.showDelay, showDelay = _a2 === void 0 ? 60 : _a2;
      var currentTimestamp = Date.now();
      if (this.timestamp > 0 && currentTimestamp - this.timestamp < showDelay)
        return;
      this.timestamp = currentTimestamp;
      this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
    };
    Tooltip3.prototype.autoPosition = function(_a2) {
      var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
      var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, bounding = _c.bounding, position = _c.position;
      if (!bounding)
        return [offsetX, offsetY];
      var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
      var _e = __read([+cursorX + offsetX, +cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
      var inversion = {
        left: "right",
        right: "left",
        top: "bottom",
        bottom: "top"
      };
      var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
      var edgeCompare = {
        left: expectLeft < boundingX,
        right: expectLeft + offsetWidth > boundingX + boundingWidth,
        top: expectTop < boundingY,
        bottom: expectTop + offsetHeight > boundingY + boundingHeight
      };
      var correctivePosition = [];
      position.split("-").forEach(function(pos) {
        if (edgeCompare[pos])
          correctivePosition.push(inversion[pos]);
        else
          correctivePosition.push(pos);
      });
      var correctedPositionString = correctivePosition.join("-");
      return this.getRelativeOffsetFromCursor(correctedPositionString);
    };
    Tooltip3.prototype.isCursorEntered = function(clientX, clientY) {
      if (this.element) {
        var _a2 = this.element.getBoundingClientRect(), x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
        return new BBox(x3, y4, width, height).isPointIn(clientX, clientY);
      }
      return false;
    };
    Tooltip3.prototype.closeTransition = function(callback) {
      var _this2 = this;
      var transition2 = this.element.style.transition;
      this.element.style.transition = "none";
      callback();
      setTimeout(function() {
        _this2.element.style.transition = transition2;
      }, 10);
    };
    Tooltip3.tag = "tooltip";
    return Tooltip3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/switch/constant.js
var SIZE_STYLE2 = {
  default: {
    sizeStyle: {
      width: 44,
      height: 22,
      radius: 11
    },
    tagStyle: {
      textStyle: {
        fontSize: 12,
        lineHeight: 16,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 11
    }
  },
  small: {
    sizeStyle: {
      width: 28,
      height: 16,
      radius: 8
    },
    tagStyle: {
      textStyle: {
        fontSize: 10,
        lineHeight: 14,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 8
    }
  },
  mini: {
    sizeStyle: {
      width: 20,
      height: 14,
      radius: 7
    },
    tagStyle: {
      textStyle: {
        fontSize: 7,
        lineHeight: 10,
        fill: "#fff"
      },
      padding: 0
    },
    markerStyle: {
      size: 7
    }
  }
};

// node_modules/@antv/component/esm/ui/switch/index.js
var OPTION_COLOR = "#1890FF";
var CLOSE_COLOR = "#00000040";
function getHandleShapeStyle(shape23, spacing, checked) {
  if (spacing === void 0) {
    spacing = 0;
  }
  if (checked === void 0) {
    checked = true;
  }
  var size3 = Number(shape23.style.height) - spacing * 2;
  return {
    x: checked ? Number(shape23.style.width) + Number(shape23.style.x) - spacing - size3 : Number(shape23.style.x) + spacing,
    y: Number(shape23.style.y) + spacing,
    width: size3,
    height: size3,
    radius: size3 / 2
  };
}
function getTagShapeStyle(backgroundStyle, _a2, spacing, checked) {
  var width = _a2.width, height = _a2.height;
  if (spacing === void 0) {
    spacing = 0;
  }
  if (checked === void 0) {
    checked = true;
  }
  return {
    x: checked ? Number(backgroundStyle.x) + spacing : Number(backgroundStyle.width) + Number(backgroundStyle.x) - width,
    y: Number(backgroundStyle.y) + (Number(backgroundStyle.height) - height) / 2
  };
}
var Switch = (
  /** @class */
  function(_super) {
    __extends(Switch2, _super);
    function Switch2(options) {
      return _super.call(this, options, {
        x: 0,
        y: 0,
        size: "default",
        spacing: 2,
        checked: true,
        disabled: false
      }) || this;
    }
    Switch2.prototype.render = function(attributes, container) {
      var _this2 = this;
      var size3 = attributes.size, spacing = attributes.spacing, disabled = attributes.disabled, checked = attributes.checked, unCheckedChildren = attributes.unCheckedChildren, checkedChildren = attributes.checkedChildren;
      var group3 = select2(container).maybeAppendByClassName("switch-content", "g").node();
      var bounds = group3.getLocalBounds();
      var _a2 = get_default(SIZE_STYLE2, size3, SIZE_STYLE2.default), sizeStyle = _a2.sizeStyle, tagStyle = _a2.tagStyle;
      var cursor = disabled ? "no-drop" : "pointer";
      var color3 = checked ? OPTION_COLOR : CLOSE_COLOR;
      var backgroundStyle = sizeStyle;
      var tagCfg = checked ? checkedChildren : unCheckedChildren;
      if (checkedChildren || unCheckedChildren) {
        select2(group3).maybeAppendByClassName("switch-tag", function() {
          return new Tag({});
        }).call(function(selection) {
          var tagShape = selection.node();
          tagShape.update(__assign(__assign({ cursor, backgroundStyle: null, text: false, marker: false }, tagStyle), tagCfg));
          var _a3 = (tagShape === null || tagShape === void 0 ? void 0 : tagShape.getLocalBounds()) || {}, max11 = _a3.max, min10 = _a3.min;
          var width = max11[0] - min10[0] + sizeStyle.radius;
          var height = max11[1] - min10[1];
          var backgroundWidth = Math.max(width + sizeStyle.height + 2, sizeStyle.width);
          backgroundStyle = __assign(__assign({}, sizeStyle), { width: backgroundWidth });
          tagShape.update(getTagShapeStyle({
            x: bounds.min[0],
            y: bounds.min[1],
            width: backgroundWidth,
            height: backgroundStyle.height
          }, { width, height }, backgroundStyle.radius, checked));
        });
      }
      var backgroundShape = select2(group3).maybeAppendByClassName("switch-background", "rect").styles(__assign({ zIndex: (group3.style.zIndex || 0) - 1, x: bounds.min[0], y: bounds.min[1], fill: color3, cursor, fillOpacity: disabled ? 0.4 : 1 }, backgroundStyle)).node();
      var backgroundStrokeShape = select2(group3).maybeAppendByClassName("switch-background-stroke", "rect").styles(__assign({ zIndex: (group3.style.zIndex || 0) - 2, x: bounds.min[0], y: bounds.min[1], stroke: color3, lineWidth: 0 }, backgroundStyle)).node();
      select2(group3).maybeAppendByClassName("switch-handle", "rect").styles({
        fill: "#fff",
        cursor
      }).call(function(selection) {
        var _a3, _b;
        var handleShape = selection.node();
        var newHandleShapeStyle = getHandleShapeStyle(backgroundShape, spacing, checked);
        var oldHandleShapeStyle = getHandleShapeStyle(backgroundShape, spacing, !checked);
        if (handleShape.attr("x") && !is_equal_default(newHandleShapeStyle, oldHandleShapeStyle) && _this2.checked !== checked) {
          handleShape.attr(oldHandleShapeStyle);
          (_a3 = handleShape.getAnimations()[0]) === null || _a3 === void 0 ? void 0 : _a3.cancel();
          (_b = backgroundStrokeShape.getAnimations()[0]) === null || _b === void 0 ? void 0 : _b.cancel();
          handleShape.animate([{ x: oldHandleShapeStyle.x }, { x: newHandleShapeStyle.x }], {
            duration: 120,
            fill: "both"
          });
          backgroundStrokeShape.animate([
            { lineWidth: 0, strokeOpacity: 0.5 },
            { lineWidth: 14, strokeOpacity: 0 }
          ], {
            duration: 400,
            easing: "ease-on"
          });
        } else {
          handleShape.attr(newHandleShapeStyle);
        }
      });
      this.checked = !!checked;
    };
    Switch2.tag = "switch";
    return Switch2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/crosshair/constant.js
var CROSSHAIR_BASE_DEFAULT_STYLE = {
  tagText: "",
  lineStroke: "#416180",
  lineStrokeOpacity: 0.45,
  lineLineWidth: 1,
  lineLineDash: [5, 5]
};
var LINE_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "line",
  tagPosition: "start",
  tagAlign: "center",
  tagVerticalAlign: "bottom"
});
var CIRCLE_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "circle",
  defaultRadius: 0
});
var POLYGON_CROSSHAIR_DEFAULT_STYLE = deepAssign2({}, CROSSHAIR_BASE_DEFAULT_STYLE, {
  type: "polygon",
  defaultRadius: 0,
  startAngle: 0
});

// node_modules/@antv/component/esm/ui/crosshair/base.js
var CrosshairBase = (
  /** @class */
  function(_super) {
    __extends(CrosshairBase2, _super);
    function CrosshairBase2(options) {
      return _super.call(this, options, CROSSHAIR_BASE_DEFAULT_STYLE) || this;
    }
    Object.defineProperty(CrosshairBase2.prototype, "localPointer", {
      /**
       *  pointer 
       */
      get: function() {
        var _a2 = __read(this.getPosition(), 2), bx = _a2[0], by = _a2[1];
        var _b = __read(this.pointer, 2), x3 = _b[0], y4 = _b[1];
        return [x3 - bx, y4 - by];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CrosshairBase2.prototype, "tagStyle", {
      get: function() {
        var style = subStyleProps(this.attributes, "tag");
        return style;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CrosshairBase2.prototype, "crosshairStyle", {
      get: function() {
        var style = subStyleProps(this.attributes, "line");
        return __assign(__assign({}, style), { d: this.crosshairPath });
      },
      enumerable: false,
      configurable: true
    });
    CrosshairBase2.prototype.render = function(attributes, container) {
      var group3 = select2(container).maybeAppendByClassName(".crosshair-group", "g").node();
      this.shapesGroup = group3;
      var tagStyle = this.tagStyle;
      var crosshairStyle = this.crosshairStyle;
      this.tagShape = select2(group3).maybeAppendByClassName("crosshair-tag", function() {
        return new Tag({ style: tagStyle });
      }).styles(tagStyle).node();
      this.crosshairShape = select2(group3).maybeAppendByClassName(".crosshair-path", "path").styles(crosshairStyle).node();
      this.adjustLayout();
    };
    CrosshairBase2.prototype.setPointer = function(pointer) {
      this.pointer = pointer;
    };
    CrosshairBase2.tag = "crosshair-base";
    return CrosshairBase2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/crosshair/line.js
var LineCrosshair = (
  /** @class */
  function(_super) {
    __extends(LineCrosshair2, _super);
    function LineCrosshair2(options) {
      return _super.call(this, deepAssign2({}, LineCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(LineCrosshair2.prototype, "crosshairPath", {
      get: function() {
        var _a2 = this.attributes, _b = __read(_a2.startPos, 2), sx = _b[0], sy = _b[1], _c = __read(_a2.endPos, 2), ex = _c[0], ey = _c[1];
        var path2 = [["M", 0, 0], ["L", ex - sx, ey - sy], ["Z"]];
        return path2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "localPointer", {
      /**
       *  pointer 
       */
      get: function() {
        if (!this.pointer)
          return this.attributes.startPos;
        var _a2 = __read(this.getPosition(), 2), bx = _a2[0], by = _a2[1];
        var _b = __read(this.pointer, 2), x3 = _b[0], y4 = _b[1];
        return [x3 - bx, y4 - by];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "isVertical", {
      get: function() {
        var _a2 = this.attributes, _b = __read(_a2.startPos, 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2.endPos, 2), x22 = _c[0], y22 = _c[1];
        return x12 === x22 && y12 !== y22;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LineCrosshair2.prototype, "tagShapeSpace", {
      get: function() {
        var _a2 = getShapeSpace(this.tagShape), width = _a2.width, height = _a2.height;
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    LineCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    LineCrosshair2.prototype.setPointer = function(pointer) {
      _super.prototype.setPointer.call(this, pointer);
      this.adjustPosition();
    };
    LineCrosshair2.prototype.setText = function(text) {
      this.tagShape.update({ text });
      this.adjustTag();
    };
    LineCrosshair2.prototype.adjustLayout = function() {
      this.adjustPosition();
      this.adjustTag();
    };
    LineCrosshair2.prototype.adjustPosition = function() {
      var _a2 = __read(this.localPointer, 2), lx = _a2[0], ly = _a2[1];
      var _b = __read(this.attributes.startPos, 2), sx = _b[0], sy = _b[1];
      var targetPos = this.getOrientVal([sx, ly], [lx, sy]);
      this.shapesGroup.setLocalPosition(targetPos);
    };
    LineCrosshair2.prototype.adjustTag = function() {
      var _a2 = this.attributes, tagText = _a2.tagText, tagPosition = _a2.tagPosition, _b = __read(_a2.startPos, 2), x12 = _b[0], y12 = _b[1], _c = __read(_a2.endPos, 2), x22 = _c[0], y22 = _c[1];
      if (!tagText || tagText === "") {
        hide(this.tagShape);
        return;
      }
      show(this.tagShape);
      var _d = this.tagShapeSpace, width = _d.width, height = _d.height;
      var _e = __read(this.getOrientVal({
        start: [-width / 2, height / 2],
        end: [x22 - x12 + width / 2, height / 2]
      }, {
        start: [0, 0],
        end: [0, y22 - y12 + height]
      })[tagPosition], 2), xOffset = _e[0], yOffset = _e[1];
      this.tagShape.setLocalPosition(xOffset, yOffset);
    };
    LineCrosshair2.prototype.getOrientVal = function(v1, v2) {
      return this.isVertical ? v2 : v1;
    };
    LineCrosshair2.tag = "line-crosshair";
    LineCrosshair2.defaultOptions = {
      style: LINE_CROSSHAIR_DEFAULT_STYLE
    };
    return LineCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/crosshair/circle.js
var CircleCrosshair = (
  /** @class */
  function(_super) {
    __extends(CircleCrosshair2, _super);
    function CircleCrosshair2(options) {
      return _super.call(this, deepAssign2({}, CircleCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(CircleCrosshair2.prototype, "crosshairPath", {
      get: function() {
        return this.createCirclePath();
      },
      enumerable: false,
      configurable: true
    });
    CircleCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    CircleCrosshair2.prototype.setPointer = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y4 = _b[1];
      _super.prototype.setPointer.call(this, [x3, y4]);
      var _c = __read(this.localPointer, 2), lx = _c[0], ly = _c[1];
      var _d = __read(this.attributes.center, 2), cx = _d[0], cy = _d[1];
      var path2 = this.createCirclePath(Math.pow(Math.pow(lx - cx, 2) + Math.pow(ly - cy, 2), 0.5));
      this.crosshairShape.attr({ d: path2 });
    };
    CircleCrosshair2.prototype.adjustLayout = function() {
      hide(this.tagShape);
    };
    CircleCrosshair2.prototype.createCirclePath = function(radius) {
      var _a2 = this.attributes, _b = __read(_a2.center, 2), x3 = _b[0], y4 = _b[1], defaultRadius2 = _a2.defaultRadius;
      return circle(x3, y4, radius || defaultRadius2);
    };
    CircleCrosshair2.tag = "circle-crosshair";
    CircleCrosshair2.defaultOptions = {
      style: CIRCLE_CROSSHAIR_DEFAULT_STYLE
    };
    return CircleCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/crosshair/polygon.js
var PolygonCrosshair = (
  /** @class */
  function(_super) {
    __extends(PolygonCrosshair2, _super);
    function PolygonCrosshair2(options) {
      return _super.call(this, deepAssign2({}, PolygonCrosshair2.defaultOptions, options)) || this;
    }
    Object.defineProperty(PolygonCrosshair2.prototype, "crosshairPath", {
      get: function() {
        return this.createPolygonPath();
      },
      enumerable: false,
      configurable: true
    });
    PolygonCrosshair2.prototype.update = function(cfg) {
      _super.prototype.update.call(this, cfg);
    };
    Object.defineProperty(PolygonCrosshair2.prototype, "points", {
      /**
       * 
       */
      get: function() {
        var _a2 = this.attributes, startAngle = _a2.startAngle, sides = _a2.sides;
        var a5 = Math.PI * 2 / sides;
        var unit = [1, 0];
        var points = [];
        for (var i2 = 0; i2 < sides; i2 += 1) {
          points.push(rotate5(unit, [0, 0], startAngle / 180 * Math.PI + a5 * i2));
        }
        return points;
      },
      enumerable: false,
      configurable: true
    });
    PolygonCrosshair2.prototype.setPointer = function(_a2) {
      var _b = __read(_a2, 2), x3 = _b[0], y4 = _b[1];
      _super.prototype.setPointer.call(this, [x3, y4]);
      var _c = __read(this.localPointer, 2), lx = _c[0], ly = _c[1];
      var center2 = this.attributes.center;
      var _d = __read(this.intersection([lx, ly]), 2), ix = _d[0], iy = _d[1];
      if (!ix || !iy)
        return;
      var equivalentRadius = lineLen(center2, [lx, ly]) / lineLen(center2, [ix, iy]);
      var path2 = this.createPolygonPath(equivalentRadius);
      this.crosshairShape.attr({ d: path2 });
    };
    PolygonCrosshair2.prototype.adjustLayout = function() {
      hide(this.tagShape);
    };
    PolygonCrosshair2.prototype.createPolygonPath = function(radius) {
      var _a2 = this.attributes, defaultRadius2 = _a2.defaultRadius, _b = __read(_a2.center, 2), cx = _b[0], cy = _b[1];
      var path2 = this.points.map(function(_a3, index3) {
        var _b2 = __read(_a3, 2), x3 = _b2[0], y4 = _b2[1];
        var _c = __read(scale8([x3, y4], radius || defaultRadius2), 2), tx = _c[0], ty = _c[1];
        return [index3 === 0 ? "M" : "L", cx + tx, cy + ty];
      });
      path2.push(["Z"]);
      return path2;
    };
    PolygonCrosshair2.prototype.intersection = function(_a2) {
      var _b;
      var _c = __read(_a2, 2), x3 = _c[0], y4 = _c[1];
      var points = this.points;
      var _d = __read(this.attributes.center, 2), cx = _d[0], cy = _d[1];
      var ix;
      var iy;
      for (var i2 = 1; i2 <= points.length; i2 += 1) {
        var _e = __read(points[i2 - 1], 2), sx = _e[0], sy = _e[1];
        var _f = __read(points[i2 % points.length], 2), ex = _f[0], ey = _f[1];
        var inter = intersection2([x3, y4], [cx, cy], [sx + cx, sy + cy], [ex + cx, ey + cy]);
        if (inter.length !== 0) {
          _b = __read(inter, 2), ix = _b[0], iy = _b[1];
        }
      }
      return [ix, iy];
    };
    PolygonCrosshair2.tag = "polygon-crosshair";
    PolygonCrosshair2.defaultOptions = {
      style: POLYGON_CROSSHAIR_DEFAULT_STYLE
    };
    return PolygonCrosshair2;
  }(CrosshairBase)
);

// node_modules/@antv/component/esm/ui/checkbox/constant.js
var LABEL_TEXT_STYLE = superStyleProps({
  fill: "rgba(0,0,0,0.45)",
  fontSize: 10,
  textAlign: "start",
  textBaseline: "middle",
  overflow: "clip"
}, "label");
var CHECKBOX_RECT_STYLE = {
  default: {
    width: 12,
    height: 12,
    radius: 2,
    stroke: "#dadada",
    lineWidth: 1,
    fill: "#ffffff",
    cursor: "pointer"
  },
  selected: {
    width: 12,
    height: 12,
    radius: 2,
    stroke: "#3471F9",
    lineWidth: 1,
    fill: "#3471F9",
    cursor: "pointer"
  }
};
var CHECKED_SHAPE_PATH = [
  ["M", 3, 6],
  ["L", "5", "8.5"],
  ["L", "8.5", "4"]
];
var CHECKED_SHAPE_STYLE = {
  d: CHECKED_SHAPE_PATH,
  lineWidth: 1,
  cursor: "pointer"
};

// node_modules/@antv/component/esm/ui/checkbox/index.js
function getLablePosition(shape23, spacing) {
  var bounds = shape23.getLocalBounds();
  return {
    x: bounds.halfExtents[0] ? bounds.max[0] + (spacing || 0) : shape23.style.x,
    y: bounds.halfExtents[1] ? (bounds.min[1] + bounds.max[1]) / 2 : shape23.style.y
  };
}
var Checkbox = (
  /** @class */
  function(_super) {
    __extends(Checkbox2, _super);
    function Checkbox2(options) {
      return _super.call(this, options, __assign({ labelText: "", spacing: 4, checked: false }, LABEL_TEXT_STYLE)) || this;
    }
    Checkbox2.prototype.render = function(attributes, container) {
      var checked = attributes.checked, spacing = attributes.spacing;
      this.checked = !!checked;
      var group3 = maybeAppend(container, ".checkbox-content", "g").attr("className", "checkbox-content").node();
      var boxStyle = subStyleProps(attributes, "box");
      var checkedStyle = subStyleProps(attributes, "checked");
      var labelStyle = subStyleProps(attributes, "label");
      var checkboxStyle = __assign(__assign({}, this.checked ? CHECKBOX_RECT_STYLE.selected : CHECKBOX_RECT_STYLE.default), boxStyle);
      var checkboxBoxCheckedStyle = __assign(__assign({}, CHECKED_SHAPE_STYLE), checkedStyle);
      this.checkboxBoxShape = maybeAppend(group3, ".checkbox-box", "rect").styles(__assign({ className: "checkbox-box", zIndex: (group3.style.zIndex || 0) - 1 }, checkboxStyle)).node();
      maybeAppend(this.checkboxBoxShape, ".checkbox-checked", "path").styles(__assign({ className: "checkbox-box-checked", stroke: "#fff" }, checkboxBoxCheckedStyle));
      var _a2 = getLablePosition(this.checkboxBoxShape, Number(spacing)), x3 = _a2.x, y4 = _a2.y;
      maybeAppend(group3, ".checkbox-label", "text").styles(__assign({ className: "checkbox-label", x: x3, y: y4 }, labelStyle));
    };
    Checkbox2.tag = "checkbox";
    return Checkbox2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/layout/layout.js
var Layout = (
  /** @class */
  function(_super) {
    __extends(Layout2, _super);
    function Layout2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.layoutEvents = [ElementEvent.BOUNDS_CHANGED, ElementEvent.INSERTED, ElementEvent.REMOVED];
      _this2.$margin = parseSeriesAttr(0);
      _this2.$padding = parseSeriesAttr(0);
      var _a2 = options.style || {}, _b = _a2.margin, margin = _b === void 0 ? 0 : _b, _c = _a2.padding, padding = _c === void 0 ? 0 : _c;
      _this2.margin = margin;
      _this2.padding = padding;
      _this2.isMutationObserved = true;
      _this2.bindEvents();
      return _this2;
    }
    Object.defineProperty(Layout2.prototype, "margin", {
      get: function() {
        return this.$margin;
      },
      set: function(value2) {
        this.$margin = parseSeriesAttr(value2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Layout2.prototype, "padding", {
      get: function() {
        return this.$padding;
      },
      set: function(value2) {
        this.$padding = parseSeriesAttr(value2);
      },
      enumerable: false,
      configurable: true
    });
    Layout2.prototype.getBBox = function() {
      var _a2 = this.attributes, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y4 = _c === void 0 ? 0 : _c, width = _a2.width, height = _a2.height;
      var _d = __read(this.$margin, 4), marginTop = _d[0], marginRight = _d[1], marginBottom = _d[2], marginLeft = _d[3];
      return new BBox(x3 - marginLeft, y4 - marginTop, width + marginLeft + marginRight, height + marginTop + marginBottom);
    };
    Layout2.prototype.appendChild = function(child, index3) {
      child.isMutationObserved = true;
      _super.prototype.appendChild.call(this, child, index3);
      return child;
    };
    Layout2.prototype.getAvailableSpace = function() {
      var _a2 = this.attributes, width = _a2.width, height = _a2.height;
      var _b = __read(this.$padding, 4), paddingTop = _b[0], paddingRight = _b[1], paddingBottom = _b[2], paddingLeft = _b[3];
      var _c = __read(this.$margin, 4), marginTop = _c[0], marginLeft = _c[3];
      return new BBox(paddingLeft + marginLeft, paddingTop + marginTop, width - paddingLeft - paddingRight, height - paddingTop - paddingBottom);
    };
    Layout2.prototype.layout = function() {
      if (!this.attributes.display || !this.isConnected)
        return;
      if (this.children.some(function(child) {
        return !child.isConnected;
      }))
        return;
      try {
        var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y4, ")");
        var bboxes_1 = executer_default(this.getAvailableSpace(), this.children.map(function(child) {
          return child.getBBox();
        }), this.attributes);
        this.children.forEach(function(child, index3) {
          var _a3 = bboxes_1[index3], x4 = _a3.x, y5 = _a3.y;
          child.style.transform = "translate(".concat(x4, ", ").concat(y5, ")");
        });
      } catch (e3) {
      }
    };
    Layout2.prototype.bindEvents = function() {
      var _this2 = this;
      this.layoutEvents.forEach(function(event) {
        _this2.addEventListener(event, function(e3) {
          if (!e3.target)
            return;
          e3.target.isMutationObserved = true;
          _this2.layout();
        });
      });
    };
    Layout2.prototype.attributeChangedCallback = function(name2, oldValue, newValue) {
      if (name2 === "margin")
        this.margin = newValue;
      else if (name2 === "padding")
        this.padding = newValue;
      this.layout();
    };
    return Layout2;
  }(Group2)
);

// node_modules/@antv/component/esm/ui/select/option.js
var Option = (
  /** @class */
  function(_super) {
    __extends(Option2, _super);
    function Option2(options) {
      var _this2 = _super.call(this, deepAssign2({}, Option2.defaultOptions, options)) || this;
      _this2.hoverColor = "#f5f5f5";
      _this2.selectedColor = "#e6f7ff";
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.label = _this2.background.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(Option2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.style.padding);
      },
      enumerable: false,
      configurable: true
    });
    Option2.prototype.renderLabel = function() {
      var _a2 = this.style, label = _a2.label, value2 = _a2.value;
      var labelStyle = subStyleProps(this.attributes, "label");
      select2(this.label).maybeAppend(".label", function() {
        return renderExtDo(label);
      }).attr("className", "label").styles(labelStyle);
      this.label.attr("__data__", value2);
    };
    Option2.prototype.renderBackground = function() {
      var labelBBox = this.label.getBBox();
      var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
      var labelWidth = labelBBox.width, labelHeight = labelBBox.height;
      var backgroundWidth = labelWidth + left2 + right2;
      var backgroundHeight = labelHeight + top + bottom;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      var _b = this.style, _c = _b.width, styleWidth = _c === void 0 ? 0 : _c, _d = _b.height, styleHeight = _d === void 0 ? 0 : _d, selected = _b.selected;
      this.background.attr(__assign(__assign({}, backgroundStyle), { width: Math.max(backgroundWidth, styleWidth), height: Math.max(backgroundHeight, styleHeight), fill: selected ? this.selectedColor : "#fff" }));
      this.label.attr({ transform: "translate(".concat(left2, ", ").concat((backgroundHeight - labelHeight) / 2, ")") });
    };
    Option2.prototype.render = function() {
      this.renderLabel();
      this.renderBackground();
    };
    Option2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("pointerenter", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.hoverColor);
      });
      this.addEventListener("pointerleave", function() {
        if (_this2.style.selected)
          return;
        _this2.background.attr("fill", _this2.style.backgroundFill);
      });
      var item = this;
      this.addEventListener("click", function() {
        var _a2 = _this2.style, label = _a2.label, value2 = _a2.value, onClick = _a2.onClick;
        onClick === null || onClick === void 0 ? void 0 : onClick(value2, { label, value: value2 }, item);
      });
    };
    Option2.defaultOptions = {
      style: {
        value: "",
        label: "",
        cursor: "pointer"
      }
    };
    return Option2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/select/select.js
var Select2 = (
  /** @class */
  function(_super) {
    __extends(Select3, _super);
    function Select3(options) {
      var _a2, _b;
      var _this2 = _super.call(this, deepAssign2({}, Select3.defaultOptions, options)) || this;
      _this2.currentValue = (_a2 = Select3.defaultOptions.style) === null || _a2 === void 0 ? void 0 : _a2.defaultValue;
      _this2.isPointerInSelect = false;
      _this2.select = _this2.appendChild(new Rect({
        className: "select",
        style: {
          cursor: "pointer",
          width: 0,
          height: 0
        }
      }));
      _this2.dropdown = _this2.appendChild(new Rect({
        className: "dropdown"
      }));
      var defaultValue = _this2.style.defaultValue;
      if (defaultValue && ((_b = _this2.style.options) === null || _b === void 0 ? void 0 : _b.some(function(option) {
        return option.value === defaultValue;
      }))) {
        _this2.currentValue = defaultValue;
      }
      return _this2;
    }
    Select3.prototype.setValue = function(value2) {
      this.currentValue = value2;
      this.render();
    };
    Select3.prototype.getValue = function() {
      return this.currentValue;
    };
    Object.defineProperty(Select3.prototype, "dropdownPadding", {
      get: function() {
        return parseSeriesAttr(this.style.dropdownPadding);
      },
      enumerable: false,
      configurable: true
    });
    Select3.prototype.renderSelect = function() {
      var _this2 = this;
      var _a2;
      var _b = this.style, x3 = _b.x, y4 = _b.y, width = _b.width, height = _b.height, bordered = _b.bordered, showDropdownIcon = _b.showDropdownIcon;
      var selectStyle = subStyleProps(this.attributes, "select");
      var placeholderStyle = subStyleProps(this.attributes, "placeholder");
      this.select.attr(__assign(__assign({ x: x3, y: y4, width, height }, selectStyle), { fill: "#fff", strokeWidth: bordered ? 1 : 0 }));
      var padding = this.dropdownPadding;
      var iconSize = 10;
      if (showDropdownIcon) {
        select2(this.select).maybeAppend(".dropdown-icon", "path").style("d", "M-5,-3.5 L0,3.5 L5,-3.5").style("transform", "translate(".concat(x3 + width - iconSize - padding[1] - padding[3], ", ").concat(y4 + height / 2, ")")).style("lineWidth", 1).style("stroke", this.select.style.stroke);
      }
      var currentOption = (_a2 = this.style.options) === null || _a2 === void 0 ? void 0 : _a2.find(function(option) {
        return option.value === _this2.currentValue;
      });
      var finalPlaceholderStyle = __assign({ x: x3 + padding[3] }, placeholderStyle);
      select2(this.select).selectAll(".placeholder").data(!currentOption ? [1] : []).join(function(enter) {
        return enter.append("text").attr("className", "placeholder").styles(finalPlaceholderStyle).style("y", function() {
          var bbox = this.getBBox();
          return y4 + (height - bbox.height) / 2;
        });
      }, function(update2) {
        return update2.styles(finalPlaceholderStyle);
      }, function(exit) {
        return exit.remove();
      });
      var labelStyle = subStyleProps(this.attributes, "optionLabel");
      var finalValueStyle = __assign({ x: x3 + padding[3] }, labelStyle);
      select2(this.select).selectAll(".value").data(currentOption ? [currentOption] : []).join(function(enter) {
        return enter.append(function(datum) {
          return renderExtDo(datum.label);
        }).attr("className", "value").styles(finalValueStyle).style("y", function() {
          var bbox = this.getBBox();
          return y4 + (height - bbox.height) / 2;
        });
      }, function(update2) {
        return update2.styles(finalValueStyle);
      }, function(exit) {
        return exit.remove();
      });
    };
    Select3.prototype.renderDropdown = function() {
      var _this2 = this;
      var _a2, _b;
      var _c = this.style, x3 = _c.x, y4 = _c.y, width = _c.width, height = _c.height, options = _c.options, onSelect = _c.onSelect, open = _c.open;
      var dropdownStyle = subStyleProps(this.attributes, "dropdown");
      var optionStyle = subStyleProps(this.attributes, "option");
      var padding = this.dropdownPadding;
      select2(this.dropdown).maybeAppend(".dropdown-container", "g").attr("className", "dropdown-container").selectAll(".dropdown-item").data(options, function(datum) {
        return datum.value;
      }).join(function(enter) {
        return enter.append(function(datum) {
          return new Option({
            className: "dropdown-item",
            style: __assign(__assign(__assign({}, datum), optionStyle), { width: width - padding[1] - padding[3], selected: datum.value === _this2.currentValue, onClick: function(value2, option, item) {
              _this2.setValue(value2);
              onSelect === null || onSelect === void 0 ? void 0 : onSelect(value2, option, item);
              _this2.dispatchEvent(new CustomEvent("change", { detail: { value: value2, option, item } }));
              hide(_this2.dropdown);
            } })
          });
        }).each(function(datum, i2) {
          var _a3;
          var nodes = (_a3 = this.parentNode) === null || _a3 === void 0 ? void 0 : _a3.children;
          var accHeight = nodes.reduce(function(acc, curr, index3) {
            if (index3 < i2) {
              acc += curr.getBBox().height;
            }
            return acc;
          }, 0);
          this.attr("transform", "translate(".concat(padding[3], ", ").concat(padding[0] + accHeight, ")"));
        });
      }, function(update2) {
        return update2.update(function(datum) {
          return { selected: datum.value === _this2.currentValue };
        });
      }, function(exit) {
        return exit.remove();
      });
      var bbox = (_b = (_a2 = this.dropdown.getElementsByClassName("dropdown-container")) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.getBBox();
      var spacing = dropdownStyle.spacing;
      this.dropdown.attr(__assign({ transform: "translate(".concat(x3, ", ").concat(y4 + height + spacing, ")"), width: bbox.width + padding[1] + padding[3], height: bbox.height + padding[0] + padding[2] }, dropdownStyle));
      !open && hide(this.dropdown);
    };
    Select3.prototype.render = function() {
      this.renderSelect();
      this.renderDropdown();
    };
    Select3.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("click", function(e3) {
        e3.stopPropagation();
      });
      this.select.addEventListener("click", function() {
        if (_this2.dropdown.style.visibility === "visible")
          hide(_this2.dropdown);
        else {
          show(_this2.dropdown);
        }
      });
      this.addEventListener("pointerenter", function() {
        _this2.isPointerInSelect = true;
      });
      this.addEventListener("pointerleave", function() {
        _this2.isPointerInSelect = false;
      });
      document === null || document === void 0 ? void 0 : document.addEventListener("click", function() {
        if (!_this2.isPointerInSelect) {
          hide(_this2.dropdown);
        }
      });
    };
    Select3.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 140,
        height: 32,
        options: [],
        bordered: true,
        defaultValue: "",
        selectRadius: 8,
        selectStroke: "#d9d9d9",
        showDropdownIcon: true,
        placeholderText: "",
        placeholderFontSize: 12,
        placeholderTextBaseline: "top",
        placeholderFill: "#c2c2c2",
        dropdownFill: "#fff",
        dropdownStroke: "#d9d9d9",
        dropdownRadius: 8,
        dropdownShadowBlur: 4,
        dropdownShadowColor: "rgba(0, 0, 0, 0.08)",
        dropdownPadding: 8,
        dropdownSpacing: 10,
        optionPadding: [8, 12],
        optionFontSize: 12,
        optionTextBaseline: "top",
        optionBackgroundFill: "#fff",
        optionBackgroundRadius: 4,
        optionLabelFontSize: 12,
        optionLabelTextBaseline: "top"
      }
    };
    return Select3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/icons.js
var IconBase = (
  /** @class */
  function(_super) {
    __extends(IconBase2, _super);
    function IconBase2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { backgroundOpacity: IconBase2.backgroundOpacities.default } }, IconBase2.defaultOptions, options)) || this;
      _this2.showBackground = true;
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.icon = _this2.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(IconBase2.prototype, "label", {
      get: function() {
        return "BaseIcon";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "lineWidth", {
      get: function() {
        return Math.log10(this.attributes.size);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.size / 5);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IconBase2.prototype, "iconSize", {
      get: function() {
        var size3 = this.attributes.size;
        var _a2 = __read(this.padding, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
        return Math.max(size3 - Math.max(left2 + right2, top + bottom), this.lineWidth * 2 + 1);
      },
      enumerable: false,
      configurable: true
    });
    IconBase2.prototype.renderBackground = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, size3 = _a2.size;
      var halfSize = size3 / 2;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: x3 - halfSize, y: y4 - halfSize, width: size3, height: size3 }, backgroundStyle));
    };
    IconBase2.prototype.showIndicator = function() {
      if (!this.label)
        return;
      var size3 = this.attributes.size;
      var _a2 = this.background.getBBox(), x3 = _a2.x, y4 = _a2.y;
      this.indicator.update({ x: x3 + size3 / 2, y: y4 - 5, labelText: this.label, visibility: "visible" });
    };
    IconBase2.prototype.hideIndicator = function() {
      this.indicator.update({ visibility: "hidden" });
    };
    IconBase2.prototype.connectedCallback = function() {
      var _a2;
      _super.prototype.connectedCallback.call(this);
      var size3 = this.attributes.size;
      var _b = this.background.getBBox(), x3 = _b.x, y4 = _b.y;
      var canvas = (_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
      if (canvas) {
        this.indicator = canvas.appendChild(new Indicator({
          style: {
            x: x3 + size3 / 2,
            y: y4 - size3 / 2,
            visibility: "hidden",
            position: "top",
            radius: 3,
            zIndex: 100
          }
        }));
      }
    };
    IconBase2.prototype.disconnectedCallback = function() {
      this.indicator.destroy();
    };
    IconBase2.prototype.render = function() {
      this.renderIcon();
      if (this.showBackground)
        this.renderBackground();
    };
    IconBase2.prototype.bindEvents = function() {
      var _this2 = this;
      var onClick = this.attributes.onClick;
      this.addEventListener("click", function() {
        onClick === null || onClick === void 0 ? void 0 : onClick(_this2);
      });
      if (this.showBackground) {
        var resetBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.default });
        };
        var hoverBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.hover });
        };
        var activeBackground_1 = function() {
          return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.active });
        };
        this.addEventListener("pointerenter", function() {
          hoverBackground_1();
          _this2.showIndicator();
        });
        this.addEventListener("pointerleave", function() {
          resetBackground_1();
          _this2.hideIndicator();
        });
        this.addEventListener("pointerdown", function() {
          activeBackground_1();
        });
        this.addEventListener("pointerup", function() {
          resetBackground_1();
        });
      }
    };
    IconBase2.tag = "IconBase";
    IconBase2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        size: 10,
        color: "#565758",
        backgroundRadius: 4,
        backgroundFill: "#e2e2e2"
      }
    };
    IconBase2.backgroundOpacities = {
      default: 0,
      hover: 0.8,
      active: 1
    };
    return IconBase2;
  }(Component)
);
var arrow = function(size3, color3) {
  if (color3 === void 0) {
    color3 = "#565758";
  }
  return new Path2({
    style: {
      fill: color3,
      d: "M ".concat(size3, ",").concat(size3, " L -").concat(size3, ",0 L ").concat(size3, ",-").concat(size3, " Z"),
      transformOrigin: "center"
    }
  });
};
var Reset = (
  /** @class */
  function(_super) {
    __extends(Reset2, _super);
    function Reset2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Reset2.prototype.arcPath = function(cx, cy, radius) {
      var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
      var getPosByAngle = function(angle4) {
        return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
      };
      var _b = __read(getPosByAngle(-5 / 4 * Math.PI), 2), x12 = _b[0], y12 = _b[1];
      var _c = __read(getPosByAngle(1 / 4 * Math.PI), 2), x22 = _c[0], y22 = _c[1];
      return "M".concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,1,1,").concat(x22, ",").concat(y22);
    };
    Object.defineProperty(Reset2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Reset2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var lineWidth = this.lineWidth;
      var arrowSize = lineWidth + 0.5;
      select2(this.icon).maybeAppend(".reset", "path").styles({
        stroke: color3,
        lineWidth,
        d: this.arcPath(x3, y4, size3 / 2 - lineWidth),
        markerStart: arrow(arrowSize, color3)
      });
    };
    return Reset2;
  }(IconBase)
);
var Backward = (
  /** @class */
  function(_super) {
    __extends(Backward2, _super);
    function Backward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Backward2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Backward2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var deltaX = size3 / 2;
      var deltaY = size3 / 2 / Math.pow(3, 0.5);
      var points = [
        [x3, y4],
        [x3, y4 - deltaY],
        [x3 - deltaX, y4],
        [x3, y4 + deltaY],
        [x3, y4],
        [x3 + deltaX, y4 - deltaY],
        [x3 + deltaX, y4 + deltaY],
        [x3, y4]
      ];
      select2(this.icon).maybeAppend(".backward", "polygon").styles({
        points,
        fill: color3
      });
    };
    return Backward2;
  }(IconBase)
);
var Forward = (
  /** @class */
  function(_super) {
    __extends(Forward2, _super);
    function Forward2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Forward2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Forward2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var deltaX = size3 / 2;
      var deltaY = size3 / 2 / Math.pow(3, 0.5);
      var points = [
        [x3, y4],
        [x3, y4 - deltaY],
        [x3 + deltaX, y4],
        [x3, y4 + deltaY],
        [x3, y4],
        [x3 - deltaX, y4 - deltaY],
        [x3 - deltaX, y4 + deltaY],
        [x3, y4]
      ];
      select2(this.icon).maybeAppend(".forward", "polygon").styles({
        points,
        fill: color3
      });
    };
    return Forward2;
  }(IconBase)
);
var Play = (
  /** @class */
  function(_super) {
    __extends(Play2, _super);
    function Play2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Play2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Play2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var deltaX = size3 / 3 * Math.pow(3, 0.5) * 0.8;
      var points = [
        [x3 + deltaX, y4],
        [x3 - deltaX / 2, y4 - size3 / 2 * 0.8],
        [x3 - deltaX / 2, y4 + size3 / 2 * 0.8],
        [x3 + deltaX, y4]
      ];
      select2(this.icon).maybeAppend(".play", "polygon").styles({
        points,
        fill: color3
      });
    };
    return Play2;
  }(IconBase)
);
var Pause = (
  /** @class */
  function(_super) {
    __extends(Pause2, _super);
    function Pause2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Pause2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Pause2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var size3 = this.iconSize;
      var deltaX = size3 / 3;
      var points = [
        [x3 - deltaX, y4 - size3 / 2],
        [x3 - deltaX, y4 + size3 / 2],
        [x3 - deltaX / 2, y4 + size3 / 2],
        [x3 - deltaX / 2, y4 - size3 / 2],
        [x3 - deltaX, y4 - size3 / 2],
        [x3 + deltaX / 2, y4 - size3 / 2],
        [x3 + deltaX / 2, y4 + size3 / 2],
        [x3 + deltaX, y4 + size3 / 2],
        [x3 + deltaX, y4 - size3 / 2]
      ];
      select2(this.icon).maybeAppend(".pause", "polygon").styles({
        points,
        fill: color3
      });
    };
    return Pause2;
  }(IconBase)
);
var Range = (
  /** @class */
  function(_super) {
    __extends(Range3, _super);
    function Range3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Range3.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Range3.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      select2(this.icon).maybeAppend(".left-line", "line").styles({
        x1: x3 - size3 / 2,
        y1: y4 - size3 / 2,
        x2: x3 - size3 / 2,
        y2: y4 + size3 / 2,
        stroke: color3,
        lineWidth
      });
      select2(this.icon).maybeAppend(".right-line", "line").styles({
        x1: x3 + size3 / 2,
        y1: y4 - size3 / 2,
        x2: x3 + size3 / 2,
        y2: y4 + size3 / 2,
        stroke: color3,
        lineWidth
      });
      select2(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: x3,
        y1: y4,
        x2: x3 - size3 / 2 + gap * 2,
        y2: y4,
        stroke: color3,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color3)
      });
      select2(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: x3,
        y1: y4,
        x2: x3 + size3 / 2 - gap * 2,
        y2: y4,
        stroke: color3,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color3)
      });
    };
    return Range3;
  }(IconBase)
);
var Value = (
  /** @class */
  function(_super) {
    __extends(Value2, _super);
    function Value2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Value2.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Value2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      select2(this.icon).maybeAppend(".line", "line").styles({
        x1: x3,
        y1: y4 - size3 / 2,
        x2: x3,
        y2: y4 + size3 / 2,
        stroke: color3,
        lineWidth
      });
      var gap = lineWidth;
      select2(this.icon).maybeAppend(".left-arrow", "line").styles({
        x1: x3 - size3 / 2 - gap * 2,
        y1: y4,
        x2: x3 - gap * 2,
        y2: y4,
        stroke: color3,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color3)
      });
      select2(this.icon).maybeAppend(".right-arrow", "line").styles({
        x1: x3 + size3 / 2 + gap * 2,
        y1: y4,
        x2: x3 + gap * 2,
        y2: y4,
        stroke: color3,
        lineWidth,
        markerEnd: arrow(lineWidth * 2, color3)
      });
    };
    return Value2;
  }(IconBase)
);
var getCoordinatePoints = function(size3) {
  return [
    [-size3 / 2, -size3 / 2],
    [-size3 / 2, size3 / 2],
    [size3 / 2, size3 / 2]
  ];
};
var LineChart = (
  /** @class */
  function(_super) {
    __extends(LineChart3, _super);
    function LineChart3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(LineChart3.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    LineChart3.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      var deltaX = (size3 - gap * 2 - lineWidth) / 4;
      var deltaY = (size3 - gap * 2 - lineWidth) / 2;
      var _c = __read([x3 - size3 / 2 + gap, y4 + size3 / 2 - gap * 2], 2), ox = _c[0], oy = _c[1];
      select2(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size3).map(function(_a3) {
          var _b2 = __read(_a3, 2), px2 = _b2[0], py = _b2[1];
          return [px2 + x3, py + y4];
        }),
        stroke: color3,
        lineWidth
      });
      select2(this.icon).maybeAppend(".line", "polyline").styles({
        points: [
          [ox, oy],
          [ox + deltaX, oy - deltaY],
          [ox + deltaX * 2, oy],
          [ox + deltaX * 4, oy - deltaY * 2]
        ],
        stroke: color3,
        lineWidth
      });
    };
    return LineChart3;
  }(IconBase)
);
var BarChart = (
  /** @class */
  function(_super) {
    __extends(BarChart3, _super);
    function BarChart3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BarChart3.prototype, "label", {
      get: function() {
        return "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BarChart3.prototype, "data", {
      get: function() {
        return [1, 4, 2, 4, 3];
      },
      enumerable: false,
      configurable: true
    });
    BarChart3.prototype.renderIcon = function() {
      var data2 = this.data;
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      var gap = lineWidth;
      var deltaX = (size3 - gap) / data2.length;
      var deltaY = (size3 - gap * 2) / 4;
      var _c = __read([x3 - size3 / 2 + gap * 2, y4 + size3 / 2 - gap], 2), ox = _c[0], oy = _c[1];
      select2(this.icon).maybeAppend(".coordinate", "polyline").styles({
        points: getCoordinatePoints(size3).map(function(_a3) {
          var _b2 = __read(_a3, 2), px2 = _b2[0], py = _b2[1];
          return [px2 + x3, py + y4];
        }),
        stroke: color3,
        lineWidth
      });
      select2(this.icon).maybeAppend(".bars", "g").selectAll(".column").data(this.data.map(function(value2, index3) {
        return { value: value2, index: index3 };
      })).join(function(enter) {
        return enter.append("line").attr("className", "column").style("x1", function(_a3) {
          var index3 = _a3.index;
          return ox + deltaX * index3;
        }).style("y1", oy).style("x2", function(_a3) {
          var index3 = _a3.index;
          return ox + deltaX * index3;
        }).style("y2", function(_a3) {
          var value2 = _a3.value;
          return oy - deltaY * value2;
        }).styles({
          y1: oy,
          stroke: color3,
          lineWidth
        });
      });
    };
    return BarChart3;
  }(IconBase)
);
var Split = (
  /** @class */
  function(_super) {
    __extends(Split2, _super);
    function Split2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { color: "#d8d9d9" } }, options)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Split2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, color3 = _a2.color;
      var _b = this, size3 = _b.iconSize, lineWidth = _b.lineWidth;
      select2(this.icon).maybeAppend(".split", "line").styles({
        x1: x3,
        y1: y4 - size3 / 2,
        x2: x3,
        y2: y4 + size3 / 2,
        stroke: color3,
        lineWidth
      });
    };
    return Split2;
  }(IconBase)
);
var SpeedSelect = (
  /** @class */
  function(_super) {
    __extends(SpeedSelect2, _super);
    function SpeedSelect2() {
      var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this2.showBackground = false;
      return _this2;
    }
    Object.defineProperty(SpeedSelect2.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(0);
      },
      enumerable: false,
      configurable: true
    });
    SpeedSelect2.prototype.renderIcon = function() {
      var iconSize = this.iconSize;
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, _b = _a2.speed, speed = _b === void 0 ? 1 : _b;
      var inheritStyle = omit_default(this.attributes, [
        "x",
        "y",
        "transform",
        "transformOrigin",
        "width",
        "height",
        "size",
        "color",
        "speed"
      ]);
      var width = clamp_default(iconSize, 20, Infinity);
      var height = 20;
      var style = __assign(__assign({}, inheritStyle), { x: x3 - width / 2, y: y4 - height / 2, width, height, defaultValue: speed, bordered: false, showDropdownIcon: false, selectRadius: 2, dropdownPadding: this.padding, dropdownRadius: 2, dropdownSpacing: iconSize / 5, placeholderFontSize: iconSize / 2, optionPadding: 0, optionLabelFontSize: iconSize / 2, optionBackgroundRadius: 1, options: [
        { label: "1x", value: 1 },
        { label: "1.5x", value: 1.5 },
        { label: "2x", value: 2 }
      ] });
      select2(this.icon).maybeAppend(".speed", function() {
        return new Select2({ style });
      }).attr("className", "speed").each(function() {
        this.update(style);
      });
    };
    SpeedSelect2.tag = "SpeedSelect";
    return SpeedSelect2;
  }(IconBase)
);
var ToggleIcon = (
  /** @class */
  function(_super) {
    __extends(ToggleIcon2, _super);
    function ToggleIcon2(options) {
      var _this2 = _super.call(this, options) || this;
      _this2.icon = _this2.appendChild(new Group2({}));
      _this2.currentType = _this2.attributes.type;
      return _this2;
    }
    ToggleIcon2.prototype.getType = function() {
      return this.currentType;
    };
    ToggleIcon2.prototype.render = function() {
      var _this2 = this;
      var _a2 = this.attributes, onChange = _a2.onChange, restStyles = __rest(_a2, ["onChange"]);
      select2(this.icon).selectAll(".icon").data([this.currentType]).join(function(enter) {
        return enter.append(function(type) {
          var _a3;
          var Ctor = (_a3 = _this2.toggles.find(function(_a4) {
            var _b = __read(_a4, 1), key = _b[0];
            return key === type;
          })) === null || _a3 === void 0 ? void 0 : _a3[1];
          if (!Ctor)
            throw new Error("Invalid type: ".concat(type));
          return new Ctor({});
        }).attr("className", "icon").styles(restStyles, false).update({});
      }, function(update2) {
        return update2.styles({ restStyles }).update({});
      }, function(exit) {
        return exit.remove();
      });
    };
    ToggleIcon2.prototype.bindEvents = function() {
      var _this2 = this;
      var onChange = this.attributes.onChange;
      this.addEventListener("click", function(e3) {
        e3.preventDefault();
        e3.stopPropagation();
        var nextIndex = (_this2.toggles.findIndex(function(_a2) {
          var _b = __read(_a2, 1), key = _b[0];
          return key === _this2.currentType;
        }) + 1) % _this2.toggles.length;
        var nextType = _this2.toggles[nextIndex][0];
        onChange === null || onChange === void 0 ? void 0 : onChange(_this2.currentType);
        _this2.currentType = nextType;
        _this2.render();
      });
    };
    ToggleIcon2.tag = "ToggleIcon";
    return ToggleIcon2;
  }(Component)
);
var PlayPause = (
  /** @class */
  function(_super) {
    __extends(PlayPause2, _super);
    function PlayPause2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "play" } }, options)) || this;
      _this2.toggles = [
        ["play", Play],
        ["pause", Pause]
      ];
      return _this2;
    }
    return PlayPause2;
  }(ToggleIcon)
);
var SelectionType = (
  /** @class */
  function(_super) {
    __extends(SelectionType2, _super);
    function SelectionType2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "range" } }, options)) || this;
      _this2.toggles = [
        ["range", Range],
        ["value", Value]
      ];
      return _this2;
    }
    return SelectionType2;
  }(ToggleIcon)
);
var ChartType = (
  /** @class */
  function(_super) {
    __extends(ChartType2, _super);
    function ChartType2(options) {
      var _this2 = _super.call(this, deepAssign2({}, { style: { type: "column" } }, options)) || this;
      _this2.toggles = [
        ["line", LineChart],
        ["column", BarChart]
      ];
      return _this2;
    }
    return ChartType2;
  }(ToggleIcon)
);

// node_modules/@antv/component/esm/ui/timebar/controller.js
var componentsMap = {
  reset: Reset,
  speed: SpeedSelect,
  backward: Backward,
  playPause: PlayPause,
  forward: Forward,
  selectionType: SelectionType,
  chartType: ChartType,
  split: Split
};
var Controller = (
  /** @class */
  function(_super) {
    __extends(Controller3, _super);
    function Controller3(options) {
      var _this2 = _super.call(this, deepAssign2({}, Controller3.defaultOptions, options)) || this;
      _this2.background = _this2.appendChild(new Rect({}));
      _this2.functions = _this2.appendChild(new Group2({}));
      return _this2;
    }
    Object.defineProperty(Controller3.prototype, "padding", {
      get: function() {
        return parseSeriesAttr(this.attributes.padding);
      },
      enumerable: false,
      configurable: true
    });
    Controller3.prototype.renderBackground = function() {
      var _a2 = this.style, x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
      var backgroundStyle = subStyleProps(this.attributes, "background");
      this.background.attr(__assign({ x: x3, y: y4, width, height }, backgroundStyle));
    };
    Controller3.prototype.renderFunctions = function() {
      var _this2 = this;
      var _a2;
      var _b = this.attributes, functions = _b.functions, iconSize = _b.iconSize, iconSpacing = _b.iconSpacing, x3 = _b.x, y4 = _b.y, width = _b.width, height = _b.height, align = _b.align;
      var _c = __read(this.padding, 4), right2 = _c[1], left2 = _c[3];
      var components = functions.reduce(function(prev, curr) {
        if (prev.length && curr.length) {
          return prev.concat.apply(prev, __spreadArray(["split"], __read(curr), false));
        }
        return prev.concat.apply(prev, __spreadArray([], __read(curr), false));
      }, []);
      var componentsWidth = components.length * (iconSize + iconSpacing) - iconSpacing;
      var xOffset = {
        left: left2 + iconSize / 2,
        center: (width - componentsWidth) / 2 + iconSize / 2,
        right: width - componentsWidth - left2 - right2 + iconSize / 2
      }[align] || 0;
      (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      this.functions.removeChildren();
      components.forEach(function(name2, index3) {
        var _a3;
        var Ctor = componentsMap[name2];
        var style = {
          x: x3 + index3 * (iconSize + iconSpacing) + xOffset,
          y: y4 + height / 2,
          size: iconSize
        };
        if (Ctor === SpeedSelect) {
          style.speed = _this2.attributes.speed;
          style.onSelect = function(value2) {
            return _this2.handleFunctionChange(name2, { value: value2 });
          };
        } else if ([PlayPause, SelectionType, ChartType].includes(Ctor)) {
          style.onChange = function(value2) {
            return _this2.handleFunctionChange(name2, { value: value2 });
          };
          if (Ctor === PlayPause)
            style.type = _this2.attributes.state === "play" ? "pause" : "play";
          if (Ctor === SelectionType)
            style.type = _this2.attributes.selectionType === "range" ? "value" : "range";
          if (Ctor === ChartType)
            style.type = _this2.attributes.chartType === "line" ? "column" : "line";
        } else {
          style.onClick = function() {
            return _this2.handleFunctionChange(name2, { value: name2 });
          };
        }
        if (Ctor === SpeedSelect) {
          var canvas = (_a3 = _this2.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
          if (canvas) {
            _this2.speedSelect = new Ctor({ style: __assign(__assign({}, style), { zIndex: 100 }) });
            canvas.appendChild(_this2.speedSelect);
          }
        } else {
          _this2.functions.appendChild(new Ctor({ style }));
        }
      });
    };
    Controller3.prototype.disconnectedCallback = function() {
      var _a2;
      _super.prototype.disconnectedCallback.call(this);
      (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    };
    Controller3.prototype.render = function() {
      this.renderBackground();
      this.renderFunctions();
    };
    Controller3.prototype.handleFunctionChange = function(name2, value2) {
      var onChange = this.attributes.onChange;
      onChange === null || onChange === void 0 ? void 0 : onChange(name2, value2);
    };
    Controller3.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 300,
        height: 40,
        padding: 0,
        align: "center",
        iconSize: 25,
        iconSpacing: 0,
        speed: 1,
        state: "pause",
        chartType: "line",
        selectionType: "range",
        backgroundFill: "#fbfdff",
        backgroundStroke: "#ebedf0",
        functions: [
          ["reset", "speed"],
          ["backward", "playPause", "forward"],
          ["selectionType", "chartType"]
        ]
      }
    };
    return Controller3;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/handle.js
var TimeModeHandle = (
  /** @class */
  function(_super) {
    __extends(TimeModeHandle2, _super);
    function TimeModeHandle2(options) {
      var _this2 = _super.call(this, deepAssign2({}, TimeModeHandle2.defaultOptions, options)) || this;
      _this2.bindEvents();
      return _this2;
    }
    TimeModeHandle2.prototype.bindEvents = function() {
      var _this2 = this;
      this.addEventListener("mouseenter", function() {
        _this2.attr("lineWidth", Math.ceil(+(_this2.style.r || 0) / 2));
      });
      this.addEventListener("mouseleave", function() {
        _this2.attr("lineWidth", 0);
      });
    };
    TimeModeHandle2.defaultOptions = {
      style: {
        r: 5,
        fill: "#3f7cf7",
        lineWidth: 0,
        stroke: "#3f7cf7",
        strokeOpacity: 0.5,
        cursor: "pointer"
      }
    };
    return TimeModeHandle2;
  }(Circle)
);
var ChartModeHandle = (
  /** @class */
  function(_super) {
    __extends(ChartModeHandle2, _super);
    function ChartModeHandle2(options) {
      return _super.call(this, deepAssign2({}, ChartModeHandle2.defaultOptions, options)) || this;
    }
    ChartModeHandle2.prototype.renderBackground = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
      var style = subStyleProps(this.attributes, "background");
      select2(this).maybeAppend("background", "rect").attr("className", "background").styles(__assign({ x: x3 - width / 2, y: y4 - height / 2, width, height }, style));
    };
    ChartModeHandle2.prototype.renderIcon = function() {
      var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, iconSize = _a2.iconSize;
      var style = subStyleProps(this.attributes, "icon");
      var diffX = 1;
      var diffY = iconSize / 2;
      select2(this).maybeAppend("icon-left-line", "line").attr("className", "icon-left-line").styles(__assign({ x1: x3 - diffX, y1: y4 - diffY, x2: x3 - diffX, y2: y4 + diffY }, style));
      select2(this).maybeAppend("icon-right-line", "line").attr("className", "icon-right-line").styles(__assign({ x1: x3 + diffX, y1: y4 - diffY, x2: x3 + diffX, y2: y4 + diffY }, style));
    };
    ChartModeHandle2.prototype.renderBorder = function() {
      var _a2 = this.attributes, xx = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height, type = _a2.type;
      var style = subStyleProps(this.attributes, "border");
      var x3 = type === "start" ? +width / 2 : -width / 2;
      select2(this).maybeAppend("border", "line").attr("className", "border").styles(__assign({ x1: x3 + xx, y1: y4 - height / 2, x2: x3 + xx, y2: y4 + height / 2 }, style));
    };
    ChartModeHandle2.prototype.render = function() {
      this.renderBackground();
      this.renderIcon();
      this.renderBorder();
    };
    ChartModeHandle2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        width: 10,
        height: 50,
        iconSize: 10,
        type: "start",
        backgroundFill: "#fff",
        backgroundFillOpacity: 0.5,
        iconStroke: "#9a9a9a",
        iconLineWidth: 1,
        borderStroke: "#e8e8e8",
        borderLineWidth: 1
      }
    };
    return ChartModeHandle2;
  }(Component)
);

// node_modules/@antv/component/esm/ui/timebar/utils.js
function labelFormatter(time, interval2) {
  if (typeof time === "number") {
    return parseBySeries(time);
  }
  return parseByTime(time, interval2);
}
function parseByTime(time, interval2) {
  var date = new Date(time);
  switch (interval2) {
    case "half-hour":
    case "hour":
    case "four-hour":
      if ([0, 6, 12, 18].includes(date.getHours()) && date.getMinutes() === 0) {
        return formatTime(date, "HH:mm\nYYYY-MM-DD");
      }
      return formatTime(date, "HH:mm");
    case "half-day":
      if (date.getHours() < 12) {
        return "AM\n".concat(formatTime(date, "YYYY-MM-DD"));
      }
      return "PM";
    case "day":
      if ([1, 10, 20].includes(date.getDate())) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "week":
      if (date.getDate() <= 7) {
        return formatTime(date, "DD\nYYYY-MM");
      }
      return formatTime(date, "DD");
    case "month":
      if ([0, 6].includes(date.getMonth())) {
        return formatTime(date, "MM\nYYYY");
      }
      return formatTime(date, "MM");
    case "season":
      if ([0].includes(date.getMonth())) {
        return formatTime(date, "MM\nYYYY");
      }
      return formatTime(date, "MM");
    case "year":
      return formatTime(date, "YYYY");
    default:
      return formatTime(date, "YYYY-MM-DD HH:mm");
  }
}
function parseBySeries(time) {
  var hours = String(Math.floor(time / 3600)).padStart(2, "0");
  var minutes = String(Math.floor(time % 3600 / 60)).padStart(2, "0");
  var seconds = String(Math.floor(time % 60)).padStart(2, "0");
  if (time < 3600) {
    return "".concat(minutes, ":").concat(seconds);
  }
  return "".concat(hours, ":").concat(minutes, ":").concat(seconds);
}

// node_modules/@antv/component/esm/ui/timebar/timebar.js
var Timebar = (
  /** @class */
  function(_super) {
    __extends(Timebar2, _super);
    function Timebar2(options) {
      var _this2 = _super.call(this, deepAssign2({}, Timebar2.defaultOptions, options)) || this;
      _this2.axis = _this2.appendChild(new Axis({
        style: { type: "linear", startPos: [0, 0], endPos: [0, 0], data: [], showArrow: false, animate: false }
      }));
      _this2.timeline = _this2.appendChild(new Slider({
        style: {
          onChange: function(values5) {
            _this2.handleSliderChange(values5);
          }
        }
      }));
      _this2.controller = _this2.appendChild(new Controller({}));
      _this2.states = {};
      _this2.handleSliderChange = function(values5) {
        var prevValues = function() {
          var val = _this2.states.values;
          if (Array.isArray(val))
            return __spreadArray([], __read(val), false);
          return val;
        }();
        _this2.setBySliderValues(values5);
        _this2.dispatchOnChange(prevValues);
      };
      var _a2 = _this2.attributes, selectionType = _a2.selectionType, chartType = _a2.chartType, speed = _a2.speed, state = _a2.state, playMode = _a2.playMode, values4 = _a2.values;
      _this2.states = { chartType, playMode, selectionType, speed, state };
      _this2.setByTimebarValues(values4);
      return _this2;
    }
    Object.defineProperty(Timebar2.prototype, "data", {
      get: function() {
        var data2 = this.attributes.data;
        var compareFn = function(a5, b) {
          if (a5.time < b.time)
            return -1;
          if (a5.time > b.time)
            return 1;
          return 0;
        };
        return data2.sort(compareFn);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "space", {
      /**  */
      get: function() {
        var _a2 = this.attributes, x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height, type = _a2.type, controllerHeight = _a2.controllerHeight;
        var availableTimelineHeight = clamp_default(+height - controllerHeight, 0, +height);
        var controllerBBox = new BBox(x3, y4 + +height - controllerHeight, +width, controllerHeight);
        var axisBBox;
        var axisHeight = 0;
        if (type === "chart") {
          axisHeight = 35;
          axisBBox = new BBox(x3, y4 + availableTimelineHeight - axisHeight, +width, axisHeight);
        } else
          axisBBox = new BBox();
        var timelineHeight = type === "time" ? 10 : availableTimelineHeight;
        var timelineBBox = new BBox(x3, y4 + (type === "time" ? availableTimelineHeight : availableTimelineHeight - timelineHeight), +width, timelineHeight - axisHeight);
        return { axisBBox, controllerBBox, timelineBBox };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.setBySliderValues = function(val) {
      var _a2, _b;
      var data2 = this.data;
      var _c = __read(Array.isArray(val) ? val : [0, val], 2), startRatio = _c[0], endRatio = _c[1];
      var length5 = data2.length;
      var startDatum = data2[Math.floor(startRatio * length5)];
      var endDatum = data2[Math.ceil(endRatio * length5) - (Array.isArray(val) ? 0 : 1)];
      this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : data2[0].time, (_b = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _b !== void 0 ? _b : Infinity];
    };
    Timebar2.prototype.setByTimebarValues = function(val) {
      var _a2, _b, _c;
      var data2 = this.data;
      var _d = __read(Array.isArray(val) ? val : [void 0, val], 2), start = _d[0], end = _d[1];
      var startDatum = data2.find(function(_a3) {
        var time = _a3.time;
        return time === start;
      });
      var endDatum = data2.find(function(_a3) {
        var time = _a3.time;
        return time === end;
      });
      this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : (_b = data2[0]) === null || _b === void 0 ? void 0 : _b.time, (_c = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _c !== void 0 ? _c : Infinity];
    };
    Timebar2.prototype.setByIndex = function(index3) {
      var _a2, _b, _c, _d;
      var data2 = this.data;
      var _e = __read(index3, 2), startIndex = _e[0], endIndex = _e[1];
      this.states.values = [(_b = (_a2 = data2[startIndex]) === null || _a2 === void 0 ? void 0 : _a2.time) !== null && _b !== void 0 ? _b : data2[0].time, (_d = (_c = this.data[endIndex]) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : Infinity];
    };
    Object.defineProperty(Timebar2.prototype, "sliderValues", {
      /**
       *  timebar  values
       */
      get: function() {
        var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(Array.isArray(values4) ? values4 : [void 0, values4], 2), start = _b[0], end = _b[1];
        var data2 = this.data;
        var length5 = data2.length;
        var isValue = selectionType === "value";
        var getStartValue = function() {
          var startDatumIndex = data2.findIndex(function(_a3) {
            var time = _a3.time;
            return time === start;
          });
          if (isValue)
            return 0;
          if (startDatumIndex > -1)
            return startDatumIndex / length5;
          return 0;
        };
        var getEndValue = function() {
          if (end === Infinity)
            return 1;
          var endDatumIndex = data2.findIndex(function(_a3) {
            var time = _a3.time;
            return time === end;
          });
          if (endDatumIndex > -1)
            return endDatumIndex / length5;
          if (isValue)
            return 0.5;
          return 1;
        };
        return [getStartValue(), getEndValue()];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Timebar2.prototype, "values", {
      get: function() {
        var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(Array.isArray(values4) ? values4 : [this.data[0].time, values4], 2), start = _b[0], end = _b[1];
        if (selectionType === "value")
          return end;
        return [start, end];
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getDatumByRatio = function(ratio) {
      var data2 = this.data;
      var length5 = data2.length;
      var index3 = Math.floor(ratio * (length5 - 1));
      return data2[index3];
    };
    Object.defineProperty(Timebar2.prototype, "chartHandleIconShape", {
      get: function() {
        var selectionType = this.states.selectionType;
        var height = this.space.timelineBBox.height;
        if (selectionType === "range")
          return function(type) {
            return new ChartModeHandle({ style: { type, height, iconSize: height / 6 } });
          };
        return function() {
          return new Line({ style: { x1: 0, y1: -height / 2, x2: 0, y2: height / 2, lineWidth: 2, stroke: "#c8c8c8" } });
        };
      },
      enumerable: false,
      configurable: true
    });
    Timebar2.prototype.getChartStyle = function(bbox) {
      var _this2 = this;
      var x3 = bbox.x, y4 = bbox.y, width = bbox.width, height = bbox.height;
      var _a2 = this.states, selectionType = _a2.selectionType, chartType = _a2.chartType;
      var data2 = this.data;
      var _b = this.attributes, type = _b.type, userDefinedLabelFormatter = _b.labelFormatter;
      var _c = subStyleProps(this.attributes, "chart"), ignoreType = _c.type, userDefinedChartStyle = __rest(_c, ["type"]);
      var isRange = selectionType === "range";
      if (type === "time") {
        return __assign({
          handleIconShape: function() {
            return new TimeModeHandle({});
          },
          selectionFill: "#2e7ff8",
          selectionFillOpacity: 1,
          showLabelOnInteraction: true,
          handleLabelDy: isRange ? -15 : 0,
          autoFitLabel: isRange,
          handleSpacing: isRange ? -15 : 0,
          trackFill: "#edeeef",
          trackLength: width,
          trackOpacity: 0.5,
          trackRadius: height / 2,
          trackSize: height / 2,
          type: selectionType,
          values: this.sliderValues,
          formatter: function(value2) {
            if (userDefinedLabelFormatter)
              return userDefinedLabelFormatter(value2);
            var time = _this2.getDatumByRatio(value2).time;
            if (typeof time === "number")
              return parseBySeries(time);
            return formatTime(time, "YYYY-MM-DD HH:mm:ss");
          },
          transform: "translate(".concat(x3, ", ").concat(y4, ")"),
          // x,
          // y,
          zIndex: 1
        }, userDefinedChartStyle);
      }
      var handleIconOffset = selectionType === "range" ? 5 : 0;
      var sparklineData = data2.map(function(_a3) {
        var value2 = _a3.value;
        return value2;
      });
      return __assign({
        handleIconOffset,
        handleIconShape: this.chartHandleIconShape,
        selectionFill: "#fff",
        selectionFillOpacity: 0.5,
        selectionType: "invert",
        sparklineSpacing: 0.1,
        sparklineColumnLineWidth: 0,
        sparklineColor: "#d4e5fd",
        sparklineAreaOpacity: 1,
        sparklineAreaLineWidth: 0,
        sparklineData,
        sparklineType: chartType,
        sparklineScale: 0.8,
        trackLength: width,
        trackSize: height,
        type: selectionType,
        values: this.sliderValues,
        // x,
        // y,
        transform: "translate(".concat(x3, ", ").concat(y4, ")"),
        zIndex: 1
      }, userDefinedChartStyle);
    };
    Timebar2.prototype.renderChart = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.timelineBBox;
      }
      this.timeline.update(this.getChartStyle(bbox));
    };
    Timebar2.prototype.updateSelection = function() {
      this.timeline.setValues(this.sliderValues, true);
      this.handleSliderChange(this.sliderValues);
    };
    Timebar2.prototype.getAxisStyle = function(bbox) {
      var data2 = this.data;
      var _a2 = this.attributes, interval2 = _a2.interval, userDefinedLabelFormatter = _a2.labelFormatter;
      var userDefinedAxisStyle = subStyleProps(this.attributes, "axis");
      var x3 = bbox.x, y4 = bbox.y, width = bbox.width;
      var axisData = __spreadArray(__spreadArray([], __read(data2), false), [{ time: 0 }], false).map(function(_a3, index3, arr) {
        var time = _a3.time;
        return {
          label: "".concat(time),
          value: index3 / (arr.length - 1),
          time
        };
      });
      var style = __assign({
        startPos: [x3, y4],
        endPos: [x3 + width, y4],
        data: axisData,
        // hide last label
        labelFilter: function(_datum, index3) {
          return index3 < axisData.length - 1;
        },
        labelFormatter: function(_a3) {
          var time = _a3.time;
          return userDefinedLabelFormatter ? userDefinedLabelFormatter(time) : labelFormatter(time, interval2);
        }
      }, userDefinedAxisStyle);
      return style;
    };
    Timebar2.prototype.renderAxis = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.axisBBox;
      }
      var type = this.attributes.type;
      if (type !== "chart")
        return;
      this.axis.update(this.getAxisStyle(bbox));
    };
    Timebar2.prototype.renderController = function(bbox) {
      if (bbox === void 0) {
        bbox = this.space.controllerBBox;
      }
      var type = this.attributes.type;
      var _a2 = this.states, state = _a2.state, speed = _a2.speed, selectionType = _a2.selectionType, chartType = _a2.chartType;
      var userDefinedControllerStyle = subStyleProps(this.attributes, "controller");
      var that = this;
      var style = __assign(__assign(__assign({}, bbox), { iconSize: 20, speed, state, selectionType, chartType, onChange: function(type2, _a3) {
        var value2 = _a3.value;
        switch (type2) {
          case "reset":
            that.internalReset();
            break;
          case "speed":
            that.handleSpeedChange(value2);
            break;
          case "backward":
            that.internalBackward();
            break;
          case "playPause":
            if (value2 === "play")
              that.internalPlay();
            else
              that.internalPause();
            break;
          case "forward":
            that.internalForward();
            break;
          case "selectionType":
            that.handleSelectionTypeChange(value2);
            break;
          case "chartType":
            that.handleChartTypeChange(value2);
            break;
          default:
            break;
        }
      } }), userDefinedControllerStyle);
      if (type === "time") {
        style.functions = [["reset", "speed"], ["backward", "playPause", "forward"], ["selectionType"]];
      }
      this.controller.update(style);
    };
    Timebar2.prototype.dispatchOnChange = function(prevValues) {
      var data2 = this.data;
      var onChange = this.attributes.onChange;
      var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType;
      var _b = __read(values4, 2), start = _b[0], end = _b[1];
      var endTime = end === Infinity ? data2.at(-1).time : end;
      var newValues = selectionType === "range" ? [start, endTime] : endTime;
      var isEqual3 = function(val1, val2) {
        if (Array.isArray(val1)) {
          if (!Array.isArray(val2))
            return false;
          if (val1[0] === val2[0]) {
            if (val1[1] === val2[1])
              return true;
            if (val1[1] === Infinity || val2[1] === Infinity)
              return true;
          }
          return false;
        }
        if (Array.isArray(val2))
          return false;
        return val1 === val2;
      };
      if (!prevValues || !isEqual3(prevValues, newValues)) {
        onChange === null || onChange === void 0 ? void 0 : onChange(selectionType === "range" ? [start, endTime] : endTime);
      }
    };
    Timebar2.prototype.internalReset = function(preventEvent) {
      var _a2, _b;
      var selectionType = this.states.selectionType;
      this.internalPause();
      this.setBySliderValues(selectionType === "range" ? [0, 1] : [0, 0]);
      this.renderController();
      this.updateSelection();
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onReset) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
    };
    Timebar2.prototype.reset = function() {
      this.internalReset();
    };
    Timebar2.prototype.moveSelection = function(direction3, preventEvent) {
      var data2 = this.data;
      var length5 = data2.length;
      var _a2 = this.states, values4 = _a2.values, selectionType = _a2.selectionType, playMode = _a2.playMode;
      var _b = __read(values4, 2), startTime = _b[0], endTime = _b[1];
      var startIndex = data2.findIndex(function(_a3) {
        var time = _a3.time;
        return time === startTime;
      });
      var endIndex = data2.findIndex(function(_a3) {
        var time = _a3.time;
        return time === endTime;
      });
      if (endIndex === -1)
        endIndex = length5;
      var diff = direction3 === "backward" ? -1 : 1;
      var currentIndexes;
      if (selectionType === "range") {
        if (playMode === "acc") {
          currentIndexes = [startIndex, endIndex + diff];
          if (diff === -1 && startIndex === endIndex) {
            currentIndexes = [startIndex, length5];
          }
        } else
          currentIndexes = [startIndex + diff, endIndex + diff];
      } else
        currentIndexes = [startIndex, endIndex + diff];
      var normalizeIndexes = function(indexes2) {
        var _a3 = __read(indexes2.sort(function(a5, b) {
          return a5 - b;
        }), 2), start = _a3[0], end = _a3[1];
        var clampIndex = function(index3) {
          return clamp_default(index3, 0, length5);
        };
        if (end > length5) {
          if (selectionType === "value")
            return [0, 0];
          if (playMode === "acc")
            return [clampIndex(start), clampIndex(start)];
          return [0, clampIndex(end - start)];
        }
        if (start < 0) {
          if (playMode === "acc")
            return [0, clampIndex(end)];
          return [clampIndex(start + length5 - end), length5];
        }
        return [clampIndex(start), clampIndex(end)];
      };
      var normalizedIndexes = normalizeIndexes(currentIndexes);
      this.setByIndex(normalizedIndexes);
      this.updateSelection();
      return normalizedIndexes;
    };
    Timebar2.prototype.internalBackward = function(preventEvent) {
      var _a2, _b;
      var indexes2 = this.moveSelection("backward", preventEvent);
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onBackward) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
      return indexes2;
    };
    Timebar2.prototype.backward = function() {
      this.internalBackward();
    };
    Timebar2.prototype.internalPlay = function(preventEvent) {
      var _this2 = this;
      var _a2, _b;
      var data2 = this.data;
      var loop = this.attributes.loop;
      var _c = this.states.speed, speed = _c === void 0 ? 1 : _c;
      this.playInterval = window.setInterval(function() {
        var indexes2 = _this2.internalForward();
        if (indexes2[1] === data2.length && !loop) {
          _this2.internalPause();
          _this2.renderController();
        }
      }, 1e3 / speed);
      this.states.state = "play";
      !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPlay) === null || _b === void 0 ? void 0 : _b.call(_a2));
    };
    Timebar2.prototype.play = function() {
      this.internalPlay();
    };
    Timebar2.prototype.internalPause = function(preventEvent) {
      var _a2, _b;
      clearInterval(this.playInterval);
      this.states.state = "pause";
      !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPause) === null || _b === void 0 ? void 0 : _b.call(_a2));
    };
    Timebar2.prototype.pause = function() {
      this.internalPause();
    };
    Timebar2.prototype.internalForward = function(preventEvent) {
      var _a2, _b;
      var indexes2 = this.moveSelection("forward", preventEvent);
      if (!preventEvent) {
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onForward) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.dispatchOnChange();
      }
      return indexes2;
    };
    Timebar2.prototype.forward = function() {
      this.internalForward();
    };
    Timebar2.prototype.handleSpeedChange = function(value2) {
      var _a2, _b;
      this.states.speed = value2;
      var state = this.states.state;
      if (state === "play") {
        this.internalPause(true);
        this.internalPlay(true);
      }
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSpeedChange) === null || _b === void 0 ? void 0 : _b.call(_a2, value2);
    };
    Timebar2.prototype.handleSelectionTypeChange = function(type) {
      var _a2, _b;
      this.states.selectionType = type;
      this.renderChart();
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSelectionTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
    };
    Timebar2.prototype.handleChartTypeChange = function(type) {
      var _a2, _b;
      this.states.chartType = type;
      this.renderChart();
      (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onChartTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
    };
    Timebar2.prototype.render = function() {
      var _a2 = this.space, axisBBox = _a2.axisBBox, controllerBBox = _a2.controllerBBox, timelineBBox = _a2.timelineBBox;
      this.renderController(controllerBBox);
      this.renderAxis(axisBBox);
      this.renderChart(timelineBBox);
      if (this.states.state === "play")
        this.internalPlay();
    };
    Timebar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.internalPause(true);
    };
    Timebar2.defaultOptions = {
      style: {
        x: 0,
        y: 0,
        axisLabelFill: "#6e6e6e",
        axisLabelTextAlign: "left",
        axisLabelTextBaseline: "top",
        axisLabelTransform: "translate(5, -12)",
        axisLineLineWidth: 1,
        axisLineStroke: "#cacdd1",
        axisTickLength: 15,
        axisTickLineWidth: 1,
        axisTickStroke: "#cacdd1",
        chartShowLabel: false,
        chartType: "line",
        controllerAlign: "center",
        controllerHeight: 40,
        data: [],
        interval: "day",
        loop: false,
        playMode: "acc",
        selectionType: "range",
        type: "time"
      }
    };
    return Timebar2;
  }(Component)
);

// node_modules/@antv/g2/esm/shape/text/advance.js
var __rest21 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getConnectorPoint(shape23) {
  const { min: [x05, y05], max: [x12, y12] } = shape23.getLocalBounds();
  let x3 = 0;
  let y4 = 0;
  if (x05 > 0)
    x3 = x05;
  if (x12 < 0)
    x3 = x12;
  if (y05 > 0)
    y4 = y05;
  if (y12 < 0)
    y4 = y12;
  return [x3, y4];
}
function inferBackgroundBounds(textShape, padding = []) {
  const [top = 0, right2 = 0, bottom = top, left2 = right2] = padding;
  const container = textShape.parentNode;
  const angle4 = container.getEulerAngles();
  container.setEulerAngles(0);
  const { min: min10, halfExtents } = textShape.getLocalBounds();
  const [x3, y4] = min10;
  const [hw, hh] = halfExtents;
  container.setEulerAngles(angle4);
  return {
    x: x3 - left2,
    y: y4 - top,
    width: hw * 2 + left2 + right2,
    height: hh * 2 + top + bottom
  };
}
function inferConnectorPath(shape23, end, control, coordCenter, left2 = true, top = true) {
  const path2 = (points) => line_default()(points);
  if (!end[0] && !end[1])
    return path2([getConnectorPoint(shape23), end]);
  if (!control.length)
    return path2([[0, 0], end]);
  const [inflection, start] = control;
  const p1 = [...start];
  const p22 = [...inflection];
  if (start[0] !== inflection[0]) {
    const offset2 = left2 ? -4 : 4;
    p1[1] = start[1];
    if (top && !left2) {
      p1[0] = Math.max(inflection[0], start[0] - offset2);
      if (start[1] < inflection[1]) {
        p22[1] = p1[1];
      } else {
        p22[1] = inflection[1];
        p22[0] = Math.max(p22[0], p1[0] - offset2);
      }
    }
    if (!top && !left2) {
      p1[0] = Math.max(inflection[0], start[0] - offset2);
      if (start[1] > inflection[1]) {
        p22[1] = p1[1];
      } else {
        p22[1] = inflection[1];
        p22[0] = Math.max(p22[0], p1[0] - offset2);
      }
    }
    if (!top && left2) {
      p1[0] = Math.min(inflection[0], start[0] - offset2);
      if (start[1] > inflection[1]) {
        p22[1] = p1[1];
      } else {
        p22[1] = inflection[1];
        p22[0] = Math.min(p22[0], p1[0] - offset2);
      }
    }
    if (top && left2) {
      p1[0] = Math.min(inflection[0], start[0] - offset2);
      if (start[1] < inflection[1]) {
        p22[1] = p1[1];
      } else {
        p22[1] = inflection[1];
        p22[0] = Math.min(p22[0], p1[0] - offset2);
      }
    }
  }
  return path2([start, p1, p22, inflection, end]);
}
var Advance = createElement((g) => {
  const _a2 = g.attributes, {
    className: className2,
    // Do not pass className
    class: _c,
    transform: transform2,
    rotate: rotate7,
    labelTransform,
    labelTransformOrigin,
    x: x3,
    y: y4,
    x0: x05 = x3,
    y0: y05 = y4,
    text,
    background,
    connector,
    startMarker,
    endMarker,
    coordCenter,
    innerHTML
  } = _a2, rest = __rest21(_a2, ["className", "class", "transform", "rotate", "labelTransform", "labelTransformOrigin", "x", "y", "x0", "y0", "text", "background", "connector", "startMarker", "endMarker", "coordCenter", "innerHTML"]);
  g.style.transform = `translate(${x3}, ${y4})`;
  if ([x3, y4, x05, y05].some((v) => !isNumber(v))) {
    g.children.forEach((d4) => d4.remove());
    return;
  }
  const _b = subObject(rest, "background"), { padding } = _b, backgroundStyle = __rest21(_b, ["padding"]);
  const _d = subObject(rest, "connector"), { points: controlPoints2 = [] } = _d, connectorStyle = __rest21(_d, ["points"]);
  let textShape;
  if (innerHTML) {
    textShape = select(g).maybeAppend("html", "html", className2).style("zIndex", 0).style("innerHTML", innerHTML).call(applyStyle, Object.assign({ transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
  } else {
    textShape = select(g).maybeAppend("text", "text").style("zIndex", 0).style("text", text).call(applyStyle, Object.assign({ textBaseline: "middle", transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
  }
  const rect4 = select(g).maybeAppend("background", "rect").style("zIndex", -1).call(applyStyle, inferBackgroundBounds(textShape, padding)).call(applyStyle, background ? backgroundStyle : {}).node();
  const left2 = +x05 < coordCenter[0];
  const top = +y05 < coordCenter[1];
  const end = [+x05 - +x3, +y05 - +y4];
  const connectorPath = inferConnectorPath(rect4, end, controlPoints2, coordCenter, left2, top);
  const markerStart = startMarker && new Marker({
    id: "startMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest, "startMarker"))
  });
  const markerEnd = endMarker && new Marker({
    id: "endMarker",
    style: Object.assign({ x: 0, y: 0 }, subObject(rest, "endMarker"))
  });
  select(g).maybeAppend("connector", "path").style("zIndex", 0).style("d", connectorPath).style("markerStart", markerStart).style("markerEnd", markerEnd).call(applyStyle, connector ? connectorStyle : {});
});

// node_modules/@antv/g2/esm/shape/text/text.js
var Text3 = (options, context) => {
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: color3, text = "", fontSize, rotate: rotate7 = 0, transform: transform2 = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color3,
      fill: color3,
      fontSize
    };
    const [[x05, y05]] = points;
    return select(new Advance()).style("x", x05).style("y", y05).call(applyStyle, defaults4).style("transform", `${transform2}rotate(${+rotate7})`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
  };
};
Text3.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/badge.js
var __rest22 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getPath(r2) {
  const offset2 = r2 / Math.sqrt(2);
  const dy = r2 * Math.sqrt(2);
  const [p0x, p0y] = [-offset2, offset2 - dy];
  const [p1x, p1y] = [0, 0];
  const [p2x, p2y] = [offset2, offset2 - dy];
  return [
    ["M", p0x, p0y],
    ["A", r2, r2, 0, 1, 1, p2x, p2y],
    ["L", p1x, p1y],
    ["Z"]
  ];
}
function inferTextPosition(shape23) {
  const { min: min10, max: max11 } = shape23.getLocalBounds();
  return [(min10[0] + max11[0]) * 0.5, (min10[1] + max11[1]) * 0.5];
}
var BadgeShape = createElement((g) => {
  const _a2 = g.attributes, { class: className2, x: x05, y: y05, transform: transform2 } = _a2, rest = __rest22(_a2, ["class", "x", "y", "transform"]);
  const markerStyle = subObject(rest, "marker");
  const { size: size3 = 24 } = markerStyle;
  const symbol = () => getPath(size3 / 2);
  const bgShape = select(g).maybeAppend("marker", () => new Marker({})).call((selection) => selection.node().update(Object.assign({ symbol }, markerStyle))).node();
  const [x3, y4] = inferTextPosition(bgShape);
  select(g).maybeAppend("text", "text").style("x", x3).style("y", y4).call(applyStyle, rest);
});
var Badge = (options, context) => {
  const style = __rest22(options, []);
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest22(defaults4, ["color"]);
    const { color: color3 = defaultColor, text = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color3,
      fill: color3
    };
    const [[x05, y05]] = points;
    return select(new BadgeShape()).call(applyStyle, rest).style("transform", `translate(${x05},${y05})`).call(applyStyle, textStyle).call(applyStyle, style).node();
  };
};
Badge.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/text/tag.js
var Tag2 = (options, context) => {
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: color3, text = "", fontSize, rotate: rotate7 = 0, transform: transform2 = "" } = value2;
    const textStyle = {
      text: String(text),
      stroke: color3,
      fill: color3,
      fontSize,
      textAlign: "center",
      textBaseline: "middle"
    };
    const [[x05, y05]] = points;
    const n2 = select(new Text()).style("x", x05).style("y", y05).call(applyStyle, defaults4).style("transformOrigin", "center center").style("transform", `${transform2}rotate(${rotate7}deg)`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
    return n2;
  };
};
Tag2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/curve.js
var __rest23 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function segmentation2(points, defined4) {
  const definedPointsY1 = [];
  const definedPointsY0 = [];
  const segments = [];
  let m3 = false;
  let dp = null;
  const mid2 = points.length / 2;
  for (let i2 = 0; i2 < mid2; i2++) {
    const y12 = points[i2];
    const y05 = points[i2 + mid2];
    if ([...y12, ...y05].some((v) => !defined4(v)))
      m3 = true;
    else {
      definedPointsY1.push(y12);
      definedPointsY0.push(y05);
      if (m3 && dp) {
        m3 = false;
        const [dpy1, dpy0] = dp;
        segments.push([dpy1, y12, dpy0, y05]);
      }
      dp = [y12, y05];
    }
  }
  return [definedPointsY1.concat(definedPointsY0), segments];
}
var DoubleArea = createElement((g) => {
  const { areaPath, connectPath, areaStyle, connectStyle } = g.attributes;
  const document2 = g.ownerDocument;
  select(g).maybeAppend("connect-path", () => document2.createElement("path", {})).style("d", connectPath).call(applyStyle, connectStyle);
  select(g).maybeAppend("area-path", () => document2.createElement("path", {})).style("d", areaPath).call(applyStyle, areaStyle);
});
var Curve2 = (options, context) => {
  const { curve, gradient: gradient2 = false, defined: defined4 = (d4) => !Number.isNaN(d4) && d4 !== void 0 && d4 !== null, connect: connectNulls = false } = options, style = __rest23(options, ["curve", "gradient", "defined", "connect"]);
  const { coordinate, document: document2 } = context;
  return (P, value2, defaults4) => {
    const { color: defaultColor } = defaults4;
    const { color: color3 = defaultColor, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
    const tpShape = isTranspose(coordinate);
    const transform2 = getTransform(coordinate, value2);
    const fill = gradient2 && sc ? computeGradient(sc, sx, sy, gradient2, void 0, tpShape) : color3;
    const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, defaults4), { stroke: fill, fill }), transform2 && { transform: transform2 }), style);
    const [DP, MS] = segmentation2(P, defined4);
    const connectStyle = subObject(finalStyle, "connect");
    const missing = !!MS.length;
    const getPathNode = (path2) => {
      return select(document2.createElement("path", {})).style("d", path2 || "").call(applyStyle, finalStyle).node();
    };
    if (!isPolar(coordinate)) {
      const areaPath = (points) => {
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return tpShape ? area_default().y((_2, idx) => Y12[idx][1]).x1((_2, idx) => Y12[idx][0]).x0((_2, idx) => Y02[idx][0]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12) : area_default().x((_2, idx) => Y12[idx][0]).y1((_2, idx) => Y12[idx][1]).y0((_2, idx) => Y02[idx][1]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaPath(P)).style("connectPath", MS.map(areaPath).join("")).node();
    } else {
      const areaRadialPath = (points) => {
        const center2 = coordinate.getCenter();
        const Y12 = points.slice(0, points.length / 2);
        const Y02 = points.slice(points.length / 2);
        return areaRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(Y12[idx], center2))).outerRadius((_2, idx) => dist4(Y12[idx], center2)).innerRadius((_2, idx) => dist4(Y02[idx], center2)).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y02);
      };
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return getPathNode(areaRadialPath(DP));
      }
      if (missing && !connectNulls) {
        return getPathNode(areaRadialPath(P));
      }
      return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaRadialPath(P)).style("connectPath", MS.map(areaRadialPath).join("")).node();
    }
  };
};
Curve2.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/area/area.js
var Area = (options, context) => {
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
    return Curve2(Object.assign({ curve }, options), context)(...params);
  };
};
Area.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "square" });

// node_modules/@antv/g2/esm/shape/area/smooth.js
var __rest24 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Smooth2 = (options, context) => {
  const rest = __rest24(options, []);
  const { coordinate } = context;
  return (...params) => {
    const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
    return Curve2(Object.assign({ curve }, rest), context)(...params);
  };
};
Smooth2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "smooth" });

// node_modules/@antv/g2/esm/shape/area/hvh.js
var HVH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: step_default }, options), context)(...params);
  };
};
HVH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hvh" });

// node_modules/@antv/g2/esm/shape/area/vh.js
var VH2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepBefore }, options), context)(...params);
  };
};
VH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "vh" });

// node_modules/@antv/g2/esm/shape/area/hv.js
var HV2 = (options, context) => {
  return (...params) => {
    return Curve2(Object.assign({ curve: stepAfter }, options), context)(...params);
  };
};
HV2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hv" });

// node_modules/@antv/g2/esm/shape/link/link.js
var Link = (options, context) => {
  const { arrow: arrow2 = false } = options;
  return (...params) => {
    return Vector(Object.assign(Object.assign({}, options), { arrow: arrow2 }), context)(...params);
  };
};
Link.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/smooth.js
var __rest25 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Smooth3 = (options, context) => {
  const style = __rest25(options, []);
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest25(defaults4, ["color"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    path2.bezierCurveTo(from[0] / 2 + to[0] / 2, from[1], from[0] / 2 + to[0] / 2, to[1], to[0], to[1]);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("transform", transform2).call(applyStyle, style).node();
  };
};
Smooth3.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/vhv.js
var __rest26 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getVHVPath(from, to, coordinate, ratio) {
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const a5 = dist4(from, center2);
    const b = dist4(to, center2);
    const radius = (b - a5) * ratio + a5;
    path2.moveTo(from[0], from[1]);
    appendArc(path2, from, to, center2, radius);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  if (isTranspose(coordinate)) {
    path2.moveTo(from[0], from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, from[1]);
    path2.lineTo(from[0] + (to[0] - from[0]) * ratio, to[1]);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  path2.moveTo(from[0], from[1]);
  path2.lineTo(from[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], from[1] + (to[1] - from[1]) * ratio);
  path2.lineTo(to[0], to[1]);
  return path2;
}
var VHV = (options, context) => {
  const { cornerRatio = 1 / 3 } = options, style = __rest26(options, ["cornerRatio"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { defaultColor } = defaults4, rest = __rest26(defaults4, ["defaultColor"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = getVHVPath(from, to, coordinate, cornerRatio);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("transform", transform2).call(applyStyle, style).node();
  };
};
VHV.props = {
  defaultMarker: "vhv",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/link/arc.js
var __rest27 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Arc = (options, context) => {
  const style = __rest27(options, []);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest27(defaults4, ["color"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const [from, to] = points;
    const path2 = path();
    path2.moveTo(from[0], from[1]);
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      path2.quadraticCurveTo(center2[0], center2[1], to[0], to[1]);
    } else {
      const center2 = mid(from, to);
      const raduis = dist4(from, to) / 2;
      appendArc(path2, from, to, center2, raduis);
    }
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("transform", transform2).call(applyStyle, style).node();
  };
};
Arc.props = {
  defaultMarker: "smooth",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/mark/utils.js
function baseChannels(options = {}) {
  const { shapes } = options;
  return [
    { name: "color" },
    { name: "opacity" },
    { name: "shape", range: shapes },
    { name: "enterType" },
    { name: "enterDelay", scaleKey: "enter" },
    { name: "enterDuration", scaleKey: "enter" },
    { name: "enterEasing" },
    { name: "key", scale: "identity" },
    { name: "groupKey", scale: "identity" },
    { name: "label", scale: "identity" }
  ];
}
function baseGeometryChannels(options = {}) {
  return [...baseChannels(options), { name: "title", scale: "identity" }];
}
function tooltip2d() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["x", "y"] }
  ];
}
function tooltip1d() {
  return [
    { type: MaybeTitle, channel: "x" },
    { type: MaybeTooltip, channel: ["y"] }
  ];
}
function tooltipXd() {
  return [
    { type: MaybeTitle, channel: "color" },
    { type: MaybeTooltip, channel: ["position"] }
  ];
}
function baseAnnotationChannels(options = {}) {
  return baseChannels(options);
}
function basePreInference() {
  return [{ type: MaybeKey }];
}
function basePostInference() {
  return [];
}
function bandWidth(scale12, x3) {
  return scale12.getBandWidth(scale12.invert(x3));
}
function createBandOffset(scale12, value2, options = {}) {
  const { x: X, y: Y, series: S } = value2;
  const { x: x3, y: y4, series } = scale12;
  const { style: { bandOffset = series ? 0 : 0.5, bandOffsetX = bandOffset, bandOffsetY = bandOffset } = {} } = options;
  const isBandX = !!(x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth);
  const isBandY = !!(y4 === null || y4 === void 0 ? void 0 : y4.getBandWidth);
  const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);
  if (!isBandX && !isBandY)
    return (d4) => d4;
  return (d4, i2) => {
    const widthX = isBandX ? bandWidth(x3, X[i2]) : 0;
    const widthY = isBandY ? bandWidth(y4, Y[i2]) : 0;
    const f2 = () => (bandWidth(series, S[i2]) / 2 + +S[i2]) * widthX;
    const offset2 = isSeries && S ? f2() : 0;
    const [x05, y05] = d4;
    return [x05 + bandOffsetX * widthX + offset2, y05 + bandOffsetY * widthY];
  };
}
function p(d4) {
  return parseFloat(d4) / 100;
}
function visualMark(index3, scale12, value2, coordinate) {
  const { x: X, y: Y } = value2;
  const { innerWidth, innerHeight } = coordinate.getOptions();
  const P = Array.from(index3, (i2) => {
    const x05 = X[i2];
    const y05 = Y[i2];
    const x3 = typeof x05 === "string" ? p(x05) * innerWidth : +x05;
    const y4 = typeof y05 === "string" ? p(y05) * innerHeight : +y05;
    return [[x3, y4]];
  });
  return [index3, P];
}
function field(encode) {
  return typeof encode === "function" ? encode : (d4) => d4[encode];
}
function valueof(data2, encode) {
  return Array.from(data2, field(encode));
}
function initializeData(data2, encode) {
  const { source = (d4) => d4.source, target = (d4) => d4.target, value: value2 = (d4) => d4.value } = encode;
  const { links, nodes } = data2;
  const LS = valueof(links, source);
  const LT = valueof(links, target);
  const LV = valueof(links, value2);
  return {
    links: links.map((_2, i2) => ({
      target: LT[i2],
      source: LS[i2],
      value: LV[i2]
    })),
    nodes: nodes || Array.from(/* @__PURE__ */ new Set([...LS, ...LT]), (key) => ({ key }))
  };
}

// node_modules/@antv/g2/esm/shape/image/image.js
var __rest28 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Image3 = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest28(defaults4, ["color"]);
    const { color: color3 = defaultColor, src = "", size: size3 = 32, transform: transform2 = "" } = value2;
    let { width = size3, height = size3 } = options;
    const [[x05, y05]] = points;
    const [w2, h2] = coordinate.getSize();
    width = typeof width === "string" ? p(width) * w2 : width;
    height = typeof height === "string" ? p(height) * h2 : height;
    const x3 = x05 - Number(width) / 2;
    const y4 = y05 - Number(height) / 2;
    return select(document2.createElement("image", {})).call(applyStyle, rest).style("x", x3).style("y", y4).style("src", src).style("stroke", color3).style("transform", transform2).call(applyStyle, options).style("width", width).style("height", height).node();
  };
};
Image3.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/polygon.js
var __rest29 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getPolygonPath(points, coordinate) {
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const closedPoints = [...points, points[0]];
    const dists = closedPoints.map((p3) => dist4(p3, center2));
    closedPoints.forEach((curr, idx) => {
      if (idx === 0) {
        path2.moveTo(curr[0], curr[1]);
        return;
      }
      const currDist = dists[idx];
      const prev = points[idx - 1];
      const prevDist = dists[idx - 1];
      if (prevDist !== void 0 && Math.abs(currDist - prevDist) < 1e-10) {
        appendArc(path2, prev, curr, center2, currDist);
      } else {
        path2.lineTo(curr[0], curr[1]);
      }
    });
    path2.closePath();
    return path2;
  }
  return appendPolygon(path2, points);
}
var Polygon2 = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest29(defaults4, ["color"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const path2 = getPolygonPath(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3).style("fill", color3).style("transform", transform2).call(applyStyle, options).node();
  };
};
Polygon2.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/polygon/ribbon.js
var __rest30 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getRibbonPath(points, coordinate) {
  const [p0, p1, p22, p3] = points;
  const path2 = path();
  if (isPolar(coordinate)) {
    const center2 = coordinate.getCenter();
    const radius = dist4(center2, p0);
    path2.moveTo(p0[0], p0[1]);
    path2.quadraticCurveTo(center2[0], center2[1], p22[0], p22[1]);
    appendArc(path2, p22, p3, center2, radius);
    path2.quadraticCurveTo(center2[0], center2[1], p1[0], p1[1]);
    appendArc(path2, p1, p0, center2, radius);
    path2.closePath();
    return path2;
  }
  path2.moveTo(p0[0], p0[1]);
  path2.bezierCurveTo(p0[0] / 2 + p22[0] / 2, p0[1], p0[0] / 2 + p22[0] / 2, p22[1], p22[0], p22[1]);
  path2.lineTo(p3[0], p3[1]);
  path2.bezierCurveTo(p3[0] / 2 + p1[0] / 2, p3[1], p3[0] / 2 + p1[0] / 2, p1[1], p1[0], p1[1]);
  path2.lineTo(p0[0], p0[1]);
  path2.closePath();
  return path2;
}
var Ribbon2 = (options, context) => {
  const style = __rest30(options, []);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor } = defaults4, rest = __rest30(defaults4, ["color"]);
    const { color: color3 = defaultColor, transform: transform2 } = value2;
    const path2 = getRibbonPath(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("fill", color3 || defaultColor).style("stroke", color3 || defaultColor).style("transform", transform2).call(applyStyle, style).node();
  };
};
Ribbon2.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/box.js
var __rest31 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getPath2(points, coordinate) {
  const path2 = path();
  if (!isPolar(coordinate)) {
    path2.moveTo(...points[0]);
    path2.lineTo(...points[1]);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.lineTo(...points[5]);
    path2.lineTo(...points[6]);
    path2.lineTo(...points[7]);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.lineTo(...points[9]);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.lineTo(...points[13]);
  } else {
    const center2 = coordinate.getCenter();
    const [x3, y4] = center2;
    const startAngle = angle3(sub6(points[0], center2));
    const endAngle = angle3(sub6(points[1], center2));
    const radiusHigh = dist4(center2, points[2]);
    const radiusQ3 = dist4(center2, points[3]);
    const radiusMedian = dist4(center2, points[8]);
    const radiusQ1 = dist4(center2, points[10]);
    const radiusLow = dist4(center2, points[11]);
    path2.moveTo(...points[0]);
    path2.arc(x3, y4, radiusHigh, startAngle, endAngle);
    path2.arc(x3, y4, radiusHigh, endAngle, startAngle, true);
    path2.moveTo(...points[2]);
    path2.lineTo(...points[3]);
    path2.moveTo(...points[4]);
    path2.arc(x3, y4, radiusQ3, startAngle, endAngle);
    path2.lineTo(...points[6]);
    path2.arc(x3, y4, radiusQ1, endAngle, startAngle, true);
    path2.closePath();
    path2.moveTo(...points[8]);
    path2.arc(x3, y4, radiusMedian, startAngle, endAngle);
    path2.arc(x3, y4, radiusMedian, endAngle, startAngle, true);
    path2.moveTo(...points[10]);
    path2.lineTo(...points[11]);
    path2.moveTo(...points[12]);
    path2.arc(x3, y4, radiusLow, startAngle, endAngle);
    path2.arc(x3, y4, radiusLow, endAngle, startAngle, true);
  }
  return path2;
}
var Box = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: color3, transform: transform2 } = value2;
    const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults4, rest = __rest31(defaults4, ["color", "fill", "stroke"]);
    const path2 = getPath2(points, coordinate);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color3 || fill).style("transform", transform2).call(applyStyle, options).node();
  };
};
Box.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/box/violin.js
var __rest32 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getPath3(p3, coordinate, size3 = 4) {
  const path2 = path();
  if (!isPolar(coordinate)) {
    path2.moveTo(...p3[2]);
    path2.lineTo(...p3[3]);
    path2.lineTo(p3[3][0] - size3, p3[3][1]);
    path2.lineTo(p3[10][0] - size3, p3[10][1]);
    path2.lineTo(p3[10][0] + size3, p3[10][1]);
    path2.lineTo(p3[3][0] + size3, p3[3][1]);
    path2.lineTo(...p3[3]);
    path2.closePath();
    path2.moveTo(...p3[10]);
    path2.lineTo(...p3[11]);
    path2.moveTo(p3[3][0] + size3 / 2, p3[8][1]);
    path2.arc(p3[3][0], p3[8][1], size3 / 2, 0, Math.PI * 2);
    path2.closePath();
    return path2;
  }
  const center2 = coordinate.getCenter();
  const [x3, y4] = center2;
  const radiusQ3 = dist4(center2, p3[3]);
  const radiusMedian = dist4(center2, p3[8]);
  const radiusQ1 = dist4(center2, p3[10]);
  const middleAngle = angle3(sub6(p3[2], center2));
  const rectAngle = Math.asin(size3 / radiusMedian);
  const startAngle = middleAngle - rectAngle;
  const endAngle = middleAngle + rectAngle;
  path2.moveTo(...p3[2]);
  path2.lineTo(...p3[3]);
  path2.moveTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y4);
  path2.arc(x3, y4, radiusQ3, startAngle, endAngle);
  path2.lineTo(Math.cos(endAngle) * radiusQ1 + x3, Math.sin(endAngle) * radiusQ1 + y4);
  path2.arc(x3, y4, radiusQ1, endAngle, startAngle, true);
  path2.lineTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y4);
  path2.closePath();
  path2.moveTo(...p3[10]);
  path2.lineTo(...p3[11]);
  const a5 = (startAngle + endAngle) / 2;
  path2.moveTo(Math.cos(a5) * (radiusMedian + size3 / 2) + x3, Math.sin(a5) * (radiusMedian + size3 / 2) + y4);
  path2.arc(Math.cos(a5) * radiusMedian + x3, Math.sin(a5) * radiusMedian + y4, size3 / 2, a5, Math.PI * 2 + a5);
  path2.closePath();
  return path2;
}
var Violin = (options, context) => {
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: color3, transform: transform2 } = value2;
    const size3 = 4;
    const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults4, rest = __rest32(defaults4, ["color", "fill", "stroke"]);
    const path2 = getPath3(points, coordinate, size3);
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color3 || fill).style("transform", transform2).call(applyStyle, options).node();
  };
};
Violin.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/lineXY/line.js
var __rest33 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getArrowMarker(document2, arrowSize, arrowStyle) {
  const arrowMarker = document2.createElement("path", {
    style: Object.assign({ d: `M ${arrowSize},${arrowSize} L -${arrowSize},0 L ${arrowSize},-${arrowSize} L 0,0 Z`, transformOrigin: "center" }, arrowStyle)
  });
  return arrowMarker;
}
function getPath4(points, coordinate) {
  if (!isPolar(coordinate))
    return line_default().x((d4) => d4[0]).y((d4) => d4[1])(points);
  const center2 = coordinate.getCenter();
  return arc_default()({
    startAngle: 0,
    endAngle: Math.PI * 2,
    outerRadius: dist4(points[0], center2),
    innerRadius: dist4(points[1], center2)
  });
}
function getTransform2(coordinate, transform2) {
  if (!isPolar(coordinate))
    return transform2;
  const [cx, cy] = coordinate.getCenter();
  return `translate(${cx}, ${cy}) ${transform2 || ""}`;
}
var Line4 = (options, context) => {
  const { arrow: arrow2, arrowSize = 4 } = options, style = __rest33(options, ["arrow", "arrowSize"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, lineWidth } = defaults4, shapeTheme = __rest33(defaults4, ["color", "lineWidth"]);
    const { color: color3 = defaultColor, size: size3 = lineWidth } = value2;
    const arrowMarker = arrow2 ? getArrowMarker(document2, arrowSize, Object.assign({ fill: style.stroke || color3, stroke: style.stroke || color3 }, subObject(style, "arrow"))) : null;
    const path2 = getPath4(points, coordinate);
    const transform2 = getTransform2(coordinate, value2.transform);
    return select(document2.createElement("path", {})).call(applyStyle, shapeTheme).style("d", path2).style("stroke", color3).style("lineWidth", size3).style("transform", transform2).style("markerEnd", arrowMarker).call(applyStyle, style).node();
  };
};
Line4.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/connector/connector.js
var __rest34 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function inferSymbol(x3, y4, r2) {
  return [["M", x3, y4], ["L", x3 + 2 * r2, y4 - r2], ["L", x3 + 2 * r2, y4 + r2], ["Z"]];
}
function inferConnectorPath2(points) {
  return line_default().x((d4) => d4[0]).y((d4) => d4[1])(points);
}
function getPoints(coordinate, points, sourceOffsetY, targetOffsetY, sourceOffsetX, targetOffsetX, length1 = 0) {
  const [[x05, y05], [x12, y12]] = points;
  if (isTranspose(coordinate)) {
    const X03 = x05 + sourceOffsetY;
    const X13 = x12 + targetOffsetY;
    const X = X03 + length1;
    const Y03 = y05 + sourceOffsetX;
    const Y13 = y12 + targetOffsetX;
    return [
      [X03, Y03],
      [X, Y03],
      [X, Y13],
      [X13, Y13]
    ];
  }
  const Y02 = y05 - sourceOffsetY;
  const Y12 = y12 - targetOffsetY;
  const Y = Y02 - length1;
  const X02 = x05 - sourceOffsetX;
  const X12 = x12 - targetOffsetX;
  return [
    [X02, Y02],
    [X02, Y],
    [X12, Y],
    [X12, Y12]
  ];
}
var Connector = (options, context) => {
  const { offsetX = 0, sourceOffsetX = offsetX, targetOffsetX = offsetX, offsetY = 0, sourceOffsetY = offsetY, targetOffsetY = offsetY, connectLength1: length1, endMarker = true } = options, style = __rest34(options, ["offsetX", "sourceOffsetX", "targetOffsetX", "offsetY", "sourceOffsetY", "targetOffsetY", "connectLength1", "endMarker"]);
  const { coordinate } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, connectLength1 } = defaults4, rest = __rest34(defaults4, ["color", "connectLength1"]);
    const { color: color3, transform: transform2 } = value2;
    const P = getPoints(coordinate, points, sourceOffsetY, targetOffsetY, sourceOffsetX, targetOffsetX, length1 !== null && length1 !== void 0 ? length1 : connectLength1);
    const makerStyle = subObject(Object.assign(Object.assign({}, style), defaults4), "endMarker");
    return select(new Path2()).call(applyStyle, rest).style("d", inferConnectorPath2(P)).style("stroke", color3 || defaultColor).style("transform", transform2).style("markerEnd", endMarker ? new Marker({
      className: "marker",
      style: Object.assign(Object.assign({}, makerStyle), { symbol: inferSymbol })
    }) : null).call(applyStyle, style).node();
  };
};
Connector.props = {
  defaultMarker: "line",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/label/position/index.js
var position_exports = {};
__export(position_exports, {
  area: () => area,
  bottom: () => getDefaultStyle,
  bottomLeft: () => getDefaultStyle,
  bottomRight: () => getDefaultStyle,
  inside: () => getDefaultStyle,
  left: () => getDefaultStyle,
  outside: () => outside,
  right: () => getDefaultStyle,
  spider: () => spider,
  surround: () => surround,
  top: () => getDefaultStyle,
  topLeft: () => getDefaultStyle,
  topRight: () => getDefaultStyle
});

// node_modules/@antv/g2/esm/shape/label/position/area.js
function area(position, points, value2, coordinate) {
  const l2 = points.length / 2;
  const Y12 = points.slice(0, l2);
  const Y02 = points.slice(l2);
  let idx = maxIndex(Y12, (p3, i2) => Math.abs(p3[1] - Y02[i2][1]));
  idx = Math.max(Math.min(idx, l2 - 2), 1);
  const mid2 = (i2) => [Y12[i2][0], (Y12[i2][1] + Y02[i2][1]) / 2];
  const point7 = mid2(idx);
  const prev = mid2(idx - 1);
  const next = mid2(idx + 1);
  const rotate7 = angle3(sub6(next, prev)) / Math.PI * 180;
  return {
    x: point7[0],
    y: point7[1],
    transform: `rotate(${rotate7})`,
    textAlign: "center",
    textBaseline: "middle"
  };
}

// node_modules/@antv/g2/esm/shape/label/position/default.js
function inferNonCircularStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  const [[x05, y05], [x12, y12]] = bounds;
  const w2 = x12 - x05;
  const h2 = y12 - y05;
  const xy = (options) => {
    const { x: ox, y: oy } = options;
    const px2 = maybePercentage(value2.x, w2);
    const py = maybePercentage(value2.y, h2);
    return Object.assign(Object.assign({}, options), { x: (px2 || ox) + x05, y: (py || oy) + y05 });
  };
  if (position === "left")
    return xy({ x: 0, y: h2 / 2, textAlign: "start", textBaseline: "middle" });
  if (position === "right")
    return xy({ x: w2, y: h2 / 2, textAlign: "end", textBaseline: "middle" });
  if (position === "top")
    return xy({ x: w2 / 2, y: 0, textAlign: "center", textBaseline: "top" });
  if (position === "bottom")
    return xy({ x: w2 / 2, y: h2, textAlign: "center", textBaseline: "bottom" });
  if (position === "top-left")
    return xy({ x: 0, y: 0, textAlign: "start", textBaseline: "top" });
  if (position === "top-right")
    return xy({ x: w2, y: 0, textAlign: "end", textBaseline: "top" });
  if (position === "bottom-left")
    return xy({ x: 0, y: h2, textAlign: "start", textBaseline: "bottom" });
  if (position === "bottom-right")
    return xy({ x: w2, y: h2, textAlign: "end", textBaseline: "bottom" });
  return xy({
    x: w2 / 2,
    y: h2 / 2,
    textAlign: "center",
    textBaseline: "middle"
  });
}
function inferRadialStyle(position, points, value2, coordinate) {
  const { y: y4, y1: y12, autoRotate, rotateToAlignArc } = value2;
  const center2 = coordinate.getCenter();
  const arcObject = getArcObject(coordinate, points, [y4, y12]);
  const { innerRadius, outerRadius, startAngle, endAngle } = arcObject;
  const angle4 = position === "inside" ? (startAngle + endAngle) / 2 : endAngle;
  const rotate7 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const point7 = (() => {
    const [p0, p1] = points;
    const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
    const [x3, y5] = position === "inside" ? pointOfArc(center2, angle4, radius) : mid(p0, p1);
    return { x: x3, y: y5 };
  })();
  return Object.assign(Object.assign({}, point7), { textAlign: position === "inside" ? "center" : "start", textBaseline: "middle", rotate: rotate7 });
}
function pointOfArc(center2, angle4, radius) {
  return [
    center2[0] + Math.sin(angle4) * radius,
    center2[1] - Math.cos(angle4) * radius
  ];
}
function inferRotation(angle4, autoRotate, rotateToAlignArc) {
  if (!autoRotate)
    return 0;
  const append3 = rotateToAlignArc ? 0 : Math.sin(angle4) < 0 ? 90 : -90;
  return angle4 / Math.PI * 180 + append3;
}
function inferInnerCircularStyle(position, points, value2, coordinate) {
  const { y: y4, y1: y12, autoRotate, rotateToAlignArc, radius: radiusRatio = 0.5, offset: offset2 = 0 } = value2;
  const arcObject = getArcObject(coordinate, points, [y4, y12]);
  const { startAngle, endAngle } = arcObject;
  const center2 = coordinate.getCenter();
  const angle4 = (startAngle + endAngle) / 2;
  const rotate7 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const textStyle = { textAlign: "center", textBaseline: "middle", rotate: rotate7 };
  const { innerRadius, outerRadius } = arcObject;
  const r0 = innerRadius + (outerRadius - innerRadius) * radiusRatio;
  const r1 = r0 + offset2;
  const [x05, y05] = pointOfArc(center2, angle4, r1);
  return Object.assign({ x: x05, y: y05 }, textStyle);
}
function maybeUndefined(d4) {
  return d4 === void 0 ? null : d4;
}
function inferIdentityStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  const [p3] = bounds;
  return {
    x: maybeUndefined(p3[0]),
    y: maybeUndefined(p3[1])
  };
}
function getDefaultStyle(position, points, value2, coordinate) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate);
  }
  const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferInnerCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate);
}

// node_modules/@antv/g2/esm/shape/label/position/outside.js
function linePoints(center2, angle4, radius, radius1, offsetX) {
  const [x05, y05] = pointOfArc(center2, angle4, radius);
  const [x12, y12] = pointOfArc(center2, angle4, radius1);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  return [
    [x05, y05],
    [x12, y12],
    [x12 + sign3 * offsetX, y12]
  ];
}
function radiusOf2(points, value2, coordinate) {
  const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
  const { innerRadius, outerRadius } = arcObject;
  return innerRadius + (outerRadius - innerRadius);
}
function angleOf2(points, value2, coordinate) {
  const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
  const { startAngle, endAngle } = arcObject;
  return (startAngle + endAngle) / 2;
}
function inferOutsideCircularStyle(position, points, value2, coordinate) {
  const { autoRotate, rotateToAlignArc, offset: offset2 = 0, connector = true, connectorLength = offset2, connectorLength2 = 0, connectorDistance = 0 } = value2;
  const center2 = coordinate.getCenter();
  const angle4 = angleOf2(points, value2, coordinate);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const rotate7 = inferRotation(angle4, autoRotate, rotateToAlignArc);
  const textStyle = {
    textAlign: sign3 > 0 || isRadial(coordinate) ? "start" : "end",
    textBaseline: "middle",
    rotate: rotate7
  };
  const radius = radiusOf2(points, value2, coordinate);
  const radius1 = radius + (connector ? connectorLength : offset2);
  const [[x05, y05], [x12, y12], [x22, y22]] = linePoints(center2, angle4, radius, radius1, connector ? connectorLength2 : 0);
  const dx = connector ? +connectorDistance * sign3 : 0;
  const x3 = x22 + dx;
  const y4 = y22;
  const connectorStyle = {
    connector,
    connectorPoints: [
      [x12 - x3, y12 - y4],
      [x22 - x3, y22 - y4]
    ]
  };
  return Object.assign(Object.assign({
    x0: x05,
    y0: y05,
    x: x22 + dx,
    y: y22
  }, textStyle), connectorStyle);
}
function outside(position, points, value2, coordinate) {
  const { bounds } = value2;
  if (bounds.length === 1) {
    return inferIdentityStyle(position, points, value2, coordinate);
  }
  const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferOutsideCircularStyle : inferNonCircularStyle;
  return inferDefaultStyle2(position, points, value2, coordinate);
}

// node_modules/@antv/g2/esm/shape/label/position/utils.js
function dodgeY(labels, options = {}) {
  const { labelHeight = 14, height } = options;
  const sortedLabels = sort(labels, (d4) => d4.y);
  const n2 = sortedLabels.length;
  const boxes = new Array(n2);
  for (let i3 = 0; i3 < n2; i3++) {
    const label = sortedLabels[i3];
    const { y: y4 } = label;
    boxes[i3] = { y: y4, y1: y4 + labelHeight, labels: [y4] };
  }
  let overlap = true;
  while (overlap) {
    overlap = false;
    for (let i3 = boxes.length - 1; i3 > 0; i3--) {
      const box2 = boxes[i3];
      const preBox = boxes[i3 - 1];
      if (preBox.y1 > box2.y) {
        overlap = true;
        preBox.labels.push(...box2.labels);
        boxes.splice(i3, 1);
        preBox.y1 += box2.y1 - box2.y;
        const newHeight = preBox.y1 - preBox.y;
        preBox.y1 = Math.max(Math.min(preBox.y1, height), newHeight);
        preBox.y = preBox.y1 - newHeight;
      }
    }
  }
  let i2 = 0;
  for (const box2 of boxes) {
    const { y: y4, labels: labels2 } = box2;
    let prevY = y4 - labelHeight;
    for (const curY of labels2) {
      const label = sortedLabels[i2++];
      const expectedY = prevY + labelHeight;
      const dy = expectedY - curY;
      label.connectorPoints[0][1] -= dy;
      label.y = prevY + labelHeight;
      prevY += labelHeight;
    }
  }
}
function hideAndDodgeY(unsorted, options) {
  const labels = sort(unsorted, (d4) => d4.y);
  const { height, labelHeight = 14 } = options;
  const maxCount = Math.ceil(height / labelHeight);
  if (labels.length <= maxCount)
    return dodgeY(labels, options);
  const filtered = [];
  for (let i2 = 0; i2 < labels.length; i2++) {
    if (i2 < labels.length - maxCount) {
      labels[i2].opacity = 0;
      labels[i2].connector = false;
    } else
      filtered.push(labels[i2]);
  }
  dodgeY(filtered, options);
}

// node_modules/@antv/g2/esm/shape/label/position/spider.js
var __rest35 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var styleByPoints = /* @__PURE__ */ new WeakMap();
function compute(points, value2, coordinate) {
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest35(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
  const center2 = coordinate.getCenter();
  const radius = radiusOf2(points, value2, coordinate);
  const angle4 = angleOf2(points, value2, coordinate);
  const radius1 = radius + connectorLength + connectorLength2;
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const newX = center2[0] + (radius1 + +connectorDistance) * sign3;
  const { x: originX } = style;
  const dx = newX - originX;
  style.x += dx;
  style.connectorPoints[0][0] -= dx;
  return style;
}
function spider(position, points, value2, coordinate, options, labels) {
  if (!isCircular(coordinate))
    return {};
  if (styleByPoints.has(points))
    return styleByPoints.get(points);
  const computed = labels.map((points2) => compute(points2, value2, coordinate));
  const { width, height } = coordinate.getOptions();
  const left2 = computed.filter((d4) => d4.x < width / 2);
  const right2 = computed.filter((d4) => d4.x >= width / 2);
  const extendedOptions = Object.assign(Object.assign({}, options), { height });
  hideAndDodgeY(left2, extendedOptions);
  hideAndDodgeY(right2, extendedOptions);
  computed.forEach((style, i2) => styleByPoints.set(labels[i2], style));
  return styleByPoints.get(points);
}

// node_modules/@antv/g2/esm/shape/label/position/surround.js
var __rest36 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function surround(position, points, value2, coordinate) {
  if (!isCircular(coordinate))
    return {};
  const { connectorLength, connectorLength2, connectorDistance } = value2;
  const style = __rest36(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
  const { x0: x05, y0: y05 } = style;
  const center2 = coordinate.getCenter();
  const radius = getRadius(coordinate);
  const radius1 = radius + connectorLength;
  const angle4 = angleWithQuadrant([x05 - center2[0], y05 - center2[1]]);
  const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
  const [newX, newY] = pointOfArc(center2, angle4, radius1);
  style.x = newX + (connectorLength2 + connectorDistance) * sign3;
  style.y = newY;
  return style;
}

// node_modules/@antv/g2/esm/shape/label/label.js
var __rest37 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function inferPosition(position, coordinate) {
  if (position !== void 0)
    return position;
  if (isCircular(coordinate))
    return "inside";
  if (isTranspose(coordinate))
    return "right";
  return "top";
}
function getDefaultStyle2(points, value2, coordinate, theme, options, labels) {
  const { position } = value2;
  const { render: render3 } = options;
  const p3 = inferPosition(position, coordinate);
  const labelType = render3 ? "htmlLabel" : p3 === "inside" ? "innerLabel" : "label";
  const t = theme[labelType];
  const v = Object.assign({}, t, value2);
  const processor = position_exports[camelCase(p3)];
  if (!processor) {
    throw new Error(`Unknown position: ${p3}`);
  }
  return Object.assign(Object.assign({}, t), processor(p3, points, v, coordinate, options, labels));
}
var Label = (options, context) => {
  const { coordinate, theme } = context;
  const { render: render3 } = options;
  return (points, value2, style, labels) => {
    const { text, x: x3, y: y4, transform: specifiedTS = "", transformOrigin, className: className2 = "" } = value2, overrideStyle = __rest37(value2, ["text", "x", "y", "transform", "transformOrigin", "className"]);
    const _a2 = getDefaultStyle2(points, value2, coordinate, theme, options, labels), { rotate: rotate7 = 0, transform: transform2 = "" } = _a2, defaultStyle2 = __rest37(_a2, ["rotate", "transform"]);
    return select(new Advance()).call(applyStyle, defaultStyle2).style("text", `${text}`).style("className", `${className2} g2-label`).style("innerHTML", render3 ? render3(text, value2.datum, value2.index) : void 0).style("labelTransform", `${transform2} rotate(${+rotate7}) ${specifiedTS}`.trim()).style("labelTransformOrigin", transformOrigin).style("coordCenter", coordinate.getCenter()).call(applyStyle, overrideStyle).node();
  };
};
Label.props = {
  defaultMarker: "point"
};

// node_modules/@antv/g2/esm/shape/path/color.js
var __rest38 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Color4 = (options, context) => {
  const { arrow: arrow2, colorAttribute } = options, style = __rest38(options, ["arrow", "colorAttribute"]);
  const { coordinate, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { color: defaultColor, stroke: stroke2 } = defaults4, rest = __rest38(defaults4, ["color", "stroke"]);
    const { d: d4, color: color3 = defaultColor } = value2;
    const [width, height] = coordinate.getSize();
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", typeof d4 === "function" ? d4({ width, height }) : d4).style(colorAttribute, color3).call(applyStyle, style).node();
  };
};
Color4.props = {
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/path.js
var Path3 = (options, context) => {
  return Color4(Object.assign({ colorAttribute: "fill" }, options), context);
};
Path3.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/path/hollow.js
var Hollow2 = (options, context) => {
  return Color4(Object.assign({ fill: "none", colorAttribute: "stroke" }, options), context);
};
Hollow2.props = {
  defaultMarker: "hvh",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/density/density.js
var __rest39 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Density = (options, context) => {
  const { document: document2 } = context;
  return (points, value2, defaults4) => {
    const { transform: transform2 } = value2;
    const { color: defaultColor } = defaults4, rest = __rest39(defaults4, ["color"]);
    const { color: color3 = defaultColor } = value2;
    const [first3, ...p3] = points;
    const path2 = path();
    path2.moveTo(...first3);
    p3.forEach(([x3, y4]) => {
      path2.lineTo(x3, y4);
    });
    path2.closePath();
    return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color3 || defaultColor).style("fill", color3 || defaultColor).style("fillOpacity", 0.4).style("transform", transform2).call(applyStyle, options).node();
  };
};
Density.props = {
  defaultMarker: "square",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/flru/dist/flru.mjs
function flru_default(max11) {
  var num, curr, prev;
  var limit = max11 || 1;
  function keep(key, value2) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value2;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0) return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value2) {
      if (curr[key] !== void 0) {
        curr[key] = value2;
      } else {
        keep(key, value2);
      }
    }
  };
}

// node_modules/@antv/g2/esm/utils/lru.js
var cache = flru_default(3);
function lru(fn, keyFn = (...args) => `${args[0]}`, maxSize = 16) {
  const cache2 = flru_default(maxSize);
  return (...args) => {
    const key = keyFn(...args);
    let v = cache2.get(key);
    if (cache2.has(key))
      return cache2.get(key);
    v = fn(...args);
    cache2.set(key, v);
    return v;
  };
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/gradient.js
function parseGradient2(gradient2) {
  if (typeof gradient2 === "string") {
    return gradient2.split(" ").map((stop) => {
      const [r2, c6] = stop.split(":");
      return [+r2, c6];
    });
  }
  return gradient2;
}

// node_modules/@antv/g2/esm/shape/heatmap/renderer/index.js
function newCanvas(createCanvas, width, height) {
  const c6 = createCanvas ? createCanvas() : document.createElement("canvas");
  c6.width = width;
  c6.height = height;
  return c6;
}
var getPointTemplate = lru((radius, blurFactor, createCanvas) => {
  const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);
  const tplCtx = tplCanvas.getContext("2d");
  const x3 = radius;
  const y4 = radius;
  if (blurFactor === 1) {
    tplCtx.beginPath();
    tplCtx.arc(x3, y4, radius, 0, 2 * Math.PI, false);
    tplCtx.fillStyle = "rgba(0,0,0,1)";
    tplCtx.fill();
  } else {
    const gradient2 = tplCtx.createRadialGradient(x3, y4, radius * blurFactor, x3, y4, radius);
    gradient2.addColorStop(0, "rgba(0,0,0,1)");
    gradient2.addColorStop(1, "rgba(0,0,0,0)");
    tplCtx.fillStyle = gradient2;
    tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
  }
  return tplCanvas;
}, (radius) => `${radius}`);
function getColorPalette(gradientConfig, createCanvas) {
  const paletteCanvas = newCanvas(createCanvas, 256, 1);
  const paletteCtx = paletteCanvas.getContext("2d");
  const gradient2 = paletteCtx.createLinearGradient(0, 0, 256, 1);
  parseGradient2(gradientConfig).forEach(([r2, c6]) => {
    gradient2.addColorStop(r2, c6);
  });
  paletteCtx.fillStyle = gradient2;
  paletteCtx.fillRect(0, 0, 256, 1);
  return paletteCtx.getImageData(0, 0, 256, 1).data;
}
function drawAlpha(shadowCtx, min10, max11, data2, options, createCanvas) {
  const { blur: blur3 } = options;
  let len5 = data2.length;
  while (len5--) {
    const { x: x3, y: y4, value: v, radius } = data2[len5];
    const value2 = Math.min(v, max11);
    const rectX = x3 - radius;
    const rectY = y4 - radius;
    const tpl = getPointTemplate(radius, 1 - blur3, createCanvas);
    const templateAlpha = (value2 - min10) / (max11 - min10);
    shadowCtx.globalAlpha = Math.max(templateAlpha, 1e-3);
    shadowCtx.drawImage(tpl, rectX, rectY);
  }
  return shadowCtx;
}
function colorize(shadowCtx, maxWidth, maxHeight, palette, options) {
  const { minOpacity, opacity, maxOpacity, useGradientOpacity } = options;
  const x3 = 0;
  const y4 = 0;
  const width = maxWidth;
  const height = maxHeight;
  const img = shadowCtx.getImageData(x3, y4, width, height);
  const imgData = img.data;
  const len5 = imgData.length;
  for (let i2 = 3; i2 < len5; i2 += 4) {
    const alpha = imgData[i2];
    const offset2 = alpha * 4;
    if (!offset2) {
      continue;
    }
    const finalAlpha = opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));
    imgData[i2 - 3] = palette[offset2];
    imgData[i2 - 2] = palette[offset2 + 1];
    imgData[i2 - 1] = palette[offset2 + 2];
    imgData[i2] = useGradientOpacity ? palette[offset2 + 3] : finalAlpha;
  }
  return img;
}
function HeatmapRenderer(width, height, min10, max11, data2, options, createCanvas) {
  const opts = Object.assign({ blur: 0.85, minOpacity: 0, opacity: 0.6, maxOpacity: 1, gradient: [
    [0.25, "rgb(0,0,255)"],
    [0.55, "rgb(0,255,0)"],
    [0.85, "yellow"],
    [1, "rgb(255,0,0)"]
  ] }, options);
  opts.minOpacity *= 255;
  opts.opacity *= 255;
  opts.maxOpacity *= 255;
  const shadowCanvas = newCanvas(createCanvas, width, height);
  const shadowCtx = shadowCanvas.getContext("2d");
  const palette = getColorPalette(opts.gradient, createCanvas);
  shadowCtx.clearRect(0, 0, width, height);
  drawAlpha(shadowCtx, min10, max11, data2, opts, createCanvas);
  const img = colorize(shadowCtx, width, height, palette, opts);
  const canvas = newCanvas(createCanvas, width, height);
  const ctx4 = canvas.getContext("2d");
  ctx4.putImageData(img, 0, 0);
  return ctx4;
}

// node_modules/@antv/g2/esm/shape/heatmap/heatmap.js
var __rest40 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function deleteKey(obj, fn) {
  return Object.keys(obj).reduce((r2, k2) => {
    const v = obj[k2];
    if (!fn(v, k2))
      r2[k2] = v;
    return r2;
  }, {});
}
var Heatmap = (options, context) => {
  const { gradient: gradient2, opacity, maxOpacity, minOpacity, blur: blur3, useGradientOpacity } = options, style = __rest40(options, ["gradient", "opacity", "maxOpacity", "minOpacity", "blur", "useGradientOpacity"]);
  const { coordinate, createCanvas, document: document2 } = context;
  return (points, value2, defaults4) => {
    const { transform: transform2 } = value2;
    const [width, height] = coordinate.getSize();
    const data2 = points.map((p3) => ({
      x: p3[0],
      y: p3[1],
      value: p3[2],
      radius: p3[3]
    }));
    const min10 = min4(points, (p3) => p3[2]);
    const max11 = max5(points, (p3) => p3[2]);
    const options2 = {
      gradient: gradient2,
      opacity,
      minOpacity,
      maxOpacity,
      blur: blur3,
      useGradientOpacity
    };
    const ctx4 = width && height ? HeatmapRenderer(width, height, min10, max11, data2, deleteKey(options2, (v) => v === void 0), createCanvas) : { canvas: null };
    return select(document2.createElement("image", {})).call(applyStyle, defaults4).style("x", 0).style("y", 0).style("width", width).style("height", height).style("src", ctx4.canvas.toDataURL()).style("transform", transform2).call(applyStyle, style).node();
  };
};
Heatmap.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/shape/shape.js
var __rest41 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Shape2 = (options, context) => {
  const { render: render3 } = options, rest = __rest41(options, ["render"]);
  return (points) => {
    const [[x05, y05]] = points;
    return render3(Object.assign(Object.assign({}, rest), { x: x05, y: y05 }), context);
  };
};
Shape2.props = {
  defaultMarker: "point",
  defaultEnterAnimation: "fadeIn",
  defaultUpdateAnimation: "morphing",
  defaultExitAnimation: "fadeOut"
};

// node_modules/@antv/g2/esm/shape/liquid/wave.js
var DURATION = 5e3;
function lerp5(min10, max11, factor) {
  return min10 + (max11 - min10) * factor;
}
function getWaterWavePositions(x3, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
      [x3 + 1 / 2 * waveLength / Math.PI, amplitude],
      [x3 + waveLength / 4, amplitude]
    ];
  }
  if (stage === 1) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude],
      [
        x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        amplitude / 2
      ],
      [x3 + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
      [x3 + 1 / 2 * waveLength / Math.PI, -amplitude],
      [x3 + waveLength / 4, -amplitude]
    ];
  }
  return [
    [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude],
    [
      x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
      -amplitude / 2
    ],
    [x3 + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  const curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  const path2 = [];
  let _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  const left2 = cx - radius + _phase - radius * 2;
  path2.push(["M", left2, waterLevel]);
  let waveRight = 0;
  for (let c6 = 0; c6 < curves; ++c6) {
    const stage = c6 % 4;
    const pos = getWaterWavePositions(c6 * waveLength / 4, stage, waveLength, amplitude);
    path2.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c6 === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path2.push(["L", waveRight + left2, cy + radius]);
  path2.push(["L", left2, cy + radius]);
  path2.push(["Z"]);
  return path2;
}
function addWave(x3, y4, level, waveCount, waveAttrs, group3, minY, radius, waveLength, animation, document2) {
  const { fill, fillOpacity, opacity } = waveAttrs;
  for (let idx = 0; idx < waveCount; idx++) {
    const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
    const path2 = getWaterWavePath(
      radius,
      minY + radius * level,
      waveLength,
      0,
      // Amplitude height.
      radius / 40,
      x3,
      y4
    );
    const wave = document2.createElement("path", {
      style: {
        d: path2,
        fill,
        opacity: lerp5(0.2, 0.9, factor) * Number(opacity || fillOpacity)
      }
    });
    group3.appendChild(wave);
    try {
      if (animation === false)
        return;
      const keyframes = [
        {
          transform: "translate(0, 0)"
        },
        {
          transform: `translate(${waveLength * 2}, 0)`
        }
      ];
      wave.animate(keyframes, {
        duration: lerp5(0.5 * DURATION, DURATION, factor) * 2,
        iterations: Infinity
      });
    } catch (e3) {
      console.warn("off-screen group animate error!");
    }
  }
}

// node_modules/@antv/g2/esm/shape/liquid/shapes.js
function circle2(x3, y4, r2) {
  return `
      M ${x3} ${y4 - r2} 
      a ${r2} ${r2} 0 1 0 0 ${r2 * 2}
      a ${r2} ${r2} 0 1 0 0 ${-r2 * 2}
      Z
    `;
}
function rect3(x3, y4, r2) {
  const GOLDEN_SECTION_RATIO = 0.618;
  const w2 = r2 * GOLDEN_SECTION_RATIO;
  return `
      M ${x3 - w2} ${y4 - r2}
      L ${x3 + w2} ${y4 - r2}
      L ${x3 + w2} ${y4 + r2}
      L ${x3 - w2} ${y4 + r2}
      Z
    `;
}
function diamond3(x3, y4, r2) {
  return `
      M ${x3} ${y4 - r2}
      L ${x3 + r2} ${y4}
      L ${x3} ${y4 + r2}
      L ${x3 - r2} ${y4}
      Z
    `;
}
function triangle3(x3, y4, r2) {
  return `
      M ${x3} ${y4 - r2}
      L ${x3 + r2} ${y4 + r2}
      L ${x3 - r2} ${y4 + r2}
      Z
    `;
}
function pin(x3, y4, radius) {
  const w2 = radius * 4 / 3;
  const h2 = Math.max(w2, radius * 2);
  const r2 = w2 / 2;
  const cx = x3;
  const cy = r2 + y4 - h2 / 2;
  const theta = Math.asin(r2 / ((h2 - r2) * 0.85));
  const dy = Math.sin(theta) * r2;
  const dx = Math.cos(theta) * r2;
  const x05 = cx - dx;
  const y05 = cy + dy;
  const cpX = x3;
  const cpY = cy + r2 / Math.sin(theta);
  return `
      M ${x05} ${y05}
      A ${r2} ${r2} 0 1 1 ${x05 + dx * 2} ${y05}
      Q ${cpX} ${cpY} ${x3} ${y4 + h2 / 2}
      Q ${cpX} ${cpY} ${x05} ${y05}
      Z 
    `;
}
var LiquidShapesPath = {
  pin,
  rect: rect3,
  circle: circle2,
  diamond: diamond3,
  triangle: triangle3
};

// node_modules/@antv/g2/esm/shape/liquid/liquid.js
var __rest42 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var getLiquidShape = (shape23 = "circle") => LiquidShapesPath[shape23] || LiquidShapesPath.circle;
var Liquid = (options, context) => {
  if (!context)
    return;
  const { coordinate } = context;
  const { liquidOptions, styleOptions } = options;
  const { liquidShape, percent: percent2 } = liquidOptions;
  const { background: backgroundStyle, outline = {}, wave = {} } = styleOptions, attr2 = __rest42(styleOptions, ["background", "outline", "wave"]);
  const { border = 2, distance: distance7 = 0 } = outline, outlineStyle = __rest42(outline, ["border", "distance"]);
  const { length: length5 = 192, count: count4 = 3 } = wave;
  return (points, cfg, defaultAttr) => {
    const { document: document2 } = context.canvas;
    const { color: color3, fillOpacity } = defaultAttr;
    const attrs = Object.assign(Object.assign({ fill: color3 }, defaultAttr), attr2);
    const g = document2.createElement("g", {});
    const [centerX, centerY] = coordinate.getCenter();
    const size3 = coordinate.getSize();
    const radius = Math.min(...size3) / 2;
    const buildPath = isFunction(liquidShape) ? liquidShape : getLiquidShape(liquidShape);
    const shapePath = buildPath(centerX, centerY, radius, ...size3);
    const shapeClipPath = buildPath(centerX, centerY, radius + border / 2, ...size3);
    if (Object.keys(backgroundStyle).length) {
      const backgroundShape = document2.createElement("path", {
        style: Object.assign({ d: shapePath, fill: "#fff" }, backgroundStyle)
      });
      g.appendChild(backgroundShape);
    }
    if (percent2 > 0) {
      const clipShape = document2.createElement("path", {
        style: {
          d: shapeClipPath
        }
      });
      g.appendChild(clipShape);
      g.style.clipPath = clipShape;
      addWave(centerX, centerY, 1 - percent2, count4, attrs, g, clipShape.getBBox().y, radius * 2, length5, true, document2);
    }
    const distanceShape = document2.createElement("path", {
      style: {
        d: shapePath,
        fill: "transparent",
        lineWidth: border + 2 * distance7,
        stroke: "#fff"
      }
    });
    const borderShape = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ d: shapePath, stroke: color3, strokeOpacity: fillOpacity, lineWidth: border }, attrs), outlineStyle), { fill: "transparent" })
    });
    g.appendChild(distanceShape);
    g.appendChild(borderShape);
    return g;
  };
};
Liquid.props = {};

// node_modules/@antv/g2/esm/shape/gauge/round.js
var getR = (point1, point22) => {
  return Math.sqrt(Math.pow(point1[0] - point22[0], 2) + Math.pow(point1[1] - point22[1], 2)) / 2;
};
var getAngle4 = (start, end, center2) => {
  const startAngle = Math.atan2(start[1] - center2[1], start[0] - center2[0]);
  const endAngle = Math.atan2(end[1] - center2[1], end[0] - center2[0]);
  let angle4 = endAngle - startAngle;
  if (angle4 < 0)
    angle4 += Math.PI * 2;
  return angle4;
};
var Round = (options, context) => {
  if (!context)
    return;
  const { coordinate } = context;
  if (!(coordinate === null || coordinate === void 0 ? void 0 : coordinate.getCenter))
    return;
  const center2 = coordinate.getCenter();
  return (points, cfg, defaultCfg) => {
    const { document: document2 } = context.canvas;
    const { color: color3, index: index3 } = cfg;
    const g = document2.createElement("g", {});
    const minR = getR(points[0], points[1]);
    const maxR = getR(points[0], center2) * 2;
    const isHalf = getAngle4(points[3], points[0], center2) > Math.PI;
    const roundPath2 = document2.createElement("path", {
      style: Object.assign(Object.assign(Object.assign({ d: [
        ["M", ...points[0]],
        ["A", minR, minR, 0, 1, 0, ...points[1]],
        [
          "A",
          maxR + minR * 2,
          maxR + minR * 2,
          0,
          isHalf ? 1 : 0,
          0,
          ...points[2]
        ],
        ["A", minR, minR, 0, 1, index3 === 0 ? 0 : 1, ...points[3]],
        ["A", maxR, maxR, 0, isHalf ? 1 : 0, 1, ...points[0]],
        ["Z"]
      ] }, defaultCfg), omit_default(options, ["shape", "last", "first"])), { fill: color3 || defaultCfg.color })
    });
    g.appendChild(roundPath2);
    return g;
  };
};

// node_modules/@antv/g2/esm/mark/interval.js
function bandWidth2(scale12, x3) {
  return scale12.getBandWidth(scale12.invert(x3));
}
var shape = {
  rect: Rect2,
  hollow: Hollow,
  funnel: Funnel,
  pyramid: Pyramid
};
var Interval = () => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y, y1: Y12, series: S, size: SZ } = value2;
    const x3 = scale12.x;
    const series = scale12.series;
    const [width] = coordinate.getSize();
    const NSZ = SZ ? SZ.map((d4) => +d4 / width) : null;
    const x1x2 = !SZ ? (x4, w2, i2) => [x4, x4 + w2] : (x4, w2, i2) => {
      const mx = x4 + w2 / 2;
      const s4 = NSZ[i2];
      return [mx - s4 / 2, mx + s4 / 2];
    };
    const P = Array.from(index3, (i2) => {
      const groupWidth = bandWidth2(x3, X[i2]);
      const ratio = series ? bandWidth2(series, S === null || S === void 0 ? void 0 : S[i2]) : 1;
      const width2 = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i2]) || 0) * groupWidth;
      const x05 = +X[i2] + offset2;
      const [x12, x22] = x1x2(x05, width2, i2);
      const y12 = +Y[i2];
      const y22 = +Y12[i2];
      const p1 = [x12, y12];
      const p22 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p22, p3, p4].map((d4) => coordinate.map(d4));
    });
    return [index3, P];
  };
};
Interval.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/rect.js
var shape2 = {
  rect: Rect2,
  hollow: Hollow
};
var Rect3 = () => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, x1: X12, y: Y, y1: Y12 } = value2;
    const P = Array.from(index3, (i2) => {
      const p1 = [+X[i2], +Y[i2]];
      const p22 = [+X12[i2], +Y[i2]];
      const p3 = [+X12[i2], +Y12[i2]];
      const p4 = [+X[i2], +Y12[i2]];
      return [p1, p22, p3, p4].map((d4) => coordinate.map(d4));
    });
    return [index3, P];
  };
};
Rect3.props = {
  defaultShape: "rect",
  defaultLabelShape: "label",
  composite: false,
  shape: shape2,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape2) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroY1 }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/line.js
var shape3 = {
  line: Line2,
  smooth: Smooth,
  hv: HV,
  vh: VH,
  hvh: HVH,
  trail: Trail
};
var line3 = (index3, scale12, value2, coordinate) => {
  var _a2, _b;
  const { series: S, x: X, y: Y } = value2;
  const { x: x3, y: y4 } = scale12;
  if (X === void 0 || Y === void 0) {
    throw new Error("Missing encode for x or y channel.");
  }
  const series = S ? Array.from(group(index3, (i2) => S[i2]).values()) : [index3];
  const I = series.map((group3) => group3[0]).filter((i2) => i2 !== void 0);
  const xoffset = (((_a2 = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(x3)) || 0) / 2;
  const yoffset = (((_b = y4 === null || y4 === void 0 ? void 0 : y4.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y4)) || 0) / 2;
  const P = Array.from(series, (I2) => {
    return I2.map((i2) => coordinate.map([+X[i2] + xoffset, +Y[i2] + yoffset]));
  });
  return [I, P, series];
};
var parallel = (index3, scale12, value2, coordinate) => {
  const PV = Object.entries(value2).filter(([key]) => key.startsWith("position")).map(([, value3]) => value3);
  if (PV.length === 0) {
    throw new Error("Missing encode for position channel.");
  }
  if (isPolar(coordinate))
    PV.push(PV[0]);
  const P = Array.from(index3, (i2) => {
    const vector = PV.map((pv) => +pv[i2]);
    const vectors = coordinate.map(vector);
    const points = [];
    for (let i3 = 0; i3 < vectors.length; i3 += 2) {
      points.push([vectors[i3], vectors[i3 + 1]]);
    }
    return points;
  });
  return [index3, P];
};
var Line5 = () => {
  return (index3, scale12, value2, coordinate) => {
    const mark2 = isParallel(coordinate) ? parallel : line3;
    return mark2(index3, scale12, value2, coordinate);
  };
};
Line5.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape3,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape3) }),
    { name: "x" },
    { name: "y" },
    { name: "position", independent: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    // !!!Note This order is very important.
    { type: MaybeGradient },
    { type: MaybeSeries }
  ],
  postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/point.js
var shape4 = {
  hollow: HollowPoint,
  hollowDiamond: HollowDiamond,
  hollowHexagon: HollowHexagon,
  hollowSquare: HollowSquare,
  hollowTriangleDown: HollowTriangleDown,
  hollowTriangle: HollowTriangle,
  hollowBowtie: HollowBowtie,
  hollowCircle: HollowCircle,
  point: Point3,
  plus: Plus,
  diamond: Diamond,
  square: Square,
  triangle: Triangle,
  hexagon: Hexagon,
  cross: Cross,
  bowtie: Bowtie,
  hyphen: Hyphen,
  line: Line3,
  tick: Tick,
  triangleDown: TriangleDown,
  circle: Circle2
};
var Point4 = (options) => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y, x1: X12, y1: Y12, size: S, dx: DX, dy: DY } = value2;
    const [width, height] = coordinate.getSize();
    const offset2 = createBandOffset(scale12, value2, options);
    const xy = (i2) => {
      const dx = +((DX === null || DX === void 0 ? void 0 : DX[i2]) || 0);
      const dy = +((DY === null || DY === void 0 ? void 0 : DY[i2]) || 0);
      const x3 = X12 ? (+X[i2] + +X12[i2]) / 2 : +X[i2];
      const y4 = Y12 ? (+Y[i2] + +Y12[i2]) / 2 : +Y[i2];
      const cx = x3 + dx;
      const cy = y4 + dy;
      return [cx, cy];
    };
    const P = S ? Array.from(index3, (i2) => {
      const [cx, cy] = xy(i2);
      const r2 = +S[i2];
      const a5 = r2 / width;
      const b = r2 / height;
      const p1 = [cx - a5, cy - b];
      const p22 = [cx + a5, cy + b];
      return [
        coordinate.map(offset2(p1, i2)),
        coordinate.map(offset2(p22, i2))
      ];
    }) : Array.from(index3, (i2) => [coordinate.map(offset2(xy(i2), i2))]);
    return [index3, P];
  };
};
Point4.props = {
  defaultShape: "hollow",
  defaultLabelShape: "label",
  composite: false,
  shape: shape4,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape4) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" },
    { name: "size", quantitative: "sqrt" },
    { name: "dx", scale: "identity" },
    { name: "dy", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/text.js
var shape5 = {
  text: Text3,
  badge: Badge,
  tag: Tag2
};
var Text4 = (options) => {
  const { cartesian: cartesian3 = false } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale12, value2, options);
    const P = Array.from(index3, (i2) => {
      const p3 = [+X[i2], +Y[i2]];
      return [coordinate.map(offset2(p3, i2))];
    });
    return [index3, P];
  };
};
Text4.props = {
  defaultShape: "text",
  defaultLabelShape: "label",
  composite: false,
  shape: shape5,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape5) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "text", scale: "identity" },
    { name: "fontSize", scale: "identity" },
    { name: "rotate", scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/cell.js
var shape6 = {
  cell: Rect2,
  hollow: Hollow
};
var Cell = () => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const x3 = scale12.x;
    const y4 = scale12.y;
    const P = Array.from(index3, (i2) => {
      const width = x3.getBandWidth(x3.invert(+X[i2]));
      const height = y4.getBandWidth(y4.invert(+Y[i2]));
      const x12 = +X[i2];
      const y12 = +Y[i2];
      const p1 = [x12, y12];
      const p22 = [x12 + width, y12];
      const p3 = [x12 + width, y12 + height];
      const p4 = [x12, y12 + height];
      return [p1, p22, p3, p4].map((d4) => coordinate.map(d4));
    });
    return [index3, P];
  };
};
Cell.props = {
  defaultShape: "cell",
  defaultLabelShape: "label",
  shape: shape6,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape6) }),
    { name: "x", required: true, scale: "band" },
    { name: "y", required: true, scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/area.js
var shape7 = {
  area: Area,
  smooth: Smooth2,
  hvh: HVH2,
  vh: VH2,
  hv: HV2
};
var Area2 = () => {
  return (index3, scale12, value2, coordinate) => {
    var _a2, _b;
    const { x: X, y: Y, y1: Y12, series: S } = value2;
    const { x: x3, y: y4 } = scale12;
    const series = S ? Array.from(group(index3, (i2) => S[i2]).values()) : [index3];
    const I = series.map((group3) => group3[0]).filter((i2) => i2 !== void 0);
    const xoffset = (((_a2 = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(x3)) || 0) / 2;
    const yoffset = (((_b = y4 === null || y4 === void 0 ? void 0 : y4.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y4)) || 0) / 2;
    const P = Array.from(series, (SI) => {
      const l2 = SI.length;
      const points = new Array(l2 * 2);
      for (let idx = 0; idx < SI.length; idx++) {
        const i2 = SI[idx];
        points[idx] = coordinate.map([+X[i2] + xoffset, +Y[i2] + yoffset]);
        points[l2 + idx] = coordinate.map([+X[i2] + xoffset, +Y12[i2] + yoffset]);
      }
      return points;
    });
    return [I, P, series];
  };
};
Area2.props = {
  defaultShape: "area",
  defaultLabelShape: "label",
  composite: false,
  shape: shape7,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape7) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "size" },
    { name: "series", scale: "band" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeSeries },
    { type: MaybeZeroY1 },
    { type: MaybeZeroPadding }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true,
    seriesTooltip: true,
    crosshairs: true
  }
};

// node_modules/@antv/g2/esm/mark/link.js
var shape8 = {
  link: Link,
  arc: Arc,
  smooth: Smooth3,
  vhv: VHV
};
var Link2 = (options) => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y, x1: X12 = X, y1: Y12 = Y } = value2;
    const offset2 = createBandOffset(scale12, value2, options);
    const P = index3.map((i2) => [
      coordinate.map(offset2([+X[i2], +Y[i2]], i2)),
      coordinate.map(offset2([+X12[i2], +Y12[i2]], i2))
    ]);
    return [index3, P];
  };
};
Link2.props = {
  defaultShape: "link",
  defaultLabelShape: "label",
  composite: false,
  shape: shape8,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape8) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeIdentityY },
    { type: MaybeIdentityX }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/image.js
var shape9 = {
  image: Image3
};
var Image4 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale12, value2, options);
    const P = Array.from(index3, (i2) => {
      const p3 = [+X[i2], +Y[i2]];
      return [coordinate.map(offset2(p3, i2))];
    });
    return [index3, P];
  };
};
Image4.props = {
  defaultShape: "image",
  defaultLabelShape: "label",
  composite: false,
  shape: shape9,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape9) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "src", scale: "identity" },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/polygon.js
var shape10 = {
  polygon: Polygon2,
  ribbon: Ribbon2
};
var Polygon3 = () => {
  return (index3, scale12, value2, coordinate) => {
    const Xn2 = Object.entries(value2).filter(([key]) => key.startsWith("x")).map(([, value3]) => value3);
    const Yn2 = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const P = index3.map((i2) => {
      const Pn = [];
      for (let j = 0; j < Xn2.length; j++) {
        const x3 = Xn2[j][i2];
        if (x3 === void 0)
          break;
        const y4 = Yn2[j][i2];
        Pn.push(coordinate.map([+x3, +y4]));
      }
      return Pn;
    });
    return [index3, P];
  };
};
Polygon3.props = {
  defaultShape: "polygon",
  defaultLabelShape: "label",
  composite: false,
  shape: shape10,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape10) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/box.js
var shape11 = {
  box: Box,
  violin: Violin
};
var Box2 = () => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y, y1: Y12, y2: Y22, y3: Y3, y4: Y4, series: S } = value2;
    const xScale = scale12.x;
    const series = scale12.series;
    const P = Array.from(index3, (i2) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i2]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i2]))) : 1;
      const width = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i2]) || 0) * groupWidth;
      const x3 = +X[i2] + offset2 + width / 2;
      const [low, q12, median3, q32, high] = [
        +Y[i2],
        +Y12[i2],
        +Y22[i2],
        +Y3[i2],
        +Y4[i2]
      ];
      const P13 = [
        [x3 - width / 2, high],
        [x3 + width / 2, high],
        [x3, high],
        [x3, q32],
        [x3 - width / 2, q32],
        [x3 + width / 2, q32],
        [x3 + width / 2, q12],
        [x3 - width / 2, q12],
        [x3 - width / 2, median3],
        [x3 + width / 2, median3],
        [x3, q12],
        [x3, low],
        [x3 - width / 2, low],
        [x3 + width / 2, low]
      ];
      return P13.map((d4) => coordinate.map(d4));
    });
    return [index3, P];
  };
};
Box2.props = {
  defaultShape: "box",
  defaultLabelShape: "label",
  composite: false,
  shape: shape11,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape11) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "series", scale: "band" }
  ],
  preInference: [...basePreInference(), { type: MaybeZeroX }],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: {
    shareTooltip: true
  }
};

// node_modules/@antv/g2/esm/mark/vector.js
var shape12 = {
  vector: Vector
};
var Vector2 = () => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y, size: S, rotate: R2 } = value2;
    const [width, height] = coordinate.getSize();
    const P = index3.map((i2) => {
      const angle4 = +R2[i2] / 180 * Math.PI;
      const s4 = +S[i2];
      const a5 = s4 / width;
      const b = s4 / height;
      const vx = a5 * Math.cos(angle4);
      const vy = -b * Math.sin(angle4);
      return [
        coordinate.map([+X[i2] - vx / 2, +Y[i2] - vy / 2]),
        coordinate.map([+X[i2] + vx / 2, +Y[i2] + vy / 2])
      ];
    });
    return [index3, P];
  };
};
Vector2.props = {
  defaultShape: "vector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape12,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape12) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "rotate", required: true, scale: "identity" },
    { name: "size", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/lineY.js
var shape13 = {
  line: Line4
};
var LineY = (options) => {
  return (index3, scale12, value2, coordinate) => {
    const { y: Y } = value2;
    const offset2 = createBandOffset(scale12, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index3, (i2) => {
      const p1 = [0, Y[i2]];
      const p22 = [1, Y[i2]];
      return [p1, p22].map((d4) => coordinate.map(offset2(d4, i2)));
    });
    return [index3, P];
  };
};
LineY.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape13,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape13) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/lineX.js
var shape14 = {
  line: Line4
};
var LineX = (options) => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X } = value2;
    const offset2 = createBandOffset(scale12, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
    const P = Array.from(index3, (i2) => {
      const p1 = [X[i2], 1];
      const p22 = [X[i2], 0];
      return [p1, p22].map((d4) => coordinate.map(offset2(d4, i2)));
    });
    return [index3, P];
  };
};
LineX.props = {
  defaultShape: "line",
  defaultLabelShape: "label",
  composite: false,
  shape: shape14,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape14) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeTupleX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/connector.js
var shape15 = {
  connector: Connector
};
var Connector2 = (...args) => {
  return Link2(...args);
};
Connector2.props = {
  defaultShape: "connector",
  defaultLabelShape: "label",
  composite: false,
  shape: shape15,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape15) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/range.js
function extend2(channel, extended, value2, scale12) {
  if (extended)
    return () => [0, 1];
  const { [channel]: C4, [`${channel}1`]: C1 } = value2;
  return (i2) => {
    var _a2;
    const offset2 = ((_a2 = scale12.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale12, scale12.invert(+C1[i2]))) || 0;
    return [C4[i2], C1[i2] + offset2];
  };
}
function AbstractRange(options = {}) {
  const { extendX = false, extendY = false } = options;
  return (index3, scale12, value2, coordinate) => {
    const x3 = extend2("x", extendX, value2, scale12.x);
    const y4 = extend2("y", extendY, value2, scale12.y);
    const P = Array.from(index3, (i2) => {
      const [x12, x22] = x3(i2);
      const [y12, y22] = y4(i2);
      const p1 = [x12, y12];
      const p22 = [x22, y12];
      const p3 = [x22, y22];
      const p4 = [x12, y22];
      return [p1, p22, p3, p4].map((d4) => coordinate.map(d4));
    });
    return [index3, P];
  };
}
var shape16 = { range: Rect2 };
var Range2 = () => {
  return AbstractRange();
};
Range2.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape16,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape16) }),
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeX.js
var shape17 = {
  range: Rect2
};
var RangeX = () => {
  return AbstractRange({ extendY: true });
};
RangeX.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape17,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape17) }),
    { name: "x", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultX }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/mark/rangeY.js
var shape18 = {
  range: Rect2
};
var RangeY = () => {
  return AbstractRange({ extendX: true });
};
RangeY.props = {
  defaultShape: "range",
  defaultLabelShape: "label",
  composite: false,
  shape: shape18,
  channels: [
    ...baseAnnotationChannels({ shapes: Object.keys(shape18) }),
    { name: "y", required: true }
  ],
  preInference: [...basePreInference(), { type: MaybeDefaultY }],
  postInference: [...basePostInference()]
};

// node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js
function targetDepth(d4) {
  return d4.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n2) {
  return n2 - 1 - node.height;
}
function justify(node, n2) {
  return node.sourceLinks.length ? node.depth : n2 - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min4(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js
function constant3(x3) {
  return function() {
    return x3;
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js
function ascendingSourceBreadth(a5, b) {
  return ascendingBreadth(a5.source, b.source) || a5.index - b.index;
}
function ascendingTargetBreadth(a5, b) {
  return ascendingBreadth(a5.target, b.target) || a5.index - b.index;
}
function ascendingBreadth(a5, b) {
  return a5.y0 - b.y0;
}
function value(d4) {
  return d4.value;
}
function defaultId(d4) {
  return d4.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find4(nodeById, id4) {
  const node = nodeById.get(id4);
  if (!node)
    throw new Error("missing: " + id4);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y05 = node.y0;
    let y12 = y05;
    for (const link3 of node.sourceLinks) {
      link3.y0 = y05 + link3.width / 2;
      y05 += link3.width;
    }
    for (const link3 of node.targetLinks) {
      link3.y1 = y12 + link3.width / 2;
      y12 += link3.width;
    }
  }
}
function Sankey() {
  let x05 = 0, y05 = 0, x12 = 1, y12 = 1;
  let dx = 24;
  let dy = 8, py;
  let id4 = defaultId;
  let align = justify;
  let depth;
  let sort2;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations2 = 6;
  function sankey(arg) {
    const graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_2) {
    return arguments.length ? (id4 = typeof _2 === "function" ? _2 : constant3(_2), sankey) : id4;
  };
  sankey.nodeAlign = function(_2) {
    return arguments.length ? (align = typeof _2 === "function" ? _2 : constant3(_2), sankey) : align;
  };
  sankey.nodeDepth = function(_2) {
    return arguments.length ? (depth = typeof _2 === "function" ? _2 : _2, sankey) : depth;
  };
  sankey.nodeSort = function(_2) {
    return arguments.length ? (sort2 = _2, sankey) : sort2;
  };
  sankey.nodeWidth = function(_2) {
    return arguments.length ? (dx = +_2, sankey) : dx;
  };
  sankey.nodePadding = function(_2) {
    return arguments.length ? (dy = py = +_2, sankey) : dy;
  };
  sankey.nodes = function(_2) {
    return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant3(_2), sankey) : nodes;
  };
  sankey.links = function(_2) {
    return arguments.length ? (links = typeof _2 === "function" ? _2 : constant3(_2), sankey) : links;
  };
  sankey.linkSort = function(_2) {
    return arguments.length ? (linkSort = _2, sankey) : linkSort;
  };
  sankey.size = function(_2) {
    return arguments.length ? (x05 = y05 = 0, x12 = +_2[0], y12 = +_2[1], sankey) : [x12 - x05, y12 - y05];
  };
  sankey.extent = function(_2) {
    return arguments.length ? (x05 = +_2[0][0], x12 = +_2[1][0], y05 = +_2[0][1], y12 = +_2[1][1], sankey) : [
      [x05, y05],
      [x12, y12]
    ];
  };
  sankey.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, sankey) : iterations2;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    nodes2.forEach((node, idx) => {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    const nodeById = new Map(nodes2.map((d4) => [id4(d4), d4]));
    links2.forEach((link3, idx) => {
      link3.index = idx;
      let { source, target } = link3;
      if (typeof source !== "object")
        source = link3.source = find4(nodeById, source);
      if (typeof target !== "object")
        target = link3.target = find4(nodeById, target);
      source.sourceLinks.push(link3);
      target.targetLinks.push(link3);
    });
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n2 = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x3 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.depth = x3;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      });
      if (++x3 > n2)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
    if (depth) {
      const maxDepth2 = Math.max(max5(nodes2, (d4) => d4.depth) + 1, 0);
      let node;
      for (let i2 = 0; i2 < nodes2.length; i2++) {
        node = nodes2[i2];
        node.depth = depth.call(null, node, maxDepth2);
      }
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n2 = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x3 = 0;
    while (current.size) {
      current.forEach((node) => {
        node.height = x3;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      });
      if (++x3 > n2)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x3 = Math.max(max5(nodes2, (d4) => d4.depth) + 1, 0);
    const kx2 = (x12 - x05 - dx) / (x3 - 1);
    const columns = new Array(x3).fill(0).map(() => []);
    for (const node of nodes2) {
      const i2 = Math.max(0, Math.min(x3 - 1, Math.floor(align.call(null, node, x3))));
      node.layer = i2;
      node.x0 = x05 + i2 * kx2;
      node.x1 = node.x0 + dx;
      if (columns[i2])
        columns[i2].push(node);
      else
        columns[i2] = [node];
    }
    if (sort2)
      for (const column2 of columns) {
        column2.sort(sort2);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky2 = min4(columns, (c6) => (y12 - y05 - (c6.length - 1) * py) / sum(c6, value));
    for (const nodes2 of columns) {
      let y4 = y05;
      for (const node of nodes2) {
        node.y0 = y4;
        node.y1 = y4 + node.value * ky2;
        y4 = node.y1 + py;
        for (const link3 of node.sourceLinks) {
          link3.width = link3.value * ky2;
        }
      }
      y4 = (y12 - y4 + py) / (nodes2.length + 1);
      for (let i2 = 0; i2 < nodes2.length; ++i2) {
        const node = nodes2[i2];
        node.y0 += y4 * (i2 + 1);
        node.y1 += y4 * (i2 + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y12 - y05) / (max5(columns, (c6) => c6.length) - 1));
    initializeNodeBreadths(columns);
    for (let i2 = 0; i2 < iterations2; ++i2) {
      const alpha = Math.pow(0.99, i2);
      const beta = Math.max(1 - alpha, (i2 + 1) / iterations2);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i2 = 1, n2 = columns.length; i2 < n2; ++i2) {
      const column2 = columns[i2];
      for (const target of column2) {
        let y4 = 0;
        let w2 = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          const v = value2 * (target.layer - source.layer);
          y4 += targetTop(source, target) * v;
          w2 += v;
        }
        if (!(w2 > 0))
          continue;
        const dy2 = (y4 / w2 - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n2 = columns.length, i2 = n2 - 2; i2 >= 0; --i2) {
      const column2 = columns[i2];
      for (const source of column2) {
        let y4 = 0;
        let w2 = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          const v = value2 * (target.layer - source.layer);
          y4 += sourceTop(source, target) * v;
          w2 += v;
        }
        if (!(w2 > 0))
          continue;
        const dy2 = (y4 / w2 - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort2 === void 0)
        column2.sort(ascendingBreadth);
      if (column2.length)
        resolveCollisions(column2, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i2 = nodes2.length >> 1;
    const subject = nodes2[i2];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i2 - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i2 + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y12, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y05, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y4, i2, alpha) {
    for (; i2 < nodes2.length; ++i2) {
      const node = nodes2[i2];
      const dy2 = (y4 - node.y0) * alpha;
      if (dy2 > 1e-6)
        node.y0 += dy2, node.y1 += dy2;
      y4 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y4, i2, alpha) {
    for (; i2 >= 0; --i2) {
      const node = nodes2[i2];
      const dy2 = (node.y1 - y4) * alpha;
      if (dy2 > 1e-6)
        node.y0 -= dy2, node.y1 -= dy2;
      y4 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y4 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y4 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y4 -= width;
    }
    return y4;
  }
  function sourceTop(source, target) {
    let y4 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y4 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y4 -= width;
    }
    return y4;
  }
  return sankey;
}

// node_modules/@antv/g2/esm/data/sankey.js
var DEFAULT_OPTIONS = {
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodes: (graph) => graph.nodes,
  links: (graph) => graph.links,
  nodeSort: void 0,
  linkSort: void 0,
  iterations: 6
};
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
function getNodeAlignFunction(nodeAlign) {
  const type = typeof nodeAlign;
  if (type === "string")
    return ALIGN_METHOD[nodeAlign] || justify;
  if (type === "function")
    return nodeAlign;
  return justify;
}
var Sankey2 = (options) => {
  return (data2) => {
    const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding, nodeDepth, nodes: nodeNodes, links: nodeLinks, linkSort, iterations: iterations2 } = Object.assign({}, DEFAULT_OPTIONS, options);
    const sankeyProcessor = Sankey().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations2).extent([
      [0, 0],
      [1, 1]
    ]);
    if (typeof nodeId === "function") {
      sankeyProcessor.nodeId(nodeId);
    }
    const layoutData = sankeyProcessor(data2);
    const { nodes: N, links: L } = layoutData;
    const nodes = N.map((node) => {
      const { x0: x05, x1: x12, y0: y05, y1: y12 } = node;
      return Object.assign(Object.assign({}, node), { x: [x05, x12, x12, x05], y: [y05, y05, y12, y12] });
    });
    const links = L.map((edge) => {
      const { source, target } = edge;
      const sx = source.x1;
      const tx = target.x0;
      const offset2 = edge.width / 2;
      return Object.assign(Object.assign({}, edge), { x: [sx, sx, tx, tx], y: [
        edge.y0 + offset2,
        edge.y0 - offset2,
        edge.y1 + offset2,
        edge.y1 - offset2
      ] });
    });
    return { nodes, links };
  };
};
Sankey2.props = {};

// node_modules/@antv/g2/esm/utils/mark.js
function subTooltip(tooltip2, name2, defaults4 = {}, main = false) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2) && main)
    return tooltip2;
  const sub8 = subObject(tooltip2, name2);
  return deep_mix_default(defaults4, sub8);
}
function maybeTooltip(tooltip2, defaults4 = {}) {
  if (isUnset(tooltip2))
    return tooltip2;
  if (Array.isArray(tooltip2))
    return tooltip2;
  if (!isFullTooltip(tooltip2))
    return tooltip2;
  return deep_mix_default(defaults4, tooltip2);
}
function isFullTooltip(tooltip2) {
  if (Object.keys(tooltip2).length === 0)
    return true;
  const { title, items } = tooltip2;
  return title !== void 0 || items !== void 0;
}
function maybeAnimation(animate2, sub8) {
  return typeof animate2 === "object" ? subObject(animate2, sub8) : animate2;
}

// node_modules/@antv/g2/esm/mark/sankey.js
var __rest43 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS = {
  nodeId: (d4) => d4.key,
  nodeWidth: 0.02,
  nodePadding: 0.02
};
var DEFAULT_NODE_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    stroke: "#000"
  }
};
var DEFAULT_LINK_OPTIONS = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    fillOpacity: 0.5,
    stroke: void 0
  }
};
var DEFAULT_LABEL_OPTIONS = {
  textAlign: (d4) => d4.x[0] < 0.5 ? "start" : "end",
  position: (d4) => d4.x[0] < 0.5 ? "right" : "left",
  fontSize: 10
};
var Sankey3 = (options) => {
  const { data: data2, encode = {}, scale: scale12, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {}, interaction, state = {} } = options;
  const { links, nodes } = initializeData(data2, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d4) => d4.key, color: color3 = nodeKey } = nodeEncode;
  const { links: linkData, nodes: nodeData } = Sankey2(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS), { nodeId: field(nodeKey) }), layout))({ links, nodes });
  const _a2 = subObject(style, "label"), { text = nodeKey, spacing = 5 } = _a2, labelStyle = __rest43(_a2, ["text", "spacing"]);
  const key1 = field(nodeKey);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: key1,
    items: [{ field: "value" }]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d4) => ({ name: "source", value: key1(d4.source) }),
      (d4) => ({ name: "target", value: key1(d4.target) })
    ]
  });
  const [nodeState, linkState] = Object.entries(state).reduce((acc, [stateName, styleObj]) => {
    const commonState = omitPrefixObject(styleObj, "node", "link");
    const nodeState2 = subObject(styleObj, "node");
    acc[0][stateName] = Object.assign(Object.assign({}, commonState), nodeState2);
    const linkState2 = subObject(styleObj, "link");
    acc[1][stateName] = Object.assign(Object.assign({}, commonState), linkState2);
    return acc;
  }, [{}, {}]);
  return [
    deep_mix_default({}, DEFAULT_NODE_OPTIONS, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color: color3 }),
      scale: scale12,
      style: subObject(style, "node"),
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS), { text, dx: (d4) => d4.x[0] < 0.5 ? spacing : -spacing }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node"),
      axis: false,
      interaction,
      state: nodeState
    }),
    deep_mix_default({}, DEFAULT_LINK_OPTIONS, {
      data: linkData,
      encode: linkEncode,
      labels: linkLabels,
      style: Object.assign({ fill: linkEncode.color ? void 0 : "#aaa", lineWidth: 0 }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link"),
      interaction,
      state: linkState
    })
  ];
};
Sankey3.props = {};

// node_modules/@antv/g2/esm/data/utils/arc/sort.js
var sort_exports = {};
__export(sort_exports, {
  frequency: () => frequency,
  id: () => id2,
  name: () => name,
  weight: () => weight
});
function weight(a5, b) {
  return b.value - a5.value;
}
function frequency(a5, b) {
  return b.frequency - a5.frequency;
}
function id2(a5, b) {
  return `${a5.id}`.localeCompare(`${b.id}`);
}
function name(a5, b) {
  return `${a5.name}`.localeCompare(`${b.name}`);
}

// node_modules/@antv/g2/esm/data/utils/arc/arc.js
var DEFAULT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  weight: false,
  marginRatio: 0.1,
  id: (node) => node.id,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
};
function Arc2(options) {
  const { y: y4, thickness, weight: weight2, marginRatio, id: id4, source, target, sourceWeight, targetWeight, sortBy: sortBy2 } = Object.assign(Object.assign({}, DEFAULT_OPTIONS2), options);
  function arc(data2) {
    const nodes = data2.nodes.map((n2) => Object.assign({}, n2));
    const edges = data2.edges.map((n2) => Object.assign({}, n2));
    preprocess(nodes, edges);
    sortNodes(nodes, edges);
    layoutNodes(nodes, edges);
    layoutEdges(nodes, edges);
    return { nodes, edges };
  }
  function preprocess(nodes, edges) {
    edges.forEach((edge) => {
      edge.source = source(edge);
      edge.target = target(edge);
      edge.sourceWeight = sourceWeight(edge);
      edge.targetWeight = targetWeight(edge);
    });
    const edgesBySource = group(edges, (e3) => e3.source);
    const edgesByTarget = group(edges, (e3) => e3.target);
    nodes.forEach((node) => {
      node.id = id4(node);
      const sources = edgesBySource.has(node.id) ? edgesBySource.get(node.id) : [];
      const targets = edgesByTarget.has(node.id) ? edgesByTarget.get(node.id) : [];
      node.frequency = sources.length + targets.length;
      node.value = sum(sources, (d4) => d4.sourceWeight) + sum(targets, (d4) => d4.targetWeight);
    });
    return { nodes, edges };
  }
  function sortNodes(nodes, edges) {
    const method = typeof sortBy2 === "function" ? sortBy2 : sort_exports[sortBy2];
    if (method) {
      nodes.sort(method);
    }
  }
  function layoutNodes(nodes, edges) {
    const size3 = nodes.length;
    if (!size3) {
      throw error("Invalid nodes: it's empty!");
    }
    if (!weight2) {
      const deltaX = 1 / size3;
      nodes.forEach((node, i2) => {
        node.x = (i2 + 0.5) * deltaX;
        node.y = y4;
      });
      return { nodes, edges };
    }
    const margin = marginRatio / (2 * size3);
    const total = nodes.reduce((prev, node) => prev += node.value, 0);
    nodes.reduce((deltaX, node) => {
      node.weight = node.value / total;
      node.width = node.weight * (1 - marginRatio);
      node.height = thickness;
      const minX = margin + deltaX;
      const maxX = minX + node.width;
      const minY = y4 - thickness / 2;
      const maxY2 = minY + thickness;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY2, maxY2];
      return deltaX + node.width + 2 * margin;
    }, 0);
    return {
      nodes,
      edges
    };
  }
  function layoutEdges(nodes, edges) {
    const nodesMap = new Map(nodes.map((d4) => [d4.id, d4]));
    if (!weight2) {
      edges.forEach((edge) => {
        const sourceId = source(edge);
        const targetId = target(edge);
        const sourceNode = nodesMap.get(sourceId);
        const targetNode = nodesMap.get(targetId);
        if (sourceNode && targetNode) {
          edge.x = [sourceNode.x, targetNode.x];
          edge.y = [sourceNode.y, targetNode.y];
        }
      });
      return { nodes, edges };
    }
    edges.forEach((edge) => {
      edge.x = [0, 0, 0, 0];
      edge.y = [y4, y4, y4, y4];
    });
    const edgesBySource = group(edges, (e3) => e3.source);
    const edgesByTarget = group(edges, (e3) => e3.target);
    nodes.forEach((node) => {
      const { edges: edges2, width, x: x3, y: y5, value: value2, id: id5 } = node;
      const sourceEdges = edgesBySource.get(id5) || [];
      const targetEdges = edgesByTarget.get(id5) || [];
      let offset2 = 0;
      sourceEdges.map((edge) => {
        const w2 = edge.sourceWeight / value2 * width;
        edge.x[0] = x3[0] + offset2;
        edge.x[1] = x3[0] + offset2 + w2;
        offset2 += w2;
      });
      targetEdges.forEach((edge) => {
        const w2 = edge.targetWeight / value2 * width;
        edge.x[3] = x3[0] + offset2;
        edge.x[2] = x3[0] + offset2 + w2;
        offset2 += w2;
      });
    });
  }
  return arc;
}

// node_modules/@antv/g2/esm/data/arc.js
var Arc3 = (options) => {
  return (data2) => {
    return Arc2(options)(data2);
  };
};
Arc3.props = {};

// node_modules/@antv/g2/esm/mark/chord.js
var __rest44 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS2 = {
  y: 0,
  thickness: 0.05,
  marginRatio: 0.1,
  id: (node) => node.key,
  source: (edge) => edge.source,
  target: (edge) => edge.target,
  sourceWeight: (edge) => edge.value || 1,
  targetWeight: (edge) => edge.value || 1,
  sortBy: null
  // optional, id | weight | frequency | {function}
};
var DEFAULT_NODE_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "polygon",
    x: "x",
    y: "y"
  },
  scale: {
    x: { type: "identity" },
    y: { type: "identity" }
  },
  style: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  }
};
var DEFAULT_LINK_OPTIONS2 = {
  type: "polygon",
  axis: false,
  legend: false,
  encode: {
    shape: "ribbon",
    x: "x",
    y: "y"
  },
  style: {
    opacity: 0.5,
    lineWidth: 1
  }
};
var DEFAULT_LABEL_OPTIONS2 = {
  position: "outside",
  fontSize: 10
};
var Chord = (options, context) => {
  const { data: data2, encode = {}, scale: scale12, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const { nodes, links } = initializeData(data2, encode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { key: nodeKey = (d4) => d4.key, color: color3 = nodeKey } = nodeEncode;
  const { linkEncodeColor = (d4) => d4.source } = linkEncode;
  const { nodeWidthRatio = DEFAULT_LAYOUT_OPTIONS2.thickness, nodePaddingRatio = DEFAULT_LAYOUT_OPTIONS2.marginRatio } = layout, restLayout = __rest44(layout, ["nodeWidthRatio", "nodePaddingRatio"]);
  const { nodes: nodeData, edges: linkData } = Arc3(Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS2), { id: field(nodeKey), thickness: nodeWidthRatio, marginRatio: nodePaddingRatio }), restLayout), { weight: true }))({ nodes, edges: links });
  const _a2 = subObject(style, "label"), { text = nodeKey } = _a2, labelStyle = __rest44(_a2, ["text"]);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "",
    items: [(d4) => ({ name: d4.key, value: d4.value })]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [(d4) => ({ name: `${d4.source} -> ${d4.target}`, value: d4.value })]
  });
  const { height, width } = context;
  const minimumLen = Math.min(height, width);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS2, {
      data: linkData,
      encode: Object.assign(Object.assign({}, linkEncode), { color: linkEncodeColor }),
      labels: linkLabels,
      style: Object.assign({ fill: linkEncodeColor ? void 0 : "#aaa" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS2, {
      data: nodeData,
      encode: Object.assign(Object.assign({}, nodeEncode), { color: color3 }),
      scale: scale12,
      style: subObject(style, "node"),
      coordinate: {
        type: "polar",
        // Leave enough rendering space for the label.
        outerRadius: (minimumLen - 20) / minimumLen,
        startAngle: -Math.PI * 2,
        endAngle: 0
      },
      labels: [
        Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS2), { text }), labelStyle),
        ...nodeLabels
      ],
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node"),
      axis: false
    })
  ];
};
Chord.props = {};

// node_modules/@antv/g2/esm/mark/path.js
var shape19 = {
  path: Path3,
  hollow: Hollow2
};
var Path4 = (options) => {
  return (index3, scale12, value2, coordinate) => {
    return [index3, index3.map(() => [[0, 0]])];
  };
};
Path4.props = {
  defaultShape: "path",
  defaultLabelShape: "label",
  shape: shape19,
  composite: false,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape19) }),
    { name: "d", scale: "identity" }
  ],
  preInference: [...basePreInference()],
  postInference: [...basePostInference()]
};

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a5, b) {
  return a5.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x3, c6) {
  return x3 + c6.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y4, c6) {
  return Math.max(y4, c6.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root2) {
    var previousNode, x3 = 0;
    root2.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x3 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x05 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x05) / (x12 - x05) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster.separation = function(x3) {
    return arguments.length ? (separation = x3, cluster) : separation;
  };
  cluster.size = function(x3) {
    return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x3) {
    return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count3(node) {
  var sum4 = 0, children = node.children, i2 = children && children.length;
  if (!i2) sum4 = 1;
  else while (--i2 >= 0) sum4 += children[i2].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count3);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index3 = -1;
  for (const node of this) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children, i2, index3 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index3, this);
    if (children = node.children) {
      for (i2 = children.length - 1; i2 >= 0; --i2) {
        nodes.push(children[i2]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children, i2, n2, index3 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        nodes.push(children[i2]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index3, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index3 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index3, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node) {
    var sum4 = +value2(node.data) || 0, children = node.children, i2 = children && children.length;
    while (--i2 >= 0) sum4 += children[i2].value;
    node.value = sum4;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a5, b) {
  if (a5 === b) return a5;
  var aNodes = a5.ancestors(), bNodes = b.ancestors(), c6 = null;
  a5 = aNodes.pop();
  b = bNodes.pop();
  while (a5 === b) {
    c6 = a5;
    a5 = aNodes.pop();
    b = bNodes.pop();
  }
  return c6;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current, next = [node], children, i2, n2;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
          next.push(children[i2]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data2, children) {
  if (data2 instanceof Map) {
    data2 = [void 0, data2];
    if (children === void 0) children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root2 = new Node2(data2), node, nodes = [root2], child, childs, i2, n2;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n2 = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = childs[i2] = new Node2(childs[i2]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d4) {
  return d4.children;
}
function mapChildren(d4) {
  return Array.isArray(d4) ? d4[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f2) {
  return f2 == null ? null : required(f2);
}
function required(f2) {
  if (typeof f2 !== "function") throw new Error();
  return f2;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default2(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a2 = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s4 = 1;
  return () => (s4 = (a2 * s4 + c) % m) / m;
}

// node_modules/d3-hierarchy/src/array.js
function array_default2(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}
function shuffle(array2, random5) {
  let m3 = array2.length, t, i2;
  while (m3) {
    i2 = random5() * m3-- | 0;
    t = array2[m3];
    array2[m3] = array2[i2];
    array2[i2] = t;
  }
  return array2;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random5) {
  var i2 = 0, n2 = (circles = shuffle(Array.from(circles), random5)).length, B4 = [], p3, e3;
  while (i2 < n2) {
    p3 = circles[i2];
    if (e3 && enclosesWeak(e3, p3)) ++i2;
    else e3 = encloseBasis(B4 = extendBasis(B4, p3)), i2 = 0;
  }
  return e3;
}
function extendBasis(B4, p3) {
  var i2, j;
  if (enclosesWeakAll(p3, B4)) return [p3];
  for (i2 = 0; i2 < B4.length; ++i2) {
    if (enclosesNot(p3, B4[i2]) && enclosesWeakAll(encloseBasis2(B4[i2], p3), B4)) {
      return [B4[i2], p3];
    }
  }
  for (i2 = 0; i2 < B4.length - 1; ++i2) {
    for (j = i2 + 1; j < B4.length; ++j) {
      if (enclosesNot(encloseBasis2(B4[i2], B4[j]), p3) && enclosesNot(encloseBasis2(B4[i2], p3), B4[j]) && enclosesNot(encloseBasis2(B4[j], p3), B4[i2]) && enclosesWeakAll(encloseBasis3(B4[i2], B4[j], p3), B4)) {
        return [B4[i2], B4[j], p3];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a5, b) {
  var dr = a5.r - b.r, dx = b.x - a5.x, dy = b.y - a5.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a5, b) {
  var dr = a5.r - b.r + Math.max(a5.r, b.r, 1) * 1e-9, dx = b.x - a5.x, dy = b.y - a5.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a5, B4) {
  for (var i2 = 0; i2 < B4.length; ++i2) {
    if (!enclosesWeak(a5, B4[i2])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B4) {
  switch (B4.length) {
    case 1:
      return encloseBasis1(B4[0]);
    case 2:
      return encloseBasis2(B4[0], B4[1]);
    case 3:
      return encloseBasis3(B4[0], B4[1], B4[2]);
  }
}
function encloseBasis1(a5) {
  return {
    x: a5.x,
    y: a5.y,
    r: a5.r
  };
}
function encloseBasis2(a5, b) {
  var x12 = a5.x, y12 = a5.y, r1 = a5.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l2 = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x22 + x21 / l2 * r21) / 2,
    y: (y12 + y22 + y21 / l2 * r21) / 2,
    r: (l2 + r1 + r2) / 2
  };
}
function encloseBasis3(a5, b, c6) {
  var x12 = a5.x, y12 = a5.y, r1 = a5.r, x22 = b.x, y22 = b.y, r2 = b.r, x3 = c6.x, y32 = c6.y, r3 = c6.r, a22 = x12 - x22, a32 = x12 - x3, b2 = y12 - y22, b3 = y12 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d22 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d32 = d1 - x3 * x3 - y32 * y32 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d32 - b3 * d22) / (ab * 2) - x12, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d22 - a22 * d32) / (ab * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab, A6 = xb * xb + yb * yb - 1, B4 = 2 * (r1 + xa * xb + ya * yb), C4 = xa * xa + ya * ya - r1 * r1, r4 = -(Math.abs(A6) > 1e-6 ? (B4 + Math.sqrt(B4 * B4 - 4 * A6 * C4)) / (2 * A6) : C4 / B4);
  return {
    x: x12 + xa + xb * r4,
    y: y12 + ya + yb * r4,
    r: r4
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b, a5, c6) {
  var dx = b.x - a5.x, x3, a22, dy = b.y - a5.y, y4, b2, d22 = dx * dx + dy * dy;
  if (d22) {
    a22 = a5.r + c6.r, a22 *= a22;
    b2 = b.r + c6.r, b2 *= b2;
    if (a22 > b2) {
      x3 = (d22 + b2 - a22) / (2 * d22);
      y4 = Math.sqrt(Math.max(0, b2 / d22 - x3 * x3));
      c6.x = b.x - x3 * dx - y4 * dy;
      c6.y = b.y - x3 * dy + y4 * dx;
    } else {
      x3 = (d22 + a22 - b2) / (2 * d22);
      y4 = Math.sqrt(Math.max(0, a22 / d22 - x3 * x3));
      c6.x = a5.x + x3 * dx - y4 * dy;
      c6.y = a5.y + x3 * dy + y4 * dx;
    }
  } else {
    c6.x = a5.x + c6.r;
    c6.y = a5.y;
  }
}
function intersects(a5, b) {
  var dr = a5.r + b.r - 1e-6, dx = b.x - a5.x, dy = b.y - a5.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a5 = node._, b = node.next._, ab = a5.r + b.r, dx = (a5.x * b.r + b.x * a5.r) / ab, dy = (a5.y * b.r + b.y * a5.r) / ab;
  return dx * dx + dy * dy;
}
function Node3(circle3) {
  this._ = circle3;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random5) {
  if (!(n2 = (circles = array_default2(circles)).length)) return 0;
  var a5, b, c6, n2, aa, ca, i2, j, k2, sj, sk;
  a5 = circles[0], a5.x = 0, a5.y = 0;
  if (!(n2 > 1)) return a5.r;
  b = circles[1], a5.x = -b.r, b.x = a5.r, b.y = 0;
  if (!(n2 > 2)) return a5.r + b.r;
  place(b, a5, c6 = circles[2]);
  a5 = new Node3(a5), b = new Node3(b), c6 = new Node3(c6);
  a5.next = c6.previous = b;
  b.next = a5.previous = c6;
  c6.next = b.previous = a5;
  pack: for (i2 = 3; i2 < n2; ++i2) {
    place(a5._, b._, c6 = circles[i2]), c6 = new Node3(c6);
    j = b.next, k2 = a5.previous, sj = b._.r, sk = a5._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c6._)) {
          b = j, a5.next = b, b.previous = a5, --i2;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k2._, c6._)) {
          a5 = k2, a5.next = b, b.previous = a5, --i2;
          continue pack;
        }
        sk += k2._.r, k2 = k2.previous;
      }
    } while (j !== k2.next);
    c6.previous = a5, c6.next = b, a5.next = b.previous = b = c6;
    aa = score(a5);
    while ((c6 = c6.next) !== b) {
      if ((ca = score(c6)) < aa) {
        a5 = c6, aa = ca;
      }
    }
    b = a5.next;
  }
  a5 = [b._], c6 = b;
  while ((c6 = c6.next) !== b) a5.push(c6._);
  c6 = packEncloseRandom(a5, random5);
  for (i2 = 0; i2 < n2; ++i2) a5 = circles[i2], a5.x -= c6.x, a5.y -= c6.y;
  return c6.r;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d4) {
  return Math.sqrt(d4.value);
}
function pack_default() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack3(root2) {
    const random5 = lcg_default();
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius) {
      root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random5)).eachAfter(packChildrenRandom(padding, root2.r / Math.min(dx, dy), random5)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack3.radius = function(x3) {
    return arguments.length ? (radius = optional(x3), pack3) : radius;
  };
  pack3.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], pack3) : [dx, dy];
  };
  pack3.padding = function(x3) {
    return arguments.length ? (padding = typeof x3 === "function" ? x3 : constant_default2(+x3), pack3) : padding;
  };
  return pack3;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildrenRandom(padding, k2, random5) {
  return function(node) {
    if (children = node.children) {
      var children, i2, n2 = children.length, r2 = padding(node) * k2 || 0, e3;
      if (r2) for (i2 = 0; i2 < n2; ++i2) children[i2].r += r2;
      e3 = packSiblingsRandom(children, random5);
      if (r2) for (i2 = 0; i2 < n2; ++i2) children[i2].r -= r2;
      node.r = e3 + r2;
    }
  };
}
function translateChild(k2) {
  return function(node) {
    var parent = node.parent;
    node.r *= k2;
    if (parent) {
      node.x = parent.x + k2 * node.x;
      node.y = parent.y + k2 * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i2 = -1, n2 = nodes.length, k2 = parent.value && (x12 - x05) / parent.value;
  while (++i2 < n2) {
    node = nodes[i2], node.y0 = y05, node.y1 = y12;
    node.x0 = x05, node.x1 = x05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round6 = false;
  function partition2(root2) {
    var n2 = root2.height + 1;
    root2.x0 = root2.y0 = padding;
    root2.x1 = dx;
    root2.y1 = dy / n2;
    root2.eachBefore(positionNode(dy, n2));
    if (round6) root2.eachBefore(round_default);
    return root2;
  }
  function positionNode(dy2, n2) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n2, node.x1, dy2 * (node.depth + 2) / n2);
      }
      var x05 = node.x0, y05 = node.y0, x12 = node.x1 - padding, y12 = node.y1 - padding;
      if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
      node.x0 = x05;
      node.y0 = y05;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition2.round = function(x3) {
    return arguments.length ? (round6 = !!x3, partition2) : round6;
  };
  partition2.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x3) {
    return arguments.length ? (padding = +x3, partition2) : padding;
  };
  return partition2;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId2(d4) {
  return d4.id;
}
function defaultParentId(d4) {
  return d4.parentId;
}
function stratify_default() {
  var id4 = defaultId2, parentId = defaultParentId, path2;
  function stratify(data2) {
    var nodes = Array.from(data2), currentId = id4, currentParentId = parentId, n2, d4, i2, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I = nodes.map((d5, i3) => normalize8(path2(d5, i3, data2)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i3 of P) {
        if (!S.has(i3)) {
          S.add(i3);
          I.push(i3);
          P.push(parentof(i3));
          nodes.push(imputed);
        }
      }
      currentId = (_2, i3) => I[i3];
      currentParentId = (_2, i3) => P[i3];
    }
    for (i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      d4 = nodes[i2], node = nodes[i2] = new Node2(d4);
      if ((nodeId = currentId(d4, i2, data2)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d4, i2, data2)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root2) throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2) throw new Error("no root");
    if (path2 != null) {
      while (root2.data === imputed && root2.children.length === 1) {
        root2 = root2.children[0], --n2;
      }
      for (let i3 = nodes.length - 1; i3 >= 0; --i3) {
        node = nodes[i3];
        if (node.data !== imputed) break;
        node.data = null;
      }
    }
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n2;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n2 > 0) throw new Error("cycle");
    return root2;
  }
  stratify.id = function(x3) {
    return arguments.length ? (id4 = optional(x3), stratify) : id4;
  };
  stratify.parentId = function(x3) {
    return arguments.length ? (parentId = optional(x3), stratify) : parentId;
  };
  stratify.path = function(x3) {
    return arguments.length ? (path2 = optional(x3), stratify) : path2;
  };
  return stratify;
}
function normalize8(path2) {
  path2 = `${path2}`;
  let i2 = path2.length;
  if (slash(path2, i2 - 1) && !slash(path2, i2 - 2)) path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i2 = path2.length;
  if (i2 < 2) return "";
  while (--i2 > 1) if (slash(path2, i2)) break;
  return path2.slice(0, i2);
}
function slash(path2, i2) {
  if (path2[i2] === "/") {
    let k2 = 0;
    while (i2 > 0 && path2[--i2] === "\\") ++k2;
    if ((k2 & 1) === 0) return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a5, b) {
  return a5.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i2 = children.length, w2;
  while (--i2 >= 0) {
    w2 = children[i2];
    w2.z += shift;
    w2.m += shift;
    shift += w2.s + (change += w2.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i2) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i2;
}
TreeNode.prototype = Object.create(Node2.prototype);
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children, i2, n2;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n2 = children.length);
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = node.children[i2] = new TreeNode(children[i2], i2));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize) root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x) left2 = node;
        if (node.x > right2.x) right2 = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s4 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s4 - left2.x, kx2 = dx / (right2.x + s4 + tx), ky2 = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx2;
        node.y = node.depth * ky2;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children = v.children, siblings = v.parent.children, w2 = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w2) {
        v.z = w2.z + separation(v._, w2._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w2) {
      v.z = w2.z + separation(v._, w2._);
    }
    v.parent.A = apportion(v, w2, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w2, ancestor) {
    if (w2) {
      var vip = v, vop = v, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x3) {
    return arguments.length ? (separation = x3, tree) : separation;
  };
  tree.size = function(x3) {
    return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x3) {
    return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, node, i2 = -1, n2 = nodes.length, k2 = parent.value && (y12 - y05) / parent.value;
  while (++i2 < n2) {
    node = nodes[i2], node.x0 = x05, node.x1 = x12;
    node.y0 = y05, node.y1 = y05 += node.value * k2;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x05, y05, x12, y12) {
  var rows = [], nodes = parent.children, row2, nodeValue, i0 = 0, i1 = 0, n2 = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n2) {
    dx = x12 - x05, dy = y12 - y05;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n2);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n2; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row2 = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row2.dice) dice_default(row2, x05, y05, x12, value2 ? y05 += dy * sumValue / value2 : y12);
    else slice_default(row2, x05, y05, value2 ? x05 += dx * sumValue / value2 : x12, y12);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom8(ratio) {
  function squarify(parent, x05, y05, x12, y12) {
    squarifyRatio(ratio, parent, x05, y05, x12, y12);
  }
  squarify.ratio = function(x3) {
    return custom8((x3 = +x3) > 1 ? x3 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round6 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round6) root2.eachBefore(round_default);
    return root2;
  }
  function positionNode(node) {
    var p3 = paddingStack[node.depth], x05 = node.x0 + p3, y05 = node.y0 + p3, x12 = node.x1 - p3, y12 = node.y1 - p3;
    if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
    if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
    node.x0 = x05;
    node.y0 = y05;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p3 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x05 += paddingLeft(node) - p3;
      y05 += paddingTop(node) - p3;
      x12 -= paddingRight(node) - p3;
      y12 -= paddingBottom(node) - p3;
      if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
      tile(node, x05, y05, x12, y12);
    }
  }
  treemap.round = function(x3) {
    return arguments.length ? (round6 = !!x3, treemap) : round6;
  };
  treemap.size = function(x3) {
    return arguments.length ? (dx = +x3[0], dy = +x3[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x3) {
    return arguments.length ? (tile = required(x3), treemap) : tile;
  };
  treemap.padding = function(x3) {
    return arguments.length ? treemap.paddingInner(x3).paddingOuter(x3) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x3) {
    return arguments.length ? (paddingInner = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x3) {
    return arguments.length ? treemap.paddingTop(x3).paddingRight(x3).paddingBottom(x3).paddingLeft(x3) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x3) {
    return arguments.length ? (paddingTop = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x3) {
    return arguments.length ? (paddingRight = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x3) {
    return arguments.length ? (paddingBottom = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x3) {
    return arguments.length ? (paddingLeft = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x05, y05, x12, y12) {
  var nodes = parent.children, i2, n2 = nodes.length, sum4, sums = new Array(n2 + 1);
  for (sums[0] = sum4 = i2 = 0; i2 < n2; ++i2) {
    sums[i2 + 1] = sum4 += nodes[i2].value;
  }
  partition2(0, n2, parent.value, x05, y05, x12, y12);
  function partition2(i3, j, value2, x06, y06, x13, y13) {
    if (i3 >= j - 1) {
      var node = nodes[i3];
      node.x0 = x06, node.y0 = y06;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i3], valueTarget = value2 / 2 + valueOffset, k2 = i3 + 1, hi = j - 1;
    while (k2 < hi) {
      var mid2 = k2 + hi >>> 1;
      if (sums[mid2] < valueTarget) k2 = mid2 + 1;
      else hi = mid2;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i3 + 1 < k2) --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value2 - valueLeft;
    if (x13 - x06 > y13 - y06) {
      var xk = value2 ? (x06 * valueRight + x13 * valueLeft) / value2 : x13;
      partition2(i3, k2, valueLeft, x06, y06, xk, y13);
      partition2(k2, j, valueRight, xk, y06, x13, y13);
    } else {
      var yk = value2 ? (y06 * valueRight + y13 * valueLeft) / value2 : y13;
      partition2(i3, k2, valueLeft, x06, y06, x13, yk);
      partition2(k2, j, valueRight, x06, yk, x13, y13);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x05, y05, x12, y12) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x05, y05, x12, y12);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom9(ratio) {
  function resquarify(parent, x05, y05, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row2, nodes, i2, j = -1, n2, m3 = rows.length, value2 = parent.value;
      while (++j < m3) {
        row2 = rows[j], nodes = row2.children;
        for (i2 = row2.value = 0, n2 = nodes.length; i2 < n2; ++i2) row2.value += nodes[i2].value;
        if (row2.dice) dice_default(row2, x05, y05, x12, value2 ? y05 += (y12 - y05) * row2.value / value2 : y12);
        else slice_default(row2, x05, y05, value2 ? x05 += (x12 - x05) * row2.value / value2 : x12, y12);
        value2 -= row2.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x05, y05, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x3) {
    return custom9((x3 = +x3) > 1 ? x3 : 1);
  };
  return resquarify;
}(phi);

// node_modules/@antv/g2/esm/utils/treeDataTransform.js
function generateHierarchyRoot(data2, path2) {
  if (Array.isArray(data2)) {
    return typeof path2 === "function" ? stratify_default().path(path2)(data2) : stratify_default()(data2);
  }
  return hierarchy(data2);
}
function addObjectDataPath(root2, path2 = [root2.data.name]) {
  root2.id = root2.id || root2.data.name;
  root2.path = path2;
  if (root2.children) {
    root2.children.forEach((item) => {
      item.id = `${root2.id}/${item.data.name}`;
      item.path = [...path2, item.data.name];
      addObjectDataPath(item, item.path);
    });
  }
}
function addArrayDataPath(root2) {
  const name2 = get_default(root2, ["data", "name"]);
  if (name2.replaceAll) {
    root2.path = name2.replaceAll(".", "/").split("/");
  }
  if (root2.children) {
    root2.children.forEach((item) => {
      addArrayDataPath(item);
    });
  }
}
function getTileMethod(tile, ratio) {
  const tiles = {
    treemapBinary: binary_default,
    treemapDice: dice_default,
    treemapSlice: slice_default,
    treemapSliceDice: sliceDice_default,
    treemapSquarify: squarify_default,
    treemapResquarify: resquarify_default
  };
  const tileMethod = tile === "treemapSquarify" ? tiles[tile].ratio(ratio) : tiles[tile];
  if (!tileMethod) {
    throw new TypeError("Invalid tile method!");
  }
  return tileMethod;
}
function treeDataTransform(data2, layout, encode) {
  const { value: value2 } = encode;
  const tileMethod = getTileMethod(layout.tile, layout.ratio);
  const root2 = generateHierarchyRoot(data2, layout.path);
  if (isArray(data2)) {
    addArrayDataPath(root2);
  } else {
    addObjectDataPath(root2);
  }
  value2 ? root2.sum((d4) => layout.ignoreParentValue && d4.children ? 0 : field(value2)(d4)).sort(layout.sort) : root2.count();
  treemap_default().tile(tileMethod).size(layout.size).round(layout.round).paddingInner(layout.paddingInner).paddingOuter(layout.paddingOuter).paddingTop(layout.paddingTop).paddingRight(layout.paddingRight).paddingBottom(layout.paddingBottom).paddingLeft(layout.paddingLeft)(root2);
  const nodes = root2.descendants().map((d4) => Object.assign(d4, {
    id: d4.id.replace(/^\//, ""),
    x: [d4.x0, d4.x1],
    y: [d4.y0, d4.y1]
  }));
  const filterData = nodes.filter(typeof layout.layer === "function" ? layout.layer : (d4) => d4.height === layout.layer);
  return [filterData, nodes];
}

// node_modules/@antv/g2/esm/mark/treemap.js
var __rest45 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS = (width, height) => ({
  tile: "treemapSquarify",
  ratio: 0.5 * (1 + Math.sqrt(5)),
  size: [width, height],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  sort: (a5, b) => b.value - a5.value,
  layer: 0
});
var GET_DEFAULT_OPTIONS = (width, height) => ({
  type: "rect",
  axis: false,
  encode: {
    x: "x",
    y: "y",
    key: "id",
    color: (d4) => d4.path[1]
  },
  scale: {
    x: { domain: [0, width], range: [0, 1] },
    y: { domain: [0, height], range: [0, 1] }
  },
  style: {
    stroke: "#fff"
  },
  state: {
    active: { opacity: 0.6 },
    inactive: { opacity: 1 }
  }
});
var DEFAULT_LABEL_OPTIONS3 = {
  fontSize: 10,
  text: (d4) => last(d4.path),
  position: "inside",
  fill: "#000",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d4) => d4.x1 - d4.x0,
  isTreemapLabel: true
};
var DEFAULT_TOOLTIP_OPTIONS = {
  title: (d4) => {
    var _a2, _b;
    return (_b = (_a2 = d4.path) === null || _a2 === void 0 ? void 0 : _a2.join) === null || _b === void 0 ? void 0 : _b.call(_a2, ".");
  },
  items: [{ field: "value" }]
};
var DEFAULT_TOOLTIP_OPTIONS_DRILL = {
  title: (d4) => last(d4.path),
  items: [{ field: "value" }]
};
var Treemap = (options, context) => {
  const { width, height, options: markOptions } = context;
  const { data: data2, encode = {}, scale: scale12, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = options, resOptions = __rest45(options, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const treemapDrillDown = get_default(markOptions, ["interaction", "treemapDrillDown"]) || get_default(markOptions, ["marks", 0, "interaction", "treemapDrillDown"]);
  const layoutOptions = deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS(width, height), layout, {
    layer: treemapDrillDown ? (d4) => {
      return d4.depth === 1;
    } : layout.layer
  });
  const [transformedData, transformedDataAll] = treeDataTransform(data2, layoutOptions, encode);
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, GET_DEFAULT_OPTIONS(width, height), Object.assign(Object.assign({
    data: transformedData,
    scale: scale12,
    style,
    labels: [
      Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS3), labelStyle), treemapDrillDown && { cursor: "pointer" }),
      ...labels
    ]
  }, resOptions), { encode, tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS), axis: false }), treemapDrillDown ? {
    interaction: Object.assign(Object.assign({}, resOptions.interaction), { treemapDrillDown: treemapDrillDown ? Object.assign(Object.assign({}, treemapDrillDown), { originData: transformedDataAll, layout: layoutOptions }) : void 0 }),
    encode: Object.assign({ color: (d4) => last(d4.path) }, encode),
    tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS_DRILL)
  } : {});
};
Treemap.props = {};

// node_modules/@antv/g2/esm/mark/pack.js
var __rest46 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var GET_DEFAULT_LAYOUT_OPTIONS2 = (width, height) => ({
  size: [width, height],
  padding: 0,
  sort: (a5, b) => b.value - a5.value
});
var GET_DEFAULT_OPTIONS2 = (width, height, encode) => ({
  type: "point",
  axis: false,
  legend: false,
  scale: {
    x: { domain: [0, width] },
    y: { domain: [0, height] },
    size: { type: "identity" }
  },
  encode: {
    x: "x",
    y: "y",
    size: "r",
    shape: "point"
  },
  style: {
    fill: !encode.color ? (d4) => d4.height === 0 ? "#ddd" : "#fff" : void 0,
    stroke: !encode.color ? (d4) => d4.height === 0 ? "" : "#000" : void 0
  }
});
var DEFAULT_LABEL_OPTIONS4 = {
  text: "",
  position: "inside",
  textOverflow: "clip",
  wordWrap: true,
  maxLines: 1,
  wordWrapWidth: (d4) => d4.r * 2
};
var DEFAULT_TOOLTIP_OPTIONS2 = {
  title: (d4) => d4.data.name,
  items: [{ field: "value" }]
};
var dataTransform = (data2, layout, encode) => {
  const { value: value2 } = encode;
  const root2 = isArray(data2) ? stratify_default().path(layout.path)(data2) : hierarchy(data2);
  value2 ? root2.sum((d4) => field(value2)(d4)).sort(layout.sort) : root2.count();
  pack_default().size(layout.size).padding(layout.padding)(root2);
  return root2.descendants();
};
var Pack2 = (markOptions, context) => {
  const { width, height } = context;
  const { data: data2, encode = {}, scale: scale12 = {}, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = markOptions, resOptions = __rest46(markOptions, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
  const DEFAULT_OPTIONS8 = GET_DEFAULT_OPTIONS2(width, height, encode);
  const transformedData = dataTransform(data2, deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS2(width, height), layout), deep_mix_default({}, DEFAULT_OPTIONS8["encode"], encode));
  const labelStyle = subObject(style, "label");
  return deep_mix_default({}, DEFAULT_OPTIONS8, Object.assign(Object.assign({
    data: transformedData,
    encode,
    scale: scale12,
    style,
    labels: [
      Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS4), labelStyle),
      ...labels
    ]
  }, resOptions), { tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS2), axis: false }));
};
Pack2.props = {};

// node_modules/@antv/g2/esm/mark/boxplot.js
var __rest47 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function min9(I, V) {
  return min4(I, (i2) => V[i2]);
}
function max10(I, V) {
  return max5(I, (i2) => V[i2]);
}
function lower(I, V) {
  const lo = q1(I, V) * 2.5 - q3(I, V) * 1.5;
  return min4(I, (i2) => V[i2] >= lo ? V[i2] : NaN);
}
function q1(I, V) {
  return quantile(I, 0.25, (i2) => V[i2]);
}
function q2(I, V) {
  return quantile(I, 0.5, (i2) => V[i2]);
}
function q3(I, V) {
  return quantile(I, 0.75, (i2) => V[i2]);
}
function upper(I, V) {
  const hi = q3(I, V) * 2.5 - q1(I, V) * 1.5;
  return max5(I, (i2) => V[i2] <= hi ? V[i2] : NaN);
}
function OutlierY() {
  return (I, mark2) => {
    const { encode } = mark2;
    const { y: y4, x: x3 } = encode;
    const { value: V } = y4;
    const { value: X } = x3;
    const GI = Array.from(group(I, (i2) => X[+i2]).values());
    const FI = GI.flatMap((I2) => {
      const lo = lower(I2, V);
      const hi = upper(I2, V);
      return I2.filter((i2) => V[i2] < lo || V[i2] > hi);
    });
    return [FI, mark2];
  };
}
var Boxplot = (options) => {
  const { data: data2, encode, style = {}, tooltip: tooltip2 = {}, transform: transform2, animate: animate2 } = options, rest = __rest47(options, ["data", "encode", "style", "tooltip", "transform", "animate"]);
  const { point: point7 = true } = style, restStyle = __rest47(style, ["point"]);
  const { y: y4 } = encode;
  const encodeY = { y: y4, y1: y4, y2: y4, y3: y4, y4 };
  const qy = { y1: q1, y2: q2, y3: q3 };
  const boxTooltip = subTooltip(tooltip2, "box", {
    items: [
      { channel: "y", name: "min" },
      { channel: "y1", name: "q1" },
      { channel: "y2", name: "q2" },
      { channel: "y3", name: "q3" },
      { channel: "y4", name: "max" }
    ]
  }, true);
  const pointTooltip = subTooltip(tooltip2, "point", {
    title: { channel: "x" },
    items: [{ name: "outlier", channel: "y" }]
  });
  if (!point7) {
    return Object.assign({ type: "box", data: data2, transform: [
      Object.assign(Object.assign({ type: "groupX", y: min9 }, qy), { y4: max10 })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: restStyle, tooltip: boxTooltip }, rest);
  }
  const boxStyle = subObject(restStyle, "box");
  const pointStyle = subObject(restStyle, "point");
  return [
    Object.assign({ type: "box", data: data2, transform: [
      Object.assign(Object.assign({ type: "groupX", y: lower }, qy), { y4: upper })
    ], encode: Object.assign(Object.assign({}, encode), encodeY), style: boxStyle, tooltip: boxTooltip, animate: maybeAnimation(animate2, "box") }, rest),
    // Draw outliers.
    {
      type: "point",
      data: data2,
      transform: [{ type: OutlierY }],
      encode,
      style: Object.assign({}, pointStyle),
      tooltip: pointTooltip,
      animate: maybeAnimation(animate2, "point")
    }
  ];
};
Boxplot.props = {};

// node_modules/@antv/g2/esm/mark/shape.js
var shape20 = {
  shape: Shape2
};
var Shape3 = (options) => {
  const { cartesian: cartesian3 } = options;
  if (cartesian3)
    return visualMark;
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y } = value2;
    const offset2 = createBandOffset(scale12, value2, options);
    const P = Array.from(index3, (i2) => {
      const p3 = [+X[i2], +Y[i2]];
      return [coordinate.map(offset2(p3, i2))];
    });
    return [index3, P];
  };
};
Shape3.props = {
  defaultShape: "shape",
  defaultLabelShape: "label",
  composite: false,
  shape: shape20,
  channels: [
    { name: "x", required: true },
    { name: "y", required: true }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeTuple },
    { type: MaybeVisualPosition },
    { type: MaybeFunctionAttribute }
  ]
};

// node_modules/d3-force/src/center.js
function center_default(x3, y4) {
  var nodes, strength = 1;
  if (x3 == null) x3 = 0;
  if (y4 == null) y4 = 0;
  function force() {
    var i2, n2 = nodes.length, node, sx = 0, sy = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n2 - x3) * strength, sy = (sy / n2 - y4) * strength, i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = +_2, force) : x3;
  };
  force.y = function(_2) {
    return arguments.length ? (y4 = +_2, force) : y4;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d4) {
  const x3 = +this._x.call(null, d4), y4 = +this._y.call(null, d4);
  return add9(this.cover(x3, y4), x3, y4, d4);
}
function add9(tree, x3, y4, d4) {
  if (isNaN(x3) || isNaN(y4)) return tree;
  var parent, node = tree._root, leaf = { data: d4 }, x05 = tree._x0, y05 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right2, bottom, i2, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
    else x12 = xm;
    if (bottom = y4 >= (ym = (y05 + y12) / 2)) y05 = ym;
    else y12 = ym;
    if (parent = node, !(node = node[i2 = bottom << 1 | right2])) return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x3 === xp && y4 === yp) return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
    if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
    else x12 = xm;
    if (bottom = y4 >= (ym = (y05 + y12) / 2)) y05 = ym;
    else y12 = ym;
  } while ((i2 = bottom << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i2] = leaf, tree;
}
function addAll(data2) {
  var d4, i2, n2 = data2.length, x3, y4, xz = new Array(n2), yz = new Array(n2), x05 = Infinity, y05 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x3 = +this._x.call(null, d4 = data2[i2])) || isNaN(y4 = +this._y.call(null, d4))) continue;
    xz[i2] = x3;
    yz[i2] = y4;
    if (x3 < x05) x05 = x3;
    if (x3 > x12) x12 = x3;
    if (y4 < y05) y05 = y4;
    if (y4 > y12) y12 = y4;
  }
  if (x05 > x12 || y05 > y12) return this;
  this.cover(x05, y05).cover(x12, y12);
  for (i2 = 0; i2 < n2; ++i2) {
    add9(this, xz[i2], yz[i2], data2[i2]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x3, y4) {
  if (isNaN(x3 = +x3) || isNaN(y4 = +y4)) return this;
  var x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x05)) {
    x12 = (x05 = Math.floor(x3)) + 1;
    y12 = (y05 = Math.floor(y4)) + 1;
  } else {
    var z = x12 - x05 || 1, node = this._root, parent, i2;
    while (x05 > x3 || x3 >= x12 || y05 > y4 || y4 >= y12) {
      i2 = (y4 < y05) << 1 | x3 < x05;
      parent = new Array(4), parent[i2] = node, node = parent, z *= 2;
      switch (i2) {
        case 0:
          x12 = x05 + z, y12 = y05 + z;
          break;
        case 1:
          x05 = x12 - z, y12 = y05 + z;
          break;
        case 2:
          x12 = x05 + z, y05 = y12 - z;
          break;
        case 3:
          x05 = x12 - z, y05 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x05;
  this._y0 = y05;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data2 = [];
  this.visit(function(node) {
    if (!node.length) do
      data2.push(node.data);
    while (node = node.next);
  });
  return data2;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x05, y05, x12, y12) {
  this.node = node;
  this.x0 = x05;
  this.y0 = y05;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/d3-quadtree/src/find.js
function find_default3(x3, y4, radius) {
  var data2, x05 = this._x0, y05 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i2;
  if (node) quads.push(new quad_default(node, x05, y05, x32, y32));
  if (radius == null) radius = Infinity;
  else {
    x05 = x3 - radius, y05 = y4 - radius;
    x32 = x3 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x05 || (y22 = q.y1) < y05) continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x12, ym, xm, y22),
        new quad_default(node[1], xm, y12, x22, ym),
        new quad_default(node[0], x12, y12, xm, ym)
      );
      if (i2 = (y4 >= ym) << 1 | x3 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q;
      }
    } else {
      var dx = x3 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d22 = dx * dx + dy * dy;
      if (d22 < radius) {
        var d4 = Math.sqrt(radius = d22);
        x05 = x3 - d4, y05 = y4 - d4;
        x32 = x3 + d4, y32 = y4 + d4;
        data2 = node.data;
      }
    }
  }
  return data2;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default2(d4) {
  if (isNaN(x3 = +this._x.call(null, d4)) || isNaN(y4 = +this._y.call(null, d4))) return this;
  var parent, node = this._root, retainer, previous, next, x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1, x3, y4, xm, ym, right2, bottom, i2, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
    else x12 = xm;
    if (bottom = y4 >= (ym = (y05 + y12) / 2)) y05 = ym;
    else y12 = ym;
    if (!(parent = node, node = node[i2 = bottom << 1 | right2])) return this;
    if (!node.length) break;
    if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3]) retainer = parent, j = i2;
  }
  while (node.data !== d4) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data2) {
  for (var i2 = 0, n2 = data2.length; i2 < n2; ++i2) this.remove(data2[i2]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size3 = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size3;
    while (node = node.next);
  });
  return size3;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x05, y05, x12, y12;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x12, y12));
      if (child = node[2]) quads.push(new quad_default(child, x05, ym, xm, y12));
      if (child = node[1]) quads.push(new quad_default(child, xm, y05, x12, ym));
      if (child = node[0]) quads.push(new quad_default(child, x05, y05, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
      if (child = node[0]) quads.push(new quad_default(child, x05, y05, xm, ym));
      if (child = node[1]) quads.push(new quad_default(child, xm, y05, x12, ym));
      if (child = node[2]) quads.push(new quad_default(child, x05, ym, xm, y12));
      if (child = node[3]) quads.push(new quad_default(child, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d4) {
  return d4[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d4) {
  return d4[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x3, y4) {
  var tree = new Quadtree(x3 == null ? defaultX : x3, y4 == null ? defaultY : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x3, y4, x05, y05, x12, y12) {
  this._x = x3;
  this._y = y4;
  this._x0 = x05;
  this._y0 = y05;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy7 = { data: leaf.data }, next = copy7;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy7;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy7 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node) return copy7;
  if (!node.length) return copy7._root = leaf_copy(node), copy7;
  nodes = [{ source: node, target: copy7._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 4; ++i2) {
      if (child = node.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node.target[i2] = new Array(4) });
        else node.target[i2] = leaf_copy(child);
      }
    }
  }
  return copy7;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default3;
treeProto.remove = remove_default2;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default3(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random5) {
  return (random5() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/link.js
function index2(d4) {
  return d4.index;
}
function find5(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id4 = index2, strength = defaultStrength, strengths, distance7 = constant_default3(30), distances, nodes, count4, bias, random5, iterations2 = 1;
  if (links == null) links = [];
  function defaultStrength(link3) {
    return 1 / Math.min(count4[link3.source.index], count4[link3.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n2 = links.length; k2 < iterations2; ++k2) {
      for (var i2 = 0, link3, source, target, x3, y4, l2, b; i2 < n2; ++i2) {
        link3 = links[i2], source = link3.source, target = link3.target;
        x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random5);
        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random5);
        l2 = Math.sqrt(x3 * x3 + y4 * y4);
        l2 = (l2 - distances[i2]) / l2 * alpha * strengths[i2];
        x3 *= l2, y4 *= l2;
        target.vx -= x3 * (b = bias[i2]);
        target.vy -= y4 * b;
        source.vx += x3 * (b = 1 - b);
        source.vy += y4 * b;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d4, i3) => [id4(d4, i3, nodes), d4])), link3;
    for (i2 = 0, count4 = new Array(n2); i2 < m3; ++i2) {
      link3 = links[i2], link3.index = i2;
      if (typeof link3.source !== "object") link3.source = find5(nodeById, link3.source);
      if (typeof link3.target !== "object") link3.target = find5(nodeById, link3.target);
      count4[link3.source.index] = (count4[link3.source.index] || 0) + 1;
      count4[link3.target.index] = (count4[link3.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m3); i2 < m3; ++i2) {
      link3 = links[i2], bias[i2] = count4[link3.source.index] / (count4[link3.source.index] + count4[link3.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance7(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id4 = _2, force) : id4;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, force) : iterations2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance7 = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeDistance(), force) : distance7;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t; i2 < n2; ++i2) {
    if (!(t = arguments[i2] + "") || t in _2 || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _2[t] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i2 = t.indexOf(".");
    if (i2 >= 0) name2 = t.slice(i2 + 1), t = t.slice(0, i2);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T2 = parseTypenames(typename + "", _2), t, i2 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      while (++i2 < n2) if ((t = (typename = T2[i2]).type) && (t = get(_2[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i2 < n2) {
      if (t = (typename = T2[i2]).type) _2[t] = set7(_2[t], typename.name, callback);
      else if (callback == null) for (t in _2) _2[t] = set7(_2[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy7 = {}, _2 = this._;
    for (var t in _2) copy7[t] = _2[t].slice();
    return new Dispatch(copy7);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i2 = 0, n2 = t.length; i2 < n2; ++i2) t[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i2 = 0, n2 = t.length; i2 < n2; ++i2) t[i2].value.apply(that, args);
  }
};
function get(type, name2) {
  for (var i2 = 0, n2 = type.length, c6; i2 < n2; ++i2) {
    if ((c6 = type[i2]).name === name2) {
      return c6.value;
    }
  }
}
function set7(type, name2, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
    if (type[i2].name === name2) {
      type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  }
  if (callback != null) type.push({ name: name2, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock2 = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock2.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e3;
  while (t) {
    if ((e3 = clockNow - t._time) >= 0) t._call.call(void 0, e3);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock2.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock2.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time) time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock2.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock2.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-force/src/lcg.js
var a3 = 1664525;
var c2 = 1013904223;
var m2 = 4294967296;
function lcg_default2() {
  let s4 = 1;
  return () => (s4 = (a3 * s4 + c2) % m2) / m2;
}

// node_modules/d3-force/src/simulation.js
function x2(d4) {
  return d4.x;
}
function y2(d4) {
  return d4.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch_default("tick", "end"), random5 = lcg_default2();
  if (nodes == null) nodes = [];
  function step2() {
    tick3();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick3(iterations2) {
    var i2, n2 = nodes.length, node;
    if (iterations2 === void 0) iterations2 = 1;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i2), angle4 = i2 * initialAngle;
        node.x = radius * Math.cos(angle4);
        node.y = radius * Math.sin(angle4);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random5);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick3,
    restart: function() {
      return stepper.restart(step2), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random5 = _2, forces.forEach(initializeForce), simulation) : random5;
    },
    force: function(name2, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name2) : forces.set(name2, initializeForce(_2)), simulation) : forces.get(name2);
    },
    find: function(x3, y4, radius) {
      var i2 = 0, n2 = nodes.length, dx, dy, d22, node, closest;
      if (radius == null) radius = Infinity;
      else radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x3 - node.x;
        dy = y4 - node.y;
        d22 = dx * dx + dy * dy;
        if (d22 < radius) closest = node, radius = d22;
      }
      return closest;
    },
    on: function(name2, _2) {
      return arguments.length > 1 ? (event.on(name2, _2), simulation) : event.on(name2);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random5, alpha, strength = constant_default3(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i2, n2 = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _2, i2 = 0; i2 < n2; ++i2) node = nodes[i2], tree.visit(apply);
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c6, weight2 = 0, x3, y4, i2;
    if (quad.length) {
      for (x3 = y4 = i2 = 0; i2 < 4; ++i2) {
        if ((q = quad[i2]) && (c6 = Math.abs(q.value))) {
          strength2 += q.value, weight2 += c6, x3 += c6 * q.x, y4 += c6 * q.y;
        }
      }
      quad.x = x3 / weight2;
      quad.y = y4 / weight2;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x12, _2, x22) {
    if (!quad.value) return true;
    var x3 = quad.x - node.x, y4 = quad.y - node.y, w2 = x22 - x12, l2 = x3 * x3 + y4 * y4;
    if (w2 * w2 / theta2 < l2) {
      if (l2 < distanceMax2) {
        if (x3 === 0) x3 = jiggle_default(random5), l2 += x3 * x3;
        if (y4 === 0) y4 = jiggle_default(random5), l2 += y4 * y4;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
        node.vx += x3 * quad.value * alpha / l2;
        node.vy += y4 * quad.value * alpha / l2;
      }
      return true;
    } else if (quad.length || l2 >= distanceMax2) return;
    if (quad.data !== node || quad.next) {
      if (x3 === 0) x3 = jiggle_default(random5), l2 += x3 * x3;
      if (y4 === 0) y4 = jiggle_default(random5), l2 += y4 * y4;
      if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (quad.data !== node) {
        w2 = strengths[quad.data.index] * alpha / l2;
        node.vx += x3 * w2;
        node.vy += y4 * w2;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random5 = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x3) {
  var strength = constant_default3(0.1), nodes, strengths, xz;
  if (typeof x3 !== "function") x3 = constant_default3(x3 == null ? 0 : +x3);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vx += (xz[i2] - node.x) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    xz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(xz[i2] = +x3(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : x3;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y4) {
  var strength = constant_default3(0.1), nodes, strengths, yz;
  if (typeof y4 !== "function") y4 = constant_default3(y4 == null ? 0 : +y4);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vy += (yz[i2] - node.y) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    yz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(yz[i2] = +y4(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : y4;
  };
  return force;
}

// node_modules/@antv/g2/esm/mark/forceGraph.js
var __rest48 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var DEFAULT_LAYOUT_OPTIONS3 = {
  joint: true
};
var DEFAULT_LINK_OPTIONS3 = {
  type: "link",
  axis: false,
  legend: false,
  encode: {
    x: [(d4) => d4.source.x, (d4) => d4.target.x],
    y: [(d4) => d4.source.y, (d4) => d4.target.y]
  },
  style: {
    stroke: "#999",
    strokeOpacity: 0.6
  }
};
var DEFAULT_NODE_OPTIONS3 = {
  type: "point",
  axis: false,
  legend: false,
  encode: {
    x: "x",
    y: "y",
    size: 5,
    color: "group",
    shape: "point"
  },
  style: {
    stroke: "#fff"
  }
};
var DEFAULT_LABEL_OPTIONS5 = {
  text: ""
};
function dataTransform2(data2, layout, encode) {
  const { nodes, links } = data2;
  const { joint, nodeStrength, linkStrength } = layout;
  const { nodeKey = (d4) => d4.id, linkKey = (d4) => d4.id } = encode;
  const nodeForce = manyBody_default();
  const linkForce = link_default(links).id(field(linkKey));
  typeof nodeStrength === "function" && nodeForce.strength(nodeStrength);
  typeof linkStrength === "function" && linkForce.strength(linkStrength);
  const simulation = simulation_default(nodes).force("link", linkForce).force("charge", nodeForce);
  joint ? simulation.force("center", center_default()) : simulation.force("x", x_default2()).force("y", y_default2());
  simulation.stop();
  const n2 = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
  for (let i2 = 0; i2 < n2; i2++)
    simulation.tick();
  return {
    nodesData: nodes,
    linksData: links
  };
}
var ForceGraph = (options) => {
  const { data: data2, encode: e3 = {}, scale: scale12, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const { nodeKey = (d4) => d4.id, linkKey = (d4) => d4.id } = e3, restEncode = __rest48(e3, ["nodeKey", "linkKey"]);
  const encode = Object.assign({ nodeKey, linkKey }, restEncode);
  const nodeEncode = subObject(encode, "node");
  const linkEncode = subObject(encode, "link");
  const { links, nodes } = initializeData(data2, encode);
  const { nodesData, linksData } = dataTransform2({ links, nodes }, deep_mix_default({}, DEFAULT_LAYOUT_OPTIONS3, layout), encode);
  const linkTooltip = subTooltip(tooltip2, "link", {
    items: [
      (d4) => ({ name: "source", value: field(linkKey)(d4.source) }),
      (d4) => ({ name: "target", value: field(linkKey)(d4.target) })
    ]
  });
  const nodeTooltip = subTooltip(tooltip2, "node", {
    items: [(d4) => ({ name: "key", value: field(nodeKey)(d4) })]
  }, true);
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS3, {
      data: linksData,
      encode: linkEncode,
      labels: linkLabels,
      style: subObject(style, "link"),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS3, {
      data: nodesData,
      encode: Object.assign({}, nodeEncode),
      scale: scale12,
      style: subObject(style, "node"),
      tooltip: nodeTooltip,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS5), subObject(style, "label")),
        ...nodeLabels
      ],
      animate: maybeAnimation(animate2, "link")
    })
  ];
};
ForceGraph.props = {};

// node_modules/@antv/g2/esm/data/cluster.js
var hierarchyFunction = (layoutFunction) => (options) => {
  return (data2) => {
    const { field: field3 = "value", nodeSize, separation, sortBy: sortBy2, as = ["x", "y"] } = options;
    const [x3, y4] = as;
    const root2 = hierarchy(data2, (d4) => d4.children).sum((d4) => d4[field3]).sort(sortBy2);
    const c6 = layoutFunction();
    c6.size([1, 1]);
    if (nodeSize)
      c6.nodeSize(nodeSize);
    if (separation)
      c6.separation(separation);
    c6(root2);
    const nodes = [];
    root2.each((node) => {
      node[x3] = node.x;
      node[y4] = node.y;
      node.name = node.data.name;
      nodes.push(node);
    });
    const edges = root2.links();
    edges.forEach((edge) => {
      edge[x3] = [edge.source[x3], edge.target[x3]];
      edge[y4] = [edge.source[y4], edge.target[y4]];
    });
    return { nodes, edges };
  };
};
var Cluster = (options) => {
  return hierarchyFunction(cluster_default)(options);
};
Cluster.props = {};

// node_modules/@antv/g2/esm/data/tree.js
var Tree = (options) => {
  return hierarchyFunction(tree_default)(options);
};
Tree.props = {};

// node_modules/@antv/g2/esm/mark/tree.js
var DEFAULT_LAYOUT_OPTIONS4 = {
  sortBy: (a5, b) => b.value - a5.value
};
var DEFAULT_NODE_OPTIONS4 = {
  axis: false,
  legend: false,
  type: "point",
  encode: {
    x: "x",
    y: "y",
    size: 2,
    shape: "point"
  }
};
var DEFAULT_LINK_OPTIONS4 = {
  type: "link",
  encode: {
    x: "x",
    y: "y",
    shape: "smooth"
  }
};
var DEFAULT_LABEL_OPTIONS6 = {
  text: "",
  fontSize: 10
};
var Tree2 = (options) => {
  const { data: data2, encode = {}, scale: scale12 = {}, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
  const valueEncode = encode === null || encode === void 0 ? void 0 : encode.value;
  const { nodes, edges } = Tree(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS4), layout), { field: valueEncode }))(data2);
  const nodeTooltip = subTooltip(tooltip2, "node", {
    title: "name",
    items: ["value"]
  }, true);
  const linkTooltip = subTooltip(tooltip2, "link", {
    title: "",
    items: [
      (d4) => ({ name: "source", value: d4.source.name }),
      (d4) => ({ name: "target", value: d4.target.name })
    ]
  });
  return [
    deep_mix_default({}, DEFAULT_LINK_OPTIONS4, {
      data: edges,
      encode: subObject(encode, "link"),
      scale: subObject(scale12, "link"),
      labels: linkLabels,
      style: Object.assign({ stroke: "#999" }, subObject(style, "link")),
      tooltip: linkTooltip,
      animate: maybeAnimation(animate2, "link")
    }),
    deep_mix_default({}, DEFAULT_NODE_OPTIONS4, {
      data: nodes,
      scale: subObject(scale12, "node"),
      encode: subObject(encode, "node"),
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS6), subObject(style, "label")),
        ...nodeLabels
      ],
      style: Object.assign({}, subObject(style, "node")),
      tooltip: nodeTooltip,
      animate: maybeAnimation(animate2, "node")
    })
  ];
};
Tree2.props = {};

// node_modules/@antv/g2/esm/mark/wordCloud.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest49 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function initializeData2(data2, encode) {
  const { text = "text", value: value2 = "value" } = encode;
  return data2.map((d4) => Object.assign(Object.assign({}, d4), { text: d4[text], value: d4[value2] }));
}
var GET_DEFAULT_OPTIONS3 = () => ({
  axis: false,
  type: "text",
  encode: {
    x: "x",
    y: "y",
    text: "text",
    rotate: "rotate",
    fontSize: "size",
    shape: "tag"
  },
  scale: {
    x: { range: [0, 1] },
    y: { range: [0, 1] }
  },
  style: {
    fontFamily: (d4) => d4.fontFamily
  },
  tooltip: {
    items: [
      (datum) => ({
        name: datum.text,
        value: datum.value
      })
    ]
  }
});
var WordCloud = (options, context) => __awaiter2(void 0, void 0, void 0, function* () {
  const { width, height } = context;
  const { data: data2, encode = {}, scale: scale12, style = {}, layout = {} } = options, resOptions = __rest49(options, ["data", "encode", "scale", "style", "layout"]);
  const initializedData = initializeData2(data2, encode);
  return deep_mix_default({}, GET_DEFAULT_OPTIONS3(), Object.assign(Object.assign({
    data: {
      value: initializedData,
      transform: [
        Object.assign({ type: "wordCloud", size: [width, height] }, layout)
      ]
    },
    encode,
    scale: scale12,
    style
  }, resOptions), { axis: false }));
});
WordCloud.props = {};

// node_modules/@antv/g2/esm/mark/gauge.js
var __rest50 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var indicatorShape = (options, context) => {
  const { shape: shape23, radius } = options, style = __rest50(options, ["shape", "radius"]);
  const pointerStyle = subObject(style, "pointer");
  const pinStyle = subObject(style, "pin");
  const { shape: pointerShape } = pointerStyle, resPointerStyle = __rest50(pointerStyle, ["shape"]);
  const { shape: pinShape } = pinStyle, resPinStyle = __rest50(pinStyle, ["shape"]);
  const { coordinate, theme } = context;
  return (points, value2) => {
    const invertedPoints = points.map((p3) => coordinate.invert(p3));
    const [startAngle, endAngle, innerRadius] = getTransformOptions(coordinate, "polar");
    const newCoordinate = coordinate.clone();
    const { color: stroke2 } = value2;
    const newTransformations = Radial({
      startAngle,
      endAngle,
      innerRadius,
      outerRadius: radius
    });
    newTransformations.push(["cartesian"]);
    newCoordinate.update({
      transformations: newTransformations
    });
    const newPoints = invertedPoints.map((p3) => newCoordinate.map(p3));
    const [x3, y4] = getOrigin(newPoints);
    const [cx, cy] = coordinate.getCenter();
    const pointerAttrs = Object.assign(Object.assign({ x1: x3, y1: y4, x2: cx, y2: cy, stroke: stroke2 }, resPointerStyle), style);
    const pinAttrs = Object.assign(Object.assign({
      cx,
      cy,
      stroke: stroke2
    }, resPinStyle), style);
    const indicatorGroup = select(new Group2());
    if (!isUnset(pointerShape)) {
      typeof pointerShape === "function" ? indicatorGroup.append(() => pointerShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("line").call(applyStyle, pointerAttrs).node();
    }
    if (!isUnset(pinShape)) {
      typeof pinShape === "function" ? indicatorGroup.append(() => pinShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("circle").call(applyStyle, pinAttrs).node();
    }
    return indicatorGroup.node();
  };
};
var DEFAULT_OPTIONS3 = {
  coordinate: {
    type: "radial",
    innerRadius: 0.9,
    outerRadius: 1,
    startAngle: -11 / 10 * Math.PI,
    endAngle: 1 / 10 * Math.PI
  },
  axis: {
    x: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "x",
    y: "y",
    color: "color"
  },
  scale: {
    color: {
      range: ["#30BF78", "#D0D0D0"]
    }
  }
};
var DEFAULT_INDICATOR_OPTIONS = {
  style: {
    shape: indicatorShape,
    lineWidth: 4,
    pointerLineCap: "round",
    pinR: 10,
    pinFill: "#fff",
    radius: 0.6
  }
};
var DEFAULT_TEXT_OPTIONS = {
  type: "text",
  style: {
    x: "50%",
    y: "60%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  tooltip: false
};
function getGaugeData(data2) {
  if (isNumber(data2)) {
    const percent2 = Math.max(0, Math.min(data2, 1));
    return {
      percent: percent2,
      target: percent2,
      total: 1
    };
  }
  return data2;
}
function dataTransform3(data2, scale12) {
  const { name: name2 = "score", target, total, percent: percent2, thresholds = [] } = getGaugeData(data2);
  const _target = percent2 || target;
  const _total = percent2 ? 1 : total;
  const newScale = Object.assign({ y: {
    domain: [0, _total]
  } }, scale12);
  if (!thresholds.length) {
    return {
      targetData: [{ x: name2, y: _target, color: "target" }],
      totalData: [
        { x: name2, y: _target, color: "target" },
        { x: name2, y: _total - _target, color: "total" }
      ],
      target: _target,
      total: _total,
      scale: newScale
    };
  }
  return {
    targetData: [{ x: name2, y: _target, color: "target" }],
    totalData: thresholds.map((d4, i2) => ({
      x: name2,
      y: i2 >= 1 ? d4 - thresholds[i2 - 1] : d4,
      color: i2
    })),
    target: _target,
    total: _total,
    scale: newScale
  };
}
function getTextContent(textStyle, { target, total }) {
  const { content } = textStyle;
  return content ? content(target, total) : target.toString();
}
var Gauge = (options) => {
  const { data: data2 = {}, scale: scale12 = {}, style = {}, animate: animate2 = {}, transform: transform2 = [] } = options, resOptions = __rest50(options, ["data", "scale", "style", "animate", "transform"]);
  const { targetData, totalData, target, total, scale: newScale } = dataTransform3(data2, scale12);
  const _a2 = subObject(style, "text"), { tooltip: tooltip2 } = _a2, textStyle = __rest50(_a2, ["tooltip"]);
  const indicatorStyle = filterPrefixObject(style, ["pointer", "pin"]);
  const arcStyle = subObject(style, "arc");
  const shape23 = arcStyle.shape;
  return [
    deep_mix_default({}, DEFAULT_OPTIONS3, Object.assign({ type: "interval", transform: [{ type: "stackY" }], data: totalData, scale: newScale, style: shape23 === "round" ? Object.assign(Object.assign({}, arcStyle), { shape: Round }) : arcStyle, animate: typeof animate2 === "object" ? subObject(animate2, "arc") : animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_OPTIONS3, DEFAULT_INDICATOR_OPTIONS, Object.assign({ type: "point", data: targetData, scale: newScale, style: indicatorStyle, animate: typeof animate2 === "object" ? subObject(animate2, "indicator") : animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS, {
      style: Object.assign({ text: getTextContent(textStyle, { target, total }) }, textStyle),
      tooltip: tooltip2,
      animate: typeof animate2 === "object" ? subObject(animate2, "text") : animate2
    })
  ];
};
Gauge.props = {};

// node_modules/@antv/g2/esm/mark/density.js
var shape21 = {
  density: Density
};
var Density2 = () => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, series: S } = value2;
    const Yn2 = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
    const SZn = Object.entries(value2).filter(([key]) => key.startsWith("size")).map(([, value3]) => value3);
    if (X === void 0 || Yn2 === void 0 || SZn === void 0) {
      throw new Error("Missing encode for x or y or size channel.");
    }
    const xScale = scale12.x;
    const series = scale12.series;
    const P = Array.from(index3, (i2) => {
      const groupWidth = xScale.getBandWidth(xScale.invert(+X[i2]));
      const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i2]))) : 1;
      const width = groupWidth * ratio;
      const offset2 = (+(S === null || S === void 0 ? void 0 : S[i2]) || 0) * groupWidth;
      const x3 = +X[i2] + offset2 + width / 2;
      const PN = [
        ...Yn2.map((_2, idx) => [x3 + +SZn[idx][i2] / index3.length, +Yn2[idx][i2]]),
        ...Yn2.map((_2, idx) => [
          x3 - +SZn[idx][i2] / index3.length,
          +Yn2[idx][i2]
        ]).reverse()
        // left
      ];
      return PN.map((p3) => coordinate.map(p3));
    });
    return [index3, P];
  };
};
Density2.props = {
  defaultShape: "density",
  defaultLabelShape: "label",
  composite: false,
  shape: shape21,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape21) }),
    { name: "x", scale: "band", required: true },
    { name: "y", required: true },
    { name: "size", required: true },
    { name: "series", scale: "band" },
    { name: "size", required: true, scale: "identity" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroY1 },
    { type: MaybeZeroX }
  ],
  postInference: [...basePostInference(), ...tooltip1d()],
  interaction: { shareTooltip: true }
};

// node_modules/@antv/g2/esm/mark/heatmap.js
var shape22 = {
  heatmap: Heatmap
};
var Heatmap2 = (options) => {
  return (index3, scale12, value2, coordinate) => {
    const { x: X, y: Y, size: S, color: C4 } = value2;
    const P = Array.from(index3, (i2) => {
      const r2 = S ? +S[i2] : 40;
      return [...coordinate.map([+X[i2], +Y[i2]]), C4[i2], r2];
    });
    return [[0], [P]];
  };
};
Heatmap2.props = {
  defaultShape: "heatmap",
  defaultLabelShape: "label",
  composite: false,
  shape: shape22,
  channels: [
    ...baseGeometryChannels({ shapes: Object.keys(shape22) }),
    { name: "x", required: true },
    { name: "y", required: true },
    { name: "color", scale: "identity", required: true },
    { name: "size" }
  ],
  preInference: [
    ...basePreInference(),
    { type: MaybeZeroX },
    { type: MaybeZeroY }
  ],
  postInference: [...basePostInference(), ...tooltip2d()]
};

// node_modules/@antv/g2/esm/mark/liquid.js
var __rest51 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var DEFAULT_OPTIONS4 = {
  axis: {
    x: false,
    y: false
  },
  legend: false,
  tooltip: false,
  encode: {
    x: "type",
    y: "percent"
  },
  scale: {
    y: {
      domain: [0, 1]
    }
  },
  style: {
    shape: Liquid
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var DEFAULT_TEXT_OPTIONS2 = {
  type: "text",
  style: {
    x: "50%",
    y: "50%",
    textAlign: "center",
    textBaseline: "middle",
    fontSize: 20,
    fontWeight: 800,
    fill: "#888"
  },
  animate: {
    enter: {
      type: "fadeIn"
    }
  }
};
var Liquid2 = (options) => {
  const { data: data2 = {}, style = {}, animate: animate2 } = options, resOptions = __rest51(options, ["data", "style", "animate"]);
  const percent2 = Math.max(0, isNumber(data2) ? data2 : data2 === null || data2 === void 0 ? void 0 : data2.percent);
  const newData = [{ percent: percent2, type: "liquid" }];
  const contentStyle = Object.assign(Object.assign({}, subObject(style, "text")), subObject(style, "content"));
  const outline = subObject(style, "outline");
  const wave = subObject(style, "wave");
  const background = subObject(style, "background");
  return [
    deep_mix_default({}, DEFAULT_OPTIONS4, Object.assign({ type: "interval", data: newData, style: {
      liquidOptions: {
        percent: percent2,
        liquidShape: style === null || style === void 0 ? void 0 : style.shape
      },
      styleOptions: Object.assign(Object.assign({}, style), {
        outline,
        wave,
        background
      })
    }, animate: animate2 }, resOptions)),
    deep_mix_default({}, DEFAULT_TEXT_OPTIONS2, {
      style: Object.assign({ text: `${prettyNumber2(percent2 * 100)} %` }, contentStyle),
      animate: animate2
    })
  ];
};
Liquid2.props = {};

// node_modules/@antv/g2/esm/palette/category10.js
var Category10 = () => {
  return [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#6F5EF9",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
};
Category10.props = {};

// node_modules/@antv/g2/esm/palette/category20.js
var Category20 = () => {
  return [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#6F5EF9",
    "#D3CEFD",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
};
Category20.props = {};

// node_modules/@antv/g2/esm/scale/band.js
var Band2 = (options) => {
  return new Band(options);
};
Band2.props = {};

// node_modules/@antv/g2/esm/scale/linear.js
var Linear3 = (options) => {
  return new Linear(options);
};
Linear3.props = {};

// node_modules/@antv/g2/esm/scale/ordinal.js
var Ordinal2 = (options) => {
  return new Ordinal(options);
};
Ordinal2.props = {};

// node_modules/@antv/g2/esm/scale/identity.js
var Identity2 = (options) => {
  return new Identity(options);
};
Identity2.props = {};

// node_modules/@antv/g2/esm/scale/point.js
var Point5 = (options) => {
  return new Point(options);
};
Point5.props = {};

// node_modules/@antv/g2/esm/scale/time.js
var Time2 = (options) => {
  return new Time(options);
};
Time2.props = {};

// node_modules/@antv/g2/esm/scale/log.js
var Log2 = (options) => {
  return new Log(options);
};
Log2.props = {};

// node_modules/@antv/g2/esm/scale/pow.js
var Pow2 = (options) => {
  return new Pow(options);
};
Pow2.props = {};

// node_modules/@antv/g2/esm/scale/threshold.js
var Threshold2 = (options) => {
  return new Threshold(options);
};
Threshold2.props = {};

// node_modules/@antv/g2/esm/scale/quantile.js
var Quantile2 = (options) => {
  return new Quantile(options);
};
Quantile2.props = {};

// node_modules/@antv/g2/esm/scale/quantize.js
var Quantize2 = (options) => {
  return new Quantize(options);
};
Quantize2.props = {};

// node_modules/@antv/g2/esm/scale/sqrt.js
var Sqrt2 = (options) => {
  return new Sqrt(options);
};
Sqrt2.props = {};

// node_modules/@antv/g2/esm/scale/sequential.js
var Sequential3 = (options) => {
  return new Sequential(options);
};
Sequential3.props = {};

// node_modules/@antv/g2/esm/scale/constant.js
var Constant3 = (options) => {
  return new Constant2(options);
};
Constant3.props = {};

// node_modules/@antv/g2/esm/theme/create.js
function create7({ colorDefault, colorBlack, colorWhite, colorStroke, colorBackground, padding1, padding2, padding3, alpha90, alpha65, alpha45, alpha25, alpha10, category10, category20, sizeDefault = 1, padding = "auto", margin = 16 }) {
  return {
    padding,
    margin,
    size: sizeDefault,
    color: colorDefault,
    category10,
    category20,
    enter: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    update: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    exit: {
      duration: 300,
      fill: "both",
      delay: 0
    },
    view: {
      viewFill: colorBackground,
      plotFill: "transparent",
      mainFill: "transparent",
      contentFill: "transparent"
    },
    line: {
      line: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 1,
        lineCap: "round"
      }
    },
    point: {
      point: {
        r: 3,
        fillOpacity: 0.95,
        lineWidth: 0
      },
      hollow: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      },
      plus: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 3
      },
      diamond: {
        r: 3,
        strokeOpacity: 0.95,
        lineWidth: 1
      }
    },
    interval: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    area: {
      area: {
        fillOpacity: 0.85,
        lineWidth: 0
      }
    },
    polygon: {
      polygon: {
        fillOpacity: 0.95
      }
    },
    cell: {
      cell: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    rect: {
      rect: {
        fillOpacity: 0.95
      },
      hollow: {
        fill: "",
        strokeOpacity: 1,
        lineWidth: 2
      }
    },
    link: {
      link: {
        fill: "",
        strokeOpacity: 1
      }
    },
    vector: {
      vector: {
        fillOpacity: 1
      }
    },
    box: {
      box: {
        fillOpacity: 0.95,
        stroke: colorBlack,
        lineWidth: 1
      }
    },
    text: {
      text: {
        fill: "#1D2129",
        fontSize: 12,
        lineWidth: 0,
        connectorStroke: colorStroke,
        connectorStrokeOpacity: 0.45,
        connectorLineWidth: 1,
        backgroundFill: colorStroke,
        backgroundFillOpacity: 0.15,
        backgroundPadding: [2, 4],
        startMarkerSymbol: "circle",
        startMarkerSize: 4,
        endMarkerSymbol: "circle",
        endMarkerSize: 4
      },
      badge: {
        fill: "#1D2129",
        fillOpacity: 0.65,
        lineWidth: 0,
        fontSize: 10,
        textAlign: "center",
        textBaseline: "middle",
        markerFill: colorStroke,
        markerFillOpacity: 0.25,
        markerStrokeOpacity: 0
      }
    },
    lineX: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    lineY: {
      line: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1
      }
    },
    rangeX: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    rangeY: {
      range: {
        fill: colorStroke,
        fillOpacity: 0.15,
        lineWidth: 0
      }
    },
    connector: {
      connector: {
        stroke: colorStroke,
        strokeOpacity: 0.45,
        lineWidth: 1,
        connectLength1: 12,
        endMarker: true,
        endMarkerSize: 6,
        endMarkerFill: colorStroke,
        endMarkerFillOpacity: 0.95
      }
    },
    axis: {
      arrow: false,
      gridLineDash: [3, 4],
      gridLineWidth: 0.5,
      gridStroke: colorBlack,
      gridStrokeOpacity: alpha10,
      labelAlign: "horizontal",
      labelFill: colorBlack,
      labelOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: padding1,
      line: false,
      lineLineWidth: 0.5,
      lineStroke: colorBlack,
      lineStrokeOpacity: alpha45,
      tickLength: 4,
      tickLineWidth: 1,
      tickStroke: colorBlack,
      tickOpacity: alpha45,
      titleFill: colorBlack,
      titleOpacity: alpha90,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 12,
      titleTransformOrigin: "center",
      lineArrowOffset: 6,
      lineArrowSize: 6
    },
    axisTop: {
      gridDirection: "positive",
      labelDirection: "negative",
      tickDirection: "negative",
      titlePosition: "top",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "middle"
    },
    axisBottom: {
      gridDirection: "negative",
      labelDirection: "positive",
      tickDirection: "positive",
      titlePosition: "bottom",
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: "bottom",
      titleTransform: "translate(0, 8)"
    },
    axisLeft: {
      gridDirection: "positive",
      labelDirection: "negative",
      labelSpacing: 4,
      tickDirection: "negative",
      titlePosition: "left",
      titleSpacing: 12,
      titleTextBaseline: "middle",
      titleDirection: "vertical",
      titleTransform: "rotate(-90) translate(0, -8)",
      titleTransformOrigin: "center"
    },
    axisRight: {
      gridDirection: "negative",
      labelDirection: "positive",
      labelSpacing: 4,
      tickDirection: "positive",
      titlePosition: "right",
      titleSpacing: 12,
      titleTextBaseline: "top",
      titleDirection: "vertical",
      titleTransformOrigin: "center"
    },
    axisLinear: {
      girdClosed: true,
      gridConnect: "arc",
      gridDirection: "negative",
      gridType: "surround",
      titlePosition: "top",
      titleSpacing: 0
    },
    axisArc: {
      title: false,
      titlePosition: "inner",
      line: false,
      tick: true,
      labelSpacing: 4
    },
    axisRadar: {
      girdClosed: true,
      gridStrokeOpacity: 0.3,
      gridType: "surround",
      tick: false,
      titlePosition: "start"
    },
    legendCategory: {
      backgroundFill: "transparent",
      itemBackgroundFill: "transparent",
      itemLabelFill: colorBlack,
      itemLabelFillOpacity: alpha90,
      itemLabelFontSize: 12,
      itemLabelFontWeight: "normal",
      itemMarkerFillOpacity: 1,
      itemMarkerSize: 8,
      itemSpacing: [padding1, padding1],
      itemValueFill: colorBlack,
      itemValueFillOpacity: 0.65,
      itemValueFontSize: 12,
      itemValueFontWeight: "normal",
      navButtonFill: colorBlack,
      navButtonFillOpacity: 0.65,
      navPageNumFill: colorBlack,
      navPageNumFillOpacity: 0.45,
      navPageNumFontSize: 12,
      padding: 8,
      title: false,
      titleFill: colorBlack,
      titleFillOpacity: 0.65,
      titleFontSize: 12,
      titleFontWeight: "normal",
      titleSpacing: 4,
      tickStroke: colorBlack,
      tickStrokeOpacity: 0.25,
      rowPadding: padding1,
      colPadding: padding2,
      maxRows: 3,
      maxCols: 3
    },
    legendContinuous: {
      handleHeight: 12,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: alpha45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal",
      handleMarkerFill: colorBlack,
      handleMarkerFillOpacity: 0.6,
      handleMarkerLineWidth: 1,
      handleMarkerStroke: colorBlack,
      handleMarkerStrokeOpacity: 0.25,
      handleWidth: 10,
      labelFill: colorBlack,
      labelFillOpacity: alpha45,
      labelFontSize: 12,
      labelFontWeight: "normal",
      labelSpacing: 3,
      tick: true,
      tickLength: 12,
      ribbonSize: 12,
      ribbonFill: "#aaa",
      handle: true,
      handleLabel: false,
      handleShape: "slider",
      handleIconSize: 12 / 1.8,
      indicator: false,
      titleFontSize: 12,
      titleSpacing: 4,
      titleFontWeight: "normal",
      titleFillOpacity: alpha90,
      tickStroke: colorBlack,
      tickStrokeOpacity: alpha45
    },
    label: {
      fill: colorBlack,
      fillOpacity: 0.65,
      fontSize: 12,
      fontWeight: "normal",
      stroke: void 0,
      offset: 12,
      connectorStroke: colorBlack,
      connectorStrokeOpacity: 0.45,
      connectorLineWidth: 1,
      connectorLength: 12,
      connectorLength2: 8,
      connectorDistance: 4
    },
    innerLabel: {
      fill: colorWhite,
      fontSize: 12,
      fillOpacity: 0.85,
      fontWeight: "normal",
      stroke: void 0,
      offset: 0
    },
    htmlLabel: {
      fontSize: 12,
      opacity: 0.65,
      color: colorBlack,
      fontWeight: "normal"
    },
    slider: {
      trackSize: 16,
      trackFill: colorStroke,
      trackFillOpacity: 1,
      selectionFill: colorDefault,
      selectionFillOpacity: 0.15,
      handleIconSize: 10,
      handleIconFill: "#f7f7f7",
      handleIconFillOpacity: 1,
      handleIconStroke: colorBlack,
      handleIconStrokeOpacity: 0.25,
      handleIconLineWidth: 1,
      handleIconRadius: 2,
      handleLabelFill: colorBlack,
      handleLabelFillOpacity: 0.45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: "normal"
    },
    scrollbar: {
      padding: [0, 0, 0, 0],
      trackSize: 6,
      isRound: true,
      slidable: true,
      scrollable: true,
      trackFill: "#e5e5e5",
      trackFillOpacity: 0,
      thumbFill: "#000",
      thumbFillOpacity: 0.15,
      thumbHighlightedFillOpacity: 0.2
    },
    title: {
      spacing: 8,
      titleFill: colorBlack,
      titleFillOpacity: alpha90,
      titleFontSize: 16,
      titleFontWeight: "bold",
      titleTextBaseline: "top",
      subtitleFill: colorBlack,
      subtitleFillOpacity: alpha65,
      subtitleFontSize: 12,
      subtitleFontWeight: "normal",
      subtitleTextBaseline: "top"
    },
    tooltip: {
      css: {
        ".g2-tooltip": {
          "font-family": "sans-serif"
        }
      }
    }
  };
}

// node_modules/@antv/g2/esm/theme/light.js
var tokens = {
  colorBlack: "#1D2129",
  colorWhite: "#ffffff",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults = create7(tokens);
var Light = (options) => {
  return deep_mix_default({}, defaults, options);
};
Light.props = {};

// node_modules/@antv/g2/esm/theme/classic.js
var Classic = (options) => {
  return deep_mix_default({}, Light(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
Classic.props = {};

// node_modules/@antv/g2/esm/theme/dark.js
var tokens2 = {
  colorBlack: "#fff",
  colorWhite: "#000",
  colorStroke: "#416180",
  colorDefault: "#1783FF",
  colorBackground: "transparent",
  category10: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F"
  ],
  category20: [
    "#1783FF",
    "#00C9C9",
    "#F0884D",
    "#D580FF",
    "#7863FF",
    "#60C42D",
    "#BD8F24",
    "#FF80CA",
    "#2491B3",
    "#17C76F",
    "#AABA01",
    "#BC7CFC",
    "#237CBC",
    "#2DE379",
    "#CE8032",
    "#FF7AF4",
    "#545FD3",
    "#AFE410",
    "#D8C608",
    "#FFA1E0"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.25
};
var defaults2 = create7(tokens2);
var Dark = (options) => {
  return deep_mix_default({}, defaults2, {
    tooltip: {
      crosshairsStroke: "#fff",
      crosshairsLineWidth: 1,
      crosshairsStrokeOpacity: 0.25,
      css: {
        ".g2-tooltip": {
          background: "#1f1f1f",
          opacity: 0.95
        },
        ".g2-tooltip-title": {
          color: "#A6A6A6"
        },
        ".g2-tooltip-list-item-name-label": {
          color: "#A6A6A6"
        },
        ".g2-tooltip-list-item-value": {
          color: "#A6A6A6"
        }
      }
    }
  }, options);
};

// node_modules/@antv/g2/esm/theme/classicDark.js
var ClassicDark = (options) => {
  return Object.assign({}, Dark(), {
    category10: "category10",
    category20: "category20"
  }, options);
};
ClassicDark.props = {};

// node_modules/@antv/g2/esm/theme/academy.js
var tokens3 = {
  colorBlack: "#000",
  colorWhite: "#fff",
  colorStroke: "#888",
  colorDefault: "#4e79a7",
  colorBackground: "transparent",
  category10: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  category20: [
    "#4e79a7",
    "#f28e2c",
    "#e15759",
    "#76b7b2",
    "#59a14f",
    "#edc949",
    "#af7aa1",
    "#ff9da7",
    "#9c755f",
    "#bab0ab"
  ],
  padding1: 8,
  padding2: 12,
  padding3: 20,
  alpha90: 0.9,
  alpha65: 0.65,
  alpha45: 0.45,
  alpha25: 0.25,
  alpha10: 0.1
};
var defaults3 = create7(tokens3);
var Academy = (options) => {
  return deep_mix_default({}, defaults3, {
    text: { text: { fontSize: 10 } },
    axis: {
      gridLineDash: [0, 0],
      gridLineWidth: 1,
      gridStroke: "#ddd",
      gridStrokeOpacity: 1,
      labelOpacity: 1,
      labelStrokeOpacity: 1,
      labelFontSize: 10,
      line: true,
      lineLineWidth: 1,
      lineStroke: "#888",
      lineStrokeOpacity: 1,
      tickLength: 5,
      tickStrokeOpacity: 1,
      titleOpacity: 1,
      titleStrokeOpacity: 1,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    axisLeft: {
      gridFilter: (_2, i2) => i2 !== 0
    },
    axisRight: {
      gridFilter: (_2, i2) => i2 !== 0
    },
    legendCategory: {
      itemLabelFillOpacity: 1,
      itemLabelFontSize: 10,
      itemValueFillOpacity: 1,
      itemValueFontSize: 10,
      titleFillOpacity: 1,
      titleFontSize: 11,
      titleFontWeight: "bold"
    },
    legendContinuous: {
      handleLabelFontSize: 10,
      labelFillOpacity: 0.45,
      labelFontSize: 10
    },
    label: {
      fontSize: 10
    },
    innerLabel: {
      fontSize: 10
    },
    htmlLabel: {
      fontSize: 10
    },
    slider: {
      handleLabelFontSize: 10,
      trackFillOpacity: 0.05
    }
  }, options);
};
Academy.props = {};

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x3) {
  return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
}
function formatDecimalParts(x3, p3) {
  if ((i2 = (x3 = p3 ? x3.toExponential(p3 - 1) : x3.toExponential()).indexOf("e")) < 0) return null;
  var i2, coefficient = x3.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x3.slice(i2 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x3) {
  return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value2, width) {
    var i2 = value2.length, t = [], j = 0, g = grouping[0], length5 = 0;
    while (i2 > 0 && g > 0) {
      if (length5 + g + 1 > width) g = Math.max(1, width - length5);
      t.push(value2.substring(i2 -= g, i2 + g));
      if ((length5 += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s4) {
  out: for (var n2 = s4.length, i2 = 1, i0 = -1, i1; i2 < n2; ++i2) {
    switch (s4[i2]) {
      case ".":
        i0 = i1 = i2;
        break;
      case "0":
        if (i0 === 0) i0 = i2;
        i1 = i2;
        break;
      default:
        if (!+s4[i2]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s4.slice(0, i0) + s4.slice(i1 + 1) : s4;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x3, p3) {
  var d4 = formatDecimalParts(x3, p3);
  if (!d4) return x3 + "";
  var coefficient = d4[0], exponent = d4[1], i2 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
  return i2 === n2 ? coefficient : i2 > n2 ? coefficient + new Array(i2 - n2 + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x3, Math.max(0, p3 + i2 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x3, p3) {
  var d4 = formatDecimalParts(x3, p3);
  if (!d4) return x3 + "";
  var coefficient = d4[0], exponent = d4[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x3, p3) => (x3 * 100).toFixed(p3),
  "b": (x3) => Math.round(x3).toString(2),
  "c": (x3) => x3 + "",
  "d": formatDecimal_default,
  "e": (x3, p3) => x3.toExponential(p3),
  "f": (x3, p3) => x3.toFixed(p3),
  "g": (x3, p3) => x3.toPrecision(p3),
  "o": (x3) => Math.round(x3).toString(8),
  "p": (x3, p3) => formatRounded_default(x3 * 100, p3),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
  "x": (x3) => Math.round(x3).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default3(x3) {
  return x3;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group3 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default3 : formatGroup_default(map3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default3 : formatNumerals_default(map3.call(locale2.numerals, String)), percent2 = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero5 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero5 || fill === "0" && align === "=") zero5 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent2 : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i2, n2, c6;
      if (type === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim) value2 = formatTrim_default(value2);
        if (valueNegative && +value2 === 0 && sign3 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n2 = value2.length;
          while (++i2 < n2) {
            if (c6 = value2.charCodeAt(i2), 48 > c6 || c6 > 57) {
              valueSuffix = (c6 === 46 ? decimal + value2.slice(i2 + 1) : value2.slice(i2)) + valueSuffix;
              value2 = value2.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero5) value2 = group3(value2, Infinity);
      var length5 = valuePrefix.length + value2.length + valueSuffix.length, padding = length5 < width ? new Array(width - length5 + 1).join(fill) : "";
      if (comma && zero5) value2 = group3(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length5 = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length5);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value2) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value3) {
      return f2(k2 * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format2;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/@antv/g2/esm/component/utils.js
var __rest52 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function createComponent(descriptor) {
  return class extends CustomElement {
    constructor(config) {
      super(config);
      this.descriptor = descriptor;
    }
    connectedCallback() {
      var _a2, _b;
      (_b = (_a2 = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attributes, this);
    }
    update(cfg = {}) {
      var _a2, _b;
      this.attr(deep_mix_default({}, this.attributes, cfg));
      (_b = (_a2 = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attributes, this);
    }
  };
}
function maybeAppend2(parent, selector, node) {
  if (!parent.querySelector(selector)) {
    return select(parent).append(node);
  }
  return select(parent).select(selector);
}
function titleContent(field3) {
  return Array.isArray(field3) ? field3.join(", ") : `${field3 || ""}`;
}
function inferComponentLayout(position, userDefinitions) {
  const preset = {
    display: "flex",
    flexDirection: "row",
    justifyContent: "flex-start",
    alignItems: "center"
  };
  let { flexDirection, justifyContent, alignItems } = preset;
  const layout = {
    top: ["row", "flex-start", "center"],
    bottom: ["row", "flex-start", "center"],
    left: ["column", "flex-start", "center"],
    right: ["column", "flex-start", "center"],
    center: ["column", "center", "center"]
  };
  if (position in layout) {
    [flexDirection, justifyContent, alignItems] = layout[position];
  }
  return Object.assign({
    display: "flex",
    flexDirection,
    justifyContent,
    alignItems
  }, userDefinitions);
}
var G2Layout = class extends Layout {
  get child() {
    var _a2;
    return (_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2[0];
  }
  update(options) {
    var _a2;
    this.attr(options);
    const { subOptions } = options;
    (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.update(subOptions);
  }
};
var LegendCategoryLayout = class extends G2Layout {
  update(options) {
    var _a2;
    const { subOptions } = options;
    this.attr(options);
    (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.update(subOptions);
  }
};
function scaleOf(scales, type) {
  var _a2;
  return (_a2 = scales.filter((s4) => s4.getOptions().name === type)) === null || _a2 === void 0 ? void 0 : _a2[0];
}
function isHorizontal2(orientation) {
  return orientation === "horizontal" || orientation === 0;
}
function isVertical(orientation) {
  return orientation === "vertical" || orientation === -Math.PI / 2;
}
function inferComponentShape(value2, options, component) {
  const { bbox } = value2;
  const { position = "top", size: userDefinedSize, length: userDefinedLength } = options;
  const isHorizontal3 = ["top", "bottom", "center"].includes(position);
  const [bboxSize, bboxLength] = isHorizontal3 ? [bbox.height, bbox.width] : [bbox.width, bbox.height];
  const { defaultSize, defaultLength } = component.props;
  const size3 = userDefinedSize || defaultSize || bboxSize;
  const length5 = userDefinedLength || defaultLength || bboxLength;
  const orientation = isHorizontal3 ? "horizontal" : "vertical";
  const [width, height] = isHorizontal3 ? [length5, size3] : [size3, length5];
  return {
    orientation,
    width,
    height,
    size: size3,
    length: length5
  };
}
function domainOf2(scales) {
  return scales.find((scale12) => scale12.getOptions().domain.length > 0).getOptions().domain;
}
function adaptor(style) {
  const reservedKeys = [
    "arrow",
    "crosshairs",
    "grid",
    "handle",
    "handleLabel",
    "indicator",
    "label",
    "line",
    "tick",
    "tip",
    "title",
    "trunc"
  ];
  const { style: styles } = style, rest = __rest52(style, ["style"]);
  const finalStyle = {};
  Object.entries(rest).forEach(([key, value2]) => {
    if (reservedKeys.includes(key)) {
      finalStyle[`show${upper_first_default(key)}`] = value2;
    } else
      finalStyle[key] = value2;
  });
  return Object.assign(Object.assign({}, finalStyle), styles);
}

// node_modules/@antv/g2/esm/component/axis.js
var __rest53 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function rotateAxis(axis, options) {
  const { eulerAngles, origin } = options;
  if (origin) {
    axis.setOrigin(origin);
  }
  if (eulerAngles) {
    axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);
  }
}
function sizeOf(coordinate) {
  const { innerWidth, innerHeight, depth } = coordinate.getOptions();
  return [innerWidth, innerHeight, depth];
}
function createFisheye(position, coordinate) {
  const { width, height } = coordinate.getOptions();
  return (tick3) => {
    if (!isFisheye(coordinate))
      return tick3;
    const tickPoint = position === "bottom" ? [tick3, 1] : [0, tick3];
    const vector = coordinate.map(tickPoint);
    if (position === "bottom") {
      const v = vector[0];
      const x3 = new Linear({
        domain: [0, width],
        range: [0, 1]
      });
      return x3.map(v);
    } else if (position === "left") {
      const v = vector[1];
      const x3 = new Linear({
        domain: [0, height],
        range: [0, 1]
      });
      return x3.map(v);
    }
    return tick3;
  };
}
function ticksOf(scale12, domain, tickMethod) {
  if (scale12.getTicks)
    return scale12.getTicks();
  if (!tickMethod)
    return domain;
  const [min10, max11] = extent(domain, (d4) => +d4);
  const { tickCount } = scale12.getOptions();
  return tickMethod(min10, max11, tickCount);
}
function createInset(position, coordinate) {
  if (isPolar(coordinate))
    return (d4) => d4;
  const options = coordinate.getOptions();
  const { innerWidth, innerHeight, insetTop, insetBottom, insetLeft, insetRight } = options;
  const [start, end, size3] = position === "left" || position === "right" ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];
  const x3 = new Linear({
    domain: [0, 1],
    range: [start / size3, 1 - end / size3]
  });
  return (i2) => x3.map(i2);
}
function getData2(scale12, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate) {
  var _a2;
  if (tickCount !== void 0 || tickMethod !== void 0) {
    scale12.update(Object.assign(Object.assign({}, tickCount && { tickCount }), tickMethod && { tickMethod }));
  }
  const ticks2 = ticksOf(scale12, domain, tickMethod);
  const filteredTicks = tickFilter ? ticks2.filter(tickFilter) : ticks2;
  const toString5 = (d4) => d4 instanceof Date ? String(d4) : typeof d4 === "object" && !!d4 ? d4 : String(d4);
  const labelFormatter2 = defaultTickFormatter || ((_a2 = scale12.getFormatter) === null || _a2 === void 0 ? void 0 : _a2.call(scale12)) || toString5;
  const applyInset = createInset(position, coordinate);
  const applyFisheye = createFisheye(position, coordinate);
  const isHorizontal3 = (position2) => ["top", "bottom", "center", "outer"].includes(position2);
  const isVertical2 = (position2) => ["left", "right"].includes(position2);
  if (isPolar(coordinate) || isTranspose(coordinate)) {
    return filteredTicks.map((d4, i2, array2) => {
      var _a3, _b;
      const offset2 = ((_a3 = scale12.getBandWidth) === null || _a3 === void 0 ? void 0 : _a3.call(scale12, d4)) / 2 || 0;
      const tick3 = applyInset(scale12.map(d4) + offset2);
      const shouldReverse = isRadial(coordinate) && position === "center" || isTranspose(coordinate) && ((_b = scale12.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale12)) && isHorizontal3(position) || isTranspose(coordinate) && isVertical2(position);
      return {
        value: shouldReverse ? 1 - tick3 : tick3,
        label: toString5(labelFormatter2(prettyNumber2(d4), i2, array2)),
        id: String(i2)
      };
    });
  }
  return filteredTicks.map((d4, i2, array2) => {
    var _a3;
    const offset2 = ((_a3 = scale12.getBandWidth) === null || _a3 === void 0 ? void 0 : _a3.call(scale12, d4)) / 2 || 0;
    const tick3 = applyFisheye(applyInset(scale12.map(d4) + offset2));
    const shouldReverse = isVertical2(position);
    return {
      value: shouldReverse ? 1 - tick3 : tick3,
      label: toString5(labelFormatter2(prettyNumber2(d4), i2, array2)),
      id: String(i2)
    };
  });
}
function inferGridLength(position, coordinate, plane = "xy") {
  const [width, height, depth] = sizeOf(coordinate);
  if (plane === "xy") {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return width;
  } else if (plane === "xz") {
    if (position.includes("bottom") || position.includes("top"))
      return depth;
    return width;
  } else {
    if (position.includes("bottom") || position.includes("top"))
      return height;
    return depth;
  }
}
function inferLabelOverlap(transform2 = [], style) {
  if (transform2.length > 0)
    return transform2;
  const { labelAutoRotate, labelAutoHide, labelAutoEllipsis, labelAutoWrap } = style;
  const finalTransforms = [];
  const addToTransforms = (overlap, state) => {
    if (state) {
      finalTransforms.push(Object.assign(Object.assign({}, overlap), state));
    }
  };
  addToTransforms({
    type: "rotate",
    optionalAngles: [0, 15, 30, 45, 60, 90]
  }, labelAutoRotate);
  addToTransforms({ type: "ellipsis", minLength: 20 }, labelAutoEllipsis);
  addToTransforms({ type: "hide" }, labelAutoHide);
  addToTransforms({ type: "wrap", wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: true }, labelAutoWrap);
  return finalTransforms;
}
function inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate) {
  const { x: x3, y: y4, width, height } = bbox;
  const center2 = [x3 + width / 2, y4 + height / 2];
  const radius = Math.min(width, height) / 2;
  const [startAngle, endAngle] = angleOf(coordinate);
  const [w2, h2] = sizeOf(coordinate);
  const r2 = Math.min(w2, h2) / 2;
  const common = {
    center: center2,
    radius,
    startAngle,
    endAngle,
    gridLength: (outerRadius - innerRadius) * r2
  };
  if (position === "inner") {
    const { insetLeft, insetTop } = coordinate.getOptions();
    return Object.assign(Object.assign({}, common), { center: [center2[0] - insetLeft, center2[1] - insetTop], labelAlign: "perpendicular", labelDirection: "positive", tickDirection: "positive", gridDirection: "negative" });
  }
  return Object.assign(Object.assign({}, common), { labelAlign: "parallel", labelDirection: "negative", tickDirection: "negative", gridDirection: "positive" });
}
function inferGrid(value2, coordinate, scale12) {
  if (isTheta(coordinate) || isParallel(coordinate))
    return false;
  return value2 === void 0 ? !!scale12.getTicks : value2;
}
function infer3DAxisLinearOverrideStyle(coordinate) {
  const { depth } = coordinate.getOptions();
  return depth ? {
    tickIsBillboard: true,
    lineIsBillboard: true,
    labelIsBillboard: true,
    titleIsBillboard: true,
    gridIsBillboard: true
  } : {};
}
function inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale) {
  const { x: x3, y: y4, width, height } = bbox;
  if (position === "bottom") {
    return { startPos: [x3, y4], endPos: [x3 + width, y4] };
  }
  if (position === "left") {
    return { startPos: [x3 + width, y4 + height], endPos: [x3 + width, y4] };
  }
  if (position === "right") {
    return { startPos: [x3, y4 + height], endPos: [x3, y4] };
  }
  if (position === "top") {
    return { startPos: [x3, y4 + height], endPos: [x3 + width, y4 + height] };
  }
  if (position === "center") {
    if (orientation === "vertical") {
      return {
        startPos: [x3, y4],
        endPos: [x3, y4 + height]
      };
    } else if (orientation === "horizontal") {
      return {
        startPos: [x3, y4],
        endPos: [x3 + width, y4]
      };
    } else if (typeof orientation === "number") {
      const [cx, cy] = coordinate.getCenter();
      const [innerRadius, outerRadius] = radiusOf(coordinate);
      const [startAngle, endAngle] = angleOf(coordinate);
      const r2 = Math.min(width, height) / 2;
      const { insetLeft, insetTop } = coordinate.getOptions();
      const innerR = innerRadius * r2;
      const outerR = outerRadius * r2;
      const [actualCx, actualCy] = [cx + x3 - insetLeft, cy + y4 - insetTop];
      const [cos3, sin3] = [Math.cos(orientation), Math.sin(orientation)];
      const startPos = [
        actualCx + outerR * cos3,
        actualCy + outerR * sin3
      ];
      const endPos = [
        actualCx + innerR * cos3,
        actualCy + innerR * sin3
      ];
      const getAxisXDomainLength = () => {
        const { domain } = xScale.getOptions();
        return domain.length;
      };
      const controllAngleCount = isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;
      return {
        startPos,
        endPos,
        gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,
        gridCenter: [actualCx, actualCy],
        gridControlAngles: new Array(controllAngleCount).fill(0).map((d4, i2, arr) => (endAngle - startAngle) / controllAngleCount * i2)
      };
    }
  }
  return {};
}
var ArcAxisComponent = (options) => {
  const { order, size: size3, position, orientation, labelFormatter: labelFormatter2, tickFilter, tickCount, tickMethod, important = {}, style = {}, indexBBox, title, grid: grid2 = false } = options, rest = __rest53(options, ["order", "size", "position", "orientation", "labelFormatter", "tickFilter", "tickCount", "tickMethod", "important", "style", "indexBBox", "title", "grid"]);
  return ({ scales: [scale12], value: value2, coordinate, theme }) => {
    const { bbox } = value2;
    const { domain } = scale12.getOptions();
    const data2 = getData2(scale12, domain, tickCount, labelFormatter2, tickFilter, tickMethod, position, coordinate);
    const labels = indexBBox ? data2.map((d4, i2) => {
      const bbox2 = indexBBox.get(i2);
      if (!bbox2)
        return d4;
      if (bbox2[0] !== d4.label)
        return d4;
      return Object.assign(Object.assign({}, d4), { bbox: bbox2[1] });
    }) : data2;
    const [innerRadius, outerRadius] = radiusOf(coordinate);
    const defaultStyle2 = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate);
    const { axis: axisTheme, axisArc = {} } = theme;
    const finalStyle = adaptor(deep_mix_default({}, axisTheme, axisArc, defaultStyle2, Object.assign(Object.assign({ type: "arc", data: labels, titleText: titleContent(title), grid: grid2 }, rest), important)));
    return new Axis({
      // @fixme transform is not valid for arcAxis.
      // @ts-ignore
      style: omit_default(finalStyle, ["transform"])
    });
  };
};
function inferThemeStyle(scale12, coordinate, theme, direction3, position, orientation) {
  const baseStyle = theme.axis;
  const positionStyle = ["top", "right", "bottom", "left"].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;
  const channel = scale12.getOptions().name;
  const channelStyle = theme[`axis${upper_first_default(channel)}`] || {};
  return Object.assign({}, baseStyle, positionStyle, channelStyle);
}
function inferDefaultStyle(scale12, coordinate, theme, direction3, position, orientation) {
  const themeStyle = inferThemeStyle(scale12, coordinate, theme, direction3, position, orientation);
  if (position === "center") {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), { labelDirection: direction3 === "right" ? "negative" : "positive" }), direction3 === "center" ? { labelTransform: "translate(50%,0)" } : null), { tickDirection: direction3 === "right" ? "negative" : "positive", labelSpacing: direction3 === "center" ? 0 : 4, titleSpacing: isVertical(orientation) ? 10 : 0, tick: direction3 === "center" ? false : void 0 });
  }
  return themeStyle;
}
var LinearAxisComponent = (options) => {
  const { direction: direction3 = "left", important = {}, labelFormatter: labelFormatter2, order, orientation, actualPosition, position, size: size3, style = {}, title, tickCount, tickFilter, tickMethod, transform: transform2, indexBBox } = options, userDefinitions = __rest53(options, ["direction", "important", "labelFormatter", "order", "orientation", "actualPosition", "position", "size", "style", "title", "tickCount", "tickFilter", "tickMethod", "transform", "indexBBox"]);
  return ({ scales, value: value2, coordinate, theme }) => {
    const { bbox } = value2;
    const [scale12] = scales;
    const { domain, xScale } = scale12.getOptions();
    const defaultStyle2 = inferDefaultStyle(scale12, coordinate, theme, direction3, position, orientation);
    const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle2), style), userDefinitions);
    const gridLength = inferGridLength(actualPosition || position, coordinate, options.plane);
    const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale);
    const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);
    const data2 = getData2(scale12, domain, tickCount, labelFormatter2, tickFilter, tickMethod, position, coordinate);
    const labels = indexBBox ? data2.map((d4, i2) => {
      const bbox2 = indexBBox.get(i2);
      if (!bbox2)
        return d4;
      if (bbox2[0] !== d4.label)
        return d4;
      return Object.assign(Object.assign({}, d4), { bbox: bbox2[1] });
    }) : data2;
    const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {
      type: "linear",
      data: labels,
      crossSize: size3,
      titleText: titleContent(title),
      labelOverlap: inferLabelOverlap(transform2, internalAxisStyle),
      grid: inferGrid(internalAxisStyle.grid, coordinate, scale12),
      gridLength,
      // Always showLine, make title could align the end of axis.
      line: true,
      indexBBox
    }), !internalAxisStyle.line ? { lineOpacity: 0 } : null), overrideStyle), threeDOverrideStyle), important);
    const hasHide = finalAxisStyle.labelOverlap.find((d4) => d4.type === "hide");
    if (hasHide)
      finalAxisStyle.crossSize = false;
    return new Axis({
      className: "axis",
      style: adaptor(finalAxisStyle)
    });
  };
};
var axisFactor = (axis) => {
  return (options) => {
    const { labelFormatter: useDefinedLabelFormatter, labelFilter: userDefinedLabelFilter = () => true } = options;
    return (context) => {
      var _a2;
      const { scales: [scale12] } = context;
      const ticks2 = ((_a2 = scale12.getTicks) === null || _a2 === void 0 ? void 0 : _a2.call(scale12)) || scale12.getOptions().domain;
      const labelFormatter2 = typeof useDefinedLabelFormatter === "string" ? format2(useDefinedLabelFormatter) : useDefinedLabelFormatter;
      const labelFilter = (datum, index3, array2) => userDefinedLabelFilter(ticks2[index3], index3, ticks2);
      const normalizedOptions = Object.assign(Object.assign({}, options), {
        labelFormatter: labelFormatter2,
        labelFilter,
        scale: scale12
      });
      return axis(normalizedOptions)(context);
    };
  };
};
var LinearAxis = axisFactor(LinearAxisComponent);
var ArcAxis = axisFactor(ArcAxisComponent);
LinearAxis.props = {
  defaultPosition: "center",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};
ArcAxis.props = {
  defaultPosition: "outer",
  defaultOrientation: "vertical",
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/axisX.js
var AxisX = (options) => {
  return (...args) => {
    const axisX = LinearAxis(Object.assign({}, { crossPadding: 50 }, options))(...args);
    rotateAxis(axisX, options);
    return axisX;
  };
};
AxisX.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/axisY.js
var AxisY = (options) => {
  return (...args) => {
    const axisY = LinearAxis(Object.assign({}, { crossPadding: 10 }, options))(...args);
    rotateAxis(axisY, options);
    return axisY;
  };
};
AxisY.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/axisRadar.js
var __rest54 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function inferTitleTransform(orientation) {
  const internalOrientation = orientation % (Math.PI * 2);
  if (internalOrientation === Math.PI / 2) {
    return { titleTransform: "translate(0, 50%)" };
  }
  if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {
    return { titleTransform: "translate(50%, 0)" };
  }
  if (internalOrientation > Math.PI / 2 && internalOrientation < Math.PI * 3 / 2) {
    return { titleTransform: "translate(-50%, 0)" };
  }
  return {};
}
function inferAxisStyle(options, theme, coordinate, scales) {
  const { radar } = options;
  const [scale12] = scales;
  const name2 = scale12.getOptions().name;
  const [startAngle, endAngle] = angleOf(coordinate);
  const { axisRadar: radarTheme = {} } = theme;
  return Object.assign(Object.assign({}, radarTheme), { grid: name2 === "position", gridConnect: "line", gridControlAngles: new Array(radar.count).fill(0).map((_2, i2) => {
    const angle4 = (endAngle - startAngle) / radar.count;
    return angle4 * i2;
  }) });
}
var AxisRadar = (options) => {
  const { important = {} } = options, restOptions = __rest54(options, ["important"]);
  return (context) => {
    const { theme, coordinate, scales } = context;
    return LinearAxis(Object.assign(Object.assign(Object.assign({}, restOptions), inferTitleTransform(options.orientation)), { important: Object.assign(Object.assign({}, inferAxisStyle(options, theme, coordinate, scales)), important) }))(context);
  };
};
AxisRadar.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "center" });

// node_modules/@antv/g2/esm/component/legendCategory.js
var __rest55 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function inferShape(scales, markState) {
  const shapeScale = scaleOf(scales, "shape");
  const colorScale = scaleOf(scales, "color");
  const shapeScale1 = shapeScale ? shapeScale.clone() : null;
  const shapes = [];
  for (const [mark2, state] of markState) {
    const namespace = mark2.type;
    const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;
    const shape23 = domain.map((d4, i2) => {
      var _a2;
      if (shapeScale1)
        return shapeScale1.map(d4 || "point");
      return ((_a2 = mark2 === null || mark2 === void 0 ? void 0 : mark2.style) === null || _a2 === void 0 ? void 0 : _a2.shape) || state.defaultShape || "point";
    });
    if (typeof namespace === "string")
      shapes.push([namespace, shape23]);
  }
  if (shapes.length === 0)
    return ["point", ["point"]];
  if (shapes.length === 1)
    return shapes[0];
  if (!shapeScale)
    return shapes[0];
  const { range: range3 } = shapeScale.getOptions();
  return shapes.map(([namespace, shape23]) => {
    let sum4 = 0;
    for (let i2 = 0; i2 < shapes.length; i2++) {
      const targetShape = range3[i2 % range3.length];
      if (shape23[i2] === targetShape)
        sum4++;
    }
    return [sum4 / shape23.length, [namespace, shape23]];
  }).sort((a5, b) => b[0] - a5[0])[0][1];
}
function inferItemMarker(options, context) {
  const { scales, library: library3, markState } = context;
  const [mark2, shapes] = inferShape(scales, markState);
  const { itemMarker, itemMarkerSize: size3 } = options;
  const create8 = (name2, d4) => {
    var _a2, _b, _c;
    const marker = ((_c = (_b = (_a2 = library3[`mark.${mark2}`]) === null || _a2 === void 0 ? void 0 : _a2.props) === null || _b === void 0 ? void 0 : _b.shape[name2]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name2.split("."));
    const radius = typeof size3 === "function" ? size3(d4) : size3;
    return () => useMarker(marker, { color: d4.color })(0, 0, radius);
  };
  const shapeOf = (i2) => `${shapes[i2]}`;
  const shapeScale = scaleOf(scales, "shape");
  if (shapeScale && !itemMarker)
    return (d4, i2) => create8(shapeOf(i2), d4);
  if (typeof itemMarker === "function") {
    return (d4, i2) => {
      const node = itemMarker(d4.id, i2);
      if (typeof node === "string")
        return create8(node, d4);
      return node;
    };
  }
  return (d4, i2) => create8(itemMarker || shapeOf(i2), d4);
}
function inferItemMarkerOpacity(scales) {
  const scale12 = scaleOf(scales, "opacity");
  if (scale12) {
    const { range: range3 } = scale12.getOptions();
    return (d4, i2) => range3[i2];
  }
  return void 0;
}
function inferItemMarkerSize(scales, defaults4) {
  const scale12 = scaleOf(scales, "size");
  if (scale12 instanceof Identity)
    return scale12.map(NaN) * 2;
  return defaults4;
}
function inferItemMarkerLineWidth(options, context) {
  const { scales, markState } = context;
  const [mark2, shapes] = inferShape(scales, markState);
  const { itemMarker, itemMarkerLineWidth } = options;
  if (itemMarkerLineWidth !== void 0) {
    return itemMarkerLineWidth;
  }
  const lineShapes = [
    "line",
    "hyphen",
    "dash",
    "smooth",
    "hv",
    "hvh",
    "vh",
    "vhv"
  ];
  if (typeof itemMarker === "string" && lineShapes.includes(itemMarker)) {
    return 4;
  }
  if (typeof itemMarker === "function") {
    return (d4, i2) => {
      const markerShape = itemMarker(d4.id, i2);
      if (typeof markerShape === "string" && lineShapes.includes(markerShape)) {
        return 4;
      }
      return void 0;
    };
  }
  const shapesArray = Array.isArray(shapes) ? shapes : [shapes];
  const hasLineShape = shapesArray.some((shape23) => lineShapes.includes(shape23));
  if (hasLineShape) {
    return 4;
  }
  return void 0;
}
function inferCategoryStyle(options, context) {
  const { labelFormatter: labelFormatter2 = (d4) => `${d4}` } = options;
  const { scales, theme } = context;
  const defaultSize = theme.legendCategory.itemMarkerSize;
  const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);
  const baseStyle = {
    itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), { itemMarkerSize }), context),
    itemMarkerSize,
    itemMarkerOpacity: inferItemMarkerOpacity(scales),
    itemMarkerLineWidth: inferItemMarkerLineWidth(options, context)
  };
  const finalLabelFormatter = typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2;
  const colorScale = scaleOf(scales, "color");
  const domain = domainOf2(scales);
  const colorOf = colorScale ? (d4) => colorScale.map(d4) : () => context.theme.color;
  return Object.assign(Object.assign({}, baseStyle), { data: domain.map((d4) => ({
    id: d4,
    label: finalLabelFormatter(d4),
    color: colorOf(d4)
  })) });
}
function inferLegendShape(value2, options, component) {
  const { position } = options;
  if (position === "center") {
    const { bbox } = value2;
    const { width: width2, height: height2 } = bbox;
    return { width: width2, height: height2 };
  }
  const { width, height } = inferComponentShape(value2, options, component);
  return { width, height };
}
function filterEmptyIds(legendStyle) {
  return Object.assign(Object.assign({}, legendStyle), { data: (legendStyle === null || legendStyle === void 0 ? void 0 : legendStyle.data.filter((item) => item.id !== "")) || [] });
}
var LegendCategory = (options) => {
  const { labelFormatter: labelFormatter2, layout, order, orientation, position, size: size3, title, cols, itemMarker } = options, style = __rest55(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "cols", "itemMarker"]);
  const { gridRow } = style;
  return (context) => {
    const { value: value2, theme } = context;
    const { bbox } = value2;
    const { width, height } = inferLegendShape(value2, options, LegendCategory);
    const finalLayout = inferComponentLayout(position, layout);
    const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({
      orientation: ["right", "left", "center"].includes(position) ? "vertical" : "horizontal",
      width,
      height,
      layout: cols !== void 0 ? "grid" : "flex"
    }, cols !== void 0 && { gridCol: cols }), gridRow !== void 0 && { gridRow }), { titleText: titleContent(title) }), inferCategoryStyle(options, context));
    const { legendCategory: legendTheme = {} } = theme;
    const categoryStyle = adaptor(Object.assign({}, legendTheme, filterEmptyIds(legendStyle), style));
    const layoutWrapper = new LegendCategoryLayout({
      style: Object.assign(Object.assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, finalLayout), {
        // @ts-ignore
        subOptions: categoryStyle
      })
    });
    layoutWrapper.appendChild(new Category({
      className: "legend-category",
      style: categoryStyle
    }));
    return layoutWrapper;
  };
};
LegendCategory.props = {
  defaultPosition: "top",
  defaultOrder: 1,
  defaultSize: 40,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/legendContinuous.js
var __rest56 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function updateShapeDimensions(shape23, finalSize, orientation) {
  shape23.size = finalSize;
  if (isHorizontal2(orientation)) {
    shape23.height = finalSize;
  } else {
    shape23.width = finalSize;
  }
  return shape23;
}
function inferContinuousShape(value2, options, component) {
  const { size: size3 } = options;
  const shape23 = inferComponentShape(value2, options, component);
  return updateShapeDimensions(shape23, size3, shape23.orientation);
}
function getFormatter(max11) {
  return (value2) => ({
    value: value2 / max11,
    label: String(value2)
  });
}
function getQuantizeOrQuantileConfig(shape23, colorScale, min10, max11, range3) {
  const thresholds = colorScale.thresholds;
  const formatter2 = getFormatter(max11);
  return Object.assign(Object.assign({}, shape23), { color: range3, data: [min10, ...thresholds, max11].map(formatter2) });
}
function getThresholdConfig(shape23, colorScale, range3) {
  const thresholds = colorScale.thresholds;
  const data2 = [-Infinity, ...thresholds, Infinity].map((value2, index3) => ({
    value: index3,
    label: value2
  }));
  return Object.assign(Object.assign({}, shape23), { data: data2, color: range3, labelFilter: (datum, index3) => {
    return index3 > 0 && index3 < data2.length - 1;
  } });
}
function rangeOf4(scale12) {
  const { domain } = scale12.getOptions();
  const [min10, max11] = [domain[0], lastOf(domain)];
  return [min10, max11];
}
function createColorScale(scale12, defaultColor) {
  const options = scale12.getOptions();
  const newScale = scale12.clone();
  newScale.update(Object.assign(Object.assign({}, options), { range: [parseColor(defaultColor).toString()] }));
  return newScale;
}
function getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scales, theme) {
  const { length: length5 } = shape23;
  const definedScale = sizeScale || opacityScale;
  const defaultColor = scales.color ? theme.legendContinuous.ribbonFill || "black" : theme.color;
  const scale12 = colorScale || createColorScale(definedScale, defaultColor);
  const [min10, max11] = rangeOf4(scale12);
  const [domainMin, domainMax] = rangeOf4([colorScale, sizeScale, opacityScale].filter((d4) => d4 !== void 0).find((d4) => !(d4 instanceof Constant2)));
  return Object.assign(Object.assign({}, shape23), { domain: [domainMin, domainMax], data: scale12.getTicks().map((value2) => ({ value: value2 })), color: new Array(Math.floor(length5)).fill(0).map((d4, i2) => {
    const value2 = (max11 - min10) / (length5 - 1) * i2 + min10;
    const color3 = scale12.map(value2) || defaultColor;
    const opacity = opacityScale ? opacityScale.map(value2) : 1;
    return color3.replace(/rgb[a]*\(([\d]{1,3}) *, *([\d]{1,3}) *, *([\d]{1,3})[\S\s]*\)/, (match, p1, p22, p3) => `rgba(${p1}, ${p22}, ${p3}, ${opacity})`);
  }) });
}
function inferContinuousConfig(scales, scale12, value2, options, component, theme) {
  const colorScale = scaleOf(scales, "color");
  const shape23 = inferContinuousShape(value2, options, component);
  if (colorScale instanceof Threshold) {
    const { range: range3 } = colorScale.getOptions();
    const [min10, max11] = rangeOf4(colorScale);
    if (colorScale instanceof Quantize || colorScale instanceof Quantile) {
      return getQuantizeOrQuantileConfig(shape23, colorScale, min10, max11, range3);
    }
    return getThresholdConfig(shape23, colorScale, range3);
  }
  const sizeScale = scaleOf(scales, "size");
  const opacityScale = scaleOf(scales, "opacity");
  return getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scale12, theme);
}
var LegendContinuous = (options) => {
  const { labelFormatter: labelFormatter2, layout, order, orientation, position, size: size3, title, style, crossPadding, padding } = options, rest = __rest56(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "style", "crossPadding", "padding"]);
  return ({ scales, value: value2, theme, scale: scale12 }) => {
    const { bbox } = value2;
    const { x: x3, y: y4, width, height } = bbox;
    const finalLayout = inferComponentLayout(position, layout);
    const { legendContinuous: legendTheme = {} } = theme;
    const finalStyle = adaptor(Object.assign({}, legendTheme, Object.assign(Object.assign({ titleText: titleContent(title), labelAlign: "value", labelFormatter: typeof labelFormatter2 === "string" ? (d4) => format2(labelFormatter2)(d4.label) : labelFormatter2 }, inferContinuousConfig(scales, scale12, value2, options, LegendContinuous, theme)), style), rest));
    const layoutWrapper = new G2Layout({
      style: Object.assign(Object.assign({
        x: x3,
        y: y4,
        width,
        height
      }, finalLayout), {
        // @ts-ignore
        subOptions: finalStyle
      })
    });
    layoutWrapper.appendChild(new Continuous2({
      className: "legend-continuous",
      style: finalStyle
    }));
    return layoutWrapper;
  };
};
LegendContinuous.props = {
  defaultPosition: "top",
  defaultOrientation: "vertical",
  defaultOrder: 1,
  defaultSize: 60,
  defaultLength: 200,
  defaultLegendSize: 60,
  defaultPadding: [20, 10],
  defaultCrossPadding: [12, 12]
  // [horizontal, vertical]
};

// node_modules/@antv/g2/esm/component/legendContinuousBlock.js
var LegendContinuousBlock = (options) => {
  return (...args) => LegendContinuous(Object.assign({}, { block: true }, options))(...args);
};
LegendContinuousBlock.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousSize.js
var LegendContinuousSize = (options) => {
  return (context) => {
    const { scales } = context;
    const sizeScale = scaleOf(scales, "size");
    return LegendContinuous(Object.assign({}, {
      type: "size",
      data: sizeScale.getTicks().map((value2, index3) => ({
        value: value2,
        label: String(value2)
      }))
    }, options))(context);
  };
};
LegendContinuousSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/legendContinuousBlockSize.js
var LegendContinuousBlockSize = (options) => {
  return LegendContinuousSize(Object.assign({}, { block: true }, options));
};
LegendContinuousBlockSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

// node_modules/@antv/g2/esm/component/title.js
var __rest57 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function inferStyleByAlign(x3, y4, width, align) {
  switch (align) {
    case "center":
      return {
        x: x3 + width / 2,
        y: y4,
        textAlign: "middle"
      };
    case "right":
      return {
        x: x3 + width,
        y: y4,
        textAlign: "right"
      };
    default:
      return {
        x: x3,
        y: y4,
        textAlign: "left"
      };
  }
}
var Title2 = createComponent({
  render(attributes, container) {
    const { width, title, subtitle, spacing = 2, align = "left", x: x3, y: y4 } = attributes, style = __rest57(attributes, ["width", "title", "subtitle", "spacing", "align", "x", "y"]);
    container.style.transform = `translate(${x3}, ${y4})`;
    const titleStyle = subObject(style, "title");
    const subtitleStyle = subObject(style, "subtitle");
    const mainTitle = maybeAppend2(container, ".title", "text").attr("className", "title").call(applyStyle, Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, 0, width, align)), { fontSize: 14, textBaseline: "top", text: title }), titleStyle)).node();
    const bounds = mainTitle.getLocalBounds();
    maybeAppend2(container, ".sub-title", "text").attr("className", "sub-title").call((selection) => {
      if (!subtitle)
        return selection.node().remove();
      selection.node().attr(Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, bounds.max[1] + spacing, width, align)), { fontSize: 12, textBaseline: "top", text: subtitle }), subtitleStyle));
    });
  }
});
var TitleComponent = (options) => {
  return ({ value: value2, theme }) => {
    const { x: x3, y: y4, width, height } = value2.bbox;
    return new Title2({
      style: deep_mix_default({}, theme.title, Object.assign({
        x: x3,
        y: y4,
        width,
        height
      }, options))
    });
  };
};
TitleComponent.props = {
  defaultPosition: "top",
  defaultOrder: 2,
  defaultSize: 36,
  defaultCrossPadding: [20, 20],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/utils/scale.js
function constrain(x3, lo, hi) {
  return Math.min(hi, Math.max(lo, x3));
}
function isOrdinalScale(scale12) {
  return !!scale12.getBandWidth;
}
function invert4(scale12, x3, start) {
  if (!isOrdinalScale(scale12))
    return scale12.invert(x3);
  const { adjustedRange } = scale12;
  const { domain } = scale12.getOptions();
  const offset2 = start ? -1 : 0;
  const step2 = scale12.getStep();
  const range3 = start ? adjustedRange : adjustedRange.map((d4) => d4 + step2);
  const i0 = bisectLeft(range3, x3);
  const i1 = constrain(i0 + offset2, 0, domain.length - 1);
  return domain[i1];
}
function domainOf3(scale12, values4, ratioX) {
  if (!values4)
    return scale12.getOptions().domain;
  if (!isOrdinalScale(scale12)) {
    const sortedDomain = sort(values4);
    if (!ratioX)
      return sortedDomain;
    const [d4] = sortedDomain;
    const { range: range3 } = scale12.getOptions();
    const [r0, r1] = range3;
    const v = r0 > r1 ? -1 : 1;
    const d1 = scale12.invert(scale12.map(d4) + v * ratioX);
    return [d4, d1];
  }
  const { domain } = scale12.getOptions();
  const v1 = values4[0];
  const start = domain.indexOf(v1);
  if (ratioX) {
    const end2 = start + Math.round(domain.length * ratioX);
    return domain.slice(start, end2);
  }
  const v2 = values4[values4.length - 1];
  const end = domain.indexOf(v2);
  return domain.slice(start, end + 1);
}
function selectionOf(x3, y4, x12, y12, scale12, coordinate) {
  const { x: scaleX2, y: scaleY2 } = scale12;
  const abstractDomain = (point7, start) => {
    const [x4, y5] = coordinate.invert(point7);
    return [invert4(scaleX2, x4, start), invert4(scaleY2, y5, start)];
  };
  const p0 = abstractDomain([x3, y4], true);
  const p1 = abstractDomain([x12, y12], false);
  const domainX = domainOf3(scaleX2, [p0[0], p1[0]]);
  const domainY = domainOf3(scaleY2, [p0[1], p1[1]]);
  return [domainX, domainY];
}
function abstractOf(domain, scale12) {
  const [d0, d1] = domain;
  const maybeStep = (scale13) => scale13.getStep ? scale13.getStep() : 0;
  return [scale12.map(d0), scale12.map(d1) + maybeStep(scale12)];
}
function pixelsOf(selection, scale12, coordinate) {
  const { x: scaleX2, y: scaleY2 } = scale12;
  const [X, Y] = selection;
  const AX = abstractOf(X, scaleX2);
  const AY = abstractOf(Y, scaleY2);
  const p0 = [AX[0], AY[0]];
  const p1 = [AX[1], AY[1]];
  const [x3, y4] = coordinate.map(p0);
  const [x12, y12] = coordinate.map(p1);
  return [x3, y4, x12, y12];
}

// node_modules/@antv/g2/esm/component/slider.js
var __rest58 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function inferPosition2(bbox, position, trackSize) {
  const { x: x3, y: y4, width, height } = bbox;
  if (position === "left")
    return [x3 + width - trackSize, y4];
  if (position === "right")
    return [x3, y4];
  if (position === "bottom")
    return [x3, y4];
  if (position === "top")
    return [x3, y4 + height - trackSize];
}
var Slider2 = (options) => {
  const { orientation, labelFormatter: labelFormatter2, size: size3, style = {}, position } = options, rest = __rest58(options, ["orientation", "labelFormatter", "size", "style", "position"]);
  return (context) => {
    var _a2;
    const { scales: [scale12], value: value2, theme, coordinate } = context;
    const { bbox } = value2;
    const { width, height } = bbox;
    const { slider: sliderTheme = {} } = theme;
    const defaultFormatter = ((_a2 = scale12.getFormatter) === null || _a2 === void 0 ? void 0 : _a2.call(scale12)) || ((v) => v + "");
    const formatter2 = typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2;
    const isHorizontal3 = orientation === "horizontal";
    const reverse2 = isTranspose(coordinate) && isHorizontal3;
    const { trackSize = sliderTheme.trackSize } = style;
    const [x05, y05] = inferPosition2(bbox, position, trackSize);
    return new Slider({
      className: "slider",
      style: Object.assign({}, sliderTheme, Object.assign(Object.assign({ x: x05, y: y05, trackLength: isHorizontal3 ? width : height, orientation, formatter: (v) => {
        const f2 = formatter2 || defaultFormatter;
        const v1 = reverse2 ? 1 - v : v;
        const tick3 = invert4(scale12, v1, true);
        return f2(tick3);
      }, sparklineData: inferSparklineData(options, context) }, style), rest))
    });
  };
};
function markValue(markState, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === "line" || mark2.type === "area").filter(([mark2]) => mark2.slider).map(([mark2]) => {
    const { encode, slider } = mark2;
    if (slider === null || slider === void 0 ? void 0 : slider.x) {
      const channel = (name2) => {
        const channel2 = encode[name2];
        return [name2, channel2 ? channel2.value : void 0];
      };
      return Object.fromEntries(channels.map(channel));
    }
  });
  if (!(value2 === null || value2 === void 0 ? void 0 : value2.series))
    return value2 === null || value2 === void 0 ? void 0 : value2.y;
  const result = value2.series.reduce((acc, curr, index3) => {
    acc[curr] = acc[curr] || [];
    acc[curr].push(value2.y[index3]);
    return acc;
  }, {});
  return Object.values(result);
}
function inferSparklineData(options, context) {
  const { markState } = context;
  if (isArray(options.sparklineData))
    return options.sparklineData;
  return markValue(markState, ["y", "series"]);
}
Slider2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/sliderX.js
var SliderX = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
SliderX.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/sliderY.js
var SliderY = (options) => {
  return Slider2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
SliderY.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/scrollbar.js
var __rest59 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Scrollbar2 = (options) => {
  const { orientation, labelFormatter: labelFormatter2, style } = options, rest = __rest59(options, ["orientation", "labelFormatter", "style"]);
  return ({ scales: [scale12], value: value2, theme }) => {
    const { bbox } = value2;
    const { x: x3, y: y4, width, height } = bbox;
    const { scrollbar: scrollbarTheme = {} } = theme;
    const { ratio, range: range3 } = scale12.getOptions();
    const mainSize = orientation === "horizontal" ? width : height;
    const actualSize = mainSize / ratio;
    const [r0, r1] = range3;
    const value1 = r1 > r0 ? 0 : 1;
    return new Scrollbar({
      className: "g2-scrollbar",
      style: Object.assign({}, scrollbarTheme, Object.assign(Object.assign(Object.assign(Object.assign({}, style), {
        x: x3,
        y: y4,
        trackLength: mainSize,
        value: value1
      }), rest), { orientation, contentLength: actualSize, viewportLength: mainSize }))
    });
  };
};
Scrollbar2.props = {
  defaultPosition: "bottom",
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
};

// node_modules/@antv/g2/esm/component/scrollbarX.js
var ScrollbarX = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
};
ScrollbarX.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "bottom" });

// node_modules/@antv/g2/esm/component/scrollbarY.js
var ScrollbarY = (options) => {
  return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
};
ScrollbarY.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "left" });

// node_modules/@antv/g2/esm/component/legends.js
var Legends = (options) => {
  return () => {
    return new Group2();
  };
};
Legends.props = {};

// node_modules/@antv/g2/esm/animation/scaleInX.js
var ScaleInX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutX.js
var ScaleOutX = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/scaleInY.js
var ScaleInY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  CSS.registerProperty({
    name: "scaleInYRadius",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const PolarScaleInY = (shape24) => {
      const { __data__, style } = shape24;
      const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const { points, y: y4, y1: y12 } = __data__;
      const arcObject = getArcObject(coordinate, points, [y4, y12]);
      const { innerRadius, outerRadius } = arcObject;
      const keyframes = [
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          scaleInYRadius: innerRadius + ZERO,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          scaleInYRadius: outerRadius,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
      return animation;
    };
    const RectangularScaleInY = (shape24) => {
      const { style } = shape24;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
      const keyframes = [
        {
          transform: `${prefix} ${transform2}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} ${transform2}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
      return animation;
    };
    if (isPolar(coordinate)) {
      return PolarScaleInY(shape23);
    } else {
      return RectangularScaleInY(shape23);
    }
  };
};

// node_modules/@antv/g2/esm/animation/scaleOutY.js
var ScaleOutY = (options, context) => {
  const ZERO = 1e-4;
  const { coordinate } = context;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const [transformOrigin, transform2] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
    const keyframes = [
      {
        transform: `${prefix} scale(1, 1)`.trimStart(),
        transformOrigin
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} ${transform2}`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/fadeIn.js
var FadeIn = (options) => {
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const keyframes = [
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
      {
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
FadeIn.props = {};

// node_modules/@antv/g2/esm/animation/fadeOut.js
var FadeOut = (options) => {
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const keyframes = [
      {
        fillOpacity,
        strokeOpacity,
        opacity
      },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
FadeOut.props = {};

// node_modules/@antv/g2/esm/animation/utils.js
var DEFAULT_ATTRIBUTE_VALUE = {
  opacity: 1,
  strokeOpacity: 1,
  fillOpacity: 1,
  lineWidth: 0,
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  r: 0,
  rx: 0,
  ry: 0,
  width: 0,
  height: 0
};
var GEOMETRY_ATTRIBUTES = {
  [Shape.CIRCLE]: ["cx", "cy", "r"],
  [Shape.ELLIPSE]: ["cx", "cy", "rx", "ry"],
  [Shape.RECT]: ["x", "y", "width", "height"],
  [Shape.IMAGE]: ["x", "y", "width", "height"],
  [Shape.LINE]: ["x1", "y1", "x2", "y2"],
  [Shape.POLYLINE]: ["points"],
  [Shape.POLYGON]: ["points"]
};
function attributeOf(shape23, keys2, useDefaultValue = false) {
  const attribute = {};
  for (const key of keys2) {
    const value2 = shape23.style[key];
    if (value2) {
      attribute[key] = value2;
    } else if (useDefaultValue) {
      attribute[key] = DEFAULT_ATTRIBUTE_VALUE[key];
    }
  }
  return attribute;
}
var attributeKeys = [
  "fill",
  "stroke",
  "fillOpacity",
  "strokeOpacity",
  "opacity",
  "lineWidth"
];

// node_modules/@antv/g2/esm/animation/morphing.js
function localBBoxOf(shape23) {
  const { min: min10, max: max11 } = shape23.getLocalBounds();
  const [x05, y05] = min10;
  const [x12, y12] = max11;
  const height = y12 - y05;
  const width = x12 - x05;
  return [x05, y05, width, height];
}
function d2(bbox) {
  const [x3, y4, width, height] = bbox;
  return `
    M ${x3} ${y4}
    L ${x3 + width} ${y4}
    L ${x3 + width} ${y4 + height}
    L ${x3} ${y4 + height}
    Z
  `;
}
function pack2(shape23, count4) {
  const [x05, y05, width, height] = localBBoxOf(shape23);
  const aspect = height / width;
  const col = Math.ceil(Math.sqrt(count4 / aspect));
  const row2 = Math.ceil(count4 / col);
  const B4 = [];
  const h2 = height / row2;
  let j = 0;
  let n2 = count4;
  while (n2 > 0) {
    const c6 = Math.min(n2, col);
    const w2 = width / c6;
    for (let i2 = 0; i2 < c6; i2++) {
      const x3 = x05 + i2 * w2;
      const y4 = y05 + j * h2;
      B4.push(d2([x3, y4, w2, h2]));
    }
    n2 -= c6;
    j += 1;
  }
  return B4;
}
function normalizeSplit(split = "pack") {
  if (typeof split == "function")
    return split;
  return pack2;
}
function shapeToShape(from, to, timeEffect) {
  let { transform: fromTransform } = from.style;
  const { transform: toTransform } = to.style;
  replaceChild(to, from);
  let keys2 = attributeKeys;
  if (from.nodeName === Shape.GROUP) {
    const [x05, y05, w0, h0] = localBBoxOf(from);
    const [x12, y12, w1, h1] = localBBoxOf(to);
    const dx = x05 - x12;
    const dy = y05 - y12;
    const sx = w0 / w1;
    const sy = h0 / h1;
    fromTransform = `translate(${dx}, ${dy}) scale(${sx}, ${sy})`;
  } else {
    keys2 = keys2.concat(GEOMETRY_ATTRIBUTES[from.nodeName] || []);
  }
  const keyframes = [
    Object.assign({ transform: fromTransform !== null && fromTransform !== void 0 ? fromTransform : "none" }, attributeOf(from, keys2, true)),
    Object.assign({ transform: toTransform !== null && toTransform !== void 0 ? toTransform : "none" }, attributeOf(to, keys2, true))
  ];
  const animation = to.animate(keyframes, timeEffect);
  return animation;
}
function replaceChild(newChild, oldChild) {
  newChild["__data__"] = oldChild["__data__"];
  newChild.className = oldChild.className;
  newChild.markType = oldChild.markType;
  oldChild.parentNode.replaceChild(newChild, oldChild);
}
function maybePath(node, d4) {
  const { nodeName } = node;
  if (nodeName === "path")
    return node;
  const path2 = new Path2({
    style: Object.assign(Object.assign({}, attributeOf(node, attributeKeys)), { d: d4 })
  });
  replaceChild(path2, node);
  return path2;
}
function hasUniqueString(search2, pattern) {
  const first3 = search2.indexOf(pattern);
  const last5 = search2.lastIndexOf(pattern);
  return first3 === last5;
}
function hasSubPath(path2) {
  return !hasUniqueString(path2, "m") || !hasUniqueString(path2, "M");
}
function shape2path(shape23) {
  const path2 = convertToPath(shape23);
  if (!path2)
    return;
  if (hasSubPath(path2))
    return;
  return path2;
}
function hasMarker(shape23) {
  const { nodeName } = shape23;
  if (nodeName === "path") {
    const attributes = get_default(shape23, "attributes");
    return attributes.markerEnd || attributes.markerStart;
  }
  return false;
}
function oneToOne(shape23, from, to, timeEffect) {
  const { nodeName: fromName } = from;
  const { nodeName: toName } = to;
  const fromPath = shape2path(from);
  const toPath = shape2path(to);
  const isSameNodes = fromName === toName && fromName !== "path";
  const hasNonPathNode = fromPath === void 0 || toPath === void 0;
  const isPathWithMarker = hasMarker(from) || hasMarker(to);
  if (isSameNodes || hasNonPathNode || isPathWithMarker)
    return shapeToShape(from, to, timeEffect);
  const pathShape = maybePath(shape23, fromPath);
  const keyframes = [
    Object.assign({}, attributeOf(from, attributeKeys)),
    Object.assign({}, attributeOf(to, attributeKeys))
  ];
  if (fromPath !== toPath) {
    keyframes[0].d = fromPath;
    keyframes[1].d = toPath;
    const animation = pathShape.animate(keyframes, timeEffect);
    animation.onfinish = () => {
      copyAttributes(pathShape, to);
      pathShape.style.d = toPath;
      pathShape.style.transform = "none";
    };
    pathShape.style.transform = "none";
    return animation;
  }
  return null;
}
function oneToMultiple(from, to, timeEffect, split) {
  from.style.visibility = "hidden";
  const D2 = split(from, to.length);
  return to.map((shape23, i2) => {
    const path2 = new Path2({
      style: Object.assign({ d: D2[i2] }, attributeOf(from, attributeKeys))
    });
    return oneToOne(shape23, path2, shape23, timeEffect);
  });
}
function multipleToOne(from, to, timeEffect, split) {
  const D2 = split(to, from.length);
  const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = to.style;
  const keyframes = [
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
    { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },
    {
      fillOpacity,
      strokeOpacity,
      opacity
    }
  ];
  const animation = to.animate(keyframes, timeEffect);
  const animations = from.map((shape23, i2) => {
    const path2 = new Path2({
      style: {
        d: D2[i2],
        fill: to.style.fill
      }
    });
    return oneToOne(shape23, shape23, path2, timeEffect);
  });
  return [...animations, animation];
}
var Morphing = (options) => {
  return (from, to, defaults4) => {
    const split = normalizeSplit(options.split);
    const timeEffect = Object.assign(Object.assign({}, defaults4), options);
    const { length: fl } = from;
    const { length: tl } = to;
    if (fl === 1 && tl === 1 || fl > 1 && tl > 1) {
      const [f2] = from;
      const [t] = to;
      return oneToOne(f2, f2, t, timeEffect);
    }
    if (fl === 1 && tl > 1) {
      const [f2] = from;
      return oneToMultiple(f2, to, timeEffect, split);
    }
    if (fl > 1 && tl === 1) {
      const [t] = to;
      return multipleToOne(from, t, timeEffect, split);
    }
    return null;
  };
};
Morphing.props = {};

// node_modules/@antv/g2/esm/animation/waveIn.js
var WaveIn = (options, context) => {
  const ZERO = 1e-4;
  CSS.registerProperty({
    name: "waveInArcAngle",
    inherits: false,
    initialValue: "",
    interpolable: true,
    syntax: PropertySyntax.NUMBER
  });
  const { coordinate } = context;
  return (from, to, defaults4) => {
    const [shape23] = from;
    if (!isPolar(coordinate)) {
      return ScaleInX(options, context)(from, to, defaults4);
    }
    const { __data__, style } = shape23;
    const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
    const { points, y: y4, y1: y12 } = __data__;
    const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
    const arcObject = getArcObject(coordinate, points, [y4, y12]);
    const { startAngle, endAngle } = arcObject;
    const keyframes = [
      // Use custom interpolable CSS property.
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        waveInArcAngle: startAngle + ZERO,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        waveInArcAngle: endAngle,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    animation.onframe = function() {
      shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle: Number(shape23.style.waveInArcAngle) }));
    };
    animation.onfinish = function() {
      shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle }));
    };
    return animation;
  };
};
WaveIn.props = {};

// node_modules/@antv/g2/esm/animation/zoomIn.js
var ZoomIn = (options) => {
  const ZERO = 1e-4;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const transformOrigin = "center center";
    const keyframes = [
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.01
      },
      {
        transform: `${prefix} scale(1)`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/zoomOut.js
var ZoomOut = (options) => {
  const ZERO = 1e-4;
  return (from, _2, defaults4) => {
    const [shape23] = from;
    const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
    const transformOrigin = "center center";
    const keyframes = [
      { transform: `${prefix} scale(1)`.trimStart(), transformOrigin },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity,
        strokeOpacity,
        opacity,
        offset: 0.99
      },
      {
        transform: `${prefix} scale(${ZERO})`.trimStart(),
        transformOrigin,
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0
      }
    ];
    const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
    return animation;
  };
};

// node_modules/@antv/g2/esm/animation/pathIn.js
var PathIn = (options) => {
  return (from, _2, defaults4) => {
    var _a2, _b;
    const [shape23] = from;
    const length5 = ((_b = (_a2 = shape23).getTotalLength) === null || _b === void 0 ? void 0 : _b.call(_a2)) || 0;
    const keyframes = [
      { lineDash: [0, length5] },
      { lineDash: [length5, 0] }
    ];
    return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults4), options));
  };
};
PathIn.props = {};

// node_modules/@antv/g2/esm/animation/growInX.js
var GrowInX = (options, context) => {
  return (from, to, defaults4) => {
    const [shape23] = from;
    const { min: [x3, y4], halfExtents } = shape23.getLocalBounds();
    const width = halfExtents[0] * 2;
    const height = halfExtents[1] * 2;
    const clipPath = new Path2({
      style: {
        d: `M${x3},${y4}L${x3 + width},${y4}L${x3 + width},${y4 + height}L${x3},${y4 + height}Z`
      }
    });
    shape23.appendChild(clipPath);
    shape23.style.clipPath = clipPath;
    const animation = ScaleInX(options, context)([clipPath], to, defaults4);
    return animation;
  };
};
GrowInX.props = {};

// node_modules/@antv/g2/esm/animation/growInY.js
var GrowInY = (options, context) => {
  return (from, to, defaults4) => {
    const [shape23] = from;
    const { min: [x3, y4], halfExtents } = shape23.getLocalBounds();
    const width = halfExtents[0] * 2;
    const height = halfExtents[1] * 2;
    const clipPath = new Path2({
      style: {
        d: `M${x3},${y4}L${x3 + width},${y4}L${x3 + width},${y4 + height}L${x3},${y4 + height}Z`
      }
    });
    shape23.appendChild(clipPath);
    shape23.style.clipPath = clipPath;
    const animation = ScaleInY(options, context)([clipPath], to, defaults4);
    return animation;
  };
};
GrowInY.props = {};

// node_modules/@antv/g2/esm/runtime/constant.js
var MAIN_LAYER_CLASS_NAME = "main-layer";
var LABEL_LAYER_CLASS_NAME = "label-layer";
var ELEMENT_CLASS_NAME = "element";
var VIEW_CLASS_NAME = "view";
var PLOT_CLASS_NAME = "plot";
var COMPONENT_CLASS_NAME = "component";
var LABEL_CLASS_NAME = "label";
var AREA_CLASS_NAME = "area";
var MASK_CLASS_NAME = "mask";

// node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
function generatePath$6(context, parsedStyle) {
  var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, r2 = parsedStyle.r;
  context.arc(cx, cy, r2, 0, Math.PI * 2, false);
}
function generatePath$5(context, parsedStyle) {
  var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, rx = parsedStyle.rx, ry = parsedStyle.ry;
  if (context.ellipse) {
    context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
  } else {
    var r2 = rx > ry ? rx : ry;
    var scaleX2 = rx > ry ? 1 : rx / ry;
    var scaleY2 = rx > ry ? ry / rx : 1;
    context.save();
    context.scale(scaleX2, scaleY2);
    context.arc(cx, cy, r2, 0, Math.PI * 2);
  }
}
function generatePath$4(context, parsedStyle) {
  var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y4;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = x22 - x12;
    y4 = y22 - y12;
    rad2 = Math.atan2(y4, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = x12 - x22;
    y4 = y12 - y22;
    rad2 = Math.atan2(y4, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
  context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
}
function generatePath$3(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var _parsedStyle$d = parsedStyle.d, absolutePath = _parsedStyle$d.absolutePath, segments = _parsedStyle$d.segments;
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y4;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    var _getStartTangent = markerStart.parentNode.getStartTangent(), _getStartTangent2 = _slicedToArray(_getStartTangent, 2), p1 = _getStartTangent2[0], p22 = _getStartTangent2[1];
    x3 = p1[0] - p22[0];
    y4 = p1[1] - p22[1];
    rad2 = Math.atan2(y4, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    var _getEndTangent = markerEnd.parentNode.getEndTangent(), _getEndTangent2 = _slicedToArray(_getEndTangent, 2), _p = _getEndTangent2[0], _p2 = _getEndTangent2[1];
    x3 = _p[0] - _p2[0];
    y4 = _p[1] - _p2[1];
    rad2 = Math.atan2(y4, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  for (var i2 = 0; i2 < absolutePath.length; i2++) {
    var params = absolutePath[i2];
    var command = params[0];
    var nextSegment = absolutePath[i2 + 1];
    var useStartOffset = i2 === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
    var useEndOffset = (i2 === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
    var _ref = useStartOffset ? [startOffsetX, startOffsetY] : [0, 0], _ref2 = _slicedToArray(_ref, 2), startOffsetXTemp = _ref2[0], startOffsetYTemp = _ref2[1];
    var _ref3 = useEndOffset ? [endOffsetX, endOffsetY] : [0, 0], _ref4 = _slicedToArray(_ref3, 2), endOffsetXTemp = _ref4[0], endOffsetYTemp = _ref4[1];
    switch (command) {
      case "M":
        context.moveTo(params[1] + startOffsetXTemp, params[2] + startOffsetYTemp);
        break;
      case "L":
        context.lineTo(params[1] + endOffsetXTemp, params[2] + endOffsetYTemp);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] + endOffsetXTemp, params[4] + endOffsetYTemp);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] + endOffsetXTemp, params[6] + endOffsetYTemp);
        break;
      case "A": {
        var arcParams = segments[i2].arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
        } else {
          var r2 = rx > ry ? rx : ry;
          var scaleX2 = rx > ry ? 1 : rx / ry;
          var scaleY2 = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX2, scaleY2);
          context.arc(0, 0, r2, startAngle, endAngle, !!(1 - sweepFlag));
          context.scale(1 / scaleX2, 1 / scaleY2);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        if (useEndOffset) {
          context.lineTo(params[6] + endOffsetX, params[7] + endOffsetY);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
  }
}
function generatePath$2(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length5 = points.length;
  var x12 = points[0][0];
  var y12 = points[0][1];
  var x22 = points[length5 - 1][0];
  var y22 = points[length5 - 1][1];
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y4;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y4 = points[1][1] - points[0][1];
    rad2 = Math.atan2(y4, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length5 - 1][0] - points[0][0];
    y4 = points[length5 - 1][1] - points[0][1];
    rad2 = Math.atan2(y4, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x12 + (startOffsetX || endOffsetX), y12 + (startOffsetY || endOffsetY));
  for (var i2 = 1; i2 < length5 - 1; i2++) {
    var point7 = points[i2];
    context.lineTo(point7[0], point7[1]);
  }
  context.lineTo(x22, y22);
}
function generatePath$1(context, parsedStyle) {
  var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
  var points = parsedStyle.points.points;
  var length5 = points.length;
  var x12 = points[0][0];
  var y12 = points[0][1];
  var x22 = points[length5 - 1][0];
  var y22 = points[length5 - 1][1];
  var startOffsetX = 0;
  var startOffsetY = 0;
  var endOffsetX = 0;
  var endOffsetY = 0;
  var rad2 = 0;
  var x3;
  var y4;
  if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
    x3 = points[1][0] - points[0][0];
    y4 = points[1][1] - points[0][1];
    rad2 = Math.atan2(y4, x3);
    startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
    startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
  }
  if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
    x3 = points[length5 - 2][0] - points[length5 - 1][0];
    y4 = points[length5 - 2][1] - points[length5 - 1][1];
    rad2 = Math.atan2(y4, x3);
    endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
    endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
  }
  context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
  for (var i2 = 1; i2 < length5 - 1; i2++) {
    var point7 = points[i2];
    context.lineTo(point7[0], point7[1]);
  }
  context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
}
function generatePath(context, parsedStyle) {
  var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y4 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
  var w2 = width;
  var h2 = height;
  var hasRadius = radius && radius.some(function(r2) {
    return r2 !== 0;
  });
  if (!hasRadius) {
    context.rect(x3, y4, w2, h2);
  } else {
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    var sweepFlag = signX + signY === 0;
    var _radius$map = radius.map(function(r2) {
      return clamp_default(r2, 0, Math.min(Math.abs(w2) / 2, Math.abs(h2) / 2));
    }), _radius$map2 = _slicedToArray(_radius$map, 4), tlr = _radius$map2[0], trr = _radius$map2[1], brr = _radius$map2[2], blr = _radius$map2[3];
    context.moveTo(signX * tlr + x3, y4);
    context.lineTo(w2 - signX * trr + x3, y4);
    if (trr !== 0) {
      context.arc(w2 - signX * trr + x3, signY * trr + y4, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
    }
    context.lineTo(w2 + x3, h2 - signY * brr + y4);
    if (brr !== 0) {
      context.arc(w2 - signX * brr + x3, h2 - signY * brr + y4, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
    }
    context.lineTo(signX * blr + x3, h2 + y4);
    if (blr !== 0) {
      context.arc(signX * blr + x3, h2 - signY * blr + y4, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
    }
    context.lineTo(x3, signY * tlr + y4);
    if (tlr !== 0) {
      context.arc(signX * tlr + x3, signY * tlr + y4, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
    }
  }
}
var Plugin = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "canvas-path-generator";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _pathGeneratorFactory;
      var pathGeneratorFactory = (_pathGeneratorFactory = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pathGeneratorFactory, Shape.CIRCLE, generatePath$6), Shape.ELLIPSE, generatePath$5), Shape.RECT, generatePath), Shape.LINE, generatePath$4), Shape.POLYLINE, generatePath$1), Shape.POLYGON, generatePath$2), Shape.PATH, generatePath$3), Shape.TEXT, void 0), Shape.GROUP, void 0), Shape.IMAGE, void 0), _defineProperty(_defineProperty(_defineProperty(_pathGeneratorFactory, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
      this.context.pathGeneratorFactory = pathGeneratorFactory;
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      delete this.context.pathGeneratorFactory;
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
var tmpVec3a = vec3_exports.create();
var tmpVec3b = vec3_exports.create();
var tmpVec3c = vec3_exports.create();
var tmpMat4 = mat4_exports.create();
var CanvasPickerPlugin = function() {
  function CanvasPickerPlugin2() {
    var _this2 = this;
    _classCallCheck(this, CanvasPickerPlugin2);
    this.isHit = function(displayObject, position, worldTransform, isClipPath) {
      var pick3 = _this2.context.pointInPathPickerFactory[displayObject.nodeName];
      if (pick3) {
        var invertWorldMat = mat4_exports.invert(tmpMat4, worldTransform);
        var localPosition = vec3_exports.transformMat4(tmpVec3b, vec3_exports.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);
        if (pick3(displayObject, new Point2(localPosition[0], localPosition[1]), isClipPath, _this2.isPointInPath, _this2.context, _this2.runtime)) {
          return true;
        }
      }
      return false;
    };
    this.isPointInPath = function(displayObject, position) {
      var context = _this2.runtime.offscreenCanvasCreator.getOrCreateContext(_this2.context.config.offscreenCanvas);
      var generatePath2 = _this2.context.pathGeneratorFactory[displayObject.nodeName];
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, displayObject.parsedStyle);
        context.closePath();
      }
      return context.isPointInPath(position.x, position.y);
    };
  }
  return _createClass(CanvasPickerPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _renderingContext$roo, _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      this.context = context;
      this.runtime = runtime2;
      var document2 = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
      renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, function() {
        var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(result) {
          return _regeneratorRuntime().wrap(function(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", _this2.pick(document2, result));
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      }());
      renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
        return _this2.pick(document2, result);
      });
    }
  }, {
    key: "pick",
    value: function pick3(document2, result) {
      var topmost = result.topmost, _result$position = result.position, x3 = _result$position.x, y4 = _result$position.y;
      var position = vec3_exports.set(tmpVec3a, x3, y4, 0);
      var hitTestList = document2.elementsFromBBox(position[0], position[1], position[0], position[1]);
      var pickedDisplayObjects = [];
      var _iterator = _createForOfIteratorHelper(hitTestList), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _displayObject = _step.value;
          var worldTransform = _displayObject.getWorldTransform();
          var isHitOriginShape = this.isHit(_displayObject, position, worldTransform, false);
          if (isHitOriginShape) {
            var clipped = findClosestClipPathTarget(_displayObject);
            if (clipped) {
              var clipPath = clipped.parsedStyle.clipPath;
              var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);
              if (isHitClipPath) {
                if (topmost) {
                  result.picked = [_displayObject];
                  return result;
                }
                pickedDisplayObjects.push(_displayObject);
              }
            } else {
              if (topmost) {
                result.picked = [_displayObject];
                return result;
              }
              pickedDisplayObjects.push(_displayObject);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      result.picked = pickedDisplayObjects;
      return result;
    }
  }]);
}();
CanvasPickerPlugin.tag = "CanvasPicker";
function isPointInPath$8(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, r2 = _ref.r, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;
  var absDistance = distance4(cx, cy, position.x, position.y);
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  if (hasFill && hasStroke || isClipPath) {
    return absDistance <= r2 + halfLineWidth;
  }
  if (hasFill) {
    return absDistance <= r2;
  }
  if (hasStroke) {
    return absDistance >= r2 - halfLineWidth && absDistance <= r2 + halfLineWidth;
  }
  return false;
}
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
function isPointInPath$7(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, rx = _ref.rx, ry = _ref.ry, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var x3 = position.x, y4 = position.y;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;
  var squareX = (x3 - cx) * (x3 - cx);
  var squareY = (y4 - cy) * (y4 - cy);
  if (hasFill && hasStroke || isClipPath) {
    return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  if (hasFill) {
    return ellipseDistance(squareX, squareY, rx, ry) <= 1;
  }
  if (hasStroke) {
    return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
  }
  return false;
}
function inBox(minX, minY, width, height, x3, y4) {
  return x3 >= minX && x3 <= minX + width && y4 >= minY && y4 <= minY + height;
}
function inRect(minX, minY, width, height, lineWidth, x3, y4) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x3, y4) || // 
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x3, y4) || // 
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x3, y4) || // 
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x3, y4);
}
function inArc(cx, cy, r2, startAngle, endAngle, lineWidth, x3, y4) {
  var angle4 = (Math.atan2(y4 - cy, x3 - cx) + Math.PI * 2) % (Math.PI * 2);
  var point7 = {
    x: cx + r2 * Math.cos(angle4),
    y: cy + r2 * Math.sin(angle4)
  };
  return distance4(point7.x, point7.y, x3, y4) <= lineWidth / 2;
}
function inLine(x12, y12, x22, y22, lineWidth, x3, y4) {
  var minX = Math.min(x12, x22);
  var maxX = Math.max(x12, x22);
  var minY = Math.min(y12, y22);
  var maxY2 = Math.max(y12, y22);
  var halfWidth = lineWidth / 2;
  if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y4 >= minY - halfWidth && y4 <= maxY2 + halfWidth)) {
    return false;
  }
  return pointToLine(x12, y12, x22, y22, x3, y4) <= lineWidth / 2;
}
function inPolyline(points, lineWidth, x3, y4, isClose) {
  var count4 = points.length;
  if (count4 < 2) {
    return false;
  }
  for (var i2 = 0; i2 < count4 - 1; i2++) {
    var x12 = points[i2][0];
    var y12 = points[i2][1];
    var x22 = points[i2 + 1][0];
    var y22 = points[i2 + 1][1];
    if (inLine(x12, y12, x22, y22, lineWidth, x3, y4)) {
      return true;
    }
  }
  if (isClose) {
    var first3 = points[0];
    var last5 = points[count4 - 1];
    if (inLine(first3[0], first3[1], last5[0], last5[1], lineWidth, x3, y4)) {
      return true;
    }
  }
  return false;
}
var tolerance = 1e-6;
function dcmp(x3) {
  if (Math.abs(x3) < tolerance) {
    return 0;
  }
  return x3 < 0 ? -1 : 1;
}
function onSegment(p1, p22, q) {
  if ((q[0] - p1[0]) * (p22[1] - p1[1]) === (p22[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p22[0]) <= q[0] && q[0] <= Math.max(p1[0], p22[0]) && Math.min(p1[1], p22[1]) <= q[1] && q[1] <= Math.max(p1[1], p22[1])) {
    return true;
  }
  return false;
}
function inPolygon(points, x3, y4) {
  var isHit = false;
  var n2 = points.length;
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p22 = points[(i2 + 1) % n2];
    if (onSegment(p1, p22, [x3, y4])) {
      return true;
    }
    if (dcmp(p1[1] - y4) > 0 !== dcmp(p22[1] - y4) > 0 && dcmp(x3 - (y4 - p1[1]) * (p1[0] - p22[0]) / (p1[1] - p22[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function inPolygons(polygons, x3, y4) {
  var isHit = false;
  for (var i2 = 0; i2 < polygons.length; i2++) {
    var points = polygons[i2];
    isHit = inPolygon(points, x3, y4);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function isPointInPath$6(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, x12 = _ref.x1, y12 = _ref.y1, x22 = _ref.x2, y22 = _ref.y2, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke2 = _ref.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inLine(x12, y12, x22, y22, lineWidth + increasedLineWidthForHitTesting, position.x, position.y);
}
function isPointInStroke2(segments, lineWidth, px2, py, length5) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, px2, py)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px2, py);
        if (isHit) {
          return true;
        }
        break;
      case "Q":
        var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px2, py);
        isHit = qDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "C":
        var cDistance = pointDistance$3(
          prePoint[0],
          // ,  C 
          prePoint[1],
          params[1],
          // 'C' 12 34 56 
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          px2,
          py,
          length5
        );
        isHit = cDistance <= lineWidth / 2;
        if (isHit) {
          return true;
        }
        break;
      case "A":
        if (!segment.cubicParams) {
          segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
        }
        var args = segment.cubicParams;
        var prePointInCubic = prePoint;
        for (var _i = 0; _i < args.length; _i += 6) {
          var _cDistance = pointDistance$3(
            prePointInCubic[0],
            // ,  C 
            prePointInCubic[1],
            args[_i],
            args[_i + 1],
            args[_i + 2],
            args[_i + 3],
            args[_i + 4],
            args[_i + 5],
            px2,
            py,
            length5
          );
          prePointInCubic = [args[_i + 4], args[_i + 5]];
          isHit = _cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
        }
        break;
    }
  }
  return isHit;
}
function isPointInPath$5(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, stroke2 = _ref.stroke, fill = _ref.fill, d4 = _ref.d, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var segments = d4.segments, hasArc = d4.hasArc, polylines = d4.polylines, polygons = d4.polygons;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(
    pointerEvents,
    // Only a closed path can be filled.
    (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill,
    stroke2
  ), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var totalLength = getOrCalculatePathTotalLength(displayObject);
  var isHit = false;
  if (hasFill || isClipPath) {
    if (hasArc) {
      isHit = isPointInPath2(displayObject, position);
    } else {
      isHit = inPolygons(polygons, position.x, position.y) || inPolygons(polylines, position.x, position.y);
    }
    return isHit;
  }
  if (hasStroke || isClipPath) {
    isHit = isPointInStroke2(segments, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, totalLength);
  }
  return isHit;
}
function isPointInPath$4(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, stroke2 = _ref.stroke, fill = _ref.fill, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var isHit = false;
  if (hasStroke || isClipPath) {
    isHit = inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, true);
  }
  if (!isHit && (hasFill || isClipPath)) {
    isHit = inPolygon(points.points, position.x, position.y);
  }
  return isHit;
}
function isPointInPath$3(displayObject, position, isClipPath) {
  var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke2 = _ref.stroke;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
  if (!hasStroke && !isClipPath || !lineWidth) {
    return false;
  }
  return inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, false);
}
function isPointInPath$2(displayObject, position, isClipPath, isPointInPath2, runtime2) {
  var _ref = displayObject.parsedStyle, radius = _ref.radius, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y4 = _ref$y === void 0 ? 0 : _ref$y, width = _ref.width, height = _ref.height, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
  var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
  var hasRadius = radius && radius.some(function(r2) {
    return r2 !== 0;
  });
  var lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;
  if (!hasRadius) {
    var halfWidth = lineWidthForHitTesting / 2;
    if (hasFill && hasStroke || isClipPath) {
      return inBox(x3 - halfWidth, y4 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
    }
    if (hasFill) {
      return inBox(x3, y4, width, height, position.x, position.y);
    }
    if (hasStroke) {
      return inRect(x3, y4, width, height, lineWidthForHitTesting, position.x, position.y);
    }
  } else {
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inRectWithRadius(x3, y4, width, height, radius.map(function(r2) {
        return clamp_default(r2, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }), lineWidthForHitTesting, position.x, position.y);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = isPointInPath2(displayObject, position);
    }
    return isHit;
  }
  return false;
}
function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x3, y4) {
  var _radiusArray = _slicedToArray(radiusArray, 4), tlr = _radiusArray[0], trr = _radiusArray[1], brr = _radiusArray[2], blr = _radiusArray[3];
  return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x3, y4) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x3, y4) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x3, y4) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x3, y4) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x3, y4) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x3, y4) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x3, y4) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x3, y4);
}
function isPointInPath$1(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
  var _ref = displayObject.parsedStyle, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y4 = _ref$y === void 0 ? 0 : _ref$y, width = _ref.width, height = _ref.height;
  if (pointerEvents === "non-transparent-pixel") {
    var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
    var canvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    var context = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
      willReadFrequently: true
    });
    canvas.width = width;
    canvas.height = height;
    renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, _objectSpread2(_objectSpread2({}, displayObject.parsedStyle), {}, {
      x: 0,
      y: 0
    }), displayObject, void 0, void 0, void 0);
    var imagedata = context.getImageData(position.x - x3, position.y - y4, 1, 1).data;
    return imagedata.every(function(component) {
      return component !== 0;
    });
  }
  return true;
}
function isPointInPath(displayObject, position, isClipPath, isPointInPath2) {
  var bounds = displayObject.getGeometryBounds();
  return position.x >= bounds.min[0] && position.y >= bounds.min[1] && position.x <= bounds.max[0] && position.y <= bounds.max[1];
}
var Plugin2 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "canvas-picker";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _pointInPathPickerFac;
      var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pointInPathPickerFac, Shape.CIRCLE, isPointInPath$8), Shape.ELLIPSE, isPointInPath$7), Shape.RECT, isPointInPath$2), Shape.LINE, isPointInPath$6), Shape.POLYLINE, isPointInPath$3), Shape.POLYGON, isPointInPath$4), Shape.PATH, isPointInPath$5), Shape.TEXT, isPointInPath), Shape.GROUP, null), Shape.IMAGE, isPointInPath$1), _defineProperty(_defineProperty(_pointInPathPickerFac, Shape.HTML, null), Shape.MESH, null));
      this.context.pointInPathPickerFactory = pointInPathPickerFactory;
      this.addRenderingPlugin(new CanvasPickerPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      delete this.context.pointInPathPickerFactory;
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
function _classPrivateFieldBase(e3, t) {
  if (!{}.hasOwnProperty.call(e3, t)) throw new TypeError("attempted to use private field on non-instance");
  return e3;
}

// node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var id3 = 0;
function _classPrivateFieldKey(e3) {
  return "__private_" + id3++ + "_" + e3;
}

// node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
var RefCountCache = function() {
  function RefCountCache2() {
    _classCallCheck(this, RefCountCache2);
    this.cacheStore = /* @__PURE__ */ new Map();
  }
  return _createClass(RefCountCache2, [{
    key: "onRefAdded",
    value: function onRefAdded2(ref) {
    }
  }, {
    key: "has",
    value: function has(key) {
      return this.cacheStore.has(key);
    }
  }, {
    key: "put",
    value: function put(key, item, ref) {
      if (this.cacheStore.has(key)) {
        return false;
      }
      this.cacheStore.set(key, {
        value: item,
        counter: /* @__PURE__ */ new Set([ref.entity])
      });
      this.onRefAdded(ref);
      return true;
    }
  }, {
    key: "get",
    value: function get4(key, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return null;
      }
      if (!cacheItem.counter.has(ref.entity)) {
        cacheItem.counter.add(ref.entity);
        this.onRefAdded(ref);
      }
      return cacheItem.value;
    }
  }, {
    key: "update",
    value: function update2(key, value2, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return false;
      }
      cacheItem.value = _objectSpread2(_objectSpread2({}, cacheItem.value), value2);
      if (!cacheItem.counter.has(ref.entity)) {
        cacheItem.counter.add(ref.entity);
        this.onRefAdded(ref);
      }
      return true;
    }
  }, {
    key: "release",
    value: function release(key, ref) {
      var cacheItem = this.cacheStore.get(key);
      if (!cacheItem) {
        return false;
      }
      cacheItem.counter["delete"](ref.entity);
      if (cacheItem.counter.size <= 0) {
        this.cacheStore["delete"](key);
      }
      return true;
    }
  }, {
    key: "releaseRef",
    value: function releaseRef(ref) {
      var _this2 = this;
      Array.from(this.cacheStore.keys()).forEach(function(key) {
        _this2.release(key, ref);
      });
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this.cacheStore.size;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cacheStore.clear();
    }
  }]);
}();
var tasks = [];
var nextFrameTasks = [];
var ImageSlicer = function() {
  function ImageSlicer2() {
    _classCallCheck(this, ImageSlicer2);
  }
  return _createClass(ImageSlicer2, null, [{
    key: "stop",
    value: function stop() {
      var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
      if (ImageSlicer2.rafId) {
        api.cancelAnimationFrame(ImageSlicer2.rafId);
        ImageSlicer2.rafId = null;
      }
    }
  }, {
    key: "executeTask",
    value: function executeTask() {
      var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
      if (tasks.length <= 0 && nextFrameTasks.length <= 0) {
        return;
      }
      nextFrameTasks.forEach(function(task) {
        return task();
      });
      nextFrameTasks = tasks.splice(0, ImageSlicer2.TASK_NUM_PER_FRAME);
      ImageSlicer2.rafId = api.requestAnimationFrame(function() {
        ImageSlicer2.executeTask(api);
      });
    }
  }, {
    key: "sliceImage",
    value: function sliceImage(image, sliceWidth, sliceHeight, rerender) {
      var overlap = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      var api = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : ImageSlicer2.api;
      var imageWidth = image.naturalWidth || image.width;
      var imageHeight = image.naturalHeight || image.height;
      var strideW = sliceWidth - overlap;
      var strideH = sliceHeight - overlap;
      var gridCols = Math.ceil(imageWidth / strideW);
      var gridRows = Math.ceil(imageHeight / strideH);
      var result = {
        tileSize: [sliceWidth, sliceHeight],
        gridSize: [gridRows, gridCols],
        tiles: Array(gridRows).fill(null).map(function() {
          return Array(gridCols).fill(null);
        })
      };
      var _loop = function _loop2(row3) {
        var _loop22 = function _loop23(col2) {
          tasks.push(function() {
            var startX = col2 * strideW;
            var startY = row3 * strideH;
            var _ref = [Math.min(sliceWidth, imageWidth - startX), Math.min(sliceHeight, imageHeight - startY)], tempSliceWidth = _ref[0], tempSliceHeight = _ref[1];
            var sliceCanvas = api.createCanvas();
            sliceCanvas.width = sliceWidth;
            sliceCanvas.height = sliceHeight;
            var sliceCtx = sliceCanvas.getContext("2d");
            sliceCtx.drawImage(image, startX, startY, tempSliceWidth, tempSliceHeight, 0, 0, tempSliceWidth, tempSliceHeight);
            result.tiles[row3][col2] = {
              x: startX,
              y: startY,
              tileX: col2,
              tileY: row3,
              data: sliceCanvas
            };
            rerender();
          });
        };
        for (var col = 0; col < gridCols; col++) {
          _loop22(col);
        }
      };
      for (var row2 = 0; row2 < gridRows; row2++) {
        _loop(row2);
      }
      ImageSlicer2.stop();
      ImageSlicer2.executeTask();
      return result;
    }
  }]);
}();
ImageSlicer.TASK_NUM_PER_FRAME = 10;
var IMAGE_CACHE = new RefCountCache();
IMAGE_CACHE.onRefAdded = function onRefAdded(ref) {
  var _this2 = this;
  ref.addEventListener(ElementEvent.DESTROY, function() {
    _this2.releaseRef(ref);
  }, {
    once: true
  });
};
var ImagePool = function() {
  function ImagePool2(context, runtime2) {
    _classCallCheck(this, ImagePool2);
    this.gradientCache = {};
    this.patternCache = {};
    this.context = context;
    this.runtime = runtime2;
  }
  return _createClass(ImagePool2, [{
    key: "getImageSync",
    value: function getImageSync(src, ref, callback) {
      var imageSource = isString(src) ? src : src.src;
      if (IMAGE_CACHE.has(imageSource)) {
        var imageCache = IMAGE_CACHE.get(imageSource, ref);
        if (imageCache.img.complete) {
          callback === null || callback === void 0 || callback(imageCache);
          return imageCache;
        }
      }
      this.getOrCreateImage(src, ref).then(function(cache2) {
        callback === null || callback === void 0 || callback(cache2);
      })["catch"](function(reason) {
        console.error(reason);
      });
      return null;
    }
  }, {
    key: "getOrCreateImage",
    value: function getOrCreateImage(src, ref) {
      var _this2 = this;
      var imageSource = isString(src) ? src : src.src;
      if (!isString(src) && !IMAGE_CACHE.has(imageSource)) {
        var imageCache = {
          img: src,
          size: [src.naturalWidth || src.width, src.naturalHeight || src.height],
          tileSize: calculateImageTileSize(src)
        };
        IMAGE_CACHE.put(imageSource, imageCache, ref);
      }
      if (IMAGE_CACHE.has(imageSource)) {
        var _imageCache = IMAGE_CACHE.get(imageSource, ref);
        if (_imageCache.img.complete) {
          return Promise.resolve(_imageCache);
        }
        return new Promise(function(resolve, reject) {
          _imageCache.img.addEventListener("load", function() {
            _imageCache.size = [_imageCache.img.naturalWidth || _imageCache.img.width, _imageCache.img.naturalHeight || _imageCache.img.height];
            _imageCache.tileSize = calculateImageTileSize(_imageCache.img);
            resolve(_imageCache);
          });
          _imageCache.img.addEventListener("error", function(ev) {
            reject(ev);
          });
        });
      }
      return new Promise(function(resolve, reject) {
        var image = _this2.context.config.createImage();
        if (image) {
          var _imageCache2 = {
            img: image,
            size: [0, 0],
            tileSize: calculateImageTileSize(image)
          };
          IMAGE_CACHE.put(imageSource, _imageCache2, ref);
          image.onload = function() {
            _imageCache2.size = [image.naturalWidth || image.width, image.naturalHeight || image.height];
            _imageCache2.tileSize = calculateImageTileSize(_imageCache2.img);
            resolve(_imageCache2);
          };
          image.onerror = function(ev) {
            reject(ev);
          };
          image.crossOrigin = "Anonymous";
          image.src = imageSource;
        }
      });
    }
  }, {
    key: "createDownSampledImage",
    value: function() {
      var _createDownSampledImage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(src, ref) {
        var imageCache, enableLargeImageOptimization, _ref, _ref$maxDownSampledIm, maxDownSampledImageSize, _ref$downSamplingRate, downSamplingRateThreshold, createImageBitmapFunc, _imageCache$size, originWidth, originHeight, resizedImage, downSamplingRate, updateCache;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 1;
              return this.getOrCreateImage(src, ref);
            case 1:
              imageCache = _context.sent;
              if (!(typeof imageCache.downSamplingRate !== "undefined")) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", imageCache);
            case 2:
              enableLargeImageOptimization = this.context.config.enableLargeImageOptimization;
              _ref = typeof enableLargeImageOptimization === "boolean" ? {} : enableLargeImageOptimization, _ref$maxDownSampledIm = _ref.maxDownSampledImageSize, maxDownSampledImageSize = _ref$maxDownSampledIm === void 0 ? 2048 : _ref$maxDownSampledIm, _ref$downSamplingRate = _ref.downSamplingRateThreshold, downSamplingRateThreshold = _ref$downSamplingRate === void 0 ? 0.5 : _ref$downSamplingRate;
              createImageBitmapFunc = this.runtime.globalThis.createImageBitmap;
              _imageCache$size = _slicedToArray(imageCache.size, 2), originWidth = _imageCache$size[0], originHeight = _imageCache$size[1];
              resizedImage = imageCache.img;
              downSamplingRate = Math.min((maxDownSampledImageSize + maxDownSampledImageSize) / (originWidth + originHeight), Math.max(0.01, Math.min(downSamplingRateThreshold, 0.5)));
              updateCache = _objectSpread2(_objectSpread2({}, imageCache), {}, {
                downSamplingRate
              });
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              if (!createImageBitmapFunc) {
                _context.next = 7;
                break;
              }
              _context.prev = 3;
              _context.next = 4;
              return createImageBitmapFunc(imageCache.img, {
                resizeWidth: originWidth * downSamplingRate,
                resizeHeight: originHeight * downSamplingRate
              });
            case 4:
              resizedImage = _context.sent;
              _context.next = 6;
              break;
            case 5:
              _context.prev = 5;
              _context["catch"](3);
              downSamplingRate = 1;
            case 6:
              _context.next = 8;
              break;
            case 7:
              downSamplingRate = 1;
            case 8:
              updateCache = _objectSpread2(_objectSpread2({}, this.getImageSync(src, ref)), {}, {
                downSampled: resizedImage,
                downSamplingRate
              });
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              return _context.abrupt("return", updateCache);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3, 5]]);
      }));
      function createDownSampledImage(_x, _x2) {
        return _createDownSampledImage.apply(this, arguments);
      }
      return createDownSampledImage;
    }()
  }, {
    key: "createImageTiles",
    value: function() {
      var _createImageTiles = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(src, tiles, rerender, ref) {
        var imageCache, _ref$ownerDocument$de, requestAnimationFrame3, cancelAnimationFrame3, updateCache;
        return _regeneratorRuntime().wrap(function(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 1;
              return this.getOrCreateImage(src, ref);
            case 1:
              imageCache = _context2.sent;
              _ref$ownerDocument$de = ref.ownerDocument.defaultView, requestAnimationFrame3 = _ref$ownerDocument$de.requestAnimationFrame, cancelAnimationFrame3 = _ref$ownerDocument$de.cancelAnimationFrame;
              ImageSlicer.api = {
                requestAnimationFrame: requestAnimationFrame3,
                cancelAnimationFrame: cancelAnimationFrame3,
                createCanvas: function createCanvas() {
                  return OffscreenCanvasCreator.createCanvas();
                }
              };
              updateCache = _objectSpread2(_objectSpread2({}, imageCache), ImageSlicer.sliceImage(imageCache.img, imageCache.tileSize[0], imageCache.tileSize[0], rerender));
              IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
              return _context2.abrupt("return", updateCache);
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function createImageTiles(_x3, _x4, _x5, _x6) {
        return _createImageTiles.apply(this, arguments);
      }
      return createImageTiles;
    }()
  }, {
    key: "releaseImage",
    value: function releaseImage(src, ref) {
      IMAGE_CACHE.release(isString(src) ? src : src.src, ref);
    }
  }, {
    key: "releaseImageRef",
    value: function releaseImageRef(ref) {
      IMAGE_CACHE.releaseRef(ref);
    }
  }, {
    key: "getOrCreatePatternSync",
    value: function getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, min10, callback) {
      var patternKey = this.generatePatternKey(pattern);
      if (patternKey && this.patternCache[patternKey]) {
        return this.patternCache[patternKey];
      }
      var image = pattern.image, repetition = pattern.repetition, transform2 = pattern.transform;
      var src;
      var needScaleWithDPR = false;
      if (isString(image)) {
        var imageCache = this.getImageSync(image, object, callback);
        src = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
      } else if ($offscreenCanvas) {
        src = $offscreenCanvas;
        needScaleWithDPR = true;
      } else {
        src = image;
      }
      var canvasPattern = src && context.createPattern(src, repetition);
      if (canvasPattern) {
        var mat;
        if (transform2) {
          mat = parsedTransformToMat4(parseTransform(transform2), new DisplayObject({}));
        } else {
          mat = mat4_exports.identity(mat4_exports.create());
        }
        if (needScaleWithDPR) {
          mat4_exports.scale(mat, mat, [1 / dpr, 1 / dpr, 1]);
        }
        canvasPattern.setTransform({
          a: mat[0],
          b: mat[1],
          c: mat[4],
          d: mat[5],
          e: mat[12] + min10[0],
          f: mat[13] + min10[1]
        });
      }
      if (patternKey && canvasPattern) {
        this.patternCache[patternKey] = canvasPattern;
      }
      return canvasPattern;
    }
  }, {
    key: "getOrCreateGradient",
    value: function getOrCreateGradient(params, context) {
      var key = this.generateGradientKey(params);
      var type = params.type, steps = params.steps, min10 = params.min, width = params.width, height = params.height, angle4 = params.angle, cx = params.cx, cy = params.cy, size3 = params.size;
      if (this.gradientCache[key]) {
        return this.gradientCache[key];
      }
      var gradient2 = null;
      if (type === GradientType.LinearGradient) {
        var _computeLinearGradien = computeLinearGradient(min10, width, height, angle4), x12 = _computeLinearGradien.x1, y12 = _computeLinearGradien.y1, x22 = _computeLinearGradien.x2, y22 = _computeLinearGradien.y2;
        gradient2 = context.createLinearGradient(x12, y12, x22, y22);
      } else if (type === GradientType.RadialGradient) {
        var _computeRadialGradien = computeRadialGradient(min10, width, height, cx, cy, size3), x3 = _computeRadialGradien.x, y4 = _computeRadialGradien.y, r2 = _computeRadialGradien.r;
        gradient2 = context.createRadialGradient(x3, y4, 0, x3, y4, r2);
      }
      if (gradient2) {
        steps.forEach(function(_ref2) {
          var offset2 = _ref2.offset, color3 = _ref2.color;
          if (offset2.unit === UnitType.kPercentage) {
            var _gradient;
            (_gradient = gradient2) === null || _gradient === void 0 || _gradient.addColorStop(offset2.value / 100, color3.toString());
          }
        });
        this.gradientCache[key] = gradient2;
      }
      return this.gradientCache[key];
    }
  }, {
    key: "generateGradientKey",
    value: function generateGradientKey(params) {
      var type = params.type, min10 = params.min, width = params.width, height = params.height, steps = params.steps, angle4 = params.angle, cx = params.cx, cy = params.cy, size3 = params.size;
      return "gradient-".concat(type, "-").concat((angle4 === null || angle4 === void 0 ? void 0 : angle4.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size3 === null || size3 === void 0 ? void 0 : size3.toString()) || 0, "-").concat(min10[0], "-").concat(min10[1], "-").concat(width, "-").concat(height, "-").concat(steps.map(function(_ref3) {
        var offset2 = _ref3.offset, color3 = _ref3.color;
        return "".concat(offset2).concat(color3);
      }).join("-"));
    }
  }, {
    key: "generatePatternKey",
    value: function generatePatternKey(pattern) {
      var image = pattern.image, repetition = pattern.repetition;
      if (isString(image)) {
        return "pattern-".concat(image, "-").concat(repetition);
      }
      if (image.nodeName === "rect") {
        return "pattern-".concat(image.entity, "-").concat(repetition);
      }
    }
  }]);
}();
ImagePool.isSupportTile = !!OffscreenCanvasCreator.createCanvas();
function calculateImageTileSize(img) {
  if (!img.complete) {
    return [0, 0];
  }
  var width = img.naturalWidth || img.width, height = img.naturalHeight || img.height;
  var tileSize = 256;
  [256, 512].forEach(function(size3) {
    var rows = Math.ceil(height / size3);
    var cols = Math.ceil(width / size3);
    if (rows * cols < 1e3) {
      tileSize = size3;
    }
  });
  return [tileSize, tileSize];
}
var LoadImagePlugin = function() {
  function LoadImagePlugin2() {
    _classCallCheck(this, LoadImagePlugin2);
  }
  return _createClass(LoadImagePlugin2, [{
    key: "apply",
    value: function apply(context) {
      var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var calculateWithAspectRatio = function calculateWithAspectRatio2(object, imageWidth, imageHeight) {
        var _object$parsedStyle = object.parsedStyle, width = _object$parsedStyle.width, height = _object$parsedStyle.height;
        if (width && !height) {
          object.setAttribute("height", imageHeight / imageWidth * width);
        } else if (!width && height) {
          object.setAttribute("width", imageWidth / imageHeight * height);
        }
      };
      var handleMounted = function handleMounted2(e3) {
        var object = e3.target;
        var nodeName = object.nodeName, attributes = object.attributes;
        if (nodeName === Shape.IMAGE) {
          var src = attributes.src, keepAspectRatio = attributes.keepAspectRatio;
          imagePool.getImageSync(src, object, function(_ref) {
            var _ref$img = _ref.img, width = _ref$img.width, height = _ref$img.height;
            if (keepAspectRatio) {
              calculateWithAspectRatio(object, width, height);
            }
            object.renderable.dirty = true;
            renderingService.dirtify();
          });
        }
      };
      var handleAttributeChanged = function handleAttributeChanged2(e3) {
        var object = e3.target;
        var attrName = e3.attrName, prevValue = e3.prevValue, newValue = e3.newValue;
        if (object.nodeName !== Shape.IMAGE || attrName !== "src") {
          return;
        }
        if (prevValue !== newValue) {
          imagePool.releaseImage(prevValue, object);
        }
        if (isString(newValue)) {
          imagePool.getOrCreateImage(newValue, object).then(function(_ref2) {
            var _ref2$img = _ref2.img, width = _ref2$img.width, height = _ref2$img.height;
            if (object.attributes.keepAspectRatio) {
              calculateWithAspectRatio(object, width, height);
            }
            object.renderable.dirty = true;
            renderingService.dirtify();
          })["catch"](function() {
          });
        }
      };
      renderingService.hooks.init.tap(LoadImagePlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
      renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
    }
  }]);
}();
LoadImagePlugin.tag = "LoadImage";
var Plugin3 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "image-loader";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init(runtime2) {
      this.context.imagePool = new ImagePool(this.context, runtime2);
      this.addRenderingPlugin(new LoadImagePlugin());
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
var _renderState = _classPrivateFieldKey("renderState");
var CanvasRendererPlugin = function() {
  function CanvasRendererPlugin2(canvasRendererPluginOptions) {
    _classCallCheck(this, CanvasRendererPlugin2);
    this.removedRBushNodeAABBs = [];
    this.renderQueue = [];
    Object.defineProperty(this, _renderState, {
      writable: true,
      value: {
        restoreStack: [],
        prevObject: null,
        currentContext: /* @__PURE__ */ new Map()
      }
    });
    this.clearFullScreenLastFrame = false;
    this.clearFullScreen = false;
    this.vpMatrix = mat4_exports.create();
    this.dprMatrix = mat4_exports.create();
    this.tmpMat4 = mat4_exports.create();
    this.vec3a = vec3_exports.create();
    this.vec3b = vec3_exports.create();
    this.vec3c = vec3_exports.create();
    this.vec3d = vec3_exports.create();
    this.canvasRendererPluginOptions = canvasRendererPluginOptions;
  }
  return _createClass(CanvasRendererPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      this.context = context;
      var _this$context = this.context, config = _this$context.config, camera = _this$context.camera, renderingService = _this$context.renderingService, renderingContext = _this$context.renderingContext, rBushRoot = _this$context.rBushRoot, pathGeneratorFactory = _this$context.pathGeneratorFactory;
      var enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
      config.renderer.getConfig().enableDirtyCheck = false;
      config.renderer.getConfig().enableDirtyRectangleRendering = false;
      this.rBush = rBushRoot;
      this.pathGeneratorFactory = pathGeneratorFactory;
      var contextService = context.contextService;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var handleUnmounted = function handleUnmounted2(e3) {
        var object = e3.target;
        var rBushNode = object.rBushNode;
        if (rBushNode !== null && rBushNode !== void 0 && rBushNode.aabb) {
          _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      var handleCulled = function handleCulled2(e3) {
        var object = e3.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      renderingService.hooks.init.tap(CanvasRendererPlugin2.tag, function() {
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.CULLED, handleCulled);
        var dpr = contextService.getDPR();
        var width = config.width, height = config.height;
        var context2 = contextService.getContext();
        _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
      });
      renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
        _this2.renderQueue = [];
        _this2.removedRBushNodeAABBs = [];
        _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
          restoreStack: [],
          prevObject: null,
          currentContext: null
        };
      });
      var beforeDraw = function beforeDraw2() {
        var _canvas$context$rende;
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        var width = config.width, height = config.height;
        var _this$canvasRendererP = _this2.canvasRendererPluginOptions, dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
        var _renderingService$get = renderingService.getStats(), total = _renderingService$get.total, rendered = _renderingService$get.rendered;
        var ratio = rendered / total;
        _this2.clearFullScreen = _this2.clearFullScreenLastFrame || // @ts-ignore
        !((_canvas$context$rende = canvas.context.renderingPlugins[1]) !== null && _canvas$context$rende !== void 0 && _canvas$context$rende.isFirstTimeRenderingFinished) || renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
        if (!context2) {
          return;
        }
        if (typeof context2.resetTransform === "function") {
          context2.resetTransform();
        } else {
          context2.setTransform(1, 0, 0, 1, 0, 0);
        }
        if (_this2.clearFullScreen) {
          _this2.clearRect(context2, 0, 0, width * dpr, height * dpr, config.background);
        }
      };
      var renderByZIndex = function renderByZIndex2(object, context2) {
        var stack = [object];
        while (stack.length > 0) {
          var _currentObject$sortab;
          var currentObject = stack.pop();
          if (currentObject.isVisible() && !currentObject.isCulled()) {
            if (enableRenderingOptimization) {
              _this2.renderDisplayObjectOptimized(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            } else {
              _this2.renderDisplayObject(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            }
          }
          var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
          for (var i2 = objects.length - 1; i2 >= 0; i2--) {
            stack.push(objects[i2]);
          }
        }
      };
      renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
        beforeDraw();
        if (renderingContext.root.childNodes.length === 0) {
          _this2.clearFullScreenLastFrame = true;
          return;
        }
        enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
        _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
          restoreStack: [],
          prevObject: null,
          currentContext: _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext
        };
        _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext.clear();
        _this2.clearFullScreenLastFrame = false;
        var context2 = contextService.getContext();
        var dpr = contextService.getDPR();
        mat4_exports.fromScaling(_this2.dprMatrix, [dpr, dpr, 1]);
        mat4_exports.multiply(_this2.vpMatrix, _this2.dprMatrix, camera.getOrthoMatrix());
        if (_this2.clearFullScreen) {
          if (enableRenderingOptimization) {
            context2.save();
            renderByZIndex(renderingContext.root, context2);
            context2.restore();
          } else {
            renderByZIndex(renderingContext.root, context2);
          }
          _this2.removedRBushNodeAABBs = [];
        } else {
          var dirtyRenderBounds = _this2.safeMergeAABB.apply(_this2, [_this2.mergeDirtyAABBs(_this2.renderQueue)].concat(_toConsumableArray(_this2.removedRBushNodeAABBs.map(function(_ref) {
            var minX = _ref.minX, minY = _ref.minY, maxX = _ref.maxX, maxY2 = _ref.maxY;
            var aabb = new AABB();
            aabb.setMinMax(
              // vec3.fromValues(minX, minY, 0),
              // vec3.fromValues(maxX, maxY, 0),
              [minX, minY, 0],
              [maxX, maxY2, 0]
            );
            return aabb;
          }))));
          _this2.removedRBushNodeAABBs = [];
          if (AABB.isEmpty(dirtyRenderBounds)) {
            _this2.renderQueue = [];
            return;
          }
          var dirtyRect = _this2.convertAABB2Rect(dirtyRenderBounds);
          var x3 = dirtyRect.x, y4 = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
          var tl = vec3_exports.transformMat4(_this2.vec3a, [x3, y4, 0], _this2.vpMatrix);
          var tr = vec3_exports.transformMat4(_this2.vec3b, [x3 + width, y4, 0], _this2.vpMatrix);
          var bl = vec3_exports.transformMat4(_this2.vec3c, [x3, y4 + height, 0], _this2.vpMatrix);
          var br = vec3_exports.transformMat4(_this2.vec3d, [x3 + width, y4 + height, 0], _this2.vpMatrix);
          var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
          var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
          var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
          var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
          var ix = Math.floor(minx);
          var iy = Math.floor(miny);
          var iwidth = Math.ceil(maxx - minx);
          var iheight = Math.ceil(maxy - miny);
          context2.save();
          _this2.clearRect(context2, ix, iy, iwidth, iheight, config.background);
          context2.beginPath();
          context2.rect(ix, iy, iwidth, iheight);
          context2.clip();
          context2.setTransform(_this2.vpMatrix[0], _this2.vpMatrix[1], _this2.vpMatrix[4], _this2.vpMatrix[5], _this2.vpMatrix[12], _this2.vpMatrix[13]);
          var _config$renderer$getC = config.renderer.getConfig(), enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
          if (enableDirtyRectangleRenderingDebug) {
            canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
              dirtyRect: {
                x: ix,
                y: iy,
                width: iwidth,
                height: iheight
              }
            }));
          }
          var dirtyObjects = _this2.searchDirtyObjects(dirtyRenderBounds);
          dirtyObjects.sort(function(a5, b) {
            return a5.sortable.renderOrder - b.sortable.renderOrder;
          }).forEach(function(object) {
            if (object && object.isVisible() && !object.isCulled()) {
              _this2.renderDisplayObject(object, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
            }
          });
          context2.restore();
          _this2.renderQueue.forEach(function(object) {
            _this2.saveDirtyAABB(object);
          });
          _this2.renderQueue = [];
        }
        _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack.forEach(function() {
          context2.restore();
        });
        _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack = [];
      });
      renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
        if (!_this2.clearFullScreen) {
          _this2.renderQueue.push(object);
        }
      });
    }
  }, {
    key: "clearRect",
    value: function clearRect(context, x3, y4, width, height, background) {
      context.clearRect(x3, y4, width, height);
      if (background) {
        context.fillStyle = background;
        context.fillRect(x3, y4, width, height);
      }
    }
  }, {
    key: "renderDisplayObjectOptimized",
    value: function renderDisplayObjectOptimized(object, context, canvasContext, renderState, runtime2) {
      var nodeName = object.nodeName;
      var updateTransform = false;
      var clipDraw = false;
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        updateTransform = !renderState.prevObject || !mat4_exports.exactEquals(clipPath.getWorldTransform(), renderState.prevObject.getWorldTransform());
        if (updateTransform) {
          this.applyWorldTransform(context, clipPath);
          renderState.prevObject = null;
        }
        var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath) {
          context.save();
          clipDraw = true;
          context.beginPath();
          _generatePath(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        updateTransform = !renderState.prevObject || !mat4_exports.exactEquals(object.getWorldTransform(), renderState.prevObject.getWorldTransform());
        if (updateTransform) {
          this.applyWorldTransform(context, object);
        }
        var forceUpdateStyle = !renderState.prevObject;
        if (!forceUpdateStyle) {
          var prevNodeName = renderState.prevObject.nodeName;
          if (nodeName === Shape.TEXT) {
            forceUpdateStyle = prevNodeName !== Shape.TEXT;
          } else if (nodeName === Shape.IMAGE) {
            forceUpdateStyle = prevNodeName !== Shape.IMAGE;
          } else {
            forceUpdateStyle = prevNodeName === Shape.TEXT || prevNodeName === Shape.IMAGE;
          }
        }
        styleRenderer.applyStyleToContext(context, object, forceUpdateStyle, renderState);
        renderState.prevObject = object;
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.drawToContext(context, object, _classPrivateFieldBase(this, _renderState)[_renderState], this, runtime2);
      }
      if (clipDraw) {
        context.restore();
      }
      object.dirty(false);
    }
  }, {
    key: "renderDisplayObject",
    value: function renderDisplayObject(object, context, canvasContext, renderState, runtime2) {
      var nodeName = object.nodeName;
      var parent = renderState.restoreStack[renderState.restoreStack.length - 1];
      if (parent && !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {
        context.restore();
        renderState.restoreStack.pop();
      }
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath2 = this.pathGeneratorFactory[nodeName];
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        this.applyWorldTransform(context, clipPath);
        var _generatePath2 = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath2) {
          context.save();
          renderState.restoreStack.push(object);
          context.beginPath();
          _generatePath2(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      if (styleRenderer) {
        this.applyWorldTransform(context, object);
        context.save();
        this.applyAttributesToContext(context, object);
      }
      if (generatePath2) {
        context.beginPath();
        generatePath2(context, object.parsedStyle);
        if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      if (styleRenderer) {
        styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
        context.restore();
      }
      object.dirty(false);
    }
  }, {
    key: "applyAttributesToContext",
    value: function applyAttributesToContext(context, object) {
      var _ref2 = object.parsedStyle, stroke2 = _ref2.stroke, fill = _ref2.fill, opacity = _ref2.opacity, lineDash = _ref2.lineDash, lineDashOffset = _ref2.lineDashOffset;
      if (lineDash) {
        context.setLineDash(lineDash);
      }
      if (!isNil(lineDashOffset)) {
        context.lineDashOffset = lineDashOffset;
      }
      if (!isNil(opacity)) {
        context.globalAlpha *= opacity;
      }
      if (!isNil(stroke2) && !Array.isArray(stroke2) && !stroke2.isNone) {
        context.strokeStyle = object.attributes.stroke;
      }
      if (!isNil(fill) && !Array.isArray(fill) && !fill.isNone) {
        context.fillStyle = object.attributes.fill;
      }
    }
  }, {
    key: "convertAABB2Rect",
    value: function convertAABB2Rect(aabb) {
      var min10 = aabb.getMin();
      var max11 = aabb.getMax();
      var minX = Math.floor(min10[0]);
      var minY = Math.floor(min10[1]);
      var maxX = Math.ceil(max11[0]);
      var maxY2 = Math.ceil(max11[1]);
      var width = maxX - minX;
      var height = maxY2 - minY;
      return {
        x: minX,
        y: minY,
        width,
        height
      };
    }
    /**
     * TODO: merge dirty rectangles with some strategies.
     * For now, we just simply merge all the rectangles into one.
     * @see https://idom.me/articles/841.html
     */
  }, {
    key: "mergeDirtyAABBs",
    value: function mergeDirtyAABBs(dirtyObjects) {
      var aabb = new AABB();
      dirtyObjects.forEach(function(object) {
        var renderBounds = object.getRenderBounds();
        aabb.add(renderBounds);
        var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
        if (dirtyRenderBounds) {
          aabb.add(dirtyRenderBounds);
        }
      });
      return aabb;
    }
  }, {
    key: "searchDirtyObjects",
    value: function searchDirtyObjects(dirtyRectangle) {
      var _dirtyRectangle$getMi = dirtyRectangle.getMin(), _dirtyRectangle$getMi2 = _slicedToArray(_dirtyRectangle$getMi, 2), minX = _dirtyRectangle$getMi2[0], minY = _dirtyRectangle$getMi2[1];
      var _dirtyRectangle$getMa = dirtyRectangle.getMax(), _dirtyRectangle$getMa2 = _slicedToArray(_dirtyRectangle$getMa, 2), maxX = _dirtyRectangle$getMa2[0], maxY2 = _dirtyRectangle$getMa2[1];
      var rBushNodes = this.rBush.search({
        minX,
        minY,
        maxX,
        maxY: maxY2
      });
      return rBushNodes.map(function(_ref3) {
        var displayObject = _ref3.displayObject;
        return displayObject;
      });
    }
  }, {
    key: "saveDirtyAABB",
    value: function saveDirtyAABB(object) {
      var renderable = object.renderable;
      if (!renderable.dirtyRenderBounds) {
        renderable.dirtyRenderBounds = new AABB();
      }
      var renderBounds = object.getRenderBounds();
      if (renderBounds) {
        renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
      }
    }
  }, {
    key: "applyWorldTransform",
    value: function applyWorldTransform(context, object, matrix3) {
      if (matrix3) {
        mat4_exports.copy(this.tmpMat4, object.getLocalTransform());
        mat4_exports.multiply(this.tmpMat4, matrix3, this.tmpMat4);
        mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      } else {
        mat4_exports.copy(this.tmpMat4, object.getWorldTransform());
        mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      }
      context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
    }
  }, {
    key: "safeMergeAABB",
    value: function safeMergeAABB() {
      var merged = new AABB();
      for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
        aabbs[_key] = arguments[_key];
      }
      aabbs.forEach(function(aabb) {
        merged.add(aabb);
      });
      return merged;
    }
  }]);
}();
CanvasRendererPlugin.tag = "CanvasRenderer";
function getPattern(pattern, object, context, canvasContext, plugin, runtime2, imagePool) {
  var $offscreenCanvas;
  var dpr;
  if (pattern.image.nodeName === "rect") {
    var _parsedStyle = pattern.image.parsedStyle, width = _parsedStyle.width, height = _parsedStyle.height;
    dpr = canvasContext.contextService.getDPR();
    var offscreenCanvas = canvasContext.config.offscreenCanvas;
    $offscreenCanvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
    $offscreenCanvas.width = width * dpr;
    $offscreenCanvas.height = height * dpr;
    var offscreenCanvasContext = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
    var renderState = {
      restoreStack: [],
      prevObject: null,
      currentContext: /* @__PURE__ */ new Map()
    };
    pattern.image.forEach(function(object2) {
      plugin.renderDisplayObject(object2, offscreenCanvasContext, canvasContext, renderState, runtime2);
    });
    renderState.restoreStack.forEach(function() {
      offscreenCanvasContext.restore();
    });
  }
  var canvasPattern = imagePool.getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, object.getGeometryBounds().min, function() {
    object.dirty();
    canvasContext.renderingService.dirtify();
  });
  return canvasPattern;
}
function getColor2(parsedColor, object, context, imagePool) {
  var color3;
  if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
    var bounds = object.getGeometryBounds();
    var width = bounds && bounds.halfExtents[0] * 2 || 1;
    var height = bounds && bounds.halfExtents[1] * 2 || 1;
    var min10 = bounds && bounds.min || [0, 0];
    color3 = imagePool.getOrCreateGradient(_objectSpread2(_objectSpread2({
      type: parsedColor.type
    }, parsedColor.value), {}, {
      min: min10,
      width,
      height
    }), context);
  }
  return color3;
}
var SHADOW_NUMBER_STYLE = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_STYLE = ["lineCap", "lineJoin", "miterLimit"];
var DEFAULT_STYLE = {
  // common
  globalAlpha: 1,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  filter: "none",
  globalCompositeOperation: "source-over",
  // stroke/fill
  strokeStyle: "#000",
  strokeOpacity: 1,
  lineWidth: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  fillStyle: "#000",
  fillOpacity: 1
  // image
};
var defaultParsedStyle = {};
function updateContextIfNotHitCache(context, key, value2, cache2) {
  var prevValue = cache2.has(key) ? cache2.get(key) : DEFAULT_STYLE[key];
  if (prevValue !== value2) {
    if (key === "lineDash") {
      context.setLineDash(value2);
    } else {
      context[key] = value2;
    }
    cache2.set(key, value2);
  }
  return prevValue;
}
var OptimizedDefaultRenderer = function() {
  function OptimizedDefaultRenderer2(imagePool) {
    _classCallCheck(this, OptimizedDefaultRenderer2);
    this.imagePool = imagePool;
  }
  return _createClass(OptimizedDefaultRenderer2, [{
    key: "applyAttributesToContext",
    value: function applyAttributesToContext(context, object) {
    }
  }, {
    key: "render",
    value: function render3(context, parsedStyle, object, canvasContext, plugin, runtime2) {
    }
    // #region common style
  }, {
    key: "applyCommonStyleToContext",
    value: function applyCommonStyleToContext(context, object, forceUpdate, renderState) {
      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
      var style = object.parsedStyle;
      if (forceUpdate || style.opacity !== prevStyle.opacity) {
        updateContextIfNotHitCache(context, "globalAlpha", !isNil(style.opacity) ? style.opacity : DEFAULT_STYLE.globalAlpha, renderState.currentContext);
      }
      if (forceUpdate || style.blend !== prevStyle.blend) {
        updateContextIfNotHitCache(
          context,
          "globalCompositeOperation",
          // @ts-ignore
          !isNil(style.blend) ? (
            // @ts-ignore
            style.blend
          ) : DEFAULT_STYLE.globalCompositeOperation,
          renderState.currentContext
        );
      }
    }
    // #endregion common style
    // #region stroke/fill style
  }, {
    key: "applyStrokeFillStyleToContext",
    value: function applyStrokeFillStyleToContext(context, object, forceUpdate, renderState) {
      var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
      var style = object.parsedStyle;
      var _style$lineWidth = style.lineWidth, lineWidth = _style$lineWidth === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth;
      var hasFill = style.fill && !style.fill.isNone;
      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
      if (hasStroke) {
        if (forceUpdate || object.attributes.stroke !== renderState.prevObject.attributes.stroke) {
          var value2 = !isNil(style.stroke) && !Array.isArray(style.stroke) && !style.stroke.isNone ? object.attributes.stroke : DEFAULT_STYLE.strokeStyle;
          updateContextIfNotHitCache(context, "strokeStyle", value2, renderState.currentContext);
        }
        if (forceUpdate || style.lineWidth !== prevStyle.lineWidth) {
          updateContextIfNotHitCache(context, "lineWidth", !isNil(style.lineWidth) ? style.lineWidth : DEFAULT_STYLE.lineWidth, renderState.currentContext);
        }
        if (forceUpdate || style.lineDash !== prevStyle.lineDash) {
          updateContextIfNotHitCache(context, "lineDash", style.lineDash || DEFAULT_STYLE.lineDash, renderState.currentContext);
        }
        if (forceUpdate || style.lineDashOffset !== prevStyle.lineDashOffset) {
          updateContextIfNotHitCache(context, "lineDashOffset", !isNil(style.lineDashOffset) ? style.lineDashOffset : DEFAULT_STYLE.lineDashOffset, renderState.currentContext);
        }
        for (var i2 = 0; i2 < STROKE_STYLE.length; i2++) {
          var styleName = STROKE_STYLE[i2];
          if (forceUpdate || style[styleName] !== prevStyle[styleName]) {
            updateContextIfNotHitCache(context, styleName, !isNil(style[styleName]) ? style[styleName] : DEFAULT_STYLE[styleName], renderState.currentContext);
          }
        }
      }
      if (hasFill && (forceUpdate || object.attributes.fill !== renderState.prevObject.attributes.fill)) {
        var _value = !isNil(style.fill) && !Array.isArray(style.fill) && !style.fill.isNone ? object.attributes.fill : DEFAULT_STYLE.fillStyle;
        updateContextIfNotHitCache(context, "fillStyle", _value, renderState.currentContext);
      }
    }
    // #endregion stroke/fill style
  }, {
    key: "applyStyleToContext",
    value: function applyStyleToContext(context, object, forceUpdate, renderState) {
      var nodeName = object.nodeName;
      this.applyCommonStyleToContext(context, object, forceUpdate, renderState);
      if (nodeName === Shape.IMAGE) ;
      else {
        this.applyStrokeFillStyleToContext(context, object, forceUpdate, renderState);
      }
    }
  }, {
    key: "applyShadowAndFilterStyleToContext",
    value: function applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState) {
      var style = object.parsedStyle;
      if (hasShadow) {
        updateContextIfNotHitCache(context, "shadowColor", style.shadowColor.toString(), renderState.currentContext);
        for (var i2 = 0; i2 < SHADOW_NUMBER_STYLE.length; i2++) {
          var styleName = SHADOW_NUMBER_STYLE[i2];
          updateContextIfNotHitCache(context, styleName, style[styleName] || DEFAULT_STYLE[styleName], renderState.currentContext);
        }
      }
      if (style.filter && style.filter.length) {
        updateContextIfNotHitCache(
          context,
          "filter",
          // use raw filter string
          object.attributes.filter,
          renderState.currentContext
        );
      }
    }
  }, {
    key: "clearShadowAndFilterStyleForContext",
    value: function clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState) {
      var onlyClearShadowFilter = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      if (hasShadow) {
        updateContextIfNotHitCache(context, "shadowColor", DEFAULT_STYLE.shadowColor, renderState.currentContext);
        for (var i2 = 0; i2 < SHADOW_NUMBER_STYLE.length; i2++) {
          var styleName = SHADOW_NUMBER_STYLE[i2];
          updateContextIfNotHitCache(context, styleName, DEFAULT_STYLE[styleName], renderState.currentContext);
        }
      }
      if (hasFilter) {
        if (hasShadow && onlyClearShadowFilter) {
          var oldFilter = context.filter;
          if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
            updateContextIfNotHitCache(context, "filter", oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || DEFAULT_STYLE.filter, renderState.currentContext);
          }
        } else {
          updateContextIfNotHitCache(context, "filter", DEFAULT_STYLE.filter, renderState.currentContext);
        }
      }
    }
  }, {
    key: "fillToContext",
    value: function fillToContext(context, object, renderState, plugin, runtime2) {
      var _this2 = this;
      var _object$parsedStyle = object.parsedStyle, fill = _object$parsedStyle.fill, fillRule = _object$parsedStyle.fillRule;
      var resetStyle = null;
      if (Array.isArray(fill) && fill.length > 0) {
        fill.forEach(function(gradient2) {
          var prevStyle = updateContextIfNotHitCache(context, "fillStyle", getColor2(gradient2, object, context, _this2.imagePool), renderState.currentContext);
          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
          if (fillRule) {
            context.fill(fillRule);
          } else {
            context.fill();
          }
        });
      } else {
        if (isPattern(fill)) {
          var pattern = getPattern(fill, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
          if (pattern) {
            context.fillStyle = pattern;
            resetStyle = true;
          }
        }
        if (fillRule) {
          context.fill(fillRule);
        } else {
          context.fill();
        }
      }
      if (resetStyle !== null) {
        updateContextIfNotHitCache(context, "fillStyle", resetStyle, renderState.currentContext);
      }
    }
  }, {
    key: "strokeToContext",
    value: function strokeToContext(context, object, renderState, plugin, runtime2) {
      var _this2 = this;
      var stroke2 = object.parsedStyle.stroke;
      var resetStyle = null;
      if (Array.isArray(stroke2) && stroke2.length > 0) {
        stroke2.forEach(function(gradient2) {
          var prevStyle2 = updateContextIfNotHitCache(context, "strokeStyle", getColor2(gradient2, object, context, _this2.imagePool), renderState.currentContext);
          resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle2;
          context.stroke();
        });
      } else {
        if (isPattern(stroke2)) {
          var pattern = getPattern(stroke2, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
          if (pattern) {
            var prevStyle = updateContextIfNotHitCache(context, "strokeStyle", pattern, renderState.currentContext);
            resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
          }
        }
        context.stroke();
      }
      if (resetStyle !== null) {
        updateContextIfNotHitCache(context, "strokeStyle", resetStyle, renderState.currentContext);
      }
    }
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      var _style$fill;
      var nodeName = object.nodeName;
      var style = object.parsedStyle;
      var _style$opacity = style.opacity, opacity = _style$opacity === void 0 ? DEFAULT_STYLE.globalAlpha : _style$opacity, _style$fillOpacity = style.fillOpacity, fillOpacity = _style$fillOpacity === void 0 ? DEFAULT_STYLE.fillOpacity : _style$fillOpacity, _style$strokeOpacity = style.strokeOpacity, strokeOpacity = _style$strokeOpacity === void 0 ? DEFAULT_STYLE.strokeOpacity : _style$strokeOpacity, _style$lineWidth2 = style.lineWidth, lineWidth = _style$lineWidth2 === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth2;
      var hasFill = style.fill && !style.fill.isNone;
      var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
      if (!hasFill && !hasStroke) {
        return;
      }
      var hasShadow = !isNil(style.shadowColor) && style.shadowBlur > 0;
      var isInnerShadow = style.shadowType === "inner";
      var isFillTransparent = ((_style$fill = style.fill) === null || _style$fill === void 0 ? void 0 : _style$fill.alpha) === 0;
      var hasFilter = !!(style.filter && style.filter.length);
      var shouldDrawShadowWithStroke = hasShadow && hasStroke && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      var originGlobalAlpha = null;
      if (hasFill) {
        if (!shouldDrawShadowWithStroke) {
          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
        }
        var updateOpacity = opacity * fillOpacity;
        originGlobalAlpha = updateContextIfNotHitCache(context, "globalAlpha", updateOpacity, renderState.currentContext);
        this.fillToContext(context, object, renderState, plugin, runtime2);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
        }
      }
      if (hasStroke) {
        var clearShadowAndFilter = false;
        var _updateOpacity = opacity * strokeOpacity;
        var prevOpacity = updateContextIfNotHitCache(context, "globalAlpha", _updateOpacity, renderState.currentContext);
        originGlobalAlpha = hasFill ? originGlobalAlpha : prevOpacity;
        if (shouldDrawShadowWithStroke) {
          this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
          clearShadowAndFilter = true;
          if (isInnerShadow) {
            var originBlend = context.globalCompositeOperation;
            context.globalCompositeOperation = "source-atop";
            this.strokeToContext(context, object, renderState, plugin, runtime2);
            context.globalCompositeOperation = originBlend;
            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState, true);
          }
        }
        this.strokeToContext(context, object, renderState, plugin, runtime2);
        if (clearShadowAndFilter) {
          this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
        }
      }
      if (originGlobalAlpha !== null) {
        updateContextIfNotHitCache(context, "globalAlpha", originGlobalAlpha, renderState.currentContext);
      }
    }
  }]);
}();
var DefaultRenderer = function(_OptimizedDefaultRend) {
  function DefaultRenderer2() {
    _classCallCheck(this, DefaultRenderer2);
    return _callSuper(this, DefaultRenderer2, arguments);
  }
  _inherits(DefaultRenderer2, _OptimizedDefaultRend);
  return _createClass(DefaultRenderer2, [{
    key: "render",
    value: function render3(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, stroke2 = parsedStyle.stroke, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter3 = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
      var hasFill = fill && !fill.isNone;
      var hasStroke = stroke2 && !stroke2.isNone && lineWidth > 0;
      var isFillTransparent = (fill === null || fill === void 0 ? void 0 : fill.alpha) === 0;
      var hasFilter = !!(filter3 && filter3.length);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      var nodeName = object.nodeName;
      var isInnerShadow = shadowType === "inner";
      var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      if (hasFill) {
        context.globalAlpha = opacity * fillOpacity;
        if (!shouldDrawShadowWithStroke) {
          setShadowAndFilter(object, context, hasShadow);
        }
        applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilter(context, hasFilter, hasShadow);
        }
      }
      if (hasStroke) {
        context.globalAlpha = opacity * strokeOpacity;
        context.lineWidth = lineWidth;
        if (!isNil(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        if (!isNil(lineCap)) {
          context.lineCap = lineCap;
        }
        if (!isNil(lineJoin)) {
          context.lineJoin = lineJoin;
        }
        if (shouldDrawShadowWithStroke) {
          if (isInnerShadow) {
            context.globalCompositeOperation = "source-atop";
          }
          setShadowAndFilter(object, context, true);
          if (isInnerShadow) {
            applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool);
            context.globalCompositeOperation = DEFAULT_STYLE.globalCompositeOperation;
            this.clearShadowAndFilter(context, hasFilter, true);
          }
        }
        applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool);
      }
    }
  }, {
    key: "clearShadowAndFilter",
    value: function clearShadowAndFilter(context, hasFilter, hasShadow) {
      if (hasShadow) {
        context.shadowColor = "transparent";
        context.shadowBlur = 0;
      }
      if (hasFilter) {
        var oldFilter = context.filter;
        if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
          context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
        }
      }
    }
  }]);
}(OptimizedDefaultRenderer);
function setShadowAndFilter(object, context, hasShadow) {
  var _object$parsedStyle = object.parsedStyle, filter3 = _object$parsedStyle.filter, shadowColor = _object$parsedStyle.shadowColor, shadowBlur = _object$parsedStyle.shadowBlur, shadowOffsetX = _object$parsedStyle.shadowOffsetX, shadowOffsetY = _object$parsedStyle.shadowOffsetY;
  if (filter3 && filter3.length) {
    context.filter = object.style.filter;
  }
  if (hasShadow) {
    context.shadowColor = shadowColor.toString();
    context.shadowBlur = shadowBlur || 0;
    context.shadowOffsetX = shadowOffsetX || 0;
    context.shadowOffsetY = shadowOffsetY || 0;
  }
}
function applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, imagePool) {
  var skipFill = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
  if (Array.isArray(fill)) {
    fill.forEach(function(gradient2) {
      context.fillStyle = getColor2(gradient2, object, context, imagePool);
      if (!skipFill) {
        fillRule ? context.fill(fillRule) : context.fill();
      }
    });
  } else {
    if (isPattern(fill)) {
      context.fillStyle = getPattern(fill, object, context, canvasContext, plugin, runtime2, imagePool);
    }
    if (!skipFill) {
      fillRule ? context.fill(fillRule) : context.fill();
    }
  }
}
function applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, imagePool) {
  var skipStroke = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
  if (Array.isArray(stroke2)) {
    stroke2.forEach(function(gradient2) {
      context.strokeStyle = getColor2(gradient2, object, context, imagePool);
      if (!skipStroke) {
        context.stroke();
      }
    });
  } else {
    if (isPattern(stroke2)) {
      context.strokeStyle = getPattern(stroke2, object, context, canvasContext, plugin, runtime2, imagePool);
    }
    if (!skipStroke) {
      context.stroke();
    }
  }
}
function calculateOverlapRect(rect1, rect22) {
  var _rect = _slicedToArray(rect1, 4), x12 = _rect[0], y12 = _rect[1], w1 = _rect[2], h1 = _rect[3];
  var _rect2 = _slicedToArray(rect22, 4), x22 = _rect2[0], y22 = _rect2[1], w2 = _rect2[2], h2 = _rect2[3];
  var overlapLeft = Math.max(x12, x22);
  var overlapTop = Math.max(y12, y22);
  var overlapRight = Math.min(x12 + w1, x22 + w2);
  var overlapBottom = Math.min(y12 + h1, y22 + h2);
  if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) {
    return null;
  }
  return [overlapLeft, overlapTop, overlapRight - overlapLeft, overlapBottom - overlapTop];
}
function transformRect(rect4, matrix3) {
  var tl = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0], rect4[1], 0], matrix3);
  var tr = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0] + rect4[2], rect4[1], 0], matrix3);
  var bl = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0], rect4[1] + rect4[3], 0], matrix3);
  var br = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0] + rect4[2], rect4[1] + rect4[3], 0], matrix3);
  return [Math.min(tl[0], tr[0], bl[0], br[0]), Math.min(tl[1], tr[1], bl[1], br[1]), Math.max(tl[0], tr[0], bl[0], br[0]) - Math.min(tl[0], tr[0], bl[0], br[0]), Math.max(tl[1], tr[1], bl[1], br[1]) - Math.min(tl[1], tr[1], bl[1], br[1])];
}
var ImageRenderer = function(_DefaultRenderer) {
  function ImageRenderer2() {
    _classCallCheck(this, ImageRenderer2);
    return _callSuper(this, ImageRenderer2, arguments);
  }
  _inherits(ImageRenderer2, _DefaultRenderer);
  return _createClass(ImageRenderer2, [{
    key: "renderDownSampled",
    value: function renderDownSampled(context, parsedStyle, object, data2) {
      var src = data2.src, imageCache = data2.imageCache;
      if (!imageCache.downSampled) {
        this.imagePool.createDownSampledImage(src, object).then(function() {
          if (!object.ownerDocument) {
            return;
          }
          object.dirty();
          object.ownerDocument.defaultView.context.renderingService.dirtify();
        })["catch"](function(reason) {
          console.error(reason);
        });
        return;
      }
      context.drawImage(imageCache.downSampled, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
    }
  }, {
    key: "renderTile",
    value: function renderTile(context, parsedStyle, object, data2) {
      var src = data2.src, imageCache = data2.imageCache, imageRect = data2.imageRect, drawRect = data2.drawRect;
      var originalSize = imageCache.size;
      var _context$getTransform = context.getTransform(), a5 = _context$getTransform.a, b = _context$getTransform.b, c6 = _context$getTransform.c, d4 = _context$getTransform.d, e3 = _context$getTransform.e, f2 = _context$getTransform.f;
      context.resetTransform();
      if (!(imageCache !== null && imageCache !== void 0 && imageCache.gridSize)) {
        this.imagePool.createImageTiles(src, [], function() {
          if (!object.ownerDocument) {
            return;
          }
          object.dirty();
          object.ownerDocument.defaultView.context.renderingService.dirtify();
        }, object)["catch"](function(reason) {
          console.error(reason);
        });
        return;
      }
      var scaleToOrigin = [originalSize[0] / imageRect[2], originalSize[1] / imageRect[3]];
      var scaledTileSize = [imageCache.tileSize[0] / scaleToOrigin[0], imageCache.tileSize[1] / scaleToOrigin[1]];
      var _ref = [Math.floor((drawRect[0] - imageRect[0]) / scaledTileSize[0]), Math.ceil((drawRect[0] + drawRect[2] - imageRect[0]) / scaledTileSize[0])], startTileX = _ref[0], endTileX = _ref[1];
      var _ref2 = [Math.floor((drawRect[1] - imageRect[1]) / scaledTileSize[1]), Math.ceil((drawRect[1] + drawRect[3] - imageRect[1]) / scaledTileSize[1])], startTileY = _ref2[0], endTileY = _ref2[1];
      for (var tileY = startTileY; tileY <= endTileY; tileY++) {
        for (var tileX = startTileX; tileX <= endTileX; tileX++) {
          var item = imageCache.tiles[tileY][tileX];
          if (item) {
            var tileRect = [Math.floor(imageRect[0] + item.tileX * scaledTileSize[0]), Math.floor(imageRect[1] + item.tileY * scaledTileSize[1]), Math.ceil(scaledTileSize[0]), Math.ceil(scaledTileSize[1])];
            context.drawImage(item.data, tileRect[0], tileRect[1], tileRect[2], tileRect[3]);
          }
        }
      }
      context.setTransform(a5, b, c6, d4, e3, f2);
    }
  }, {
    key: "render",
    value: function render3(context, parsedStyle, object) {
      var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y4 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, width = parsedStyle.width, height = parsedStyle.height, src = parsedStyle.src, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
      var imageCache = this.imagePool.getImageSync(src, object);
      var image = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
      var iw = width;
      var ih = height;
      if (!image) {
        return;
      }
      iw || (iw = image.width);
      ih || (ih = image.height);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      try {
        var _object$ownerDocument = object.ownerDocument.defaultView.getContextService().getDomElement(), viewWidth = _object$ownerDocument.width, viewHeight = _object$ownerDocument.height;
        var currentTransform = context.getTransform();
        var a5 = currentTransform.a, b = currentTransform.b, c6 = currentTransform.c, d4 = currentTransform.d, e3 = currentTransform.e, f2 = currentTransform.f;
        var transformMatrix = mat4_exports.fromValues(a5, c6, 0, 0, b, d4, 0, 0, 0, 0, 1, 0, e3, f2, 0, 1);
        var imageRect = transformRect([x3, y4, iw, ih], transformMatrix);
        var drawRect = calculateOverlapRect([0, 0, viewWidth, viewHeight], imageRect);
        if (!drawRect) {
          return;
        }
        if (!object.ownerDocument.defaultView.getConfig().enableLargeImageOptimization) {
          ImageRenderer2.renderFull(context, parsedStyle, object, {
            image,
            drawRect: [x3, y4, iw, ih]
          });
          return;
        }
        var sizeOfOrigin = imageRect[2] / imageCache.size[0];
        if (sizeOfOrigin < (imageCache.downSamplingRate || 0.5)) {
          this.renderDownSampled(context, parsedStyle, object, {
            src,
            imageCache,
            drawRect: [x3, y4, iw, ih]
          });
          return;
        }
        if (!ImagePool.isSupportTile) {
          ImageRenderer2.renderFull(context, parsedStyle, object, {
            image,
            drawRect: [x3, y4, iw, ih]
          });
          return;
        }
        this.renderTile(context, parsedStyle, object, {
          src,
          imageCache,
          imageRect,
          drawRect
        });
      } catch (_unused) {
      }
    }
    // ---
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      this.render(context, object.parsedStyle, object);
    }
  }], [{
    key: "renderFull",
    value: function renderFull(context, parsedStyle, object, data2) {
      context.drawImage(data2.image, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
    }
  }]);
}(DefaultRenderer);
var TextRenderer = function(_DefaultRenderer) {
  function TextRenderer2() {
    _classCallCheck(this, TextRenderer2);
    return _callSuper(this, TextRenderer2, arguments);
  }
  _inherits(TextRenderer2, _DefaultRenderer);
  return _createClass(TextRenderer2, [{
    key: "render",
    value: function render3(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      object.getBounds();
      var _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$lineJoin = parsedStyle.lineJoin, lineJoin = _parsedStyle$lineJoin === void 0 ? "miter" : _parsedStyle$lineJoin, _parsedStyle$miterLim = parsedStyle.miterLimit, miterLimit = _parsedStyle$miterLim === void 0 ? 10 : _parsedStyle$miterLim, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, stroke2 = parsedStyle.stroke, fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, metrics = parsedStyle.metrics, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y4 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, dx = parsedStyle.dx, dy = parsedStyle.dy, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
      var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
      context.font = font;
      context.lineWidth = lineWidth;
      context.textAlign = textAlign === "middle" ? "center" : textAlign;
      var formattedTextBaseline = textBaseline;
      if (formattedTextBaseline === "alphabetic") {
        formattedTextBaseline = "bottom";
      }
      context.lineJoin = lineJoin;
      if (!isNil(miterLimit)) {
        context.miterLimit = miterLimit;
      }
      var linePositionY = y4;
      if (textBaseline === "middle") {
        linePositionY += -height / 2 - lineHeight / 2;
      } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
        linePositionY += -height;
      } else if (textBaseline === "top" || textBaseline === "hanging") {
        linePositionY += -lineHeight;
      }
      var offsetX = x3 + (dx || 0);
      linePositionY += dy || 0;
      if (lines.length === 1) {
        if (formattedTextBaseline === "bottom") {
          formattedTextBaseline = "middle";
          linePositionY -= 0.5 * height;
        } else if (formattedTextBaseline === "top") {
          formattedTextBaseline = "middle";
          linePositionY += 0.5 * height;
        }
      }
      context.textBaseline = formattedTextBaseline;
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      for (var i2 = 0; i2 < lines.length; i2++) {
        var linePositionX = lineWidth / 2 + offsetX;
        linePositionY += lineHeight;
        if (!isNil(stroke2) && !stroke2.isNone && lineWidth) {
          this.drawLetterSpacing(context, object, lines[i2], lineMetrics[i2], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, true, canvasContext, plugin, runtime2);
        }
        if (!isNil(fill)) {
          this.drawLetterSpacing(context, object, lines[i2], lineMetrics[i2], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, false, canvasContext, plugin, runtime2);
        }
      }
    }
  }, {
    key: "drawLetterSpacing",
    value: function drawLetterSpacing(context, object, text, lineMetrics, textAlign, x3, y4, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, isStroke, canvasContext, plugin, runtime2) {
      if (letterSpacing === 0) {
        if (isStroke) {
          this.strokeText(context, object, text, x3, y4, stroke2, strokeOpacity, canvasContext, plugin, runtime2);
        } else {
          this.fillText(context, object, text, x3, y4, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
        }
        return;
      }
      var currentTextAlign = context.textAlign;
      context.textAlign = "left";
      var currentPosition = x3;
      if (textAlign === "center" || textAlign === "middle") {
        currentPosition = x3 - lineMetrics.width / 2;
      } else if (textAlign === "right" || textAlign === "end") {
        currentPosition = x3 - lineMetrics.width;
      }
      var stringArray = Array.from(text);
      var previousWidth = context.measureText(text).width;
      var currentWidth = 0;
      for (var i2 = 0; i2 < stringArray.length; ++i2) {
        var currentChar = stringArray[i2];
        if (isStroke) {
          this.strokeText(context, object, currentChar, currentPosition, y4, stroke2, strokeOpacity, canvasContext, plugin, runtime2);
        } else {
          this.fillText(context, object, currentChar, currentPosition, y4, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
        }
        currentWidth = context.measureText(text.substring(i2 + 1)).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
      context.textAlign = currentTextAlign;
    }
  }, {
    key: "fillText",
    value: function fillText(context, object, text, x3, y4, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2) {
      applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool, true);
      var currentGlobalAlpha;
      var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = fillOpacity * opacity;
      }
      context.fillText(text, x3, y4);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    }
  }, {
    key: "strokeText",
    value: function strokeText(context, object, text, x3, y4, stroke2, strokeOpacity, canvasContext, plugin, runtime2) {
      applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool, true);
      var currentGlobalAlpha;
      var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = strokeOpacity;
      }
      context.strokeText(text, x3, y4);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    }
    // ---
  }, {
    key: "drawToContext",
    value: function drawToContext(context, object, renderState, plugin, runtime2) {
      this.render(context, object.parsedStyle, object, object.ownerDocument.defaultView.context, plugin, runtime2);
    }
  }]);
}(DefaultRenderer);
var Plugin4 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Plugin8);
    _this2 = _callSuper(this, Plugin8);
    _this2.name = "canvas-renderer";
    _this2.options = options;
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      var _defaultStyleRenderer;
      var canvasRendererPluginOptions = _objectSpread2({
        dirtyObjectNumThreshold: 500,
        dirtyObjectRatioThreshold: 0.8
      }, this.options);
      var imagePool = this.context.imagePool;
      var defaultRenderer = new DefaultRenderer(imagePool);
      var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.CIRCLE, defaultRenderer), Shape.ELLIPSE, defaultRenderer), Shape.RECT, defaultRenderer), Shape.IMAGE, new ImageRenderer(imagePool)), Shape.TEXT, new TextRenderer(imagePool)), Shape.LINE, defaultRenderer), Shape.POLYLINE, defaultRenderer), Shape.POLYGON, defaultRenderer), Shape.PATH, defaultRenderer), Shape.GROUP, void 0), _defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
      this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
      this.context.styleRendererFactory = defaultStyleRendererFactory;
      this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
      delete this.context.defaultStyleRendererFactory;
      delete this.context.styleRendererFactory;
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-dom-interaction/dist/index.esm.js
var DOMInteractionPlugin = function() {
  function DOMInteractionPlugin2() {
    _classCallCheck(this, DOMInteractionPlugin2);
  }
  return _createClass(DOMInteractionPlugin2, [{
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext, config = context.config;
      this.context = context;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var onPointerMove = function onPointerMove2(ev) {
        renderingService.hooks.pointerMove.call(ev);
      };
      var onPointerUp = function onPointerUp2(ev) {
        renderingService.hooks.pointerUp.call(ev);
      };
      var onPointerDown = function onPointerDown2(ev) {
        renderingService.hooks.pointerDown.call(ev);
      };
      var onPointerOver = function onPointerOver2(ev) {
        renderingService.hooks.pointerOver.call(ev);
      };
      var onPointerOut = function onPointerOut2(ev) {
        renderingService.hooks.pointerOut.call(ev);
      };
      var onPointerCancel = function onPointerCancel2(ev) {
        renderingService.hooks.pointerCancel.call(ev);
      };
      var onPointerWheel = function onPointerWheel2(ev) {
        renderingService.hooks.pointerWheel.call(ev);
      };
      var onClick = function onClick2(ev) {
        renderingService.hooks.click.call(ev);
      };
      var addPointerEventListener = function addPointerEventListener2($el) {
        runtime2.globalThis.document.addEventListener("pointermove", onPointerMove, true);
        $el.addEventListener("pointerdown", onPointerDown, true);
        $el.addEventListener("pointerleave", onPointerOut, true);
        $el.addEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.addEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.addEventListener("pointercancel", onPointerCancel, true);
      };
      var addTouchEventListener = function addTouchEventListener2($el) {
        $el.addEventListener("touchstart", onPointerDown, true);
        $el.addEventListener("touchend", onPointerUp, true);
        $el.addEventListener("touchmove", onPointerMove, true);
        $el.addEventListener("touchcancel", onPointerCancel, true);
      };
      var addMouseEventListener = function addMouseEventListener2($el) {
        runtime2.globalThis.document.addEventListener("mousemove", onPointerMove, true);
        $el.addEventListener("mousedown", onPointerDown, true);
        $el.addEventListener("mouseout", onPointerOut, true);
        $el.addEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.addEventListener("mouseup", onPointerUp, true);
      };
      var removePointerEventListener = function removePointerEventListener2($el) {
        runtime2.globalThis.document.removeEventListener("pointermove", onPointerMove, true);
        $el.removeEventListener("pointerdown", onPointerDown, true);
        $el.removeEventListener("pointerleave", onPointerOut, true);
        $el.removeEventListener("pointerover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("pointerup", onPointerUp, true);
        runtime2.globalThis.removeEventListener("pointercancel", onPointerCancel, true);
      };
      var removeTouchEventListener = function removeTouchEventListener2($el) {
        $el.removeEventListener("touchstart", onPointerDown, true);
        $el.removeEventListener("touchend", onPointerUp, true);
        $el.removeEventListener("touchmove", onPointerMove, true);
        $el.removeEventListener("touchcancel", onPointerCancel, true);
      };
      var removeMouseEventListener = function removeMouseEventListener2($el) {
        runtime2.globalThis.document.removeEventListener("mousemove", onPointerMove, true);
        $el.removeEventListener("mousedown", onPointerDown, true);
        $el.removeEventListener("mouseout", onPointerOut, true);
        $el.removeEventListener("mouseover", onPointerOver, true);
        runtime2.globalThis.removeEventListener("mouseup", onPointerUp, true);
      };
      renderingService.hooks.init.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "none";
          $el.style.msTouchAction = "none";
        } else if (canvas.supportsPointerEvents) {
          $el.style.touchAction = "none";
        }
        if (canvas.supportsPointerEvents) {
          addPointerEventListener($el);
        } else {
          addMouseEventListener($el);
        }
        if (canvas.supportsTouchEvents) {
          addTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.addEventListener("click", onClick, true);
        }
        $el.addEventListener("wheel", onPointerWheel, {
          passive: true,
          capture: true
        });
      });
      renderingService.hooks.destroy.tap(DOMInteractionPlugin2.tag, function() {
        var $el = _this2.context.contextService.getDomElement();
        if (runtime2.globalThis.navigator.msPointerEnabled) {
          $el.style.msContentZooming = "";
          $el.style.msTouchAction = "";
        } else if (canvas.supportsPointerEvents) {
          $el.style.touchAction = "";
        }
        if (canvas.supportsPointerEvents) {
          removePointerEventListener($el);
        } else {
          removeMouseEventListener($el);
        }
        if (canvas.supportsTouchEvents) {
          removeTouchEventListener($el);
        }
        if (config.useNativeClickEvent) {
          $el.removeEventListener("click", onClick, true);
        }
        $el.removeEventListener("wheel", onPointerWheel, true);
      });
    }
  }]);
}();
DOMInteractionPlugin.tag = "DOMInteraction";
var Plugin5 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "dom-interaction";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new DOMInteractionPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-plugin-html-renderer/dist/index.esm.js
var CANVAS_CAMERA_ID = "g-canvas-camera";
var HTMLRenderingPlugin = function() {
  function HTMLRenderingPlugin2() {
    _classCallCheck(this, HTMLRenderingPlugin2);
    this.displayObjectHTMLElementMap = /* @__PURE__ */ new WeakMap();
  }
  return _createClass(HTMLRenderingPlugin2, [{
    key: "joinTransformMatrix",
    value: (
      /**
       * ! The reason for adding `offset` is that the `transform-origin` coordinate system of DOM is the local coordinate system of the element, while the `transform-origin` coordinate system of canvas drawing is the local coordinate system of the element's parent element. At the same time, the `transform` attribute value of the DOM element does not include `transform-origin`.
       */
      function joinTransformMatrix(matrix3) {
        var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
        return "matrix(".concat([matrix3[0], matrix3[1], matrix3[4], matrix3[5], matrix3[12] + offset2[0], matrix3[13] + offset2[1]].join(","), ")");
      }
    )
  }, {
    key: "apply",
    value: function apply(context, runtime2) {
      var _this2 = this;
      var camera = context.camera, renderingContext = context.renderingContext, renderingService = context.renderingService;
      this.context = context;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var nativeHTMLMap = canvas.context.eventService.nativeHTMLMap;
      var setTransform = function setTransform2(object, $el) {
        $el.style.transform = _this2.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
      };
      var handleMounted = function handleMounted2(e3) {
        var object = e3.target;
        if (object.nodeName === Shape.HTML) {
          if (!_this2.$camera) {
            _this2.$camera = _this2.createCamera(camera);
          }
          var $el = _this2.getOrCreateEl(object);
          _this2.$camera.appendChild($el);
          Object.keys(object.attributes).forEach(function(name2) {
            _this2.updateAttribute(name2, object);
          });
          setTransform(object, $el);
          nativeHTMLMap.set($el, object);
        }
      };
      var handleUnmounted = function handleUnmounted2(e3) {
        var object = e3.target;
        if (object.nodeName === Shape.HTML && _this2.$camera) {
          var $el = _this2.getOrCreateEl(object);
          if ($el) {
            $el.remove();
            nativeHTMLMap["delete"]($el);
          }
        }
      };
      var handleAttributeChanged = function handleAttributeChanged2(e3) {
        var object = e3.target;
        if (object.nodeName === Shape.HTML) {
          var attrName = e3.attrName;
          _this2.updateAttribute(attrName, object);
        }
      };
      var handleBoundsChanged = function handleBoundsChanged2(e3) {
        var object = e3.target;
        var nodes = object.nodeName === Shape.FRAGMENT ? object.childNodes : [object];
        nodes.forEach(function(node) {
          if (node.nodeName === Shape.HTML) {
            var $el = _this2.getOrCreateEl(node);
            setTransform(node, $el);
          }
        });
      };
      var handleCanvasResize = function handleCanvasResize2() {
        if (_this2.$camera) {
          var _this$context$config = _this2.context.config, width = _this$context$config.width, height = _this$context$config.height;
          _this2.$camera.parentElement.style.width = "".concat(width || 0, "px");
          _this2.$camera.parentElement.style.height = "".concat(height || 0, "px");
        }
      };
      renderingService.hooks.init.tap(HTMLRenderingPlugin2.tag, function() {
        canvas.addEventListener(CanvasEvent.RESIZE, handleCanvasResize);
        canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
      renderingService.hooks.endFrame.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED)) {
          _this2.$camera.style.transform = _this2.joinTransformMatrix(camera.getOrthoMatrix());
        }
      });
      renderingService.hooks.destroy.tap(HTMLRenderingPlugin2.tag, function() {
        if (_this2.$camera) {
          _this2.$camera.remove();
        }
        canvas.removeEventListener(CanvasEvent.RESIZE, handleCanvasResize);
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      });
    }
  }, {
    key: "createCamera",
    value: function createCamera(camera) {
      var _this$context$config2 = this.context.config, doc = _this$context$config2.document, width = _this$context$config2.width, height = _this$context$config2.height;
      var $canvas = this.context.contextService.getDomElement();
      var $container = $canvas.parentNode;
      if ($container) {
        var cameraId = CANVAS_CAMERA_ID;
        var $existedCamera = $container.querySelector("#".concat(cameraId));
        if (!$existedCamera) {
          var $cameraContainer = (doc || document).createElement("div");
          $cameraContainer.style.overflow = "hidden";
          $cameraContainer.style.pointerEvents = "none";
          $cameraContainer.style.position = "absolute";
          $cameraContainer.style.left = "0px";
          $cameraContainer.style.top = "0px";
          $cameraContainer.style.width = "".concat(width || 0, "px");
          $cameraContainer.style.height = "".concat(height || 0, "px");
          var $camera = (doc || document).createElement("div");
          $existedCamera = $camera;
          $camera.id = cameraId;
          $camera.style.position = "absolute";
          $camera.style.left = "".concat($canvas.offsetLeft || 0, "px");
          $camera.style.top = "".concat($canvas.offsetTop || 0, "px");
          $camera.style.transformOrigin = "left top";
          $camera.style.transform = this.joinTransformMatrix(camera.getOrthoMatrix());
          $camera.style.pointerEvents = "none";
          $camera.style.width = "100%";
          $camera.style.height = "100%";
          $cameraContainer.appendChild($camera);
          $container.appendChild($cameraContainer);
        }
        return $existedCamera;
      }
      return null;
    }
  }, {
    key: "getOrCreateEl",
    value: function getOrCreateEl(object) {
      var doc = this.context.config.document;
      var $existedElement = this.displayObjectHTMLElementMap.get(object);
      if (!$existedElement) {
        $existedElement = (doc || document).createElement("div");
        object.parsedStyle.$el = $existedElement;
        this.displayObjectHTMLElementMap.set(object, $existedElement);
        if (object.id) {
          $existedElement.id = object.id;
        }
        if (object.name) {
          $existedElement.setAttribute("name", object.name);
        }
        if (object.className) {
          $existedElement.className = object.className;
        }
        $existedElement.style.position = "absolute";
        $existedElement.style["will-change"] = "transform";
        $existedElement.style.transform = this.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
      }
      return $existedElement;
    }
  }, {
    key: "updateAttribute",
    value: function updateAttribute(name2, object) {
      var $el = this.getOrCreateEl(object);
      switch (name2) {
        case "innerHTML":
          var innerHTML = object.parsedStyle.innerHTML;
          if (isString(innerHTML)) {
            $el.innerHTML = innerHTML;
          } else {
            $el.innerHTML = "";
            $el.appendChild(innerHTML);
          }
          break;
        case "x":
          $el.style.left = "".concat(object.parsedStyle.x, "px");
          break;
        case "y":
          $el.style.top = "".concat(object.parsedStyle.y, "px");
          break;
        case "transformOrigin":
          var transformOrigin = object.parsedStyle.transformOrigin;
          $el.style["transform-origin"] = "".concat(transformOrigin[0].buildCSSText(null, null, ""), " ").concat(transformOrigin[1].buildCSSText(null, null, ""));
          break;
        case "width":
          var width = object.parsedStyle.width;
          $el.style.width = isNumber(width) ? "".concat(width, "px") : width.toString();
          break;
        case "height":
          var height = object.parsedStyle.height;
          $el.style.height = isNumber(height) ? "".concat(height, "px") : height.toString();
          break;
        case "zIndex":
          var zIndex = object.parsedStyle.zIndex;
          $el.style["z-index"] = "".concat(zIndex);
          break;
        case "visibility":
          var visibility2 = object.parsedStyle.visibility;
          $el.style.visibility = visibility2;
          break;
        case "pointerEvents":
          var _object$parsedStyle$p = object.parsedStyle.pointerEvents, pointerEvents = _object$parsedStyle$p === void 0 ? "auto" : _object$parsedStyle$p;
          $el.style.pointerEvents = pointerEvents;
          break;
        case "opacity":
          var opacity = object.parsedStyle.opacity;
          $el.style.opacity = "".concat(opacity);
          break;
        case "fill":
          var fill = object.parsedStyle.fill;
          var color3 = "";
          if (isCSSRGB(fill)) {
            if (fill.isNone) {
              color3 = "transparent";
            } else {
              color3 = object.getAttribute("fill");
            }
          } else if (Array.isArray(fill)) {
            color3 = object.getAttribute("fill");
          } else if (isPattern(fill)) ;
          $el.style.background = color3;
          break;
        case "stroke":
          var stroke2 = object.parsedStyle.stroke;
          var borderColor = "";
          if (isCSSRGB(stroke2)) {
            if (stroke2.isNone) {
              borderColor = "transparent";
            } else {
              borderColor = object.getAttribute("stroke");
            }
          } else if (Array.isArray(stroke2)) {
            borderColor = object.getAttribute("stroke");
          } else if (isPattern(stroke2)) ;
          $el.style["border-color"] = borderColor;
          $el.style["border-style"] = "solid";
          break;
        case "lineWidth":
          var lineWidth = object.parsedStyle.lineWidth;
          $el.style["border-width"] = "".concat(lineWidth || 0, "px");
          break;
        case "lineDash":
          $el.style["border-style"] = "dashed";
          break;
        case "filter":
          var filter3 = object.style.filter;
          $el.style.filter = filter3;
          break;
        default:
          if (!isNil(object.style[name2]) && object.style[name2] !== "") {
            $el.style[name2] = object.style[name2];
          }
      }
    }
  }]);
}();
HTMLRenderingPlugin.tag = "HTMLRendering";
var Plugin6 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    _classCallCheck(this, Plugin8);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, Plugin8, [].concat(args));
    _this2.name = "html-renderer";
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new HTMLRenderingPlugin());
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/g-canvas/dist/index.esm.js
var Canvas2DContextService = function() {
  function Canvas2DContextService2(context) {
    _classCallCheck(this, Canvas2DContextService2);
    this.renderingContext = context.renderingContext;
    this.canvasConfig = context.config;
  }
  return _createClass(Canvas2DContextService2, [{
    key: "init",
    value: function init() {
      var _this$canvasConfig = this.canvasConfig, container = _this$canvasConfig.container, canvas = _this$canvasConfig.canvas;
      if (canvas) {
        this.$canvas = canvas;
        if (container && canvas.parentElement !== container) {
          container.appendChild(canvas);
        }
        this.$container = canvas.parentElement;
        this.canvasConfig.container = this.$container;
      } else if (container) {
        this.$container = isString(container) ? document.getElementById(container) : container;
        if (this.$container) {
          var $canvas = document.createElement("canvas");
          this.$container.appendChild($canvas);
          if (!this.$container.style.position) {
            this.$container.style.position = "relative";
          }
          this.$canvas = $canvas;
        }
      }
      this.context = this.$canvas.getContext("2d");
      this.resize(this.canvasConfig.width, this.canvasConfig.height);
    }
  }, {
    key: "getContext",
    value: function getContext() {
      return this.context;
    }
  }, {
    key: "getDomElement",
    value: function getDomElement() {
      return this.$canvas;
    }
  }, {
    key: "getDPR",
    value: function getDPR() {
      return this.dpr;
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      if (this.$canvas.getBoundingClientRect) {
        return this.$canvas.getBoundingClientRect();
      }
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      if (this.$container && this.$canvas && this.$canvas.parentNode) {
        this.$container.removeChild(this.$canvas);
      }
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      var dpr = this.canvasConfig.devicePixelRatio;
      this.dpr = dpr;
      if (this.$canvas) {
        this.$canvas.width = this.dpr * width;
        this.$canvas.height = this.dpr * height;
        setDOMSize(this.$canvas, width, height);
      }
      this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
    }
  }, {
    key: "applyCursorStyle",
    value: function applyCursorStyle(cursor) {
      if (this.$container && this.$container.style) {
        this.$container.style.cursor = cursor;
      }
    }
  }, {
    key: "toDataURL",
    value: function() {
      var _toDataURL = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
        var options, type, encoderOptions, _args = arguments;
        return _regeneratorRuntime().wrap(function(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
              type = options.type, encoderOptions = options.encoderOptions;
              return _context.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function toDataURL() {
        return _toDataURL.apply(this, arguments);
      }
      return toDataURL;
    }()
  }]);
}();
var ContextRegisterPlugin = function(_AbstractRendererPlug) {
  function ContextRegisterPlugin2() {
    var _this2;
    _classCallCheck(this, ContextRegisterPlugin2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _callSuper(this, ContextRegisterPlugin2, [].concat(args));
    _this2.name = "canvas-context-register";
    return _this2;
  }
  _inherits(ContextRegisterPlugin2, _AbstractRendererPlug);
  return _createClass(ContextRegisterPlugin2, [{
    key: "init",
    value: function init() {
      this.context.ContextService = Canvas2DContextService;
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      delete this.context.ContextService;
    }
  }]);
}(AbstractRendererPlugin);
var Renderer = function(_AbstractRenderer) {
  function Renderer2(config) {
    var _this2;
    _classCallCheck(this, Renderer2);
    _this2 = _callSuper(this, Renderer2, [config]);
    _this2.registerPlugin(new ContextRegisterPlugin());
    _this2.registerPlugin(new Plugin3());
    _this2.registerPlugin(new Plugin());
    _this2.registerPlugin(new Plugin4());
    _this2.registerPlugin(new Plugin5());
    _this2.registerPlugin(new Plugin2());
    _this2.registerPlugin(new Plugin6());
    return _this2;
  }
  _inherits(Renderer2, _AbstractRenderer);
  return _createClass(Renderer2);
}(AbstractRenderer);

// node_modules/@antv/g-plugin-dragndrop/dist/index.esm.js
var DragndropPlugin = function() {
  function DragndropPlugin2(dragndropPluginOptions) {
    _classCallCheck(this, DragndropPlugin2);
    this.dragndropPluginOptions = dragndropPluginOptions;
  }
  return _createClass(DragndropPlugin2, [{
    key: "apply",
    value: function apply(context) {
      var _this2 = this;
      var renderingService = context.renderingService, renderingContext = context.renderingContext;
      var document2 = renderingContext.root.ownerDocument;
      var canvas = document2.defaultView;
      var handlePointerdown = function handlePointerdown2(event) {
        var target = event.target;
        var isDocument = target === document2;
        var draggableEventTarget = isDocument && _this2.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
        if (draggableEventTarget) {
          var dragstartTriggered = false;
          var dragstartTimeStamp = event.timeStamp;
          var dragstartClientCoordinates = [event.clientX, event.clientY];
          var currentDroppable = null;
          var lastDragClientCoordinates = [event.clientX, event.clientY];
          var handlePointermove = function() {
            var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(event2) {
              var timeElapsed, distanceMoved, point7, elementsBelow, elementBelow, droppableBelow;
              return _regeneratorRuntime().wrap(function(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (dragstartTriggered) {
                      _context.next = 2;
                      break;
                    }
                    timeElapsed = event2.timeStamp - dragstartTimeStamp;
                    distanceMoved = distanceSquareRoot([event2.clientX, event2.clientY], dragstartClientCoordinates);
                    if (!(timeElapsed <= _this2.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this2.dragndropPluginOptions.dragstartDistanceThreshold)) {
                      _context.next = 1;
                      break;
                    }
                    return _context.abrupt("return");
                  case 1:
                    event2.type = "dragstart";
                    draggableEventTarget.dispatchEvent(event2);
                    dragstartTriggered = true;
                  case 2:
                    event2.type = "drag";
                    event2.dx = event2.clientX - lastDragClientCoordinates[0];
                    event2.dy = event2.clientY - lastDragClientCoordinates[1];
                    draggableEventTarget.dispatchEvent(event2);
                    lastDragClientCoordinates = [event2.clientX, event2.clientY];
                    if (isDocument) {
                      _context.next = 4;
                      break;
                    }
                    point7 = _this2.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                    _context.next = 3;
                    return document2.elementsFromPoint(point7[0], point7[1]);
                  case 3:
                    elementsBelow = _context.sent;
                    elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                    droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (_this2.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                    if (currentDroppable !== droppableBelow) {
                      if (currentDroppable) {
                        event2.type = "dragleave";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                      if (droppableBelow) {
                        event2.type = "dragenter";
                        event2.target = droppableBelow;
                        droppableBelow.dispatchEvent(event2);
                      }
                      currentDroppable = droppableBelow;
                      if (currentDroppable) {
                        event2.type = "dragover";
                        event2.target = currentDroppable;
                        currentDroppable.dispatchEvent(event2);
                      }
                    }
                  case 4:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function handlePointermove2(_x) {
              return _ref.apply(this, arguments);
            };
          }();
          canvas.addEventListener("pointermove", handlePointermove);
          var stopDragging = function stopDragging2(originalPointerUpEvent) {
            if (dragstartTriggered) {
              originalPointerUpEvent.detail = {
                preventClick: true
              };
              var _event = originalPointerUpEvent.clone();
              if (currentDroppable) {
                _event.type = "drop";
                _event.target = currentDroppable;
                currentDroppable.dispatchEvent(_event);
              }
              _event.type = "dragend";
              draggableEventTarget.dispatchEvent(_event);
              dragstartTriggered = false;
            }
            canvas.removeEventListener("pointermove", handlePointermove);
          };
          target.addEventListener("pointerup", stopDragging, {
            once: true
          });
          target.addEventListener("pointerupoutside", stopDragging, {
            once: true
          });
        }
      };
      renderingService.hooks.init.tap(DragndropPlugin2.tag, function() {
        canvas.addEventListener("pointerdown", handlePointerdown);
      });
      renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
        canvas.removeEventListener("pointerdown", handlePointerdown);
      });
    }
  }]);
}();
DragndropPlugin.tag = "Dragndrop";
var Plugin7 = function(_AbstractRendererPlug) {
  function Plugin8() {
    var _this2;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Plugin8);
    _this2 = _callSuper(this, Plugin8);
    _this2.name = "dragndrop";
    _this2.options = options;
    return _this2;
  }
  _inherits(Plugin8, _AbstractRendererPlug);
  return _createClass(Plugin8, [{
    key: "init",
    value: function init() {
      this.addRenderingPlugin(new DragndropPlugin(_objectSpread2({
        overlap: "pointer",
        isDocumentDraggable: false,
        isDocumentDroppable: false,
        dragstartDistanceThreshold: 0,
        dragstartTimeThreshold: 0
      }, this.options)));
    }
  }, {
    key: "destroy",
    value: function destroy2() {
      this.removeAllRenderingPlugins();
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      Object.assign(this.plugins[0].dragndropPluginOptions, options);
    }
  }]);
}(AbstractRendererPlugin);

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter2 = (
  /** @class */
  function() {
    function EventEmitter3() {
      this._events = {};
    }
    EventEmitter3.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter3.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter3.prototype.emit = function(evt) {
      var _this2 = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length5 = es.length;
        for (var i2 = 0; i2 < length5; i2++) {
          if (!es[i2]) {
            continue;
          }
          var _a2 = es[i2], callback = _a2.callback, once = _a2.once;
          if (once) {
            es.splice(i2, 1);
            if (es.length === 0) {
              delete _this2._events[evt];
            }
            length5--;
            i2--;
          }
          callback.apply(_this2, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter3.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i2 = 0; i2 < length_1; i2++) {
            if (events[i2].callback === callback) {
              events.splice(i2, 1);
              length_1--;
              i2--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter3.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter3;
  }()
);
var esm_default = EventEmitter2;

// node_modules/@antv/g2/esm/utils/event.js
var ChartEvent = {
  BEFORE_RENDER: "beforerender",
  AFTER_RENDER: "afterrender",
  BEFORE_PAINT: "beforepaint",
  AFTER_PAINT: "afterpaint",
  BEFORE_CHANGE_DATA: "beforechangedata",
  AFTER_CHANGE_DATA: "afterchangedata",
  BEFORE_CLEAR: "beforeclear",
  AFTER_CLEAR: "afterclear",
  BEFORE_DESTROY: "beforedestroy",
  AFTER_DESTROY: "afterdestroy",
  BEFORE_CHANGE_SIZE: "beforechangesize",
  AFTER_CHANGE_SIZE: "afterchangesize",
  POINTER_TAP: "pointertap",
  POINTER_DOWN: "pointerdown",
  POINTER_UP: "pointerup",
  POINTER_OVER: "pointerover",
  POINTER_OUT: "pointerout",
  POINTER_MOVE: "pointermove",
  POINTER_ENTER: "pointerenter",
  POINTER_LEAVE: "pointerleave",
  POINTER_UPOUTSIDE: "pointerupoutside",
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_END: "dragend",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "DROP",
  CLICK: "click",
  DBLCLICK: "dblclick"
};

// node_modules/@antv/expr/dist/index.esm.js
var e = { abs: Math.abs, ceil: Math.ceil, floor: Math.floor, max: Math.max, min: Math.min, round: Math.round, sqrt: Math.sqrt, pow: Math.pow };
var n = class extends Error {
  constructor(e3, t, n2) {
    super(e3), this.position = t, this.token = n2, this.name = "ExpressionError";
  }
};
var r;
!function(e3) {
  e3[e3.STRING = 0] = "STRING", e3[e3.NUMBER = 1] = "NUMBER", e3[e3.BOOLEAN = 2] = "BOOLEAN", e3[e3.NULL = 3] = "NULL", e3[e3.IDENTIFIER = 4] = "IDENTIFIER", e3[e3.OPERATOR = 5] = "OPERATOR", e3[e3.FUNCTION = 6] = "FUNCTION", e3[e3.DOT = 7] = "DOT", e3[e3.BRACKET_LEFT = 8] = "BRACKET_LEFT", e3[e3.BRACKET_RIGHT = 9] = "BRACKET_RIGHT", e3[e3.PAREN_LEFT = 10] = "PAREN_LEFT", e3[e3.PAREN_RIGHT = 11] = "PAREN_RIGHT", e3[e3.COMMA = 12] = "COMMA", e3[e3.QUESTION = 13] = "QUESTION", e3[e3.COLON = 14] = "COLON", e3[e3.DOLLAR = 15] = "DOLLAR";
}(r || (r = {}));
var o = /* @__PURE__ */ new Set([32, 9, 10, 13]);
var a4 = /* @__PURE__ */ new Set([43, 45, 42, 47, 37, 33, 38, 124, 61, 60, 62]);
var s3 = /* @__PURE__ */ new Map([["true", r.BOOLEAN], ["false", r.BOOLEAN], ["null", r.NULL]]);
var i = /* @__PURE__ */ new Map([["===", true], ["!==", true], ["<=", true], [">=", true], ["&&", true], ["||", true], ["+", true], ["-", true], ["*", true], ["/", true], ["%", true], ["!", true], ["<", true], [">", true]]);
var u = /* @__PURE__ */ new Map([[46, r.DOT], [91, r.BRACKET_LEFT], [93, r.BRACKET_RIGHT], [40, r.PAREN_LEFT], [41, r.PAREN_RIGHT], [44, r.COMMA], [63, r.QUESTION], [58, r.COLON], [36, r.DOLLAR]]);
var c3 = /* @__PURE__ */ new Map();
for (const [e3, t] of u.entries()) c3.set(e3, { type: t, value: String.fromCharCode(e3) });
function p2(e3) {
  return e3 >= 48 && e3 <= 57;
}
function l(e3) {
  return e3 >= 97 && e3 <= 122 || e3 >= 65 && e3 <= 90 || 95 === e3;
}
function f(e3) {
  return l(e3) || p2(e3);
}
function E(e3) {
  return a4.has(e3);
}
var h;
!function(e3) {
  e3[e3.Program = 0] = "Program", e3[e3.Literal = 1] = "Literal", e3[e3.Identifier = 2] = "Identifier", e3[e3.MemberExpression = 3] = "MemberExpression", e3[e3.CallExpression = 4] = "CallExpression", e3[e3.BinaryExpression = 5] = "BinaryExpression", e3[e3.UnaryExpression = 6] = "UnaryExpression", e3[e3.ConditionalExpression = 7] = "ConditionalExpression";
}(h || (h = {}));
var d3 = /* @__PURE__ */ new Map([["||", 2], ["&&", 3], ["===", 4], ["!==", 4], [">", 5], [">=", 5], ["<", 5], ["<=", 5], ["+", 6], ["-", 6], ["*", 7], ["/", 7], ["%", 7], ["!", 8]]);
var R = { type: h.Literal, value: null };
var T = { type: h.Literal, value: true };
var w = { type: h.Literal, value: false };
var y3 = (e3) => {
  let t = 0;
  const o2 = e3.length, a5 = () => t >= o2 ? null : e3[t], s4 = () => e3[t++], i2 = (e4) => {
    const t4 = a5();
    return null !== t4 && t4.type === e4;
  }, u2 = (e4) => e4.type === r.OPERATOR ? d3.get(e4.value) || -1 : e4.type === r.DOT || e4.type === r.BRACKET_LEFT ? 9 : e4.type === r.QUESTION ? 1 : -1, c6 = (e4) => {
    let o3, u3;
    if (s4().type === r.DOT) {
      if (!i2(r.IDENTIFIER)) {
        const e7 = a5();
        throw new n("Expected property name", t, e7 ? e7.value : "<end of input>");
      }
      const e6 = s4();
      o3 = { type: h.Identifier, name: e6.value }, u3 = false;
    } else {
      if (o3 = l2(0), !i2(r.BRACKET_RIGHT)) {
        const e6 = a5();
        throw new n("Expected closing bracket", t, e6 ? e6.value : "<end of input>");
      }
      s4(), u3 = true;
    }
    return { type: h.MemberExpression, object: e4, property: o3, computed: u3 };
  }, p3 = () => {
    const e4 = a5();
    if (!e4) throw new n("Unexpected end of input", t, "<end of input>");
    if (e4.type === r.OPERATOR && ("!" === e4.value || "-" === e4.value)) {
      s4();
      const t4 = p3();
      return { type: h.UnaryExpression, operator: e4.value, argument: t4, prefix: true };
    }
    switch (e4.type) {
      case r.NUMBER:
        return s4(), { type: h.Literal, value: Number(e4.value) };
      case r.STRING:
        return s4(), { type: h.Literal, value: e4.value };
      case r.BOOLEAN:
        return s4(), "true" === e4.value ? T : w;
      case r.NULL:
        return s4(), R;
      case r.IDENTIFIER:
        return s4(), { type: h.Identifier, name: e4.value };
      case r.FUNCTION:
        return (() => {
          const e6 = s4(), o3 = [];
          if (!i2(r.PAREN_LEFT)) {
            const e7 = a5();
            throw new n("Expected opening parenthesis after function name", t, e7 ? e7.value : "<end of input>");
          }
          for (s4(); ; ) {
            if (i2(r.PAREN_RIGHT)) {
              s4();
              break;
            }
            if (!a5()) {
              const e8 = a5();
              throw new n("Expected closing parenthesis", t, e8 ? e8.value : "<end of input>");
            }
            if (o3.length > 0) {
              if (!i2(r.COMMA)) {
                const e8 = a5();
                throw new n("Expected comma between function arguments", t, e8 ? e8.value : "<end of input>");
              }
              s4();
            }
            const e7 = l2(0);
            o3.push(e7);
          }
          return { type: h.CallExpression, callee: { type: h.Identifier, name: e6.value }, arguments: o3 };
        })();
      case r.PAREN_LEFT: {
        s4();
        const e6 = l2(0);
        if (!i2(r.PAREN_RIGHT)) {
          const e7 = a5();
          throw new n("Expected closing parenthesis", t, e7 ? e7.value : "<end of input>");
        }
        return s4(), e6;
      }
      default:
        throw new n(`Unexpected token: ${e4.type}`, t, e4.value);
    }
  }, l2 = (f3 = 0) => {
    let E3 = p3();
    for (; t < o2; ) {
      const o3 = e3[t], p4 = u2(o3);
      if (p4 <= f3) break;
      if (o3.type !== r.QUESTION) if (o3.type !== r.OPERATOR) {
        if (o3.type !== r.DOT && o3.type !== r.BRACKET_LEFT) break;
        E3 = c6(E3);
      } else {
        s4();
        const e4 = l2(p4);
        E3 = { type: h.BinaryExpression, operator: o3.value, left: E3, right: e4 };
      }
      else {
        s4();
        const e4 = l2(0);
        if (!i2(r.COLON)) {
          const e6 = a5();
          throw new n("Expected : in conditional expression", t, e6 ? e6.value : "<end of input>");
        }
        s4();
        const o4 = l2(0);
        E3 = { type: h.ConditionalExpression, test: E3, consequent: e4, alternate: o4 };
      }
    }
    return E3;
  }, f2 = l2();
  return { type: h.Program, body: f2 };
};
var O = (e3, t, r2) => {
  let o2 = t;
  r2 && (o2 = { ...t, context: { ...t.context, ...r2 } });
  const a5 = (e4) => {
    switch (e4.type) {
      case h.Literal:
        return ((e6) => e6.value)(e4);
      case h.Identifier:
        return ((e6) => {
          if (!(e6.name in o2.context)) throw new n(`Undefined variable: ${e6.name}`);
          return o2.context[e6.name];
        })(e4);
      case h.MemberExpression:
        return ((e6) => {
          const t4 = a5(e6.object);
          if (null == t4) throw new n("Cannot access property of null or undefined");
          return t4[e6.computed ? a5(e6.property) : e6.property.name];
        })(e4);
      case h.CallExpression:
        return ((e6) => {
          const t4 = o2.functions[e6.callee.name];
          if (!t4) throw new n(`Undefined function: ${e6.callee.name}`);
          return t4(...e6.arguments.map((e7) => a5(e7)));
        })(e4);
      case h.BinaryExpression:
        return ((e6) => {
          if ("&&" === e6.operator) {
            const t5 = a5(e6.left);
            return t5 ? a5(e6.right) : t5;
          }
          if ("||" === e6.operator) {
            return a5(e6.left) || a5(e6.right);
          }
          const t4 = a5(e6.left), r3 = a5(e6.right);
          switch (e6.operator) {
            case "+":
              return t4 + r3;
            case "-":
              return t4 - r3;
            case "*":
              return t4 * r3;
            case "/":
              return t4 / r3;
            case "%":
              return t4 % r3;
            case "===":
              return t4 === r3;
            case "!==":
              return t4 !== r3;
            case ">":
              return t4 > r3;
            case ">=":
              return t4 >= r3;
            case "<":
              return t4 < r3;
            case "<=":
              return t4 <= r3;
            default:
              throw new n(`Unknown operator: ${e6.operator}`);
          }
        })(e4);
      case h.UnaryExpression:
        return ((e6) => {
          const t4 = a5(e6.argument);
          if (e6.prefix) switch (e6.operator) {
            case "!":
              return !t4;
            case "-":
              if ("number" != typeof t4) throw new n(`Cannot apply unary - to non-number: ${t4}`);
              return -t4;
            default:
              throw new n(`Unknown operator: ${e6.operator}`);
          }
          throw new n(`Postfix operators are not supported: ${e6.operator}`);
        })(e4);
      case h.ConditionalExpression:
        return ((e6) => {
          const t4 = a5(e6.test);
          return a5(t4 ? e6.consequent : e6.alternate);
        })(e4);
      default:
        throw new n(`Evaluation error: Unsupported node type: ${e4.type}`);
    }
  };
  return a5(e3.body);
};
function A3(t) {
  const a5 = ((e3) => {
    const t4 = e3, a6 = t4.length, u3 = new Array(Math.ceil(a6 / 3));
    let h3 = 0, d4 = 0;
    function R2(e4) {
      const o2 = d4 + 1;
      d4++;
      let s4 = "", i2 = false;
      for (; d4 < a6; ) {
        const n2 = t4.charCodeAt(d4);
        if (n2 === e4) return i2 || (s4 = t4.substring(o2, d4)), d4++, { type: r.STRING, value: s4 };
        92 === n2 ? (i2 || (s4 = t4.substring(o2, d4), i2 = true), d4++, s4 += t4[d4]) : i2 && (s4 += t4[d4]), d4++;
      }
      throw new n(`Unterminated string starting with ${String.fromCharCode(e4)}`, d4, t4.substring(Math.max(0, d4 - 10), d4));
    }
    function T2() {
      const e4 = d4;
      for (45 === t4.charCodeAt(d4) && d4++; d4 < a6 && p2(t4.charCodeAt(d4)); ) d4++;
      if (d4 < a6 && 46 === t4.charCodeAt(d4)) for (d4++; d4 < a6 && p2(t4.charCodeAt(d4)); ) d4++;
      const n2 = t4.slice(e4, d4);
      return { type: r.NUMBER, value: n2 };
    }
    function w2() {
      d4++;
      const e4 = d4;
      if (d4 < a6 && l(t4.charCodeAt(d4))) for (d4++; d4 < a6 && f(t4.charCodeAt(d4)); ) d4++;
      const n2 = t4.slice(e4, d4);
      return { type: r.FUNCTION, value: n2 };
    }
    function y4() {
      const e4 = d4++;
      for (; d4 < a6 && f(t4.charCodeAt(d4)); ) d4++;
      const n2 = t4.slice(e4, d4), o2 = s3.get(n2);
      return o2 ? { type: o2, value: n2 } : { type: r.IDENTIFIER, value: n2 };
    }
    function O2() {
      if (d4 + 2 < a6) {
        const e6 = t4.substring(d4, d4 + 3);
        if (i.has(e6)) return d4 += 3, { type: r.OPERATOR, value: e6 };
      }
      if (d4 + 1 < a6) {
        const e6 = t4.substring(d4, d4 + 2);
        if (i.has(e6)) return d4 += 2, { type: r.OPERATOR, value: e6 };
      }
      const e4 = t4[d4];
      if (i.has(e4)) return d4++, { type: r.OPERATOR, value: e4 };
      throw new n(`Unknown operator at position ${d4}: ${t4.substring(d4, d4 + 1)}`, d4, t4.substring(Math.max(0, d4 - 10), d4));
    }
    for (; d4 < a6; ) {
      const e4 = t4.charCodeAt(d4);
      if (A6 = e4, o.has(A6)) {
        d4++;
        continue;
      }
      const r2 = c3.get(e4);
      if (r2) u3[h3++] = r2, d4++;
      else if (34 !== e4 && 39 !== e4) if (p2(e4) || 45 === e4 && d4 + 1 < a6 && p2(t4.charCodeAt(d4 + 1))) u3[h3++] = T2();
      else if (64 !== e4) if (l(e4)) u3[h3++] = y4();
      else {
        if (!E(e4)) throw new n(`Unexpected character: ${t4[d4]}`, d4, t4.substring(Math.max(0, d4 - 10), d4));
        u3[h3++] = O2();
      }
      else u3[h3++] = w2();
      else u3[h3++] = R2(e4);
    }
    var A6;
    return h3 === u3.length ? u3 : u3.slice(0, h3);
  })(t), u2 = y3(a5), h2 = /* @__PURE__ */ ((e3 = {}, t4 = {}) => ({ context: e3, functions: t4 }))({}, e);
  return (e3 = {}) => O(u2, h2, e3);
}

// node_modules/@antv/g2/esm/utils/expr.js
var EXPR_WHITE_LIST = ["style", "encode", "labels", "children"];
var compileExpression = lru((expr) => {
  const evaluator = A3(expr);
  return (...args) => {
    const paramNames = Array.from({ length: args.length }, (_2, i2) => String.fromCharCode(97 + i2));
    const namedParams = Object.fromEntries(args.map((value2, index3) => [paramNames[index3], value2]));
    return evaluator(Object.assign(Object.assign({}, namedParams), { global: Object.assign({}, namedParams) }));
  };
}, (expr) => expr, 128);
function parseOptionsExpr(options, isSpecRoot = true) {
  if (Array.isArray(options)) {
    return options.map((_2, i2) => parseOptionsExpr(options[i2], isSpecRoot));
  }
  if (typeof options === "object" && options) {
    return map_values_default(options, (value2, key) => {
      if (isSpecRoot && EXPR_WHITE_LIST.includes(key)) {
        return parseOptionsExpr(value2, key === "children");
      }
      if (!isSpecRoot) {
        return parseOptionsExpr(value2, false);
      }
      return value2;
    });
  }
  if (typeof options === "string") {
    const trimmed = options.trim();
    if (trimmed.startsWith("{") && trimmed.endsWith("}")) {
      return compileExpression(trimmed.slice(1, -1));
    }
  }
  return options;
}

// node_modules/@antv/g2/esm/component/constant.js
var LEGEND_INFER_STRATEGIES = [
  [
    "legendCategory",
    [
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "constant"],
        ["shape", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      //   ['size', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      //   ['size', 'constant'],
      // ],
      [
        ["color", "constant"],
        ["opacity", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["size", "constant"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "discrete"]
      ],
      [
        ["color", "discrete"],
        ["opacity", "constant"]
      ],
      [
        ["color", "discrete"],
        ["shape", "constant"]
      ],
      [
        ["color", "constant"],
        ["shape", "discrete"]
      ],
      [
        ["color", "constant"],
        ["size", "constant"]
      ],
      [
        ["color", "constant"],
        ["opacity", "discrete"]
      ],
      // [
      //   ['color', 'constant'],
      //   ['opacity', 'constant'],
      // ],
      // [
      //   ['color', 'constant'],
      //   ['shape', 'constant'],
      // ],
      [["color", "discrete"]]
      // [['color', 'constant']],
    ]
  ],
  [
    "legendContinuousSize",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["opacity", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "continuous"],
        ["size", "continuous"]
      ],
      [
        ["color", "constant"],
        ["size", "continuous"]
      ],
      [
        ["size", "continuous"],
        ["opacity", "continuous"]
      ],
      [["size", "continuous"]]
    ]
  ],
  [
    "legendContinuousBlockSize",
    [
      [
        ["color", "distribution"],
        ["opacity", "distribution"],
        ["size", "distribution"]
      ],
      [
        ["color", "distribution"],
        ["size", "distribution"]
      ]
    ]
  ],
  [
    "legendContinuousBlock",
    [
      [
        ["color", "distribution"],
        ["opacity", "continuous"]
      ],
      [["color", "distribution"]]
    ]
  ],
  [
    "legendContinuous",
    [
      [
        ["color", "continuous"],
        ["opacity", "continuous"]
      ],
      [["color", "continuous"]],
      [["opacity", "continuous"]]
    ]
  ]
];

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-type.js
var toString3 = {}.toString;
var isType2 = function(value2, type) {
  return toString3.call(value2) === "[object " + type + "]";
};
var is_type_default2 = isType2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-function.js
var is_function_default = function(value2) {
  return is_type_default2(value2, "Function");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-array.js
var is_array_default = function(value2) {
  return Array.isArray ? Array.isArray(value2) : is_type_default2(value2, "Array");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object.js
var is_object_default2 = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/each.js
function each2(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i2 = 0, len5 = elements.length; i2 < len5; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default2(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default3 = each2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-object-like.js
var isObjectLike2 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var is_object_like_default2 = isObjectLike2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject2 = function(value2) {
  if (!is_object_like_default2(value2) || !is_type_default2(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var is_plain_object_default2 = isPlainObject2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull.js
var arrPrototype2 = Array.prototype;
var splice4 = arrPrototype2.splice;
var indexOf4 = arrPrototype2.indexOf;

// node_modules/@antv/coord/node_modules/@antv/util/esm/pull-at.js
var splice5 = Array.prototype.splice;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-string.js
var is_string_default = function(str7) {
  return is_type_default2(str7, "String");
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-number.js
var isNumber2 = function(value2) {
  return is_type_default2(value2, "Number");
};
var is_number_default = isNumber2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-integer.js
var isInteger2 = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-degree.js
var DEGREE2 = 180 / Math.PI;

// node_modules/@antv/coord/node_modules/@antv/util/esm/to-radian.js
var RADIAN2 = Math.PI / 180;

// node_modules/@antv/coord/node_modules/@antv/util/esm/values.js
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each_default3(obj, function(value2, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result.push(value2);
    }
  });
  return result;
};
var values_default2 = values;

// node_modules/@antv/coord/node_modules/@antv/util/esm/get-type.js
var toString4 = {}.toString;

// node_modules/@antv/coord/node_modules/@antv/util/esm/is-prototype.js
var objectProto2 = Object.prototype;

// node_modules/@antv/coord/node_modules/@antv/util/esm/memoize.js
var memoize_default = function(f2, resolver) {
  if (!is_function_default(f2)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = f2.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/deep-mix.js
var MAX_MIX_LEVEL3 = 5;
function _deepMix2(dist5, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL3;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value2 = src[key];
      if (value2 !== null && is_plain_object_default2(value2)) {
        if (!is_plain_object_default2(dist5[key])) {
          dist5[key] = {};
        }
        if (level < maxLevel) {
          _deepMix2(dist5[key], value2, level + 1, maxLevel);
        } else {
          dist5[key] = src[key];
        }
      } else if (is_array_default(value2)) {
        dist5[key] = [];
        dist5[key] = dist5[key].concat(value2);
      } else if (value2 !== void 0) {
        dist5[key] = value2;
      }
    }
  }
}
var deepMix2 = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    _deepMix2(rst, args[i2]);
  }
  return rst;
};
var deep_mix_default2 = deepMix2;

// node_modules/@antv/coord/node_modules/@antv/util/esm/identity.js
var identity_default4 = function(v) {
  return v;
};

// node_modules/@antv/coord/node_modules/@antv/util/esm/measure-text-width.js
var ctx2;
var measure_text_width_default = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx2) {
    ctx2 = document.createElement("canvas").getContext("2d");
  }
  ctx2.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx2.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default2(font)).join("");
});

// node_modules/@antv/coord/node_modules/@antv/util/esm/cache.js
var default_12 = (
  /** @class */
  function() {
    function default_13() {
      this.map = {};
    }
    default_13.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_13.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_13.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_13.prototype.clear = function() {
      this.map = {};
    };
    default_13.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_13.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_13;
  }()
);

// node_modules/@antv/coord/esm/utils/compose.js
function compose3(fn) {
  var rest = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    rest[_i - 1] = arguments[_i];
  }
  return fn ? rest.reduce(function(total, current) {
    return function(x3) {
      return current(total(x3));
    };
  }, fn) : identity_default4;
}

// node_modules/@antv/coord/esm/utils/isMatrix.js
function isMatrix(transformer2) {
  return transformer2 instanceof Float32Array || transformer2 instanceof Array;
}

// node_modules/@antv/coord/esm/utils/extend.js
var __read2 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function extend3(transform2) {
  return function(vector) {
    var v = [];
    for (var i2 = 0; i2 < vector.length - 1; i2 += 2) {
      var from = [vector[i2], vector[i2 + 1]];
      var to = transform2(from);
      v.push.apply(v, __spreadArray2([], __read2(to), false));
    }
    return v;
  };
}
function extend3D(transform2) {
  return function(vector) {
    var v = [];
    for (var i2 = 0; i2 < vector.length - 1; i2 += 3) {
      var from = [vector[i2], vector[i2 + 1], vector[i2 + 2]];
      var to = transform2(from);
      v.push.apply(v, __spreadArray2([], __read2(to), false));
    }
    return v;
  };
}

// node_modules/@antv/coord/esm/utils/adjustAngle.js
function adjustAngle(theta, min10, max11) {
  while (theta < min10)
    theta += Math.PI * 2;
  while (theta > max11)
    theta -= Math.PI * 2;
  return theta;
}

// node_modules/@antv/coord/esm/transforms/translate.js
var __read3 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var translate5 = function(params, x3, y4, width, height) {
  var _a2 = __read3(params, 2), tx = _a2[0], ty = _a2[1];
  var matrix3 = mat3_exports.create();
  return mat3_exports.fromTranslation(matrix3, [tx, ty]);
};

// node_modules/@antv/coord/esm/transforms/cartesian.js
var __read4 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var cartesian = function(params, x3, y4, width, height) {
  var sx = new Linear({
    range: [x3, x3 + width]
  });
  var sy = new Linear({
    range: [y4, y4 + height]
  });
  return {
    transform: function(vector) {
      var _a2 = __read4(vector, 2), v1 = _a2[0], v2 = _a2[1];
      return [sx.map(v1), sy.map(v2)];
    },
    untransform: function(vector) {
      var _a2 = __read4(vector, 2), v1 = _a2[0], v2 = _a2[1];
      return [sx.invert(v1), sy.invert(v2)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/custom.js
var __read5 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var custom10 = function(params, x3, y4, width, height) {
  var _a2 = __read5(params, 1), callback = _a2[0];
  return callback(x3, y4, width, height);
};

// node_modules/@antv/coord/esm/transforms/matrix.js
var __read6 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var matrix2 = function(params, x3, y4, width, height) {
  var _a2 = __read6(params, 1), matrix3 = _a2[0];
  return matrix3;
};

// node_modules/@antv/coord/esm/transforms/polar.js
var __read7 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var polar = function(params, x3, y4, width, height) {
  var _a2 = __read7(params, 4), startAngle = _a2[0], endAngle = _a2[1], innerRadius = _a2[2], outerRadius = _a2[3];
  var radius = new Linear({
    range: [innerRadius, outerRadius]
  });
  var angle4 = new Linear({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a3 = __read7(vector, 2), v1 = _a3[0], v2 = _a3[1];
      var theta = angle4.map(v1);
      var r2 = radius.map(v2);
      var x4 = r2 * Math.cos(theta) * sx;
      var y5 = r2 * Math.sin(theta) * sy;
      var dx = x4 * 0.5 + 0.5;
      var dy = y5 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a3 = __read7(vector, 2), dx = _a3[0], dy = _a3[1];
      var x4 = (dx - 0.5) * 2 / sx;
      var y5 = (dy - 0.5) * 2 / sy;
      var r2 = Math.sqrt(Math.pow(x4, 2) + Math.pow(y5, 2));
      var t = Math.atan2(y5, x4);
      var theta = adjustAngle(t, startAngle, endAngle);
      var v1 = angle4.invert(theta);
      var v2 = radius.invert(r2);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/transpose.js
var __read8 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var transpose5 = function(params, x3, y4, width, height) {
  return {
    transform: function(_a2) {
      var _b = __read8(_a2, 2), x4 = _b[0], y5 = _b[1];
      return [y5, x4];
    },
    untransform: function(_a2) {
      var _b = __read8(_a2, 2), x4 = _b[0], y5 = _b[1];
      return [y5, x4];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale.js
var __read9 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var scale9 = function(params, x3, y4, width, height) {
  var _a2 = __read9(params, 2), sx = _a2[0], sy = _a2[1];
  var matrix3 = mat3_exports.create();
  return mat3_exports.fromScaling(matrix3, [sx, sy]);
};

// node_modules/@antv/coord/esm/transforms/reflect.js
var __read10 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var reflect2 = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[-1, -1]], __read10(args), false));
};
var reflectX = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[-1, 1]], __read10(args), false));
};
var reflectY = function(params) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return scale9.apply(void 0, __spreadArray3([[1, -1]], __read10(args), false));
};

// node_modules/@antv/coord/esm/transforms/rotate.js
var __read11 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var rotate6 = function(params, x3, y4, width, height) {
  var _a2 = __read11(params, 1), theta = _a2[0];
  var matrix3 = mat3_exports.create();
  return mat3_exports.fromRotation(matrix3, theta);
};

// node_modules/@antv/coord/esm/transforms/helix.js
var __read12 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var helix = function(params, x3, y4, width, height) {
  var _a2 = __read12(params, 4), startAngle = _a2[0], endAngle = _a2[1], innerRadius = _a2[2], outerRadius = _a2[3];
  var count4 = (endAngle - 0) / (2 * Math.PI) + 1;
  var d4 = (outerRadius - innerRadius) / count4;
  var b = d4 / (Math.PI * 2);
  var step2 = new Linear({
    range: [innerRadius, innerRadius + d4 * 0.99]
    // 
  });
  var angle4 = new Linear({
    range: [startAngle, endAngle]
  });
  var aspect = height / width;
  var sx = aspect > 1 ? 1 : aspect;
  var sy = aspect > 1 ? 1 / aspect : 1;
  return {
    transform: function(vector) {
      var _a3 = __read12(vector, 2), v1 = _a3[0], v2 = _a3[1];
      var theta = angle4.map(v1);
      var a5 = step2.map(v2);
      var x4 = Math.cos(theta) * (b * theta + a5) * sx;
      var y5 = Math.sin(theta) * (b * theta + a5) * sy;
      var dx = x4 * 0.5 + 0.5;
      var dy = y5 * 0.5 + 0.5;
      return [dx, dy];
    },
    untransform: function(vector) {
      var _a3 = __read12(vector, 2), dx = _a3[0], dy = _a3[1];
      var x4 = (dx - 0.5) * 2 / sx;
      var y5 = (dy - 0.5) * 2 / sy;
      var r2 = Math.sqrt(Math.pow(x4, 2) + Math.pow(y5, 2));
      var t = Math.atan2(y5, x4) + Math.floor(r2 / d4) * Math.PI * 2;
      var theta = adjustAngle(t, startAngle, endAngle);
      var a5 = r2 - b * theta;
      var v1 = angle4.invert(theta);
      var v2 = step2.invert(a5);
      return [v1, v2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/parallel.js
var __read13 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var parallel2 = function(params, x3, y4, width, height) {
  var _a2 = __read13(params, 4), x05 = _a2[0], x12 = _a2[1], y05 = _a2[2], y12 = _a2[3];
  var sy = new Linear({
    range: [y05, y12]
  });
  return {
    transform: function(vector) {
      var v = [];
      var len5 = vector.length;
      var sx = new Point({
        domain: new Array(len5).fill(0).map(function(_2, i3) {
          return i3;
        }),
        range: [x05, x12]
      });
      for (var i2 = 0; i2 < len5; i2++) {
        var e3 = vector[i2];
        var x_1 = sx.map(i2);
        var y_1 = sy.map(e3);
        v.push(x_1, y_1);
      }
      return v;
    },
    untransform: function(vector) {
      var v = [];
      for (var i2 = 0; i2 < vector.length; i2 += 2) {
        var y_2 = vector[i2 + 1];
        v.push(sy.invert(y_2));
      }
      return v;
    }
  };
};

// node_modules/@antv/coord/esm/transforms/shear.js
var __read14 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function cot(theta) {
  return 1 / Math.tan(theta);
}
var shearX = function(params, x3, y4, width, height) {
  var _a2 = __read14(params, 1), theta = _a2[0];
  var sx = cot(theta);
  return {
    transform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], y5 = _a3[1];
      var xx = x4 + y5 * sx;
      return [xx, y5];
    },
    untransform: function(vector) {
      var _a3 = __read14(vector, 2), xx = _a3[0], y5 = _a3[1];
      var x4 = xx - y5 * sx;
      return [x4, y5];
    }
  };
};
var shearY = function(params, x3, y4, width, height) {
  var _a2 = __read14(params, 1), theta = _a2[0];
  var sy = cot(theta);
  return {
    transform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], y5 = _a3[1];
      var yy = y5 + x4 * sy;
      return [x4, yy];
    },
    untransform: function(vector) {
      var _a3 = __read14(vector, 2), x4 = _a3[0], yy = _a3[1];
      var y5 = yy - x4 * sy;
      return [x4, y5];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/fisheye.js
var __read15 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
function fisheyeTransform(x3, focus2, distortion, min10, max11) {
  var left2 = x3 < focus2;
  var m3 = (left2 ? focus2 - min10 : max11 - focus2) || max11 - min10;
  var f2 = left2 ? -1 : 1;
  return f2 * m3 * (distortion + 1) / (distortion + m3 / ((x3 - focus2) * f2)) + focus2;
}
function fisheyeUntransform(tx, focus2, distortion, min10, max11) {
  var left2 = tx < focus2;
  var m3 = (left2 ? focus2 - min10 : max11 - focus2) || max11 - min10;
  var f2 = left2 ? -1 : 1;
  return m3 / (m3 * (distortion + 1) / (tx - focus2) - distortion * f2) + focus2;
}
function normalize9(focus2, length5, isVisual) {
  if (!isVisual)
    return focus2;
  var s4 = new Linear({
    range: [0, 1],
    domain: [0, length5]
  });
  return s4.map(focus2);
}
var fisheyeX = function(params, x3, y4, width, height) {
  var _a2 = __read15(params, 3), focus2 = _a2[0], distortion = _a2[1], _b = _a2[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize9(focus2, width, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortion, 0, 1);
      return [fx, vy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), fx = _a3[0], vy = _a3[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeY = function(params, x3, y4, width, height) {
  var _a2 = __read15(params, 3), focus2 = _a2[0], distortion = _a2[1], _b = _a2[2], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusY = normalize9(focus2, height, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fy = fisheyeTransform(vy, normalizedFocusY, distortion, 0, 1);
      return [vx, fy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], fy = _a3[1];
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortion, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheye = function(params, x3, y4, width, height) {
  var _a2 = __read15(params, 5), focusX = _a2[0], focusY = _a2[1], distortionX = _a2[2], distortionY = _a2[3], _b = _a2[4], isVisual = _b === void 0 ? false : _b;
  var normalizedFocusX = normalize9(focusX, width, isVisual);
  var normalizedFocusY = normalize9(focusY, height, isVisual);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), vx = _a3[0], vy = _a3[1];
      var fx = fisheyeTransform(vx, normalizedFocusX, distortionX, 0, 1);
      var fy = fisheyeTransform(vy, normalizedFocusY, distortionY, 0, 1);
      return [fx, fy];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), fx = _a3[0], fy = _a3[1];
      var vx = fisheyeUntransform(fx, normalizedFocusX, distortionX, 0, 1);
      var vy = fisheyeUntransform(fy, normalizedFocusY, distortionY, 0, 1);
      return [vx, vy];
    }
  };
};
var fisheyeCircular = function(params, x3, y4, width, height) {
  var _a2 = __read15(params, 5), focusX = _a2[0], focusY = _a2[1], radius = _a2[2], distortion = _a2[3], _b = _a2[4], isVisual = _b === void 0 ? false : _b;
  var scaleX2 = new Linear({
    range: [0, width]
  });
  var scaleY2 = new Linear({
    range: [0, height]
  });
  var nx = isVisual ? focusX : scaleX2.map(focusX);
  var ny = isVisual ? focusY : scaleY2.map(focusY);
  return {
    transform: function(vector) {
      var _a3 = __read15(vector, 2), x4 = _a3[0], y5 = _a3[1];
      var dx = scaleX2.map(x4) - nx;
      var dy = scaleY2.map(y5) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [x4, y5];
      var r2 = fisheyeTransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + r2 * Math.cos(theta);
      var fy = ny + r2 * Math.sin(theta);
      return [scaleX2.invert(fx), scaleY2.invert(fy)];
    },
    untransform: function(vector) {
      var _a3 = __read15(vector, 2), tx = _a3[0], ty = _a3[1];
      var dx = scaleX2.map(tx) - nx;
      var dy = scaleY2.map(ty) - ny;
      var dd = Math.sqrt(dx * dx + dy * dy);
      if (dd > radius)
        return [tx, ty];
      var x4 = fisheyeUntransform(dd, 0, distortion, 0, radius);
      var theta = Math.atan2(dy, dx);
      var fx = nx + x4 * Math.cos(theta);
      var fy = ny + x4 * Math.sin(theta);
      return [scaleX2.invert(fx), scaleY2.invert(fy)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/cartesian3D.js
var __read16 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var cartesian3D = function(params, x3, y4, z, width, height, depth) {
  var sx = new Linear({
    range: [x3, x3 + width]
  });
  var sy = new Linear({
    range: [y4, y4 + height]
  });
  var sz = new Linear({
    range: [z, z + depth]
  });
  return {
    transform: function(vector) {
      var _a2 = __read16(vector, 3), v1 = _a2[0], v2 = _a2[1], v3 = _a2[2];
      return [sx.map(v1), sy.map(v2), sz.map(v3)];
    },
    untransform: function(vector) {
      var _a2 = __read16(vector, 3), v1 = _a2[0], v2 = _a2[1], v3 = _a2[2];
      return [sx.invert(v1), sy.invert(v2), sz.invert(v3)];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/translate3D.js
var __read17 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var translate3D = function(params, x3, y4, z, width, height, depth) {
  var _a2 = __read17(params, 3), tx = _a2[0], ty = _a2[1], tz = _a2[2];
  return mat4_exports.fromTranslation(mat4_exports.create(), [tx, ty, tz]);
};

// node_modules/@antv/coord/esm/transforms/transpose3D.js
var __read18 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var transpose3D = function(params, x3, y4, z, width, height, depth) {
  return {
    transform: function(_a2) {
      var _b = __read18(_a2, 3), x4 = _b[0], y5 = _b[1], z2 = _b[2];
      return [y5, x4, z2];
    },
    untransform: function(_a2) {
      var _b = __read18(_a2, 3), x4 = _b[0], y5 = _b[1], z2 = _b[2];
      return [y5, x4, z2];
    }
  };
};

// node_modules/@antv/coord/esm/transforms/scale3D.js
var __read19 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var scale3D = function(params, x3, y4, z, width, height, depth) {
  var _a2 = __read19(params, 3), sx = _a2[0], sy = _a2[1], sz = _a2[2];
  return mat4_exports.fromScaling(mat4_exports.create(), [sx, sy, sz]);
};

// node_modules/@antv/coord/esm/coordinate.js
var __read20 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values2 = function(o2) {
  var s4 = typeof Symbol === "function" && Symbol.iterator, m3 = s4 && o2[s4], i2 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate = (
  /** @class */
  function() {
    function Coordinate2(options) {
      this.options = {
        x: 0,
        y: 0,
        width: 300,
        height: 150,
        transformations: []
      };
      this.transformers = {
        cartesian,
        translate: translate5,
        custom: custom10,
        matrix: matrix2,
        polar,
        transpose: transpose5,
        scale: scale9,
        "shear.x": shearX,
        "shear.y": shearY,
        reflect: reflect2,
        "reflect.x": reflectX,
        "reflect.y": reflectY,
        rotate: rotate6,
        helix,
        parallel: parallel2,
        fisheye,
        "fisheye.x": fisheyeX,
        "fisheye.y": fisheyeY,
        "fisheye.circular": fisheyeCircular
      };
      this.update(options);
    }
    Coordinate2.prototype.update = function(options) {
      this.options = deep_mix_default2({}, this.options, options);
      this.recoordinate();
    };
    Coordinate2.prototype.clone = function() {
      return new Coordinate2(this.options);
    };
    Coordinate2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate2.prototype.getSize = function() {
      var _a2 = this.options, width = _a2.width, height = _a2.height;
      return [width, height];
    };
    Coordinate2.prototype.getCenter = function() {
      var _a2 = this.options, x3 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height;
      return [(x3 * 2 + width) / 2, (y4 * 2 + height) / 2];
    };
    Coordinate2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray4(__spreadArray4([], __read20(transformations), false), [__spreadArray4([], __read20(args), false)], false)
      });
      return this;
    };
    Coordinate2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate2.prototype.compose = function(invert5) {
      var e_1, _a2;
      if (invert5 === void 0) {
        invert5 = false;
      }
      var transformations = invert5 ? __spreadArray4([], __read20(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert5 ? function(d4) {
        return d4.untransform;
      } : function(d4) {
        return d4.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add10 = function(transform3, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend3(transform3) : transform3);
      };
      try {
        for (var transformations_1 = __values2(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read20(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x3 = _c.x, y4 = _c.y, width = _c.width, height = _c.height;
            var transformer2 = createTransformer(__spreadArray4([], __read20(args), false), x3, y4, width, height);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert5);
                add10(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform2 = getter(transformer2) || identity_default4;
              add10(transform2, name_1 !== "parallel");
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a2 = transformations_1.return)) _a2.call(transformations_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform2 = this.createMatrixTransform(matrixes, invert5);
        add10(transform2);
      }
      return compose3.apply(void 0, __spreadArray4([], __read20(transforms), false));
    };
    Coordinate2.prototype.createMatrixTransform = function(matrixes, invert5) {
      var matrix3 = mat3_exports.create();
      if (invert5)
        matrixes.reverse();
      matrixes.forEach(function(m3) {
        return mat3_exports.mul(matrix3, matrix3, m3);
      });
      if (invert5) {
        mat3_exports.invert(matrix3, mat3_exports.clone(matrix3));
      }
      return function(vector) {
        var vector3 = [vector[0], vector[1], 1];
        vec3_exports.transformMat3(vector3, vector3, matrix3);
        return [vector3[0], vector3[1]];
      };
    };
    return Coordinate2;
  }()
);

// node_modules/@antv/coord/esm/coordinate3D.js
var __read21 = function(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e3) throw e3.error;
    }
  }
  return ar;
};
var __spreadArray5 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values3 = function(o2) {
  var s4 = typeof Symbol === "function" && Symbol.iterator, m3 = s4 && o2[s4], i2 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Coordinate3D = (
  /** @class */
  function() {
    function Coordinate3D2(options) {
      this.options = {
        x: 0,
        y: 0,
        z: 0,
        width: 300,
        height: 150,
        depth: 150,
        transformations: []
      };
      this.transformers = {
        cartesian3D,
        translate3D,
        scale3D,
        transpose3D
      };
      this.update(options);
    }
    Coordinate3D2.prototype.update = function(options) {
      this.options = deep_mix_default2({}, this.options, options);
      this.recoordinate();
    };
    Coordinate3D2.prototype.clone = function() {
      return new Coordinate3D2(this.options);
    };
    Coordinate3D2.prototype.getOptions = function() {
      return this.options;
    };
    Coordinate3D2.prototype.clear = function() {
      this.update({
        transformations: []
      });
    };
    Coordinate3D2.prototype.getSize = function() {
      var _a2 = this.options, width = _a2.width, height = _a2.height, depth = _a2.depth;
      return [width, height, depth];
    };
    Coordinate3D2.prototype.getCenter = function() {
      var _a2 = this.options, x3 = _a2.x, y4 = _a2.y, z = _a2.z, width = _a2.width, height = _a2.height, depth = _a2.depth;
      return [(x3 * 2 + width) / 2, (y4 * 2 + height) / 2, (z * 2 + depth) / 2];
    };
    Coordinate3D2.prototype.transform = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var transformations = this.options.transformations;
      this.update({
        transformations: __spreadArray5(__spreadArray5([], __read21(transformations), false), [__spreadArray5([], __read21(args), false)], false)
      });
      return this;
    };
    Coordinate3D2.prototype.map = function(vector) {
      return this.output(vector);
    };
    Coordinate3D2.prototype.invert = function(vector) {
      return this.input(vector);
    };
    Coordinate3D2.prototype.recoordinate = function() {
      this.output = this.compose();
      this.input = this.compose(true);
    };
    Coordinate3D2.prototype.compose = function(invert5) {
      var e_1, _a2;
      if (invert5 === void 0) {
        invert5 = false;
      }
      var transformations = invert5 ? __spreadArray5([], __read21(this.options.transformations), false).reverse() : this.options.transformations;
      var getter = invert5 ? function(d4) {
        return d4.untransform;
      } : function(d4) {
        return d4.transform;
      };
      var matrixes = [];
      var transforms = [];
      var add10 = function(transform3, extended) {
        if (extended === void 0) {
          extended = true;
        }
        return transforms.push(extended ? extend3D(transform3) : transform3);
      };
      try {
        for (var transformations_1 = __values3(transformations), transformations_1_1 = transformations_1.next(); !transformations_1_1.done; transformations_1_1 = transformations_1.next()) {
          var _b = __read21(transformations_1_1.value), name_1 = _b[0], args = _b.slice(1);
          var createTransformer = this.transformers[name_1];
          if (createTransformer) {
            var _c = this.options, x3 = _c.x, y4 = _c.y, z = _c.z, width = _c.width, height = _c.height, depth = _c.depth;
            var transformer2 = createTransformer(__spreadArray5([], __read21(args), false), x3, y4, z, width, height, depth);
            if (isMatrix(transformer2)) {
              matrixes.push(transformer2);
            } else {
              if (matrixes.length) {
                var transform_1 = this.createMatrixTransform(matrixes, invert5);
                add10(transform_1);
                matrixes.splice(0, matrixes.length);
              }
              var transform2 = getter(transformer2) || identity_default4;
              add10(transform2, true);
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (transformations_1_1 && !transformations_1_1.done && (_a2 = transformations_1.return)) _a2.call(transformations_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (matrixes.length) {
        var transform2 = this.createMatrixTransform(matrixes, invert5);
        add10(transform2);
      }
      return compose3.apply(void 0, __spreadArray5([], __read21(transforms), false));
    };
    Coordinate3D2.prototype.createMatrixTransform = function(matrixes, invert5) {
      var matrix3 = mat4_exports.create();
      if (invert5)
        matrixes.reverse();
      matrixes.forEach(function(m3) {
        return mat4_exports.mul(matrix3, matrix3, m3);
      });
      if (invert5) {
        mat4_exports.invert(matrix3, mat4_exports.clone(matrix3));
      }
      return function(vector) {
        var vector4 = [vector[0], vector[1], vector[2], 1];
        vec4_exports.transformMat4(vector4, vector4, matrix3);
        return [vector4[0], vector4[1], vector4[2]];
      };
    };
    return Coordinate3D2;
  }()
);

// node_modules/@antv/g2/esm/composition/utils.js
var __rest60 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function useDefaultAdaptor(adaptor33) {
  return (options, ...rest) => deep_mix_default({}, adaptor33(options, ...rest), options);
}
function useOverrideAdaptor(adaptor33) {
  return (options, ...rest) => deep_mix_default({}, options, adaptor33(options, ...rest));
}
function isObject2(d4) {
  if (d4 instanceof Date)
    return false;
  return typeof d4 === "object";
}
function mergeData(dataDescriptor, dataValue) {
  if (!dataDescriptor)
    return dataValue;
  if (Array.isArray(dataDescriptor))
    return dataDescriptor;
  if (isObject2(dataDescriptor)) {
    const { value: value2 = dataValue } = dataDescriptor, rest = __rest60(dataDescriptor, ["value"]);
    return Object.assign(Object.assign({}, rest), { value: value2 });
  }
  return dataDescriptor;
}

// node_modules/@antv/g2/esm/composition/spaceLayer.js
var __rest61 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var SpaceLayer = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { x: viewX = 0, y: viewY = 0, width: viewWidth, height: viewHeight, data: layerData } = options;
    return children.map((_a2) => {
      var { data: data2, x: x3, y: y4, width, height } = _a2, rest = __rest61(_a2, ["data", "x", "y", "width", "height"]);
      return Object.assign(Object.assign({}, rest), { data: mergeData(data2, layerData), x: x3 !== null && x3 !== void 0 ? x3 : viewX, y: y4 !== null && y4 !== void 0 ? y4 : viewY, width: width !== null && width !== void 0 ? width : viewWidth, height: height !== null && height !== void 0 ? height : viewHeight });
    });
  };
};
SpaceLayer.props = {};

// node_modules/@antv/g2/esm/composition/spaceFlex.js
var __rest62 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var SpaceFlex = () => {
  return (options) => {
    const { children } = options;
    if (!Array.isArray(children))
      return [];
    const { direction: direction3 = "row", ratio = children.map(() => 1), padding = 0, data: flexData } = options;
    const [mainStart, mainSize, crossSize, crossStart] = direction3 === "col" ? ["y", "height", "width", "x"] : ["x", "width", "height", "y"];
    const sum4 = ratio.reduce((total, value2) => total + value2);
    const totalSize = options[mainSize] - padding * (children.length - 1);
    const sizes = ratio.map((value2) => totalSize * (value2 / sum4));
    const newChildren = [];
    let next = options[mainStart] || 0;
    for (let i2 = 0; i2 < sizes.length; i2 += 1) {
      const _a2 = children[i2], { data: data2 } = _a2, rest = __rest62(_a2, ["data"]);
      const newData = mergeData(data2, flexData);
      newChildren.push(Object.assign({ [mainStart]: next, [mainSize]: sizes[i2], [crossStart]: options[crossStart] || 0, [crossSize]: options[crossSize], data: newData }, rest));
      next += sizes[i2] + padding;
    }
    return newChildren;
  };
};
SpaceFlex.props = {};

// node_modules/@antv/g2/esm/composition/view.js
var __rest63 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var View = () => {
  return (options) => {
    const { children } = options, restOptions = __rest63(options, ["children"]);
    if (!Array.isArray(children))
      return [];
    const { data: viewData, scale: viewScale = {}, axis: viewAxis = {}, legend: viewLegend = {}, encode: viewEncode = {}, transform: viewTransform = [] } = restOptions, rest = __rest63(restOptions, ["data", "scale", "axis", "legend", "encode", "transform"]);
    const marks = children.map((_a2) => {
      var { data: data2, scale: scale12 = {}, axis = {}, legend = {}, encode = {}, transform: transform2 = [] } = _a2, rest2 = __rest63(_a2, ["data", "scale", "axis", "legend", "encode", "transform"]);
      return Object.assign({ data: mergeData(data2, viewData), scale: deep_mix_default({}, viewScale, scale12), encode: deep_mix_default({}, viewEncode, encode), transform: [...viewTransform, ...transform2], axis: axis && viewAxis ? deep_mix_default({}, viewAxis, axis) : false, legend: legend && viewLegend ? deep_mix_default({}, viewLegend, legend) : false }, rest2);
    });
    return [Object.assign(Object.assign({}, rest), { marks, type: "standardView" })];
  };
};
View.props = {};

// node_modules/@antv/g2/esm/composition/mark.js
var __rest64 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Mark = ({ static: isStatic = false } = {}) => {
  return (options) => {
    const { width, height, depth, paddingLeft, paddingRight, paddingTop, paddingBottom, padding, inset, insetLeft, insetTop, insetRight, insetBottom, margin, marginLeft, marginBottom, marginTop, marginRight, data: data2, coordinate, theme, component, interaction, x: x3, y: y4, z, key, frame: frame2, labelTransform, parentKey, clip, viewStyle, title } = options, mark2 = __rest64(options, ["width", "height", "depth", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "padding", "inset", "insetLeft", "insetTop", "insetRight", "insetBottom", "margin", "marginLeft", "marginBottom", "marginTop", "marginRight", "data", "coordinate", "theme", "component", "interaction", "x", "y", "z", "key", "frame", "labelTransform", "parentKey", "clip", "viewStyle", "title"]);
    return [
      Object.assign(Object.assign({
        type: "standardView",
        x: x3,
        y: y4,
        z,
        key,
        width,
        height,
        depth,
        padding,
        paddingLeft,
        paddingRight,
        paddingTop,
        inset,
        insetLeft,
        insetTop,
        insetRight,
        insetBottom,
        paddingBottom,
        theme,
        coordinate,
        component,
        interaction,
        frame: frame2,
        labelTransform,
        margin,
        marginLeft,
        marginBottom,
        marginTop,
        marginRight,
        parentKey,
        clip,
        style: viewStyle
      }, !isStatic && { title }), { marks: [Object.assign(Object.assign(Object.assign({}, mark2), { key: `${key}-0`, data: data2 }), isStatic && { title })] })
    ];
  };
};
Mark.props = {};

// node_modules/@antv/g2/esm/utils/container.js
var Container = class _Container {
  constructor(x3) {
    this.$value = x3;
  }
  static of(x3) {
    return new _Container(x3);
  }
  call(f2, ...rest) {
    return this.$value = f2(this.$value, ...rest), this;
  }
  value() {
    return this.$value;
  }
};

// node_modules/@antv/g2/esm/composition/facetRect.js
var __rest65 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var setScale = useDefaultAdaptor((options) => {
  const { encode, data: data2, scale: scale12, shareSize = false } = options;
  const { x: x3, y: y4 } = encode;
  const flexDomain = (encode2, channel) => {
    var _a2;
    if (encode2 === void 0 || !shareSize)
      return {};
    const groups2 = group(data2, (d4) => d4[encode2]);
    const domain = ((_a2 = scale12 === null || scale12 === void 0 ? void 0 : scale12[channel]) === null || _a2 === void 0 ? void 0 : _a2.domain) || Array.from(groups2.keys());
    const flex2 = domain.map((key) => {
      if (!groups2.has(key))
        return 1;
      return groups2.get(key).length;
    });
    return { domain, flex: flex2 };
  };
  return {
    scale: {
      x: Object.assign(Object.assign({ paddingOuter: 0, paddingInner: 0.1, guide: x3 === void 0 ? null : { position: "top" } }, x3 === void 0 && { paddingInner: 0 }), flexDomain(x3, "x")),
      y: Object.assign(Object.assign({ range: [0, 1], paddingOuter: 0, paddingInner: 0.1, guide: y4 === void 0 ? null : { position: "right" } }, y4 === void 0 && { paddingInner: 0 }), flexDomain(y4, "y"))
    }
  };
});
var inferColor = useOverrideAdaptor((options) => {
  const { data: data2, scale: scale12, legend } = options;
  const discovered = [options];
  let encodeColor;
  let scaleColor;
  let legendColor;
  while (discovered.length) {
    const node = discovered.shift();
    const { children, encode = {}, scale: scale13 = {}, legend: legend2 = {} } = node;
    const { color: c6 } = encode;
    const { color: cs } = scale13;
    const { color: cl } = legend2;
    if (c6 !== void 0)
      encodeColor = c6;
    if (cs !== void 0)
      scaleColor = cs;
    if (cl !== void 0)
      legendColor = cl;
    if (Array.isArray(children)) {
      discovered.push(...children);
    }
  }
  const domainColor = () => {
    var _a2;
    const domain2 = (_a2 = scale12 === null || scale12 === void 0 ? void 0 : scale12.color) === null || _a2 === void 0 ? void 0 : _a2.domain;
    if (domain2 !== void 0)
      return [domain2];
    if (encodeColor === void 0)
      return [void 0];
    const color3 = typeof encodeColor === "function" ? encodeColor : (d4) => d4[encodeColor];
    const values4 = data2.map(color3);
    if (values4.some((d4) => typeof d4 === "number"))
      return [extent(values4)];
    return [Array.from(new Set(values4)), "ordinal"];
  };
  const title = typeof encodeColor === "string" ? encodeColor : "";
  const [domain, type] = domainColor();
  return Object.assign({ encode: { color: { type: "column", value: domain !== null && domain !== void 0 ? domain : [] } }, scale: { color: deep_mix_default({}, scaleColor, { domain, type }) } }, legend === void 0 && {
    legend: { color: deep_mix_default({ title }, legendColor) }
  });
});
var setAnimation = useDefaultAdaptor(() => ({
  animate: {
    enterType: "fadeIn"
  }
}));
var setStyle = useOverrideAdaptor(() => ({
  frame: false,
  encode: {
    shape: "hollow"
  },
  style: {
    lineWidth: 0
  }
}));
var toCell = useOverrideAdaptor(() => ({
  type: "cell"
}));
var setData = useOverrideAdaptor((options) => {
  const { data: data2 } = options;
  const connector = {
    type: "custom",
    callback: () => {
      const { data: data3, encode } = options;
      const { x: x3, y: y4 } = encode;
      const X = x3 ? Array.from(new Set(data3.map((d4) => d4[x3]))) : [];
      const Y = y4 ? Array.from(new Set(data3.map((d4) => d4[y4]))) : [];
      const cellData = () => {
        if (X.length && Y.length) {
          const cellData2 = [];
          for (const vx of X) {
            for (const vy of Y) {
              cellData2.push({ [x3]: vx, [y4]: vy });
            }
          }
          return cellData2;
        }
        if (X.length)
          return X.map((d4) => ({ [x3]: d4 }));
        if (Y.length)
          return Y.map((d4) => ({ [y4]: d4 }));
      };
      return cellData();
    }
  };
  return {
    data: { type: "inline", value: data2, transform: [connector] }
  };
});
var setChildren = useOverrideAdaptor((options, subLayout = subLayoutRect, createGuideX2 = createGuideXRect, createGuideY2 = createGuideYRect, childOptions = {}) => {
  const { data: dataValue, encode, children, scale: facetScale, x: originX = 0, y: originY = 0, shareData = false, key: viewKey } = options;
  const { value: data2 } = dataValue;
  const { x: encodeX, y: encodeY } = encode;
  const { color: facetScaleColor } = facetScale;
  const { domain: facetDomainColor } = facetScaleColor;
  const createChildren = (visualData, scale12, layout) => {
    const { x: scaleX2, y: scaleY2 } = scale12;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX2.getOptions();
    const { domain: domainY } = scaleY2.getOptions();
    const index3 = indexOf3(visualData);
    const bboxs = visualData.map(subLayout);
    const values4 = visualData.map(({ x: x3, y: y4 }) => [
      scaleX2.invert(x3),
      scaleY2.invert(y4)
    ]);
    const filters = values4.map(([fx, fy]) => (d4) => {
      const { [encodeX]: x3, [encodeY]: y4 } = d4;
      const inX = encodeX !== void 0 ? x3 === fx : true;
      const inY = encodeY !== void 0 ? y4 === fy : true;
      return inX && inY;
    });
    const facetData2d = filters.map((f2) => data2.filter(f2));
    const maxDataDomain = shareData ? max5(facetData2d, (data3) => data3.length) : void 0;
    const facets = values4.map(([fx, fy]) => ({
      columnField: encodeX,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: encodeY,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index3.flatMap((i2) => {
      const [left2, top, width, height] = bboxs[i2];
      const facet = facets[i2];
      const facetData = facetData2d[i2];
      const children2 = normalizedChildren[i2];
      return children2.map((_a2) => {
        var _b, _c;
        var { scale: scale13, key, facet: isFacet = true, axis = {}, legend = {} } = _a2, rest = __rest65(_a2, ["scale", "key", "facet", "axis", "legend"]);
        const guideY = ((_b = scale13 === null || scale13 === void 0 ? void 0 : scale13.y) === null || _b === void 0 ? void 0 : _b.guide) || axis.y;
        const guideX = ((_c = scale13 === null || scale13 === void 0 ? void 0 : scale13.x) === null || _c === void 0 ? void 0 : _c.guide) || axis.x;
        const defaultScale = {
          x: { tickCount: encodeX ? 5 : void 0 },
          y: { tickCount: encodeY ? 5 : void 0 }
        };
        const newData = isFacet ? facetData : facetData.length === 0 ? [] : data2;
        const newScale = {
          color: { domain: facetDomainColor }
        };
        const newAxis = {
          x: createGuide(guideX, createGuideX2)(facet, newData),
          y: createGuide(guideY, createGuideY2)(facet, newData)
        };
        return Object.assign(Object.assign({
          key: `${key}-${i2}`,
          data: newData,
          margin: 0,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          parentKey: viewKey,
          width,
          height,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: newData.length ? true : false,
          dataDomain: maxDataDomain,
          scale: deep_mix_default(defaultScale, scale13, newScale),
          axis: deep_mix_default({}, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false
        }, rest), childOptions);
      });
    });
  };
  return {
    children: createChildren
  };
});
function subLayoutRect(data2) {
  const { points } = data2;
  return calcBBox(points);
}
function createInnerGuide(guide, data2) {
  return data2.length ? deep_mix_default({
    title: false,
    tick: null,
    label: null
  }, guide) : deep_mix_default({
    title: false,
    tick: null,
    label: null,
    grid: null
  }, guide);
}
function createGuideXRect(guide) {
  return (facet, data2) => {
    const { rowIndex, rowValuesLength, columnIndex, columnValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guide, data2);
    const title = columnIndex !== columnValuesLength - 1 ? false : void 0;
    const grid2 = data2.length ? void 0 : null;
    return deep_mix_default({ title, grid: grid2 }, guide);
  };
}
function createGuideYRect(guide) {
  return (facet, data2) => {
    const { rowIndex, columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guide, data2);
    const title = rowIndex !== 0 ? false : void 0;
    const grid2 = data2.length ? void 0 : null;
    return deep_mix_default({ title, grid: grid2 }, guide);
  };
}
function createGuide(guide, factory) {
  if (typeof guide === "function")
    return guide;
  if (guide === null || guide === false)
    return () => null;
  return factory(guide);
}
var FacetRect = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setAnimation).call(setScale).call(setStyle).call(setData).call(setChildren).value();
    return [newOptions];
  };
};
FacetRect.props = {};

// node_modules/@antv/g2/esm/composition/repeatMatrix.js
var __rest66 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var setScale2 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: null, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setChildren2 = useOverrideAdaptor((options) => {
  const { data: data2, children, x: originX = 0, y: originY = 0, key: viewKey } = options;
  const createChildren = (visualData, scale12, layout) => {
    const { x: scaleX2, y: scaleY2 } = scale12;
    const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
    const { domain: domainX } = scaleX2.getOptions();
    const { domain: domainY } = scaleY2.getOptions();
    const index3 = indexOf3(visualData);
    const bboxs = visualData.map(({ points }) => calcBBox(points));
    const values4 = visualData.map(({ x: x3, y: y4 }) => [
      scaleX2.invert(x3),
      scaleY2.invert(y4)
    ]);
    const facets = values4.map(([fx, fy]) => ({
      columnField: fx,
      columnIndex: domainX.indexOf(fx),
      columnValue: fx,
      columnValuesLength: domainX.length,
      rowField: fy,
      rowIndex: domainY.indexOf(fy),
      rowValue: fy,
      rowValuesLength: domainY.length
    }));
    const normalizedChildren = facets.map((facet) => {
      if (Array.isArray(children))
        return children;
      return [children(facet)].flat(1);
    });
    return index3.flatMap((i2) => {
      const [left2, top, width, height] = bboxs[i2];
      const [fx, fy] = values4[i2];
      const facet = facets[i2];
      const children2 = normalizedChildren[i2];
      return children2.map((d4) => {
        var _a2, _b;
        const { scale: scale13, key, encode, axis, interaction } = d4, rest = __rest66(d4, ["scale", "key", "encode", "axis", "interaction"]);
        const guideY = (_a2 = scale13 === null || scale13 === void 0 ? void 0 : scale13.y) === null || _a2 === void 0 ? void 0 : _a2.guide;
        const guideX = (_b = scale13 === null || scale13 === void 0 ? void 0 : scale13.x) === null || _b === void 0 ? void 0 : _b.guide;
        const defaultScale = {
          // Do not sync position scales among facets by default.
          x: { facet: false },
          // Do not sync position scales among facets by default.
          y: { facet: false }
        };
        const newAxis = {
          x: createGuideX(guideX)(facet, data2),
          y: createGuideY(guideY)(facet, data2)
        };
        const defaultAxis = {
          x: { tickCount: 5 },
          y: { tickCount: 5 }
        };
        return Object.assign({
          data: data2,
          parentKey: viewKey,
          key: `${key}-${i2}`,
          x: left2 + paddingLeft + originX + marginLeft,
          y: top + paddingTop + originY + marginTop,
          width,
          height,
          margin: 0,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          paddingBottom: 0,
          frame: true,
          scale: deep_mix_default(defaultScale, scale13),
          axis: deep_mix_default(defaultAxis, axis, newAxis),
          // Hide all legends for child mark by default,
          // they are displayed in the top-level.
          legend: false,
          encode: deep_mix_default({}, encode, {
            x: fx,
            y: fy
          }),
          interaction: deep_mix_default({}, interaction, {
            // Register this interaction in parent node.
            legendFilter: false
          })
        }, rest);
      });
    });
  };
  return {
    children: createChildren
  };
});
var setData2 = useOverrideAdaptor((options) => {
  const { encode } = options, rest = __rest66(options, ["encode"]);
  const { position: P = [], x: X = P, y: Y = [...P].reverse() } = encode, restEncode = __rest66(encode, ["position", "x", "y"]);
  const data2 = [];
  for (const $x of [X].flat(1)) {
    for (const $y of [Y].flat(1)) {
      data2.push({ $x, $y });
    }
  }
  return Object.assign(Object.assign({}, rest), { data: data2, encode: Object.assign(Object.assign({}, restEncode), { x: "$x", y: "$y" }), scale: Object.assign(Object.assign({}, [X].flat(1).length === 1 && { x: { paddingInner: 0 } }), [Y].flat(1).length === 1 && { y: { paddingInner: 0 } }) });
});
function createGuideX(guideX) {
  if (typeof guideX === "function")
    return guideX;
  if (guideX === null)
    return () => null;
  return (facet, data2) => {
    const { rowIndex, rowValuesLength } = facet;
    if (rowIndex !== rowValuesLength - 1)
      return createInnerGuide(guideX, data2);
  };
}
function createGuideY(guideY) {
  if (typeof guideY === "function")
    return guideY;
  if (guideY === null)
    return () => null;
  return (facet, data2) => {
    const { columnIndex } = facet;
    if (columnIndex !== 0)
      return createInnerGuide(guideY, data2);
  };
}
var RepeatMatrix = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(inferColor).call(setChildren2).call(setData2).call(setAnimation).call(setStyle).call(setScale2).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/facetCircle.js
var __rest67 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var setScale3 = useDefaultAdaptor((options) => {
  return {
    scale: {
      x: { guide: { type: "axisArc" }, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  };
});
var setCoordinate = useDefaultAdaptor((options) => {
  return {
    coordinate: { type: "polar" }
  };
});
var setEncode = (options) => {
  const { encode } = options, rest = __rest67(options, ["encode"]);
  const { position } = encode;
  return Object.assign(Object.assign({}, rest), { encode: { x: position } });
};
function createGuideFacetCircle(guide) {
  return (facet) => null;
}
function subLayoutFacetCircle(data2) {
  const { points } = data2;
  const [p0, p1, p22, p3] = points;
  const sr = dist4(p0, p3);
  const v0 = sub6(p0, p3);
  const v1 = sub6(p1, p22);
  const a01 = angleBetween2(v0, v1);
  const t = 1 / Math.sin(a01 / 2);
  const ir = sr / (1 + t);
  const s4 = ir * Math.sqrt(2);
  const [x05, y05] = p22;
  const a0 = angleWithQuadrant(v0);
  const a32 = a0 + a01 / 2;
  const d4 = ir * t;
  const cx = x05 + d4 * Math.sin(a32);
  const cy = y05 - d4 * Math.cos(a32);
  return [cx - s4 / 2, cy - s4 / 2, s4, s4];
}
var FacetCircle = () => {
  return (options) => {
    const newOptions = Container.of(options).call(toCell).call(setEncode).call(inferColor).call(setCoordinate).call(setData).call(setChildren, subLayoutFacetCircle, createGuideFacetCircle, createGuideFacetCircle, { frame: false }).call(setAnimation).call(setStyle).call(setScale3).value();
    return [newOptions];
  };
};

// node_modules/@antv/g2/esm/composition/timingKeyframe.js
function range2(direction3, iterationCount, keyframeCount) {
  const start = 0;
  const end = keyframeCount;
  const normal = [start, end];
  const reverse2 = [-end + 1, -start + 1];
  if (direction3 === "normal")
    return normal;
  if (direction3 === "reverse")
    return reverse2;
  if (direction3 === "alternate") {
    return iterationCount % 2 === 0 ? normal : reverse2;
  }
  if (direction3 === "reverse-alternate") {
    return iterationCount % 2 === 0 ? reverse2 : normal;
  }
}
function setAnimation2(node, duration, easing) {
  const discovered = [node];
  while (discovered.length) {
    const n2 = discovered.pop();
    n2.animate = deep_mix_default({
      enter: {
        duration
      },
      update: {
        duration,
        easing,
        type: "morphing",
        fill: "both"
      },
      exit: {
        type: "fadeOut",
        duration
      }
    }, n2.animate || {});
    const { children } = n2;
    if (Array.isArray(children))
      discovered.push(...children);
  }
  return node;
}
var TimingKeyframe = () => {
  return (options) => {
    const { children = [], duration = 1e3, iterationCount = 1, direction: direction3 = "normal", easing = "ease-in-out-sine" } = options;
    const n2 = children.length;
    if (!Array.isArray(children) || n2 === 0)
      return [];
    const { key } = children[0];
    const newChildren = children.map((d4) => Object.assign(Object.assign({}, d4), { key })).map((d4) => setAnimation2(d4, duration, easing));
    return function* () {
      let count4 = 0;
      let prevIndex;
      while (iterationCount === "infinite" || count4 < iterationCount) {
        const [start, end] = range2(direction3, count4, n2);
        for (let i2 = start; i2 < end; i2 += 1) {
          const index3 = Math.abs(i2);
          if (prevIndex !== index3)
            yield newChildren[index3];
          prevIndex = index3;
        }
        count4++;
      }
    };
  };
};
TimingKeyframe.props = {};

// node_modules/@antv/g2/esm/composition/geoPath.js
var __rest68 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var GeoPath = () => {
  return (options) => {
    const { type, data: data2, scale: scale12, encode, style, animate: animate2, key, state, tooltip: tooltip2 } = options, rest = __rest68(options, ["type", "data", "scale", "encode", "style", "animate", "key", "state", "tooltip"]);
    return [
      Object.assign(Object.assign({ type: "geoView" }, rest), { children: [
        {
          type: "geoPath",
          key: `${key}-0`,
          data: {
            value: data2
          },
          scale: scale12,
          encode,
          style,
          animate: animate2,
          state,
          tooltip: tooltip2
        }
      ] })
    ];
  };
};
GeoPath.props = {};

// node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil4 = Math.ceil;
var exp2 = Math.exp;
var log = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x3) {
  return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos2(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi3 : Math.acos(x3);
}
function asin2(x3) {
  return x3 > 1 ? halfPi2 : x3 < -1 ? -halfPi2 : Math.asin(x3);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i2 = -1, n2 = features.length;
    while (++i2 < n2) streamGeometry(features[i2].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) object = coordinates[i2], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) streamLine(coordinates[i2], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i2 = -1, n2 = coordinates.length;
    while (++i2 < n2) streamPolygon(coordinates[i2], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i2 = -1, n2 = geometries.length;
    while (++i2 < n2) streamGeometry(geometries[i2], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i2 = -1, n2 = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i2 < n2) coordinate = coordinates[i2], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i2 = -1, n2 = coordinates.length;
  stream.polygonStart();
  while (++i2 < n2) streamLine(coordinates[i2], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian3) {
  return [atan22(cartesian3[1], cartesian3[0]), asin2(cartesian3[2])];
}
function cartesian2(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a5, b) {
  return a5[0] * b[0] + a5[1] * b[1] + a5[2] * b[2];
}
function cartesianCross(a5, b) {
  return [a5[1] * b[2] - a5[2] * b[1], a5[2] * b[0] - a5[0] * b[2], a5[0] * b[1] - a5[1] * b[0]];
}
function cartesianAddInPlace(a5, b) {
  a5[0] += b[0], a5[1] += b[1], a5[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d4) {
  var l2 = sqrt2(d4[0] * d4[0] + d4[1] * d4[1] + d4[2] * d4[2]);
  d4[0] /= l2, d4[1] /= l2, d4[2] /= l2;
}

// node_modules/d3-geo/src/compose.js
function compose_default(a5, b) {
  function compose4(x3, y4) {
    return x3 = a5(x3, y4), b(x3[0], x3[1]);
  }
  if (a5.invert && b.invert) compose4.invert = function(x3, y4) {
    return x3 = b.invert(x3, y4), x3 && a5.invert(x3[0], x3[1]);
  };
  return compose4;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaPhi + x3 * sinDeltaPhi;
    return [
      atan22(y4 * cosDeltaGamma - k2 * sinDeltaGamma, x3 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k2 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y4 = sin2(lambda) * cosPhi, z = sin2(phi2), k2 = z * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan22(y4 * cosDeltaGamma + z * sinDeltaGamma, x3 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin2(k2 * cosDeltaPhi - x3 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate7) {
  rotate7 = rotateRadians(rotate7[0] * radians, rotate7[1] * radians, rotate7.length > 2 ? rotate7[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate7(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate7.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction3, t02, t12) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step2 = direction3 * delta;
  if (t02 == null) {
    t02 = radius + direction3 * tau3;
    t12 = radius - step2 / 2;
  } else {
    t02 = circleRadius(cosRadius, t02);
    t12 = circleRadius(cosRadius, t12);
    if (direction3 > 0 ? t02 < t12 : t02 > t12) t02 += direction3 * tau3;
  }
  for (var point7, t = t02; direction3 > 0 ? t > t12 : t < t12; t -= step2) {
    point7 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream.point(point7[0], point7[1]);
  }
}
function circleRadius(cosRadius, point7) {
  point7 = cartesian2(point7), point7[0] -= cosRadius;
  cartesianNormalizeInPlace(point7);
  var radius = acos2(-point7[1]);
  return ((-point7[2] < 0 ? -radius : radius) + tau3 - epsilon3) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line4;
  return {
    point: function(x3, y4, m3) {
      line4.push([x3, y4, m3]);
    },
    lineStart: function() {
      lines.push(line4 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line4 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a5, b) {
  return abs2(a5[0] - b[0]) < epsilon3 && abs2(a5[1] - b[1]) < epsilon3;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point7, points, other, entry) {
  this.x = point7;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate4, stream) {
  var subject = [], clip = [], i2, n2;
  segments.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0) return;
    var n3, p0 = segment[0], p1 = segment[n3], x3;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i2 = 0; i2 < n3; ++i2) stream.point((p0 = segment[i2])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x3 = new Intersection(p0, segment, null, true));
    clip.push(x3.o = new Intersection(p0, null, x3, false));
    subject.push(x3 = new Intersection(p1, segment, null, false));
    clip.push(x3.o = new Intersection(p1, null, x3, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link2(subject);
  link2(clip);
  for (i2 = 0, n2 = clip.length; i2 < n2; ++i2) {
    clip[i2].e = startInside = !startInside;
  }
  var start = subject[0], points, point7;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i2 = 0, n2 = points.length; i2 < n2; ++i2) stream.point((point7 = points[i2])[0], point7[1]);
        } else {
          interpolate4(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i2 = points.length - 1; i2 >= 0; --i2) stream.point((point7 = points[i2])[0], point7[1]);
        } else {
          interpolate4(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array2) {
  if (!(n2 = array2.length)) return;
  var n2, i2 = 0, a5 = array2[0], b;
  while (++i2 < n2) {
    a5.n = b = array2[i2];
    b.p = a5;
    a5 = b;
  }
  a5.n = b = array2[0];
  b.p = a5;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point7) {
  return abs2(point7[0]) <= pi3 ? point7[0] : sign2(point7[0]) * ((abs2(point7[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point7) {
  var lambda = longitude(point7), phi2 = point7[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle4 = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1) phi2 = halfPi2 + epsilon3;
  else if (sinPhi === -1) phi2 = -halfPi2 - epsilon3;
  for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
    if (!(m3 = (ring = polygon[i2]).length)) continue;
    var ring, m3, point0 = ring[m3 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j = 0; j < m3; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum4.add(atan22(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos2(absDelta)));
      angle4 += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian2(point0), cartesian2(point1));
        cartesianNormalizeInPlace(arc);
        var intersection3 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection3);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection3[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle4 < -epsilon3 || angle4 < epsilon3 && sum4 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate4, start) {
  return function(sink) {
    var line4 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point7;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate4, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate4(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate4(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point7(lambda, phi2) {
      if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line4.point(lambda, phi2);
    }
    function lineStart() {
      clip.point = pointLine;
      line4.lineStart();
    }
    function lineEnd() {
      clip.point = point7;
      line4.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i2, n2 = ringSegments.length, m3, segment, point8;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i2 = 0; i2 < m3; ++i2) sink.point((point8 = segment[i2])[0], point8[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a5, b) {
  return ((a5 = a5.x)[0] < 0 ? a5[1] - halfPi2 - epsilon3 : halfPi2 - a5[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon3 : halfPi2 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon3) lambda0 -= sign0 * epsilon3;
        if (abs2(lambda1 - sign1) < epsilon3) lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction3, stream) {
  var phi2;
  if (from == null) {
    phi2 = direction3 * halfPi2;
    stream.point(-pi3, phi2);
    stream.point(0, phi2);
    stream.point(pi3, phi2);
    stream.point(pi3, 0);
    stream.point(pi3, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi3, -phi2);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction3 * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos2(radius), delta = 2 * radians, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate4(from, to, direction3, stream) {
    circleStream(stream, radius, delta, direction3, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c6 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point22 = intersect4(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point22 = intersect4(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect4(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c6 & c0) && (t = intersect4(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c6;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect4(a5, b, two) {
    var pa = cartesian2(a5), pb = cartesian2(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant3 = n2n2 - n1n2 * n1n2;
    if (!determinant3) return !two && a5;
    var c1 = cr * n2n2 / determinant3, c22 = -cr * n1n2 / determinant3, n1xn2 = cartesianCross(n1, n2), A6 = cartesianScale(n1, c1), B4 = cartesianScale(n2, c22);
    cartesianAddInPlace(A6, B4);
    var u2 = n1xn2, w2 = cartesianDot(A6, u2), uu = cartesianDot(u2, u2), t22 = w2 * w2 - uu * (cartesianDot(A6, A6) - 1);
    if (t22 < 0) return;
    var t = sqrt2(t22), q = cartesianScale(u2, (-w2 - t) / uu);
    cartesianAddInPlace(q, A6);
    q = spherical(q);
    if (!two) return q;
    var lambda0 = a5[0], lambda1 = b[0], phi0 = a5[1], phi1 = b[1], z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar2 = abs2(delta2 - pi3) < epsilon3, meridian = polar2 || delta2 < epsilon3;
    if (!polar2 && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar2 ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q12 = cartesianScale(u2, (-w2 + t) / uu);
      cartesianAddInPlace(q12, A6);
      return [q, spherical(q12)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r2) code2 |= 1;
    else if (lambda > r2) code2 |= 2;
    if (phi2 < -r2) code2 |= 4;
    else if (phi2 > r2) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate4, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a5, b, x05, y05, x12, y12) {
  var ax = a5[0], ay = a5[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x05 - ax;
  if (!dx && r2 > 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t02) return;
    if (r2 < t12) t12 = r2;
  } else if (dx > 0) {
    if (r2 > t12) return;
    if (r2 > t02) t02 = r2;
  }
  r2 = x12 - ax;
  if (!dx && r2 < 0) return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t12) return;
    if (r2 > t02) t02 = r2;
  } else if (dx > 0) {
    if (r2 < t02) return;
    if (r2 < t12) t12 = r2;
  }
  r2 = y05 - ay;
  if (!dy && r2 > 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t02) return;
    if (r2 < t12) t12 = r2;
  } else if (dy > 0) {
    if (r2 > t12) return;
    if (r2 > t02) t02 = r2;
  }
  r2 = y12 - ay;
  if (!dy && r2 < 0) return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t12) return;
    if (r2 > t02) t02 = r2;
  } else if (dy > 0) {
    if (r2 < t02) return;
    if (r2 < t12) t12 = r2;
  }
  if (t02 > 0) a5[0] = ax + t02 * dx, a5[1] = ay + t02 * dy;
  if (t12 < 1) b[0] = ax + t12 * dx, b[1] = ay + t12 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x12, y12) {
  function visible(x3, y4) {
    return x05 <= x3 && x3 <= x12 && y05 <= y4 && y4 <= y12;
  }
  function interpolate4(from, to, direction3, stream) {
    var a5 = 0, a1 = 0;
    if (from == null || (a5 = corner(from, direction3)) !== (a1 = corner(to, direction3)) || comparePoint(from, to) < 0 ^ direction3 > 0) {
      do
        stream.point(a5 === 0 || a5 === 3 ? x05 : x12, a5 > 1 ? y12 : y05);
      while ((a5 = (a5 + direction3 + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p3, direction3) {
    return abs2(p3[0] - x05) < epsilon3 ? direction3 > 0 ? 0 : 3 : abs2(p3[0] - x12) < epsilon3 ? direction3 > 0 ? 2 : 1 : abs2(p3[1] - y05) < epsilon3 ? direction3 > 0 ? 1 : 0 : direction3 > 0 ? 3 : 2;
  }
  function compareIntersection2(a5, b) {
    return comparePoint(a5.x, b.x);
  }
  function comparePoint(a5, b) {
    var ca = corner(a5, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a5[1] : ca === 1 ? a5[0] - b[0] : ca === 2 ? a5[1] - b[1] : b[0] - a5[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
    var clipStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point7(x3, y4) {
      if (visible(x3, y4)) activeStream.point(x3, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i2 = 0, n2 = polygon.length; i2 < n2; ++i2) {
        for (var ring2 = polygon[i2], j = 1, m3 = ring2.length, point8 = ring2[0], a0, a1, b0 = point8[0], b1 = point8[1]; j < m3; ++j) {
          a0 = b0, a1 = b1, point8 = ring2[j], b0 = point8[0], b1 = point8[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate4(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate4, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first3 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point7;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x3, y4) {
      var v = visible(x3, y4);
      if (polygon) ring.push([x3, y4]);
      if (first3) {
        x__ = x3, y__ = y4, v__ = v;
        first3 = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x3, y4);
        }
      } else {
        if (v && v_) activeStream.point(x3, y4);
        else {
          var a5 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];
          if (line_default2(a5, b, x05, y05, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a5[0], a5[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x3, y4);
            clean = false;
          }
        }
      }
      x_ = x3, y_ = y4, v_ = v;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y05, y12, dy) {
  var y4 = range(y05, y12 - epsilon3, dy).concat(y12);
  return function(x3) {
    return y4.map(function(y5) {
      return [x3, y5];
    });
  };
}
function graticuleY(x05, x12, dx) {
  var x3 = range(x05, x12 - epsilon3, dx).concat(x12);
  return function(y4) {
    return x3.map(function(x4) {
      return [x4, y4];
    });
  };
}
function graticule() {
  var x12, x05, X12, X02, y12, y05, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x3, y4, X, Y, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil4(X02 / DX) * DX, X12, DX).map(X).concat(range(ceil4(Y02 / DY) * DY, Y12, DY).map(Y)).concat(range(ceil4(x05 / dx) * dx, x12, dx).filter(function(x4) {
      return abs2(x4 % DX) > epsilon3;
    }).map(x3)).concat(range(ceil4(y05 / dy) * dy, y12, dy).filter(function(y5) {
      return abs2(y5 % DY) > epsilon3;
    }).map(y4));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X02).concat(
          Y(Y12).slice(1),
          X(X12).reverse().slice(1),
          Y(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_2) {
    if (!arguments.length) return graticule2.extentMinor();
    return graticule2.extentMajor(_2).extentMinor(_2);
  };
  graticule2.extentMajor = function(_2) {
    if (!arguments.length) return [[X02, Y02], [X12, Y12]];
    X02 = +_2[0][0], X12 = +_2[1][0];
    Y02 = +_2[0][1], Y12 = +_2[1][1];
    if (X02 > X12) _2 = X02, X02 = X12, X12 = _2;
    if (Y02 > Y12) _2 = Y02, Y02 = Y12, Y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_2) {
    if (!arguments.length) return [[x05, y05], [x12, y12]];
    x05 = +_2[0][0], x12 = +_2[1][0];
    y05 = +_2[0][1], y12 = +_2[1][1];
    if (x05 > x12) _2 = x05, x05 = x12, x12 = _2;
    if (y05 > y12) _2 = y05, y05 = y12, y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_2) {
    if (!arguments.length) return graticule2.stepMinor();
    return graticule2.stepMajor(_2).stepMinor(_2);
  };
  graticule2.stepMajor = function(_2) {
    if (!arguments.length) return [DX, DY];
    DX = +_2[0], DY = +_2[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_2) {
    if (!arguments.length) return [dx, dy];
    dx = +_2[0], dy = +_2[1];
    return graticule2;
  };
  graticule2.precision = function(_2) {
    if (!arguments.length) return precision;
    precision = +_2;
    x3 = graticuleX(y05, y12, 90);
    y4 = graticuleY(x05, x12, precision);
    X = graticuleX(Y02, Y12, 90);
    Y = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon3], [180, 90 - epsilon3]]).extentMinor([[-180, -80 - epsilon3], [180, 80 + epsilon3]]);
}
function graticule10() {
  return graticule()();
}

// node_modules/d3-geo/src/identity.js
var identity_default5 = (x3) => x3;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream2 = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area2 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area2;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x3, y4) {
  areaStream2.point = areaPoint;
  x00 = x0 = x3, y00 = y0 = y4;
}
function areaPoint(x3, y4) {
  areaRingSum2.add(y0 * x3 - x0 * y4);
  x0 = x3, y0 = y4;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x3, y4) {
  if (x3 < x02) x02 = x3;
  if (x3 > x1) x1 = x3;
  if (y4 < y02) y02 = y4;
  if (y4 > y1) y1 = y4;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x3, y4) {
  X0 += x3;
  Y0 += y4;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x3, y4) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x3, y03 = y4);
}
function centroidPointLine(x3, y4) {
  var dx = x3 - x03, dy = y4 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x3) / 2;
  Y1 += z * (y03 + y4) / 2;
  Z1 += z;
  centroidPoint(x03 = x3, y03 = y4);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x3, y4) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x3, y002 = y03 = y4);
}
function centroidPointRing(x3, y4) {
  var dx = x3 - x03, dy = y4 - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x3) / 2;
  Y1 += z * (y03 + y4) / 2;
  Z1 += z;
  z = y03 * x3 - x03 * y4;
  X2 += z * (x03 + x3);
  Y2 += z * (y03 + y4);
  Z2 += z * 3;
  centroidPoint(x03 = x3, y03 = y4);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x3, y4) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x3, y4);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x3, y4);
        break;
      }
      default: {
        this._context.moveTo(x3 + this._radius, y4);
        this._context.arc(x3, y4, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length5 = +lengthSum;
    lengthSum = new Adder();
    return length5;
  }
};
function lengthPointFirst(x3, y4) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x3, y003 = y04 = y4;
}
function lengthPoint(x3, y4) {
  x04 -= x3, y04 -= y4;
  lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
  x04 = x3, y04 = y4;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_2) {
    this._radius = +_2;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x3, y4) {
    switch (this._point) {
      case 0: {
        this._append`M${x3},${y4}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x3},${y4}`;
        break;
      }
      default: {
        this._append`M${x3},${y4}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r2 = this._radius;
          const s4 = this._;
          this._ = "";
          this._append`m0,${r2}a${r2},${r2} 0 1,1 0,${-2 * r2}a${r2},${r2} 0 1,1 0,${2 * r2}z`;
          cacheRadius = r2;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s4;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i2 = 1;
  this._ += strings[0];
  for (const j = strings.length; i2 < j; ++i2) {
    this._ += arguments[i2] + strings[i2];
  }
}
function appendRound2(digits) {
  const d4 = Math.floor(digits);
  if (!(d4 >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d4 > 15) return append2;
  if (d4 !== cacheDigits) {
    const k2 = 10 ** d4;
    cacheDigits = d4;
    cacheAppend = function append3(strings) {
      let i2 = 1;
      this._ += strings[0];
      for (const j = strings.length; i2 < j; ++i2) {
        this._ += Math.round(arguments[i2] * k2) / k2 + strings[i2];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default2(projection3, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default2));
    return area_default2.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path2.projection = function(_2) {
    if (!arguments.length) return projection3;
    projectionStream = _2 == null ? (projection3 = null, identity_default5) : (projection3 = _2).stream;
    return path2;
  };
  path2.context = function(_2) {
    if (!arguments.length) return context;
    contextStream = _2 == null ? (context = null, new PathString(digits)) : new PathContext(context = _2);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_2) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path2;
  };
  path2.digits = function(_2) {
    if (!arguments.length) return digits;
    if (_2 == null) digits = null;
    else {
      const d4 = Math.floor(_2);
      if (!(d4 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
      digits = d4;
    }
    if (context === null) contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection3).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transformer(methods2) {
  return function(stream) {
    var s4 = new TransformStream();
    for (var key in methods2) s4[key] = methods2[key];
    s4.stream = stream;
    return s4;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x3, y4) {
    this.stream.point(x3, y4);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object) {
  var clip = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip != null) projection3.clipExtent(null);
  stream_default(object, projection3.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null) projection3.clipExtent(clip);
  return projection3;
}
function fitExtent(projection3, extent2, object) {
  return fit(projection3, function(b) {
    var w2 = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k2 = Math.min(w2 / (b[1][0] - b[0][0]), h2 / (b[1][1] - b[0][1])), x3 = +extent2[0][0] + (w2 - k2 * (b[1][0] + b[0][0])) / 2, y4 = +extent2[0][1] + (h2 - k2 * (b[1][1] + b[0][1])) / 2;
    projection3.scale(150 * k2).translate([x3, y4]);
  }, object);
}
function fitSize(projection3, size3, object) {
  return fitExtent(projection3, [[0, 0], size3], object);
}
function fitWidth(projection3, width, object) {
  return fit(projection3, function(b) {
    var w2 = +width, k2 = w2 / (b[1][0] - b[0][0]), x3 = (w2 - k2 * (b[1][0] + b[0][0])) / 2, y4 = -k2 * b[0][1];
    projection3.scale(150 * k2).translate([x3, y4]);
  }, object);
}
function fitHeight(projection3, height, object) {
  return fit(projection3, function(b) {
    var h2 = +height, k2 = h2 / (b[1][1] - b[0][1]), x3 = -k2 * b[0][0], y4 = (h2 - k2 * (b[1][1] + b[0][1])) / 2;
    projection3.scale(150 * k2).translate([x3, y4]);
  }, object);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x3, y4) {
      x3 = project(x3, y4);
      this.stream.point(x3[0], x3[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x05, dy = y12 - y05, d22 = dx * dx + dy * dy;
    if (d22 > 4 * delta2 && depth--) {
      var a5 = a0 + a1, b = b0 + b1, c6 = c0 + c1, m3 = sqrt2(a5 * a5 + b * b + c6 * c6), phi2 = asin2(c6 /= m3), lambda2 = abs2(abs2(c6) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan22(b, a5), p3 = project(lambda2, phi2), x22 = p3[0], y22 = p3[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d22 > delta2 || abs2((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a5 /= m3, b /= m3, c6, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a5, b, c6, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point7,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point7(x3, y4) {
      x3 = project(x3, y4);
      stream.point(x3[0], x3[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi2) {
      var c6 = cartesian2([lambda, phi2]), p3 = project(lambda, phi2);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p3[0], y05 = p3[1], lambda0 = lambda, a0 = c6[0], b0 = c6[1], c0 = c6[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point7;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x3, y4) {
    this.stream.point(x3 * radians, y4 * radians);
  }
});
function transformRotate(rotate7) {
  return transformer({
    point: function(x3, y4) {
      var r2 = rotate7(x3, y4);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform2(x3, y4) {
    x3 *= sx;
    y4 *= sy;
    return [dx + k2 * x3, dy - k2 * y4];
  }
  transform2.invert = function(x3, y4) {
    return [(x3 - dx) / k2 * sx, (dy - y4) / k2 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k2, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a5 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform2(x3, y4) {
    x3 *= sx;
    y4 *= sy;
    return [a5 * x3 - b * y4 + dx, dy - b * x3 - a5 * y4];
  }
  transform2.invert = function(x3, y4) {
    return [sx * (ai * x3 - bi * y4 + ci), sy * (fi - bi * x3 - ai * y4)];
  };
  return transform2;
}
function projection2(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x3 = 480, y4 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate7, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default5, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection3(point7) {
    return projectRotateTransform(point7[0] * radians, point7[1] * radians);
  }
  function invert5(point7) {
    point7 = projectRotateTransform.invert(point7[0], point7[1]);
    return point7 && [point7[0] * degrees, point7[1] * degrees];
  }
  projection3.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate7)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection3.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
  };
  projection3.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default2(theta = _2 * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
  };
  projection3.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default5) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_2) {
    return arguments.length ? (k2 = +_2, recenter()) : k2;
  };
  projection3.translate = function(_2) {
    return arguments.length ? (x3 = +_2[0], y4 = +_2[1], recenter()) : [x3, y4];
  };
  projection3.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians, phi2 = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection3.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection3.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
  };
  projection3.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt2(delta2);
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size3, object) {
    return fitSize(projection3, size3, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x3 - center2[0], y4 - center2[1], sx, sy, alpha);
    rotate7 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform2);
    projectRotateTransform = compose_default(rotate7, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache2 = cacheStream = null;
    return projection3;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection3.invert = project.invert && invert5;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m3 = projectionMutator(projectAt), p3 = m3(phi0, phi1);
  p3.parallels = function(_2) {
    return arguments.length ? m3(phi0 = _2[0] * radians, phi1 = _2[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };
  return p3;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos2(phi0);
  function forward(lambda, phi2) {
    return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
  }
  forward.invert = function(x3, y4) {
    return [x3 / cosPhi0, asin2(y4 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y12) {
  var sy0 = sin2(y05), n2 = (sy0 + sin2(y12)) / 2;
  if (abs2(n2) < epsilon3) return cylindricalEqualAreaRaw(y05);
  var c6 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt2(c6) / n2;
  function project(x3, y4) {
    var r2 = sqrt2(c6 - 2 * n2 * sin2(y4)) / n2;
    return [r2 * sin2(x3 *= n2), r0 - r2 * cos2(x3)];
  }
  project.invert = function(x3, y4) {
    var r0y = r0 - y4, l2 = atan22(x3, abs2(r0y)) * sign2(r0y);
    if (r0y * n2 < 0)
      l2 -= pi3 * sign2(x3) * sign2(r0y);
    return [l2 / n2, asin2((c6 - (x3 * x3 + r0y * r0y) * n2 * n2) / (2 * n2))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n2 = streams.length;
  return {
    point: function(x3, y4) {
      var i2 = -1;
      while (++i2 < n2) streams[i2].point(x3, y4);
    },
    sphere: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].sphere();
    },
    lineStart: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].lineStart();
    },
    lineEnd: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].lineEnd();
    },
    polygonStart: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].polygonStart();
    },
    polygonEnd: function() {
      var i2 = -1;
      while (++i2 < n2) streams[i2].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point7, pointStream = { point: function(x3, y4) {
    point7 = [x3, y4];
  } };
  function albersUsa(coordinates) {
    var x3 = coordinates[0], y4 = coordinates[1];
    return point7 = null, (lower48Point.point(x3, y4), point7) || (alaskaPoint.point(x3, y4), point7) || (hawaiiPoint.point(x3, y4), point7);
  }
  albersUsa.invert = function(coordinates) {
    var k2 = lower48.scale(), t = lower48.translate(), x3 = (coordinates[0] - t[0]) / k2, y4 = (coordinates[1] - t[1]) / k2;
    return (y4 >= 0.12 && y4 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length) return lower48.translate();
    var k2 = lower48.scale(), x3 = +_2[0], y4 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k2, y4 - 0.238 * k2], [x3 + 0.455 * k2, y4 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x3 - 0.307 * k2, y4 + 0.201 * k2]).clipExtent([[x3 - 0.425 * k2 + epsilon3, y4 + 0.12 * k2 + epsilon3], [x3 - 0.214 * k2 - epsilon3, y4 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x3 - 0.205 * k2, y4 + 0.212 * k2]).clipExtent([[x3 - 0.214 * k2 + epsilon3, y4 + 0.166 * k2 + epsilon3], [x3 - 0.115 * k2 - epsilon3, y4 + 0.234 * k2 - epsilon3]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object) {
    return fitExtent(albersUsa, extent2, object);
  };
  albersUsa.fitSize = function(size3, object) {
    return fitSize(albersUsa, size3, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale12) {
  return function(x3, y4) {
    var cx = cos2(x3), cy = cos2(y4), k2 = scale12(cx * cy);
    if (k2 === Infinity) return [2, 0];
    return [
      k2 * cy * sin2(x3),
      k2 * sin2(y4)
    ];
  };
}
function azimuthalInvert(angle4) {
  return function(x3, y4) {
    var z = sqrt2(x3 * x3 + y4 * y4), c6 = angle4(z), sc = sin2(c6), cc = cos2(c6);
    return [
      atan22(x3 * sc, z * cc),
      asin2(z && y4 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection2(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c6) {
  return (c6 = acos2(c6)) && c6 / sin2(c6);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection2(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x3, y4) {
  return [x3, 2 * atan(exp2(y4)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project) {
  var m3 = projection2(project), center2 = m3.center, scale12 = m3.scale, translate6 = m3.translate, clipExtent = m3.clipExtent, x05 = null, y05, x12, y12;
  m3.scale = function(_2) {
    return arguments.length ? (scale12(_2), reclip()) : scale12();
  };
  m3.translate = function(_2) {
    return arguments.length ? (translate6(_2), reclip()) : translate6();
  };
  m3.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m3.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  function reclip() {
    var k2 = pi3 * scale12(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x05), y05], [Math.min(t[0] + k2, x12), y12]] : [[x05, Math.max(t[1] - k2, y05)], [x12, Math.min(t[1] + k2, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y4) {
  return tan((halfPi2 + y4) / 2);
}
function conicConformalRaw(y05, y12) {
  var cy0 = cos2(y05), n2 = y05 === y12 ? sin2(y05) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y05)), f2 = cy0 * pow2(tany(y05), n2) / n2;
  if (!n2) return mercatorRaw;
  function project(x3, y4) {
    if (f2 > 0) {
      if (y4 < -halfPi2 + epsilon3) y4 = -halfPi2 + epsilon3;
    } else {
      if (y4 > halfPi2 - epsilon3) y4 = halfPi2 - epsilon3;
    }
    var r2 = f2 / pow2(tany(y4), n2);
    return [r2 * sin2(n2 * x3), f2 - r2 * cos2(n2 * x3)];
  }
  project.invert = function(x3, y4) {
    var fy = f2 - y4, r2 = sign2(n2) * sqrt2(x3 * x3 + fy * fy), l2 = atan22(x3, abs2(fy)) * sign2(fy);
    if (fy * n2 < 0)
      l2 -= pi3 * sign2(x3) * sign2(fy);
    return [l2 / n2, 2 * atan(pow2(f2 / r2, 1 / n2)) - halfPi2];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection2(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y12) {
  var cy0 = cos2(y05), n2 = y05 === y12 ? sin2(y05) : (cy0 - cos2(y12)) / (y12 - y05), g = cy0 / n2 + y05;
  if (abs2(n2) < epsilon3) return equirectangularRaw;
  function project(x3, y4) {
    var gy = g - y4, nx = n2 * x3;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project.invert = function(x3, y4) {
    var gy = g - y4, l2 = atan22(x3, abs2(gy)) * sign2(gy);
    if (gy * n2 < 0)
      l2 -= pi3 * sign2(x3) * sign2(gy);
    return [l2 / n2, g - sign2(n2) * sqrt2(x3 * x3 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A22 = -0.081106;
var A32 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l2 = asin2(M * sin2(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
  return [
    lambda * cos2(l2) / (M * (A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A4 * l22))),
    l2 * (A1 + A22 * l22 + l6 * (A32 + A4 * l22))
  ];
}
equalEarthRaw.invert = function(x3, y4) {
  var l2 = y4, l22 = l2 * l2, l6 = l22 * l22 * l22;
  for (var i2 = 0, delta, fy, fpy; i2 < iterations; ++i2) {
    fy = l2 * (A1 + A22 * l22 + l6 * (A32 + A4 * l22)) - y4;
    fpy = A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A4 * l22);
    l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
    if (abs2(delta) < epsilon22) break;
  }
  return [
    M * x3 * (A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A4 * l22)) / cos2(l2),
    asin2(sin2(l2) / M)
  ];
};
function equalEarth_default() {
  return projection2(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x3, y4) {
  var cy = cos2(y4), k2 = cos2(x3) * cy;
  return [cy * sin2(x3) / k2, sin2(y4) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection2(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default6() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer({
    point: function(x3, y4) {
      var p3 = projection3([x3, y4]);
      this.stream.point(p3[0], p3[1]);
    }
  }), postclip = identity_default5, cache2, cacheStream;
  function reset() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache2 = cacheStream = null;
    return projection3;
  }
  function projection3(p3) {
    var x3 = p3[0] * kx2, y4 = p3[1] * ky2;
    if (alpha) {
      var t = y4 * ca - x3 * sa;
      x3 = x3 * ca + y4 * sa;
      y4 = t;
    }
    return [x3 + tx, y4 + ty];
  }
  projection3.invert = function(p3) {
    var x3 = p3[0] - tx, y4 = p3[1] - ty;
    if (alpha) {
      var t = y4 * ca + x3 * sa;
      x3 = x3 * ca - y4 * sa;
      y4 = t;
    }
    return [x3 / kx2, y4 / ky2];
  };
  projection3.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transform2(postclip(cacheStream = stream));
  };
  projection3.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default5) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_2) {
    return arguments.length ? (k2 = +_2, reset()) : k2;
  };
  projection3.translate = function(_2) {
    return arguments.length ? (tx = +_2[0], ty = +_2[1], reset()) : [tx, ty];
  };
  projection3.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, sa = sin2(alpha), ca = cos2(alpha), reset()) : alpha * degrees;
  };
  projection3.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, reset()) : sx < 0;
  };
  projection3.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, reset()) : sy < 0;
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size3, object) {
    return fitSize(projection3, size3, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  return projection3;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x3, y4) {
  var phi2 = y4, i2 = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y4) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon3 && --i2 > 0);
  return [
    x3 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection2(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x3, y4) {
  return [cos2(y4) * sin2(x3), sin2(y4)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection2(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x3, y4) {
  var cy = cos2(y4), k2 = 1 + cos2(x3) * cy;
  return [cy * sin2(x3) / k2, sin2(y4) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection2(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x3, y4) {
  return [-y4, 2 * atan(exp2(x3)) - halfPi2];
};
function transverseMercator_default() {
  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate7 = m3.rotate;
  m3.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m3.rotate = function(_2) {
    return arguments.length ? rotate7([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate7(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate7([0, 0, 90]).scale(159.155);
}

// node_modules/@antv/g2/esm/composition/d3Projection.js
var d3Projection_exports = {};
__export(d3Projection_exports, {
  geoAlbers: () => albers_default,
  geoAlbersUsa: () => albersUsa_default,
  geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
  geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
  geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
  geoConicConformal: () => conicConformal_default,
  geoConicConformalRaw: () => conicConformalRaw,
  geoConicEqualArea: () => conicEqualArea_default,
  geoConicEqualAreaRaw: () => conicEqualAreaRaw,
  geoConicEquidistant: () => conicEquidistant_default,
  geoConicEquidistantRaw: () => conicEquidistantRaw,
  geoEqualEarth: () => equalEarth_default,
  geoEqualEarthRaw: () => equalEarthRaw,
  geoEquirectangular: () => equirectangular_default,
  geoEquirectangularRaw: () => equirectangularRaw,
  geoGnomonic: () => gnomonic_default,
  geoGnomonicRaw: () => gnomonicRaw,
  geoIdentity: () => identity_default6,
  geoMercator: () => mercator_default,
  geoMercatorRaw: () => mercatorRaw,
  geoNaturalEarth1: () => naturalEarth1_default,
  geoNaturalEarth1Raw: () => naturalEarth1Raw,
  geoOrthographic: () => orthographic_default,
  geoOrthographicRaw: () => orthographicRaw,
  geoProjection: () => projection2,
  geoProjectionMutator: () => projectionMutator,
  geoStereographic: () => stereographic_default,
  geoStereographicRaw: () => stereographicRaw,
  geoTransverseMercator: () => transverseMercator_default,
  geoTransverseMercatorRaw: () => transverseMercatorRaw
});

// node_modules/@antv/g2/esm/composition/geoView.js
var __rest69 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function normalizeProjection(type) {
  if (typeof type === "function")
    return type;
  const name2 = `geo${upper_first_default(type)}`;
  const projection3 = d3Projection_exports[name2];
  if (!projection3)
    throw new Error(`Unknown coordinate: ${type}`);
  return projection3;
}
function mergeGeoJSON(gjs) {
  return {
    type: "FeatureCollection",
    features: gjs.flatMap((gj) => normalizeGeoJSON(gj).features)
  };
}
function normalizeGeoJSON(gj) {
  const types = {
    Point: "geometry",
    MultiPoint: "geometry",
    LineString: "geometry",
    MultiLineString: "geometry",
    Polygon: "geometry",
    MultiPolygon: "geometry",
    GeometryCollection: "geometry",
    Feature: "feature",
    FeatureCollection: "featureCollection"
  };
  if (!gj || !gj.type)
    return null;
  const type = types[gj.type];
  if (!type)
    return null;
  if (type === "geometry") {
    return {
      type: "FeatureCollection",
      features: [
        {
          type: "Feature",
          properties: {},
          geometry: gj
        }
      ]
    };
  } else if (type === "feature") {
    return {
      type: "FeatureCollection",
      features: [gj]
    };
  } else if (type === "featureCollection") {
    return gj;
  }
}
function setProjectionOptions(projection3, options) {
  var _a2;
  for (const [key, value2] of Object.entries(options)) {
    (_a2 = projection3[key]) === null || _a2 === void 0 ? void 0 : _a2.call(projection3, value2);
  }
}
function setProjectionSize(projection3, nodes, layout, options) {
  const defaultOutline = () => {
    const geoNodes = nodes.filter(isGeoPath);
    const sphere = geoNodes.find((d4) => d4.sphere);
    if (sphere)
      return { type: "Sphere" };
    return mergeGeoJSON(geoNodes.filter((d4) => !d4.sphere).flatMap((d4) => d4.data.value));
  };
  const { outline = defaultOutline() } = options;
  const { size: size3 = "fitExtent" } = options;
  if (size3 === "fitExtent") {
    return setFitExtent(projection3, outline, layout);
  } else if (size3 === "fitWidth") {
    return setFitWidth(projection3, outline, layout);
  }
}
function setFitExtent(projection3, object, layout) {
  const { x: x3, y: y4, width, height } = layout;
  projection3.fitExtent([
    [x3, y4],
    [width, height]
  ], object);
}
function setFitWidth(projection3, object, layout) {
  const { width, height } = layout;
  const [[x05, y05], [x12, y12]] = path_default2(projection3.fitWidth(width, object)).bounds(object);
  const dy = Math.ceil(y12 - y05);
  const l2 = Math.min(Math.ceil(x12 - x05), dy);
  const s4 = projection3.scale() * (l2 - 1) / l2;
  const [tx, ty] = projection3.translate();
  const t = ty + (height - dy) / 2;
  projection3.scale(s4).translate([tx, t]).precision(0.2);
}
function normalizeDataSource(node) {
  const { data: data2 } = node;
  if (Array.isArray(data2))
    return Object.assign(Object.assign({}, node), { data: { value: data2 } });
  const { type } = data2;
  if (type === "graticule10") {
    return Object.assign(Object.assign({}, node), { data: { value: [graticule10()] } });
  } else if (type === "sphere") {
    return Object.assign(Object.assign({}, node), { sphere: true, data: { value: [{ type: "Sphere" }] } });
  }
  return node;
}
function isGeoPath(d4) {
  return d4.type === "geoPath";
}
var GeoView = () => {
  return (options) => {
    const { children, coordinate: projection3 = {} } = options;
    if (!Array.isArray(children))
      return [];
    const { type = "equalEarth" } = projection3, projectionOptions = __rest69(projection3, ["type"]);
    const createProjection = normalizeProjection(type);
    const nodes = children.map(normalizeDataSource);
    let path2;
    function Geo() {
      return [
        [
          "custom",
          (x3, y4, width, height) => {
            const visual = createProjection();
            const layout = { x: x3, y: y4, width, height };
            setProjectionSize(visual, nodes, layout, projectionOptions);
            setProjectionOptions(visual, projectionOptions);
            path2 = path_default2(visual);
            const scaleX2 = new Linear({
              domain: [x3, x3 + width]
            });
            const scaleY2 = new Linear({
              domain: [y4, y4 + height]
            });
            const normalize10 = (point7) => {
              const visualPoint = visual(point7);
              if (!visualPoint)
                return [null, null];
              const [vx, vy] = visualPoint;
              return [scaleX2.map(vx), scaleY2.map(vy)];
            };
            const normalizeInvert = (point7) => {
              if (!point7)
                return null;
              const [px2, py] = point7;
              const visualPoint = [scaleX2.invert(px2), scaleY2.invert(py)];
              return visual.invert(visualPoint);
            };
            return {
              transform: (point7) => normalize10(point7),
              untransform: (point7) => normalizeInvert(point7)
            };
          }
        ]
      ];
    }
    function GeoPath2(options2) {
      const { style, tooltip: tooltip2 = {} } = options2;
      return Object.assign(Object.assign({}, options2), { type: "path", tooltip: maybeTooltip(tooltip2, {
        title: "id",
        items: [{ channel: "color" }]
      }), style: Object.assign(Object.assign({}, style), { d: (d4) => path2(d4) || [] }) });
    }
    const t = (d4) => isGeoPath(d4) ? GeoPath2(d4) : d4;
    return [
      Object.assign(Object.assign({}, options), { type: "view", scale: {
        x: { type: "identity" },
        y: { type: "identity" }
      }, axis: false, coordinate: { type: Geo }, children: nodes.flatMap(t) })
    ];
  };
};
GeoView.props = {};

// node_modules/@antv/g2/esm/interaction/event.js
function maybeComponentRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "component");
}
function maybeElementRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "element");
}
function maybeLabelRoot(node) {
  return maybeRoot(node, (node2) => node2.className === "label");
}
function bubblesEvent(eventType, view, emitter, predicate = (event) => true) {
  return (e3) => {
    if (!predicate(e3))
      return;
    emitter.emit(`plot:${eventType}`, e3);
    const { target } = e3;
    if (!target)
      return;
    const { className: className2 } = target;
    if (className2 === "plot")
      return;
    const elementRoot = maybeElementRoot(target);
    const componentRoot = maybeComponentRoot(target);
    const babelRoot = maybeLabelRoot(target);
    const root2 = elementRoot || componentRoot || babelRoot;
    if (!root2)
      return;
    const { className: elementType, markType } = root2;
    const e1 = Object.assign(Object.assign({}, e3), { nativeEvent: true });
    if (elementType === "element") {
      e1["data"] = { data: dataOf(root2, view) };
      emitter.emit(`element:${eventType}`, e1);
      emitter.emit(`${markType}:${eventType}`, e1);
    } else if (elementType === "label") {
      e1["data"] = { data: root2.attributes.datum };
      emitter.emit(`label:${eventType}`, e1);
      emitter.emit(`${className2}:${eventType}`, e1);
    } else {
      emitter.emit(`component:${eventType}`, e1);
      emitter.emit(`${className2}:${eventType}`, e1);
    }
  };
}
function Event2() {
  return (context, _2, emitter) => {
    const { container, view } = context;
    const click = bubblesEvent(ChartEvent.CLICK, view, emitter, (e3) => e3.detail === 1);
    const dblclick2 = bubblesEvent(ChartEvent.DBLCLICK, view, emitter, (e3) => e3.detail === 2);
    const pointertap = bubblesEvent(ChartEvent.POINTER_TAP, view, emitter);
    const pointerdown = bubblesEvent(ChartEvent.POINTER_DOWN, view, emitter);
    const pointerup = bubblesEvent(ChartEvent.POINTER_UP, view, emitter);
    const pointerover = bubblesEvent(ChartEvent.POINTER_OVER, view, emitter);
    const pointerout = bubblesEvent(ChartEvent.POINTER_OUT, view, emitter);
    const pointermove = bubblesEvent(ChartEvent.POINTER_MOVE, view, emitter);
    const pointerenter = bubblesEvent(ChartEvent.POINTER_ENTER, view, emitter);
    const pointerleave = bubblesEvent(ChartEvent.POINTER_LEAVE, view, emitter);
    const pointerupoutside = bubblesEvent(ChartEvent.POINTER_UPOUTSIDE, view, emitter);
    const dragstart = bubblesEvent(ChartEvent.DRAG_START, view, emitter);
    const drag = bubblesEvent(ChartEvent.DRAG, view, emitter);
    const dragend = bubblesEvent(ChartEvent.DRAG_END, view, emitter);
    const dragenter = bubblesEvent(ChartEvent.DRAG_ENTER, view, emitter);
    const dragleave = bubblesEvent(ChartEvent.DRAG_LEAVE, view, emitter);
    const dragover = bubblesEvent(ChartEvent.DRAG_OVER, view, emitter);
    const drop = bubblesEvent(ChartEvent.DROP, view, emitter);
    container.addEventListener("click", click);
    container.addEventListener("click", dblclick2);
    container.addEventListener("pointertap", pointertap);
    container.addEventListener("pointerdown", pointerdown);
    container.addEventListener("pointerup", pointerup);
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    container.addEventListener("pointermove", pointermove);
    container.addEventListener("pointerenter", pointerenter);
    container.addEventListener("pointerleave", pointerleave);
    container.addEventListener("pointerupoutside", pointerupoutside);
    container.addEventListener("dragstart", dragstart);
    container.addEventListener("drag", drag);
    container.addEventListener("dragend", dragend);
    container.addEventListener("dragenter", dragenter);
    container.addEventListener("dragleave", dragleave);
    container.addEventListener("dragover", dragover);
    container.addEventListener("drop", drop);
    return () => {
      container.removeEventListener("click", click);
      container.removeEventListener("click", dblclick2);
      container.removeEventListener("pointertap", pointertap);
      container.removeEventListener("pointerdown", pointerdown);
      container.removeEventListener("pointerup", pointerup);
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      container.removeEventListener("pointermove", pointermove);
      container.removeEventListener("pointerenter", pointerenter);
      container.removeEventListener("pointerleave", pointerleave);
      container.removeEventListener("pointerupoutside", pointerupoutside);
      container.removeEventListener("dragstart", dragstart);
      container.removeEventListener("drag", drag);
      container.removeEventListener("dragend", dragend);
      container.removeEventListener("dragenter", dragenter);
      container.removeEventListener("dragleave", dragleave);
      container.removeEventListener("dragover", dragover);
      container.removeEventListener("drop", drop);
    };
  };
}
Event2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/lib/builtinlib.js
function builtinlib() {
  return {
    "component.axisRadar": AxisRadar,
    "component.axisLinear": LinearAxis,
    "component.axisArc": ArcAxis,
    "component.legendContinuousBlock": LegendContinuousBlock,
    "component.legendContinuousBlockSize": LegendContinuousBlockSize,
    "component.legendContinuousSize": LegendContinuousSize,
    "interaction.event": Event2,
    "composition.mark": Mark,
    "composition.view": View,
    "shape.label.label": Label
  };
}

// node_modules/@antv/g2/esm/runtime/library.js
var __rest70 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function useLibrary(namespace, publicLibrary) {
  const library3 = Object.assign(Object.assign({}, builtinlib()), publicLibrary);
  const create8 = (type) => {
    if (typeof type !== "string")
      return type;
    const key = `${namespace}.${type}`;
    return library3[key] || error(`Unknown Component: ${key}`);
  };
  const use = (options, context) => {
    const { type } = options, rest = __rest70(options, ["type"]);
    if (!type)
      error(`Plot type is required!`);
    const currentLibrary = create8(type);
    return currentLibrary === null || currentLibrary === void 0 ? void 0 : currentLibrary(rest, context);
  };
  return [use, create8];
}
function documentOf(library3) {
  const { canvas, group: group3 } = library3;
  return (canvas === null || canvas === void 0 ? void 0 : canvas.document) || (group3 === null || group3 === void 0 ? void 0 : group3.ownerDocument) || error(`Cannot find library document`);
}

// node_modules/@antv/g2/esm/runtime/coordinate.js
var __rest71 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function createCoordinate(layout, partialOptions, library3) {
  const [useCoordinate] = useLibrary("coordinate", library3);
  const { innerHeight, innerWidth, insetLeft, insetTop, insetRight, insetBottom } = layout;
  const { coordinates: partialTransform = [] } = partialOptions;
  const transform2 = inferCoordinate(partialTransform);
  const isCartesian3D = transform2[0].type === "cartesian3D";
  const options = Object.assign(Object.assign({}, layout), { x: insetLeft, y: insetTop, width: innerWidth - insetLeft - insetRight, height: innerHeight - insetBottom - insetTop, transformations: transform2.flatMap(useCoordinate) });
  const coordinate = isCartesian3D ? (
    // @ts-ignore
    new Coordinate3D(options)
  ) : new Coordinate(options);
  return coordinate;
}
function coordinate2Transform(node, library3) {
  const { coordinate = {}, coordinates } = node, rest = __rest71(node, ["coordinate", "coordinates"]);
  if (coordinates)
    return node;
  const { type, transform: transform2 = [] } = coordinate, options = __rest71(coordinate, ["type", "transform"]);
  if (!type)
    return Object.assign(Object.assign({}, rest), { coordinates: transform2 });
  const [, createCoordinate2] = useLibrary("coordinate", library3);
  const { transform: isTransform = false } = createCoordinate2(type).props || {};
  if (isTransform) {
    throw new Error(`Unknown coordinate: ${type}.`);
  }
  return Object.assign(Object.assign({}, rest), { coordinates: [Object.assign({ type }, options), ...transform2] });
}
function coordOf(coordinates, type) {
  return coordinates.filter((d4) => d4.type === type);
}
function isPolar2(coordinates) {
  return coordOf(coordinates, "polar").length > 0;
}
function isHelix2(coordinates) {
  return coordOf(coordinates, "helix").length > 0;
}
function isTranspose2(coordinates) {
  return coordOf(coordinates, "transpose").length % 2 === 1;
}
function isParallel2(coordinates) {
  return coordOf(coordinates, "parallel").length > 0;
}
function isTheta2(coordinates) {
  return coordOf(coordinates, "theta").length > 0;
}
function isReflect(coordinates) {
  return coordOf(coordinates, "reflect").length > 0;
}
function isRadial2(coordinates) {
  return coordOf(coordinates, "radial").length > 0;
}
function isRadar2(coordinates) {
  return coordOf(coordinates, "radar").length > 0;
}
function isReflectY(coordinates) {
  return coordOf(coordinates, "reflectY").length > 0;
}
function inferCoordinate(coordinates) {
  if (coordinates.find((d4) => d4.type === "cartesian" || d4.type === "cartesian3D"))
    return coordinates;
  return [...coordinates, { type: "cartesian" }];
}

// node_modules/@antv/vendor/es/d3-scale-chromatic.mjs
var d3_scale_chromatic_exports = {};
__export(d3_scale_chromatic_exports, {
  interpolateBlues: () => Blues_default,
  interpolateBrBG: () => BrBG_default,
  interpolateBuGn: () => BuGn_default,
  interpolateBuPu: () => BuPu_default,
  interpolateCividis: () => cividis_default,
  interpolateCool: () => cool,
  interpolateCubehelixDefault: () => cubehelix_default2,
  interpolateGnBu: () => GnBu_default,
  interpolateGreens: () => Greens_default,
  interpolateGreys: () => Greys_default,
  interpolateInferno: () => inferno,
  interpolateMagma: () => magma,
  interpolateOrRd: () => OrRd_default,
  interpolateOranges: () => Oranges_default,
  interpolatePRGn: () => PRGn_default,
  interpolatePiYG: () => PiYG_default,
  interpolatePlasma: () => plasma,
  interpolatePuBu: () => PuBu_default,
  interpolatePuBuGn: () => PuBuGn_default,
  interpolatePuOr: () => PuOr_default,
  interpolatePuRd: () => PuRd_default,
  interpolatePurples: () => Purples_default,
  interpolateRainbow: () => rainbow_default,
  interpolateRdBu: () => RdBu_default,
  interpolateRdGy: () => RdGy_default,
  interpolateRdPu: () => RdPu_default,
  interpolateRdYlBu: () => RdYlBu_default,
  interpolateRdYlGn: () => RdYlGn_default,
  interpolateReds: () => Reds_default,
  interpolateSinebow: () => sinebow_default,
  interpolateSpectral: () => Spectral_default,
  interpolateTurbo: () => turbo_default,
  interpolateViridis: () => viridis_default,
  interpolateWarm: () => warm,
  interpolateYlGn: () => YlGn_default,
  interpolateYlGnBu: () => YlGnBu_default,
  interpolateYlOrBr: () => YlOrBr_default,
  interpolateYlOrRd: () => YlOrRd_default,
  schemeAccent: () => Accent_default,
  schemeBlues: () => scheme22,
  schemeBrBG: () => scheme,
  schemeBuGn: () => scheme10,
  schemeBuPu: () => scheme11,
  schemeCategory10: () => category10_default,
  schemeDark2: () => Dark2_default,
  schemeGnBu: () => scheme12,
  schemeGreens: () => scheme23,
  schemeGreys: () => scheme24,
  schemeObservable10: () => observable10_default,
  schemeOrRd: () => scheme13,
  schemeOranges: () => scheme27,
  schemePRGn: () => scheme2,
  schemePaired: () => Paired_default,
  schemePastel1: () => Pastel1_default,
  schemePastel2: () => Pastel2_default,
  schemePiYG: () => scheme3,
  schemePuBu: () => scheme15,
  schemePuBuGn: () => scheme14,
  schemePuOr: () => scheme4,
  schemePuRd: () => scheme16,
  schemePurples: () => scheme25,
  schemeRdBu: () => scheme5,
  schemeRdGy: () => scheme6,
  schemeRdPu: () => scheme17,
  schemeRdYlBu: () => scheme7,
  schemeRdYlGn: () => scheme8,
  schemeReds: () => scheme26,
  schemeSet1: () => Set1_default,
  schemeSet2: () => Set2_default,
  schemeSet3: () => Set3_default,
  schemeSpectral: () => scheme9,
  schemeTableau10: () => Tableau10_default,
  schemeYlGn: () => scheme19,
  schemeYlGnBu: () => scheme18,
  schemeYlOrBr: () => scheme20,
  schemeYlOrRd: () => scheme21
});

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n2 = specifier.length / 6 | 0, colors = new Array(n2), i2 = 0;
  while (i2 < n2) colors[i2] = "#" + specifier.slice(i2 * 6, ++i2 * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend4(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color5() {
}
var darker2 = 0.7;
var brighter2 = 1 / darker2;
var reI2 = "\\s*([+-]?\\d+)\\s*";
var reN2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex2 = /^#([0-9a-f]{3,8})$/;
var reRgbInteger2 = new RegExp(`^rgb\\(${reI2},${reI2},${reI2}\\)$`);
var reRgbPercent2 = new RegExp(`^rgb\\(${reP2},${reP2},${reP2}\\)$`);
var reRgbaInteger2 = new RegExp(`^rgba\\(${reI2},${reI2},${reI2},${reN2}\\)$`);
var reRgbaPercent2 = new RegExp(`^rgba\\(${reP2},${reP2},${reP2},${reN2}\\)$`);
var reHslPercent2 = new RegExp(`^hsl\\(${reN2},${reP2},${reP2}\\)$`);
var reHslaPercent2 = new RegExp(`^hsla\\(${reN2},${reP2},${reP2},${reN2}\\)$`);
var named2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color5, color2, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex2,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex2,
  formatHex8: color_formatHex82,
  formatHsl: color_formatHsl2,
  formatRgb: color_formatRgb2,
  toString: color_formatRgb2
});
function color_formatHex2() {
  return this.rgb().formatHex();
}
function color_formatHex82() {
  return this.rgb().formatHex8();
}
function color_formatHsl2() {
  return hslConvert2(this).formatHsl();
}
function color_formatRgb2() {
  return this.rgb().formatRgb();
}
function color2(format3) {
  var m3, l2;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex2.exec(format3)) ? (l2 = m3[1].length, m3 = parseInt(m3[1], 16), l2 === 6 ? rgbn2(m3) : l2 === 3 ? new Rgb2(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l2 === 8 ? rgba2(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l2 === 4 ? rgba2(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger2.exec(format3)) ? new Rgb2(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent2.exec(format3)) ? new Rgb2(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger2.exec(format3)) ? rgba2(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent2.exec(format3)) ? rgba2(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent2.exec(format3)) ? hsla2(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent2.exec(format3)) ? hsla2(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named2.hasOwnProperty(format3) ? rgbn2(named2[format3]) : format3 === "transparent" ? new Rgb2(NaN, NaN, NaN, 0) : null;
}
function rgbn2(n2) {
  return new Rgb2(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba2(r2, g, b, a5) {
  if (a5 <= 0) r2 = g = b = NaN;
  return new Rgb2(r2, g, b, a5);
}
function rgbConvert2(o2) {
  if (!(o2 instanceof Color5)) o2 = color2(o2);
  if (!o2) return new Rgb2();
  o2 = o2.rgb();
  return new Rgb2(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb2(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert2(r2) : new Rgb2(r2, g, b, opacity == null ? 1 : opacity);
}
function Rgb2(r2, g, b, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb2, rgb2, extend4(Color5, {
  brighter(k2) {
    k2 = k2 == null ? brighter2 : Math.pow(brighter2, k2);
    return new Rgb2(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker2 : Math.pow(darker2, k2);
    return new Rgb2(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb2(clampi2(this.r), clampi2(this.g), clampi2(this.b), clampa2(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex2,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex2,
  formatHex8: rgb_formatHex82,
  formatRgb: rgb_formatRgb2,
  toString: rgb_formatRgb2
}));
function rgb_formatHex2() {
  return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}`;
}
function rgb_formatHex82() {
  return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}${hex2((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb2() {
  const a5 = clampa2(this.opacity);
  return `${a5 === 1 ? "rgb(" : "rgba("}${clampi2(this.r)}, ${clampi2(this.g)}, ${clampi2(this.b)}${a5 === 1 ? ")" : `, ${a5})`}`;
}
function clampa2(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi2(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex2(value2) {
  value2 = clampi2(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla2(h2, s4, l2, a5) {
  if (a5 <= 0) h2 = s4 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h2 = s4 = NaN;
  else if (s4 <= 0) h2 = NaN;
  return new Hsl2(h2, s4, l2, a5);
}
function hslConvert2(o2) {
  if (o2 instanceof Hsl2) return new Hsl2(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color5)) o2 = color2(o2);
  if (!o2) return new Hsl2();
  if (o2 instanceof Hsl2) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g = o2.g / 255, b = o2.b / 255, min10 = Math.min(r2, g, b), max11 = Math.max(r2, g, b), h2 = NaN, s4 = max11 - min10, l2 = (max11 + min10) / 2;
  if (s4) {
    if (r2 === max11) h2 = (g - b) / s4 + (g < b) * 6;
    else if (g === max11) h2 = (b - r2) / s4 + 2;
    else h2 = (r2 - g) / s4 + 4;
    s4 /= l2 < 0.5 ? max11 + min10 : 2 - max11 - min10;
    h2 *= 60;
  } else {
    s4 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl2(h2, s4, l2, o2.opacity);
}
function hsl2(h2, s4, l2, opacity) {
  return arguments.length === 1 ? hslConvert2(h2) : new Hsl2(h2, s4, l2, opacity == null ? 1 : opacity);
}
function Hsl2(h2, s4, l2, opacity) {
  this.h = +h2;
  this.s = +s4;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Hsl2, hsl2, extend4(Color5, {
  brighter(k2) {
    k2 = k2 == null ? brighter2 : Math.pow(brighter2, k2);
    return new Hsl2(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker2 : Math.pow(darker2, k2);
    return new Hsl2(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s4 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s4, m1 = 2 * l2 - m22;
    return new Rgb2(
      hsl2rgb2(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m22),
      hsl2rgb2(h2, m1, m22),
      hsl2rgb2(h2 < 120 ? h2 + 240 : h2 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl2(clamph2(this.h), clampt2(this.s), clampt2(this.l), clampa2(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a5 = clampa2(this.opacity);
    return `${a5 === 1 ? "hsl(" : "hsla("}${clamph2(this.h)}, ${clampt2(this.s) * 100}%, ${clampt2(this.l) * 100}%${a5 === 1 ? ")" : `, ${a5})`}`;
  }
}));
function clamph2(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt2(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb2(h2, m1, m22) {
  return (h2 < 60 ? m1 + (m22 - m1) * h2 / 60 : h2 < 180 ? m22 : h2 < 240 ? m1 + (m22 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians2 = Math.PI / 180;
var degrees2 = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o2) {
  if (o2 instanceof Lab) return new Lab(o2.l, o2.a, o2.b, o2.opacity);
  if (o2 instanceof Hcl) return hcl2lab(o2);
  if (!(o2 instanceof Rgb2)) o2 = rgbConvert2(o2);
  var r2 = rgb2lrgb(o2.r), g = rgb2lrgb(o2.g), b = rgb2lrgb(o2.b), y4 = xyz2lab((0.2225045 * r2 + 0.7168786 * g + 0.0606169 * b) / Yn), x3, z;
  if (r2 === g && g === b) x3 = z = y4;
  else {
    x3 = xyz2lab((0.4360747 * r2 + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r2 + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y4 - 16, 500 * (x3 - y4), 200 * (y4 - z), o2.opacity);
}
function lab(l2, a5, b, opacity) {
  return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a5, b, opacity == null ? 1 : opacity);
}
function Lab(l2, a5, b, opacity) {
  this.l = +l2;
  this.a = +a5;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend4(Color5, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y4 = (this.l + 16) / 116, x3 = isNaN(this.a) ? y4 : y4 + this.a / 500, z = isNaN(this.b) ? y4 : y4 - this.b / 200;
    x3 = Xn * lab2xyz(x3);
    y4 = Yn * lab2xyz(y4);
    z = Zn * lab2xyz(z);
    return new Rgb2(
      lrgb2rgb(3.1338561 * x3 - 1.6168667 * y4 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x3 + 1.9161415 * y4 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x3 - 0.2289914 * y4 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x3) {
  return 255 * (x3 <= 31308e-7 ? 12.92 * x3 : 1.055 * Math.pow(x3, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x3) {
  return (x3 /= 255) <= 0.04045 ? x3 / 12.92 : Math.pow((x3 + 0.055) / 1.055, 2.4);
}
function hclConvert(o2) {
  if (o2 instanceof Hcl) return new Hcl(o2.h, o2.c, o2.l, o2.opacity);
  if (!(o2 instanceof Lab)) o2 = labConvert(o2);
  if (o2.a === 0 && o2.b === 0) return new Hcl(NaN, 0 < o2.l && o2.l < 100 ? 0 : NaN, o2.l, o2.opacity);
  var h2 = Math.atan2(o2.b, o2.a) * degrees2;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o2.a * o2.a + o2.b * o2.b), o2.l, o2.opacity);
}
function hcl(h2, c6, l2, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c6, l2, opacity == null ? 1 : opacity);
}
function Hcl(h2, c6, l2, opacity) {
  this.h = +h2;
  this.c = +c6;
  this.l = +l2;
  this.opacity = +opacity;
}
function hcl2lab(o2) {
  if (isNaN(o2.h)) return new Lab(o2.l, 0, 0, o2.opacity);
  var h2 = o2.h * radians2;
  return new Lab(o2.l, Math.cos(h2) * o2.c, Math.sin(h2) * o2.c, o2.opacity);
}
define_default(Hcl, hcl, extend4(Color5, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A5 = -0.14861;
var B3 = 1.78277;
var C3 = -0.29227;
var D = -0.90649;
var E2 = 1.97294;
var ED = E2 * D;
var EB = E2 * B3;
var BC_DA = B3 * C3 - D * A5;
function cubehelixConvert(o2) {
  if (o2 instanceof Cubehelix) return new Cubehelix(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Rgb2)) o2 = rgbConvert2(o2);
  var r2 = o2.r / 255, g = o2.g / 255, b = o2.b / 255, l2 = (BC_DA * b + ED * r2 - EB * g) / (BC_DA + ED - EB), bl = b - l2, k2 = (E2 * (g - l2) - C3 * bl) / D, s4 = Math.sqrt(k2 * k2 + bl * bl) / (E2 * l2 * (1 - l2)), h2 = s4 ? Math.atan2(k2, bl) * degrees2 - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s4, l2, o2.opacity);
}
function cubehelix(h2, s4, l2, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s4, l2, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s4, l2, opacity) {
  this.h = +h2;
  this.s = +s4;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend4(Color5, {
  brighter(k2) {
    k2 = k2 == null ? brighter2 : Math.pow(brighter2, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker2 : Math.pow(darker2, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians2, l2 = +this.l, a5 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
    return new Rgb2(
      255 * (l2 + a5 * (A5 * cosh2 + B3 * sinh2)),
      255 * (l2 + a5 * (C3 * cosh2 + D * sinh2)),
      255 * (l2 + a5 * (E2 * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values4) {
  var n2 = values4.length - 1;
  return function(t) {
    var i2 = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n2 - 1) : Math.floor(t * n2), v1 = values4[i2], v2 = values4[i2 + 1], v0 = i2 > 0 ? values4[i2 - 1] : 2 * v1 - v2, v3 = i2 < n2 - 1 ? values4[i2 + 2] : 2 * v2 - v1;
    return basis((t - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values4) {
  var n2 = values4.length;
  return function(t) {
    var i2 = Math.floor(((t %= 1) < 0 ? ++t : t) * n2), v0 = values4[(i2 + n2 - 1) % n2], v1 = values4[i2 % n2], v2 = values4[(i2 + 1) % n2], v3 = values4[(i2 + 2) % n2];
    return basis((t - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default5 = (x3) => () => x3;

// node_modules/d3-interpolate/src/color.js
function linear4(a5, d4) {
  return function(t) {
    return a5 + t * d4;
  };
}
function exponential(a5, b, y4) {
  return a5 = Math.pow(a5, y4), b = Math.pow(b, y4) - a5, y4 = 1 / y4, function(t) {
    return Math.pow(a5 + t * b, y4);
  };
}
function hue(a5, b) {
  var d4 = b - a5;
  return d4 ? linear4(a5, d4 > 180 || d4 < -180 ? d4 - 360 * Math.round(d4 / 360) : d4) : constant_default5(isNaN(a5) ? b : a5);
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a5, b) {
    return b - a5 ? exponential(a5, b, y4) : constant_default5(isNaN(a5) ? b : a5);
  };
}
function nogamma(a5, b) {
  var d4 = b - a5;
  return d4 ? linear4(a5, d4) : constant_default5(isNaN(a5) ? b : a5);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y4) {
  var color3 = gamma(y4);
  function rgb3(start, end) {
    var r2 = color3((start = rgb2(start)).r, (end = rgb2(end)).r), g = color3(start.g, end.g), b = color3(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r2(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb3.gamma = rgbGamma;
  return rgb3;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r2 = new Array(n2), g = new Array(n2), b = new Array(n2), i2, color3;
    for (i2 = 0; i2 < n2; ++i2) {
      color3 = rgb2(colors[i2]);
      r2[i2] = color3.r || 0;
      g[i2] = color3.g || 0;
      b[i2] = color3.b || 0;
    }
    r2 = spline(r2);
    g = spline(g);
    b = spline(b);
    color3.opacity = 1;
    return function(t) {
      color3.r = r2(t);
      color3.g = g(t);
      color3.b = b(t);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/number.js
function number_default(a5, b) {
  return a5 = +a5, b = +b, function(t) {
    return a5 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees3 = 180 / Math.PI;
var identity7 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a5, b, c6, d4, e3, f2) {
  var scaleX2, scaleY2, skewX2;
  if (scaleX2 = Math.sqrt(a5 * a5 + b * b)) a5 /= scaleX2, b /= scaleX2;
  if (skewX2 = a5 * c6 + b * d4) c6 -= a5 * skewX2, d4 -= b * skewX2;
  if (scaleY2 = Math.sqrt(c6 * c6 + d4 * d4)) c6 /= scaleY2, d4 /= scaleY2, skewX2 /= scaleY2;
  if (a5 * d4 < b * c6) a5 = -a5, b = -b, skewX2 = -skewX2, scaleX2 = -scaleX2;
  return {
    translateX: e3,
    translateY: f2,
    rotate: Math.atan2(b, a5) * degrees3,
    skewX: Math.atan(skewX2) * degrees3,
    scaleX: scaleX2,
    scaleY: scaleY2
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m3.isIdentity ? identity7 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value2) {
  if (value2 == null) return identity7;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate())) return identity7;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s4) {
    return s4.length ? s4.pop() + " " : "";
  }
  function translate6(xa, ya, xb, yb, s4, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s4.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s4.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate7(a5, b, s4, q) {
    if (a5 !== b) {
      if (a5 - b > 180) b += 360;
      else if (b - a5 > 180) a5 += 360;
      q.push({ i: s4.push(pop(s4) + "rotate(", null, degParen) - 2, x: number_default(a5, b) });
    } else if (b) {
      s4.push(pop(s4) + "rotate(" + b + degParen);
    }
  }
  function skewX2(a5, b, s4, q) {
    if (a5 !== b) {
      q.push({ i: s4.push(pop(s4) + "skewX(", null, degParen) - 2, x: number_default(a5, b) });
    } else if (b) {
      s4.push(pop(s4) + "skewX(" + b + degParen);
    }
  }
  function scale12(xa, ya, xb, yb, s4, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s4.push(pop(s4) + "scale(", null, ",", null, ")");
      q.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s4.push(pop(s4) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a5, b) {
    var s4 = [], q = [];
    a5 = parse(a5), b = parse(b);
    translate6(a5.translateX, a5.translateY, b.translateX, b.translateY, s4, q);
    rotate7(a5.rotate, b.rotate, s4, q);
    skewX2(a5.skewX, b.skewX, s4, q);
    scale12(a5.scaleX, a5.scaleY, b.scaleX, b.scaleY, s4, q);
    a5 = b = null;
    return function(t) {
      var i2 = -1, n2 = q.length, o2;
      while (++i2 < n2) s4[(o2 = q[i2]).i] = o2.x(t);
      return s4.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon23 = 1e-12;
function cosh(x3) {
  return ((x3 = Math.exp(x3)) + 1 / x3) / 2;
}
function sinh(x3) {
  return ((x3 = Math.exp(x3)) - 1 / x3) / 2;
}
function tanh(x3) {
  return ((x3 = Math.exp(2 * x3)) - 1) / (x3 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d22 = dx * dx + dy * dy, i2, S;
    if (d22 < epsilon23) {
      S = Math.log(w1 / w0) / rho;
      i2 = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d22), b0 = (w1 * w1 - w0 * w0 + rho4 * d22) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d22) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i2 = function(t) {
        var s4 = t * S, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s4 + r0) - sinh(r0));
        return [
          ux0 + u2 * dx,
          uy0 + u2 * dy,
          w0 * coshr0 / cosh(rho * s4 + r0)
        ];
      };
    }
    i2.duration = S * 1e3 * rho / Math.SQRT2;
    return i2;
  }
  zoom.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl3(hue2) {
  return function(start, end) {
    var h2 = hue2((start = hsl2(start)).h, (end = hsl2(end)).h), s4 = nogamma(start.s, end.s), l2 = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h2(t);
      start.s = s4(t);
      start.l = l2(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl3(hue);
var hslLong = hsl3(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h2 = hue2((start = hcl(start)).h, (end = hcl(end)).h), c6 = nogamma(start.c, end.c), l2 = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h2(t);
      start.c = c6(t);
      start.l = l2(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y4) {
    y4 = +y4;
    function cubehelix3(start, end) {
      var h2 = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s4 = nogamma(start.s, end.s), l2 = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h2(t);
        start.s = s4(t);
        start.l = l2(Math.pow(t, y4));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c4 = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c4.h = 360 * t - 100;
  c4.s = 1.5 - 1.5 * ts;
  c4.l = 0.8 - 0.9 * ts;
  return c4 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c5 = rgb2();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x3;
  t = (0.5 - t) * Math.PI;
  c5.r = 255 * (x3 = Math.sin(t)) * x3;
  c5.g = 255 * (x3 = Math.sin(t + pi_1_3)) * x3;
  c5.b = 255 * (x3 = Math.sin(t + pi_2_3)) * x3;
  return c5 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n2 = range3.length;
  return function(t) {
    return range3[Math.max(0, Math.min(n2 - 1, Math.floor(t * n2)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/@antv/g2/esm/runtime/scale.js
function inferScale(name2, values4, options, coordinates, theme, library3) {
  const { guide = {} } = options;
  const type = inferScaleType(name2, values4, options);
  if (typeof type !== "string")
    return options;
  const expectedDomain = inferScaleDomain(type, name2, values4, options);
  const actualDomain = maybeRatio(type, expectedDomain, options);
  return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name2, values4, options, coordinates)), {
    domain: actualDomain,
    range: inferScaleRange(type, name2, values4, options, actualDomain, theme, library3),
    expectedDomain,
    guide,
    name: name2,
    type
  });
}
function applyScale(channels, scale12) {
  const scaledValue = {};
  for (const channel of channels) {
    const { values: values4, name: scaleName } = channel;
    const scaleInstance = scale12[scaleName];
    for (const value2 of values4) {
      const { name: name2, value: V } = value2;
      scaledValue[name2] = V.map((d4) => scaleInstance.map(d4));
    }
  }
  return scaledValue;
}
function groupTransform(markState, uidScale) {
  const channels = Array.from(markState.values()).flatMap((d4) => d4.channels);
  const scaleGroups = rollups(channels, (channels2) => channels2.map((d4) => uidScale.get(d4.scale.uid)), (d4) => d4.name).filter(([, scales]) => scales.some((d4) => typeof d4.getOptions().groupTransform === "function") && // only sync scales with groupTransform options
  scales.every((d4) => d4.getTicks)).map((d4) => d4[1]);
  scaleGroups.forEach((group3) => {
    const groupTransform2 = group3.map((d4) => d4.getOptions().groupTransform)[0];
    groupTransform2(group3);
  });
}
function collectScales(states, options) {
  var _a2;
  const { components = [] } = options;
  const NONE_STATIC_KEYS = [
    "scale",
    "encode",
    "axis",
    "legend",
    "data",
    "transform"
  ];
  const scales = Array.from(new Set(states.flatMap((d4) => d4.channels.map((d5) => d5.scale))));
  const nameScale = new Map(scales.map((scale12) => [scale12.name, scale12]));
  for (const component of components) {
    const channels = inferChannelsForComponent(component);
    for (const channel of channels) {
      const scale12 = nameScale.get(channel);
      const staticScale = ((_a2 = component.scale) === null || _a2 === void 0 ? void 0 : _a2[channel]) || {};
      const { independent = false } = staticScale;
      if (scale12 && !independent) {
        const { guide } = scale12;
        const guide1 = typeof guide === "boolean" ? {} : guide;
        scale12.guide = deep_mix_default({}, guide1, component);
        Object.assign(scale12, staticScale);
      } else {
        const options1 = Object.assign(Object.assign({}, staticScale), { expectedDomain: staticScale.domain, name: channel, guide: omit_default(component, NONE_STATIC_KEYS) });
        scales.push(options1);
      }
    }
  }
  return scales;
}
function useRelation(relations) {
  if (!relations || !Array.isArray(relations))
    return [identity6, identity6];
  let map5;
  let invert5;
  const conditionalize = (scale12) => {
    var _a2;
    map5 = scale12.map.bind(scale12);
    invert5 = (_a2 = scale12.invert) === null || _a2 === void 0 ? void 0 : _a2.bind(scale12);
    const funcRelations = relations.filter(([v]) => typeof v === "function");
    const valueRelations = relations.filter(([v]) => typeof v !== "function");
    const valueOutput = new Map(valueRelations);
    scale12.map = (x3) => {
      for (const [verify, value2] of funcRelations) {
        if (verify(x3))
          return value2;
      }
      if (valueOutput.has(x3))
        return valueOutput.get(x3);
      return map5(x3);
    };
    if (!invert5)
      return scale12;
    const outputValue = new Map(valueRelations.map(([a5, b]) => [b, a5]));
    const outputFunc = new Map(funcRelations.map(([a5, b]) => [b, a5]));
    scale12.invert = (x3) => {
      if (outputFunc.has(x3))
        return x3;
      if (outputValue.has(x3))
        return outputValue.get(x3);
      return invert5(x3);
    };
    return scale12;
  };
  const deconditionalize = (scale12) => {
    if (map5 !== null)
      scale12.map = map5;
    if (invert5 !== null)
      scale12.invert = invert5;
    return scale12;
  };
  return [conditionalize, deconditionalize];
}
function assignScale(target, source) {
  const keys2 = Object.keys(target);
  for (const scale12 of Object.values(source)) {
    const { name: name2 } = scale12.getOptions();
    if (!(name2 in target))
      target[name2] = scale12;
    else {
      const I = keys2.filter((d4) => d4.startsWith(name2)).map((d4) => +(d4.replace(name2, "") || 0));
      const index3 = max5(I) + 1;
      const newKey = `${name2}${index3}`;
      target[newKey] = scale12;
      scale12.getOptions().key = newKey;
    }
  }
  return target;
}
function useRelationScale(options, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { relations } = options;
  const [conditionalize] = useRelation(relations);
  const scale12 = useScale(options);
  return conditionalize(scale12);
}
function syncFacetsScales(states) {
  const scales = states.flatMap((d4) => Array.from(d4.values())).flatMap((d4) => d4.channels.map((d5) => d5.scale));
  syncFacetsScaleByChannel(scales, "x");
  syncFacetsScaleByChannel(scales, "y");
}
function inferChannelsForComponent(component) {
  const { channels = [], type, scale: scale12 = {} } = component;
  const L = ["shape", "color", "opacity", "size"];
  if (channels.length !== 0)
    return channels;
  if (type === "axisX")
    return ["x"];
  if (type === "axisY")
    return ["y"];
  if (type === "legends")
    return Object.keys(scale12).filter((d4) => L.includes(d4));
  return [];
}
function syncFacetsScaleByChannel(scales, channel) {
  const S = scales.filter(({ name: name2, facet = true }) => facet && name2 === channel);
  const D2 = S.flatMap((d4) => d4.domain);
  const syncedD = S.every(isQuantitativeScale) ? extent(D2) : S.every(isDiscreteScale) ? Array.from(new Set(D2)) : null;
  if (syncedD === null)
    return;
  for (const scale12 of S) {
    scale12.domain = syncedD;
  }
}
function maybeRatio(type, domain, options) {
  const { ratio } = options;
  if (ratio === void 0 || ratio === null)
    return domain;
  if (isQuantitativeScale({ type })) {
    return clampQuantitativeScale(domain, ratio, type);
  }
  if (isDiscreteScale({ type }))
    return clampDiscreteScale(domain, ratio);
  return domain;
}
function clampQuantitativeScale(domain, ratio, type) {
  const D2 = domain.map(Number);
  const scale12 = new Linear({
    domain: D2,
    range: [D2[0], D2[0] + (D2[D2.length - 1] - D2[0]) * ratio]
  });
  if (type === "time")
    return domain.map((d4) => new Date(scale12.map(d4)));
  return domain.map((d4) => scale12.map(d4));
}
function clampDiscreteScale(domain, ratio) {
  const index3 = Math.round(domain.length * ratio);
  return domain.slice(0, index3);
}
function isQuantitativeScale(scale12) {
  const { type } = scale12;
  if (typeof type !== "string")
    return false;
  const names = ["linear", "log", "pow", "time"];
  return names.includes(type);
}
function isDiscreteScale(scale12) {
  const { type } = scale12;
  if (typeof type !== "string")
    return false;
  const names = ["band", "point", "ordinal"];
  return names.includes(type);
}
function inferScaleType(name2, values4, options) {
  const { type, domain, range: range3, quantitative, ordinal } = options;
  if (type !== void 0)
    return type;
  if (isObject3(values4))
    return "identity";
  if (typeof range3 === "string")
    return "linear";
  if ((domain || range3 || []).length > 2)
    return asOrdinalType(name2, ordinal);
  if (domain !== void 0) {
    if (isOrdinal([domain]))
      return asOrdinalType(name2, ordinal);
    if (isTemporal(values4))
      return "time";
    return asQuantitativeType(name2, range3, quantitative);
  }
  if (isOrdinal(values4))
    return asOrdinalType(name2, ordinal);
  if (isTemporal(values4))
    return "time";
  return asQuantitativeType(name2, range3, quantitative);
}
function inferScaleDomain(type, name2, values4, options) {
  const { domain } = options;
  if (domain !== void 0)
    return domain;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
    case "quantize":
    case "threshold":
      return maybeMinMax(inferDomainQ(values4, options), options);
    case "band":
    case "ordinal":
    case "point":
      return inferDomainC(values4);
    case "quantile":
      return inferDomainO(values4);
    case "sequential":
      return maybeMinMax(inferDomainS(values4), options);
    default:
      return [];
  }
}
function inferScaleRange(type, name2, values4, options, domain, theme, library3) {
  const { range: range3 } = options;
  if (typeof range3 === "string")
    return gradientColors(range3);
  if (range3 !== void 0)
    return range3;
  const { rangeMin, rangeMax } = options;
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt": {
      const colors = categoricalColors(values4, options, domain, theme, library3);
      const [r0, r1] = inferRangeQ(name2, colors);
      return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : r0, rangeMax !== null && rangeMax !== void 0 ? rangeMax : r1];
    }
    case "band":
    case "point": {
      const min10 = name2 === "size" ? 5 : 0;
      const max11 = name2 === "size" ? 10 : 1;
      return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : min10, rangeMax !== null && rangeMax !== void 0 ? rangeMax : max11];
    }
    case "ordinal": {
      return categoricalColors(values4, options, domain, theme, library3);
    }
    case "sequential":
      return void 0;
    case "constant":
      return [values4[0][0]];
    default:
      return [];
  }
}
function inferScaleOptions(type, name2, values4, options, coordinates) {
  switch (type) {
    case "linear":
    case "time":
    case "log":
    case "pow":
    case "sqrt":
      return inferOptionsQ(coordinates, options);
    case "band":
    case "point":
      return inferOptionsC(type, name2, coordinates, options);
    case "sequential":
      return inferOptionsS(options);
    default:
      return options;
  }
}
function categoricalColors(values4, options, domain, theme, library3) {
  const [usePalette] = useLibrary("palette", library3);
  const { category10: c10, category20: c20 } = theme;
  const defaultPalette = unique(domain).length <= c10.length ? c10 : c20;
  const { palette = defaultPalette, offset: offset2 } = options;
  if (Array.isArray(palette))
    return palette;
  try {
    return usePalette({ type: palette });
  } catch (e3) {
    const colors = interpolatedColors(palette, domain, offset2);
    if (colors)
      return colors;
    throw new Error(`Unknown Component: ${palette} `);
  }
}
function gradientColors(range3) {
  return range3.split("-");
}
function interpolatedColors(palette, domain, offset2 = (d4) => d4) {
  if (!palette)
    return null;
  const fullName = upper_first_default(palette);
  const scheme28 = d3_scale_chromatic_exports[`scheme${fullName}`];
  const interpolator = d3_scale_chromatic_exports[`interpolate${fullName}`];
  if (!scheme28 && !interpolator)
    return null;
  if (scheme28) {
    if (!scheme28.some(Array.isArray))
      return scheme28;
    const schemeColors = scheme28[domain.length];
    if (schemeColors)
      return schemeColors;
  }
  return domain.map((_2, i2) => interpolator(offset2(i2 / domain.length)));
}
function inferOptionsS(options) {
  const { palette = "ylGnBu", offset: offset2 } = options;
  const name2 = upper_first_default(palette);
  const interpolator = d3_scale_chromatic_exports[`interpolate${name2}`];
  if (!interpolator)
    throw new Error(`Unknown palette: ${name2}`);
  return {
    interpolator: offset2 ? (x3) => interpolator(offset2(x3)) : interpolator
  };
}
function inferOptionsQ(coordinates, options) {
  const { interpolate: interpolate4 = createInterpolateValue, nice: nice2 = false, tickCount = 5 } = options;
  return Object.assign(Object.assign({}, options), { interpolate: interpolate4, nice: nice2, tickCount });
}
function inferOptionsC(type, name2, coordinates, options) {
  if (options.padding !== void 0 || options.paddingInner !== void 0 || options.paddingOuter !== void 0) {
    return Object.assign(Object.assign({}, options), { unknown: NaN });
  }
  const padding = inferPadding(type, name2, coordinates);
  const { paddingInner = padding, paddingOuter = padding } = options;
  return Object.assign(Object.assign({}, options), {
    paddingInner,
    paddingOuter,
    padding,
    unknown: NaN
  });
}
function inferPadding(type, name2, coordinates) {
  if (name2 === "enterDelay" || name2 === "enterDuration")
    return 0;
  if (name2 === "size")
    return 0;
  if (type === "band")
    return isTheta2(coordinates) ? 0 : 0.1;
  if (type === "point")
    return 0.5;
  return 0;
}
function asOrdinalType(name2, defaults4) {
  if (defaults4)
    return defaults4;
  return isQuantitative(name2) ? "point" : "ordinal";
}
function asQuantitativeType(name2, range3, defaults4) {
  if (defaults4)
    return defaults4;
  if (name2 !== "color")
    return "linear";
  return range3 ? "linear" : "sequential";
}
function maybeMinMax(domain, options) {
  if (domain.length === 0)
    return domain;
  const { domainMin, domainMax } = options;
  const [d0, d1] = domain;
  return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];
}
function inferDomainQ(values4, options) {
  const { zero: zero5 = false } = options;
  let min10 = Infinity;
  let max11 = -Infinity;
  for (const value2 of values4) {
    for (const d4 of value2) {
      if (defined(d4)) {
        min10 = Math.min(min10, +d4);
        max11 = Math.max(max11, +d4);
      }
    }
  }
  if (min10 === Infinity)
    return [];
  return zero5 ? [Math.min(0, min10), max11] : [min10, max11];
}
function inferDomainC(values4) {
  return Array.from(new Set(values4.flat()));
}
function inferDomainO(values4) {
  return values4.flat().sort();
}
function inferDomainS(values4) {
  let min10 = Infinity;
  let max11 = -Infinity;
  for (const value2 of values4) {
    for (const d4 of value2) {
      if (defined(d4)) {
        min10 = Math.min(min10, +d4);
        max11 = Math.max(max11, +d4);
      }
    }
  }
  if (min10 === Infinity)
    return [];
  return [min10 < 0 ? -max11 : min10, max11];
}
function inferRangeQ(name2, palette) {
  if (name2 === "enterDelay")
    return [0, 1e3];
  if (name2 == "enterDuration")
    return [300, 1e3];
  if (name2.startsWith("y") || name2.startsWith("position"))
    return [1, 0];
  if (name2 === "color")
    return [firstOf(palette), lastOf(palette)];
  if (name2 === "opacity")
    return [0, 1];
  if (name2 === "size")
    return [1, 10];
  return [0, 1];
}
function isOrdinal(values4) {
  return some2(values4, (d4) => {
    const type = typeof d4;
    return type === "string" || type === "boolean";
  });
}
function isTemporal(values4) {
  return some2(values4, (d4) => d4 instanceof Date);
}
function isObject3(values4) {
  return some2(values4, isStrictObject);
}
function some2(values4, callback) {
  for (const V of values4) {
    if (V.some(callback))
      return true;
  }
  return false;
}
function isQuantitative(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2.startsWith("size");
}
function isPosition(name2) {
  return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2 === "enterDelay" || name2 === "enterDuration" || name2 === "updateDelay" || name2 === "updateDuration" || name2 === "exitDelay" || name2 === "exitDuration";
}
function isValidScale(scale12) {
  if (!scale12 || !scale12.type)
    return false;
  if (typeof scale12.type === "function")
    return true;
  const { type, domain, range: range3, interpolator } = scale12;
  const isValidDomain = domain && domain.length > 0;
  const isValidRange = range3 && range3.length > 0;
  if ([
    "linear",
    "sqrt",
    "log",
    "time",
    "pow",
    "threshold",
    "quantize",
    "quantile",
    "ordinal",
    "band",
    "point"
  ].includes(type) && isValidDomain && isValidRange) {
    return true;
  }
  if (["sequential"].includes(type) && isValidDomain && (isValidRange || interpolator)) {
    return true;
  }
  if (["constant", "identity"].includes(type) && isValidRange)
    return true;
  return false;
}

// node_modules/@antv/g2/esm/runtime/types/scale.js
var ContinuousScale = {
  linear: "linear",
  identity: "identity",
  log: "log",
  pow: "pow",
  sqrt: "sqrt",
  sequential: "sequential"
};
var DistributionScale = {
  threshold: "threshold",
  quantize: "quantize",
  quantile: "quantile"
};
var DiscreteScale = {
  ordinal: "ordinal",
  band: "band",
  point: "point"
};
var ConstantScale = {
  constant: "constant"
};

// node_modules/@antv/g2/esm/runtime/component.js
var __rest72 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function inferComponent(scales, partialOptions, library3) {
  const { coordinates = [], title } = partialOptions;
  const [, createGuideComponent] = useLibrary("component", library3);
  const displayedScales = scales.filter(({ guide }) => {
    if (guide === null)
      return false;
    return true;
  });
  const components = [];
  const sliders = inferScrollableComponents(partialOptions, scales, library3);
  components.push(...sliders);
  if (title) {
    const { props } = createGuideComponent("title");
    const { defaultPosition, defaultOrientation, defaultOrder, defaultSize, defaultCrossPadding } = props;
    const titleOptions = typeof title === "string" ? { title } : title;
    components.push(Object.assign({ type: "title", position: defaultPosition, orientation: defaultOrientation, order: defaultOrder, crossPadding: defaultCrossPadding[0], defaultSize }, titleOptions));
  }
  const inferredComponents = inferComponentsType(displayedScales, coordinates);
  inferredComponents.forEach(([type, relativeScales]) => {
    const { props } = createGuideComponent(type);
    const { defaultPosition, defaultPlane = "xy", defaultOrientation, defaultSize, defaultOrder, defaultLength, defaultPadding: DP = [0, 0], defaultCrossPadding: DCP = [0, 0] } = props;
    const scale12 = deep_mix_default({}, ...relativeScales);
    const { guide: guideOptions, field: field3 } = scale12;
    const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];
    for (const partialGuide of guides) {
      const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
      if (!position && !orientation)
        continue;
      const isVertical2 = position === "left" || position === "right";
      const defaultPadding = isVertical2 ? DP[1] : DP[0];
      const defaultCrossPadding = isVertical2 ? DCP[1] : DCP[0];
      const { size: size3, order = defaultOrder, length: length5 = defaultLength, padding = defaultPadding, crossPadding = defaultCrossPadding } = partialGuide;
      components.push(Object.assign(Object.assign({ title: field3 }, partialGuide), {
        defaultSize,
        length: length5,
        position,
        plane: defaultPlane,
        orientation,
        padding,
        order,
        crossPadding,
        size: size3,
        type,
        scales: relativeScales
      }));
    }
  });
  return components;
}
function renderComponent(component, coordinate, theme, library3, markState) {
  const [useGuideComponent] = useLibrary("component", library3);
  const { scaleInstances: scales, scale: scale12, bbox } = component, options = __rest72(component, ["scaleInstances", "scale", "bbox"]);
  const value2 = { bbox, library: library3 };
  const render3 = useGuideComponent(options);
  return render3({
    coordinate,
    library: library3,
    markState,
    scales,
    theme,
    value: value2,
    scale: scale12
  });
}
function normalizeComponents(components) {
  return components.map((d4) => {
    const component = deep_mix_default(d4, d4.style);
    delete component.style;
    return component;
  });
}
function groupComponents(components, crossSize) {
  const P = ["left", "right", "bottom", "top"];
  const key = ({ type, position, group: group3 }) => {
    if (!P.includes(position))
      return Symbol("independent");
    if (group3 === void 0) {
      if (type.startsWith("legend"))
        return `legend-${position}`;
      return Symbol("independent");
    }
    if (group3 === "independent")
      return Symbol("independent");
    return group3;
  };
  const grouped = groups(components, key);
  return grouped.flatMap(([, components2]) => {
    if (components2.length === 1)
      return components2[0];
    if (crossSize !== void 0) {
      const DL = components2.filter((d4) => d4.length !== void 0).map((d4) => d4.length);
      const totalLength = sum(DL);
      if (totalLength > crossSize) {
        components2.forEach((d4) => d4.group = Symbol("independent"));
        return components2;
      }
      const emptyLength = crossSize - totalLength;
      const emptyCount = components2.length - DL.length;
      const length5 = emptyLength / emptyCount;
      components2.forEach((d4) => {
        if (d4.length !== void 0)
          return;
        d4.length = length5;
      });
    }
    const size3 = max5(components2, (d4) => d4.size);
    const order = max5(components2, (d4) => d4.order);
    const crossPadding = max5(components2, (d4) => d4.crossPadding);
    const position = components2[0].position;
    return {
      type: "group",
      size: size3,
      order,
      position,
      children: components2,
      crossPadding
    };
  });
}
function inferLegendComponentType(scales, coordinates) {
  const channels = ["shape", "size", "color", "opacity"];
  const isConstantSize = (type, name2) => type === "constant" && name2 === "size";
  const accepts = scales.filter(({ type, name: name2 }) => typeof type === "string" && channels.includes(name2) && !isConstantSize(type, name2));
  const constants = accepts.filter(({ type }) => type === "constant");
  const nonConstants = accepts.filter(({ type }) => type !== "constant");
  const groupKey = (d4) => d4.field ? d4.field : Symbol("independent");
  const fieldScales = groups(nonConstants, groupKey).map(([key, scales2]) => [key, [...scales2, ...constants]]).filter(([, scales2]) => scales2.some((scale12) => scale12.type !== "constant"));
  const scalesByField = new Map(fieldScales);
  if (scalesByField.size === 0)
    return [];
  const sort2 = (arr) => arr.sort(([a5], [b]) => a5.localeCompare(b));
  const components = Array.from(scalesByField).map(([, scs]) => {
    const combinations = combine(scs).sort((a5, b) => b.length - a5.length);
    const options = combinations.map((combination) => ({
      combination,
      option: combination.map((scale12) => [scale12.name, getScaleType(scale12)])
    }));
    for (const { option, combination } of options) {
      if (option.every((d4) => d4[1] === "constant"))
        continue;
      if (option.every((d4) => d4[1] === "discrete" || d4[1] === "constant")) {
        return ["legendCategory", combination];
      }
    }
    for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {
      for (const { option, combination } of options) {
        if (accords.some((accord) => is_equal_default(sort2(accord), sort2(option)))) {
          return [componentType, combination];
        }
      }
    }
    return null;
  }).filter(defined);
  return components;
}
function getScaleType(scale12) {
  const { type } = scale12;
  if (typeof type !== "string")
    return null;
  if (type in ContinuousScale)
    return "continuous";
  if (type in DiscreteScale)
    return "discrete";
  if (type in DistributionScale)
    return "distribution";
  if (type in ConstantScale)
    return "constant";
  return null;
}
function inferAxisComponentType(scales, coordinates) {
  return scales.map((scale12) => {
    const { name: name2 } = scale12;
    if (isHelix2(coordinates) || isTheta2(coordinates))
      return null;
    if (isTranspose2(coordinates) && (isPolar2(coordinates) || isRadial2(coordinates)))
      return null;
    if (name2.startsWith("x")) {
      if (isPolar2(coordinates))
        return ["axisArc", [scale12]];
      if (isRadial2(coordinates))
        return ["axisLinear", [scale12]];
      return [isTranspose2(coordinates) ? "axisY" : "axisX", [scale12]];
    }
    if (name2.startsWith("y")) {
      if (isPolar2(coordinates))
        return ["axisLinear", [scale12]];
      if (isRadial2(coordinates))
        return ["axisArc", [scale12]];
      return [isTranspose2(coordinates) ? "axisX" : "axisY", [scale12]];
    }
    if (name2.startsWith("z")) {
      return ["axisZ", [scale12]];
    }
    if (name2.startsWith("position")) {
      if (isRadar2(coordinates))
        return ["axisRadar", [scale12]];
      if (!isPolar2(coordinates))
        return ["axisY", [scale12]];
    }
    return null;
  }).filter(defined);
}
function inferComponentsType(scales, coordinates) {
  const availableScales = scales.filter((scale12) => isValidScale(scale12));
  return [
    ...inferLegendComponentType(availableScales, coordinates),
    ...inferAxisComponentType(availableScales, coordinates)
  ];
}
function angleOf3(coordinates) {
  const polar2 = coordOf(coordinates, "polar");
  if (polar2.length) {
    const lastPolar = polar2[polar2.length - 1];
    const { startAngle, endAngle } = getPolarOptions(lastPolar);
    return [startAngle, endAngle];
  }
  const radial = coordOf(coordinates, "radial");
  if (radial.length) {
    const lastRadial = radial[radial.length - 1];
    const { startAngle, endAngle } = getRadialOptions(lastRadial);
    return [startAngle, endAngle];
  }
  return [-Math.PI / 2, Math.PI / 2 * 3];
}
function matchPosition(name2) {
  const match = /position(\d*)/g.exec(name2);
  if (!match)
    return null;
  return +match[1];
}
function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
  const { name: name2 } = relativeScales[0];
  if (type === "axisRadar") {
    const positions = scales.filter((scale12) => scale12.name.startsWith("position"));
    const index3 = matchPosition(name2);
    if (index3 === null)
      return [null, null];
    const [startAngle, endAngle] = angleOf3(coordinates);
    const positionLength = isRadar2(coordinates) ? positions.length : positions.length - 1;
    const angle4 = (endAngle - startAngle) / positionLength * index3 + startAngle;
    return ["center", angle4];
  }
  if (type === "axisY" && isParallel2(coordinates)) {
    return isTranspose2(coordinates) ? ["center", "horizontal"] : ["center", "vertical"];
  }
  if (type === "axisLinear") {
    const [startAngle] = angleOf3(coordinates);
    return ["center", startAngle];
  }
  if (type === "axisArc") {
    if (ordinalPosition[0] === "inner")
      return ["inner", null];
    return ["outer", null];
  }
  if (isPolar2(coordinates))
    return ["center", null];
  if (isRadial2(coordinates))
    return ["center", null];
  if (type === "axisX" && isReflect(coordinates) || type === "axisX" && isReflectY(coordinates)) {
    return ["top", null];
  }
  return ordinalPosition;
}
function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
  const [startAngle] = angleOf3(coordinates);
  const ordinalPositionAndOrientation = [
    guide.position || defaultPosition,
    startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation
  ];
  if (typeof type === "string" && type.startsWith("axis")) {
    return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
  }
  if (typeof type === "string" && type.startsWith("legend") && isPolar2(coordinates)) {
    if (guide.position === "center")
      return ["center", "vertical"];
  }
  return ordinalPositionAndOrientation;
}
function inferScrollableType(name2, type, coordinates = []) {
  if (name2 === "x")
    return isTranspose2(coordinates) ? `${type}Y` : `${type}X`;
  if (name2 === "y")
    return isTranspose2(coordinates) ? `${type}X` : `${type}Y`;
  return null;
}
function inferScrollableComponents(partialOptions, scales, library3) {
  const [, createGuideComponent] = useLibrary("component", library3);
  const { coordinates } = partialOptions;
  function normalized(type, channelName, scale12, options) {
    const componentType = inferScrollableType(channelName, type, coordinates);
    if (!options || !componentType)
      return;
    const { props } = createGuideComponent(componentType);
    const { defaultPosition, defaultSize, defaultOrder, defaultCrossPadding: [crossPadding] } = props;
    return Object.assign(Object.assign({ position: defaultPosition, defaultSize, order: defaultOrder, type: componentType, crossPadding }, options), { scales: [scale12] });
  }
  return scales.filter((d4) => d4.slider || d4.scrollbar).flatMap((scale12) => {
    const { slider, scrollbar, name: channelName } = scale12;
    return [
      normalized("slider", channelName, scale12, slider),
      normalized("scrollbar", channelName, scale12, scrollbar)
    ];
  }).filter((d4) => !!d4);
}
function computeComponentSize(component, crossSize, crossPadding, position, theme, library3) {
  const { type } = component;
  const paddingAreas = ["left", "right", "bottom", "top"];
  if (!paddingAreas.includes(position))
    return;
  if (typeof type !== "string")
    return;
  const t = type;
  const createCompute = () => {
    if (t.startsWith("axis"))
      return computeAxisSize;
    if (t.startsWith("group"))
      return computeGroupSize;
    if (t.startsWith("legendContinuous"))
      return computeContinuousLegendSize;
    if (t === "legendCategory")
      return computeCategoryLegendSize;
    if (t.startsWith("slider"))
      return computeSliderSize;
    if (t === "title")
      return computeTitleSize;
    if (t.startsWith("scrollbar"))
      return computeScrollbarSize;
    return () => {
    };
  };
  return createCompute()(component, crossSize, crossPadding, position, theme, library3);
}
function computeGroupSize(component, crossSize, crossPadding, position, theme, library3) {
  const { children } = component;
  const maxCrossPadding = max5(children, (d4) => d4.crossPadding);
  children.forEach((d4) => d4.crossPadding = maxCrossPadding);
  children.forEach((child) => computeComponentSize(child, crossSize, crossPadding, position, theme, library3));
  const maxSize = max5(children, (d4) => d4.size);
  component.size = maxSize;
  children.forEach((d4) => d4.size = maxSize);
}
function computeScrollbarSize(component, crossSize, crossPadding, position, theme, library3) {
  const { trackSize = 6 } = deep_mix_default({}, theme.scrollbar, component);
  component.size = trackSize;
}
function computeTitleSize(component, crossSize, crossPadding, position, theme, library3) {
  const _a2 = deep_mix_default({}, theme.title, component), { title, subtitle, spacing = 0 } = _a2, style = __rest72(_a2, ["title", "subtitle", "spacing"]);
  if (title) {
    const titleStyle = subObject(style, "title");
    const titleBBox = computeLabelSize(title, titleStyle);
    component.size = titleBBox.height;
  }
  if (subtitle) {
    const subtitleStyle = subObject(style, "subtitle");
    const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);
    component.size += spacing + subtitleBBox.height;
  }
}
function computeSliderSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { slider } = theme;
    return deep_mix_default({}, slider, component);
  };
  const { trackSize, handleIconSize } = styleOf2();
  const size3 = Math.max(trackSize, handleIconSize * 2.4);
  component.size = size3;
}
function computeAxisSize(component, crossSize, crossPadding, position, theme, library3) {
  var _a2;
  component.transform = component.transform || [{ type: "hide" }];
  const isVertical2 = position === "left" || position === "right";
  const style = styleOf(component, position, theme);
  const { tickLength = 0, labelSpacing = 0, titleSpacing = 0, labelAutoRotate } = style, rest = __rest72(style, ["tickLength", "labelSpacing", "titleSpacing", "labelAutoRotate"]);
  const scale12 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale12);
  const paddingTick = tickLength + labelSpacing;
  if (labelBBoxes && labelBBoxes.length) {
    const maxLabelWidth = max5(labelBBoxes, (d4) => d4.width);
    const maxLabelHeight = max5(labelBBoxes, (d4) => d4.height);
    if (isVertical2) {
      component.size = maxLabelWidth + paddingTick;
    } else {
      const { tickFilter, labelTransform } = component;
      if (overflowX(scale12, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {
        component.labelTransform = "rotate(90)";
        component.size = maxLabelWidth + paddingTick;
      } else {
        component.labelTransform = (_a2 = component.labelTransform) !== null && _a2 !== void 0 ? _a2 : "rotate(0)";
        component.size = maxLabelHeight + paddingTick;
      }
    }
  } else {
    component.size = tickLength;
  }
  const titleBBox = computeTitleBBox(rest);
  if (titleBBox) {
    if (isVertical2) {
      component.size += titleSpacing + titleBBox.width;
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendContinuous } = theme;
    return deep_mix_default({}, legendContinuous, component);
  };
  const _a2 = styleOf2(), { labelSpacing = 0, titleSpacing = 0 } = _a2, rest = __rest72(_a2, ["labelSpacing", "titleSpacing"]);
  const isVertical2 = position === "left" || position === "right";
  const ribbonStyles = subObject(rest, "ribbon");
  const { size: ribbonSize } = ribbonStyles;
  const handleIconStyles = subObject(rest, "handleIcon");
  const { size: handleIconSize } = handleIconStyles;
  const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);
  component.size = mainSize;
  const scale12 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale12);
  if (labelBBoxes) {
    const key = isVertical2 ? "width" : "height";
    const size3 = max5(labelBBoxes, (d4) => d4[key]);
    component.size += size3 + labelSpacing;
  }
  const titleBBox = computeTitleBBox(rest);
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library3) {
  const styleOf2 = () => {
    const { legendCategory } = theme;
    const { title } = component;
    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
    return deep_mix_default({ title: defaultTitle }, legendCategory, Object.assign(Object.assign({}, component), { title: specifiedTitle }));
  };
  const _a2 = styleOf2(), { itemSpacing, itemMarkerSize, titleSpacing, rowPadding, colPadding, maxCols = Infinity, maxRows = Infinity } = _a2, rest = __rest72(_a2, ["itemSpacing", "itemMarkerSize", "titleSpacing", "rowPadding", "colPadding", "maxCols", "maxRows"]);
  const { cols, length: length5 } = component;
  const getRows = (rows) => Math.min(rows, maxRows);
  const getCols = (cols2) => Math.min(cols2, maxCols);
  const isVertical2 = position === "left" || position === "right";
  const crossSize = length5 === void 0 ? crossSize0 + (isVertical2 ? 0 : crossPadding[0] + crossPadding[1]) : length5;
  const titleBBox = computeTitleBBox(rest);
  const scale12 = createScale(component, library3);
  const labelBBoxes = computeLabelsBBox(rest, scale12, "itemLabel");
  const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;
  const widthOf = (w2, padding = 0) => itemMarkerSize + w2 + itemSpacing[0] + padding;
  const computeVerticalSize = () => {
    let maxSize = -Infinity;
    let pos = 0;
    let cols2 = 1;
    let rows = 0;
    let maxRows2 = -Infinity;
    let maxPos = -Infinity;
    const titleHeight = titleBBox ? titleBBox.height : 0;
    const maxHeight = crossSize - titleHeight;
    for (const { width } of labelBBoxes) {
      const w2 = widthOf(width, colPadding);
      maxSize = Math.max(maxSize, w2);
      if (pos + height > maxHeight) {
        cols2++;
        maxRows2 = Math.max(maxRows2, rows);
        maxPos = Math.max(maxPos, pos);
        rows = 1;
        pos = height;
      } else {
        pos += height;
        rows++;
      }
    }
    if (cols2 <= 1) {
      maxRows2 = rows;
      maxPos = pos;
    }
    component.size = maxSize * getCols(cols2);
    component.length = maxPos + titleHeight;
    deep_mix_default(component, { cols: getCols(cols2), gridRow: maxRows2 });
  };
  const computeHorizontalGrid = () => {
    const rows = Math.ceil(labelBBoxes.length / cols);
    const maxWidth = max5(labelBBoxes, (d4) => widthOf(d4.width)) * cols;
    component.size = height * getRows(rows) - rowPadding;
    component.length = Math.min(maxWidth, crossSize);
  };
  const computeHorizontalFlex = () => {
    let rows = 1;
    let pos = 0;
    let maxPos = -Infinity;
    for (const { width } of labelBBoxes) {
      const w2 = widthOf(width, colPadding);
      if (pos + w2 > crossSize) {
        maxPos = Math.max(maxPos, pos);
        pos = w2;
        rows++;
      } else {
        pos += w2;
      }
    }
    if (rows === 1)
      maxPos = pos;
    component.size = height * getRows(rows) - rowPadding;
    component.length = maxPos;
  };
  if (isVertical2)
    computeVerticalSize();
  else if (typeof cols === "number")
    computeHorizontalGrid();
  else
    computeHorizontalFlex();
  if (titleBBox) {
    if (isVertical2) {
      component.size = Math.max(component.size, titleBBox.width);
    } else {
      component.size += titleSpacing + titleBBox.height;
    }
  }
}
function createScale(component, library3) {
  const [useScale] = useLibrary("scale", library3);
  const { scales, tickCount, tickMethod } = component;
  const scaleOptions = scales.find((d4) => d4.type !== "constant" && d4.type !== "identity");
  if (tickCount !== void 0)
    scaleOptions.tickCount = tickCount;
  if (tickMethod !== void 0)
    scaleOptions.tickMethod = tickMethod;
  return useScale(scaleOptions);
}
function computeLabelsBBox(component, scale12, key = "label") {
  const { labelFormatter: labelFormatter2, tickFilter, label = true } = component, style = __rest72(component, ["labelFormatter", "tickFilter", "label"]);
  if (!label)
    return null;
  const labels = labelsOf(scale12, labelFormatter2, tickFilter);
  const labelStyle = subObject(style, key);
  const labelStyles = labels.map((d4, i2) => Object.fromEntries(Object.entries(labelStyle).map(([key2, value2]) => [
    key2,
    typeof value2 === "function" ? value2(d4, i2) : value2
  ])));
  const labelBBoxes = labels.map((d4, i2) => {
    const normalizeStyle = labelStyles[i2];
    return computeLabelSize(d4, normalizeStyle);
  });
  const hasTransform = labelStyles.some((d4) => d4.transform);
  if (!hasTransform) {
    const I = labels.map((_2, i2) => i2);
    component.indexBBox = new Map(I.map((i2) => [i2, [labels[i2], labelBBoxes[i2]]]));
  }
  return labelBBoxes;
}
function computeTitleBBox(component) {
  const isFalsy = (x3) => x3 === false || x3 === null;
  const { title } = component, style = __rest72(component, ["title"]);
  if (isFalsy(title) || title === void 0)
    return null;
  const titleStyle = subObject(style, "title");
  const { direction: direction3, transform: transform2 } = titleStyle;
  const titleText = Array.isArray(title) ? title.join(",") : title;
  if (typeof titleText !== "string")
    return null;
  const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), { transform: transform2 || (direction3 === "vertical" ? "rotate(-90)" : "") }));
  return titleBBox;
}
function styleOf(axis, position, theme) {
  const { title } = axis;
  const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
  const {
    axis: baseStyle,
    // @ts-ignore
    [`axis${capitalizeFirst(position)}`]: positionStyle
  } = theme;
  return deep_mix_default({ title: defaultTitle }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), { title: specifiedTitle }));
}
function ticksOf2(scale12, tickFilter) {
  const ticks2 = scale12.getTicks ? scale12.getTicks() : scale12.getOptions().domain;
  if (!tickFilter)
    return ticks2;
  return ticks2.filter(tickFilter);
}
function labelsOf(scale12, labelFormatter2, tickFilter) {
  const T2 = ticksOf2(scale12, tickFilter);
  const ticks2 = T2.map((d4) => typeof d4 === "number" ? prettyNumber2(d4) : d4);
  const formatter2 = labelFormatter2 ? typeof labelFormatter2 === "string" ? format2(labelFormatter2) : labelFormatter2 : scale12.getFormatter ? scale12.getFormatter() : (d4) => `${d4}`;
  return ticks2.map(formatter2);
}
function offsetOf(scale12, d4) {
  if (!scale12.getBandWidth)
    return 0;
  const offset2 = scale12.getBandWidth(d4) / 2;
  return offset2;
}
function overflowX(scale12, labelBBoxes, crossSize, crossPadding, tickFilter) {
  const totalSize = sum(labelBBoxes, (d4) => d4.width);
  if (totalSize > crossSize)
    return true;
  const scaleX2 = scale12.clone();
  scaleX2.update({ range: [0, crossSize] });
  const ticks2 = ticksOf2(scale12, tickFilter);
  const X = ticks2.map((d4) => scaleX2.map(d4) + offsetOf(scaleX2, d4));
  const I = ticks2.map((_2, i2) => i2);
  const startX = -crossPadding[0];
  const endX = crossSize + crossPadding[1];
  const extent2 = (x3, bbox) => {
    const { width } = bbox;
    return [x3 - width / 2, x3 + width / 2];
  };
  for (let i2 = 0; i2 < I.length; i2++) {
    const x3 = X[i2];
    const [x05, x12] = extent2(x3, labelBBoxes[i2]);
    if (x05 < startX || x12 > endX)
      return true;
    const y4 = X[i2 + 1];
    if (y4) {
      const [y05] = extent2(y4, labelBBoxes[i2 + 1]);
      if (x12 > y05)
        return true;
    }
  }
  return false;
}
function computeLabelSize(d4, style) {
  const shape23 = normalizeLabel(d4);
  const { filter: filter3 } = style, rest = __rest72(style, ["filter"]);
  shape23.attr(Object.assign(Object.assign({}, rest), { visibility: "none" }));
  const bbox = shape23.getBBox();
  return bbox;
}
function normalizeLabel(d4) {
  if (d4 instanceof DisplayObject)
    return d4;
  return new Text({ style: { text: `${d4}` } });
}

// node_modules/@antv/g2/esm/runtime/layout.js
function processAxisZ(components) {
  const axisX = components.find(({ type }) => type === "axisX");
  const axisY = components.find(({ type }) => type === "axisY");
  const axisZ = components.find(({ type }) => type === "axisZ");
  if (axisX && axisY && axisZ) {
    axisX.plane = "xy";
    axisY.plane = "xy";
    axisZ.plane = "yz";
    axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];
    axisZ.eulerAngles = [0, -90, 0];
    axisZ.bbox.x = axisX.bbox.x;
    axisZ.bbox.y = axisX.bbox.y;
    components.push(Object.assign(Object.assign({}, axisX), { plane: "xz", showLabel: false, showTitle: false, origin: [axisX.bbox.x, axisX.bbox.y, 0], eulerAngles: [-90, 0, 0] }));
    components.push(Object.assign(Object.assign({}, axisY), { plane: "yz", showLabel: false, showTitle: false, origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0], eulerAngles: [0, -90, 0] }));
    components.push(Object.assign(Object.assign({}, axisZ), { plane: "xz", actualPosition: "left", showLabel: false, showTitle: false, eulerAngles: [90, -90, 0] }));
  }
}
function computeLayout(components, options, theme, library3) {
  var _a2, _b;
  const { width, height, depth, x: x3 = 0, y: y4 = 0, z = 0, inset = (_a2 = theme.inset) !== null && _a2 !== void 0 ? _a2 : 0, insetLeft = inset, insetTop = inset, insetBottom = inset, insetRight = inset, margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0, marginLeft = margin, marginBottom = margin, marginTop = margin, marginRight = margin, padding = theme.padding, paddingBottom = padding, paddingLeft = padding, paddingRight = padding, paddingTop = padding } = computeInset(components, options, theme, library3);
  const MIN_CONTENT_RATIO = 1 / 4;
  const maybeClamp = (viewWidth2, paddingLeft2, paddingRight2, pl02, pr02) => {
    const { marks } = options;
    if (marks.length === 0)
      return [pl02, pr02];
    const contentSize = viewWidth2 - pl02 - pr02;
    const diff = contentSize - viewWidth2 * MIN_CONTENT_RATIO;
    if (diff > 0)
      return [pl02, pr02];
    const shrinkSize = viewWidth2 * (1 - MIN_CONTENT_RATIO);
    return [
      paddingLeft2 === "auto" ? shrinkSize * pl02 / (pl02 + pr02) : pl02,
      paddingRight2 === "auto" ? shrinkSize * pr02 / (pl02 + pr02) : pr02
    ];
  };
  const roughPadding = (padding2) => padding2 === "auto" ? 20 : padding2 !== null && padding2 !== void 0 ? padding2 : 20;
  const rpt = roughPadding(paddingTop);
  const rpb = roughPadding(paddingBottom);
  const horizontalPadding = computePadding(components, height - rpt - rpb, [rpt + marginTop, rpb + marginBottom], ["left", "right"], options, theme, library3);
  const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;
  const viewWidth = width - marginLeft - marginRight;
  const [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);
  const iw = viewWidth - pl - pr;
  const verticalPadding = computePadding(components, iw, [pl + marginLeft, pr + marginRight], ["bottom", "top"], options, theme, library3);
  const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;
  const viewHeight = height - marginBottom - marginTop;
  const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);
  const ih = viewHeight - pb - pt;
  return {
    width,
    height,
    depth,
    insetLeft,
    insetTop,
    insetBottom,
    insetRight,
    innerWidth: iw,
    innerHeight: ih,
    paddingLeft: pl,
    paddingRight: pr,
    paddingTop: pt,
    paddingBottom: pb,
    marginLeft,
    marginBottom,
    marginTop,
    marginRight,
    x: x3,
    y: y4,
    z
  };
}
function computeRoughPlotSize(options) {
  const { height, width, padding = 0, paddingLeft = padding, paddingRight = padding, paddingTop = padding, paddingBottom = padding, margin = 16, marginLeft = margin, marginRight = margin, marginTop = margin, marginBottom = margin, inset = 0, insetLeft = inset, insetRight = inset, insetTop = inset, insetBottom = inset } = options;
  const maybeAuto = (padding2) => padding2 === "auto" ? 20 : padding2;
  const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;
  const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;
  return { width: finalWidth, height: finalHeight };
}
function computeInset(components, options, theme, library3) {
  const { coordinates } = options;
  if (!isPolar2(coordinates) && !isRadial2(coordinates)) {
    return options;
  }
  const axes = components.filter((d4) => typeof d4.type === "string" && d4.type.startsWith("axis"));
  if (axes.length === 0)
    return options;
  const styles = axes.map((component) => {
    const key = component.type === "axisArc" ? "arc" : "linear";
    return styleOf(component, key, theme);
  });
  const maxLabelSpacing = max5(styles, (d4) => {
    var _a2;
    return (_a2 = d4.labelSpacing) !== null && _a2 !== void 0 ? _a2 : 0;
  });
  const labelBBoxes = axes.flatMap((component, i2) => {
    const style = styles[i2];
    const scale12 = createScale(component, library3);
    const labels = computeLabelsBBox(style, scale12);
    return labels;
  }).filter(defined);
  const size3 = max5(labelBBoxes, (d4) => d4.height) + maxLabelSpacing;
  const titleBBoxes = axes.flatMap((_2, i2) => {
    const style = styles[i2];
    return computeTitleBBox(style);
  }).filter((d4) => d4 !== null);
  const titleSize = titleBBoxes.length === 0 ? 0 : max5(titleBBoxes, (d4) => d4.height);
  const { inset = size3, insetLeft = inset, insetBottom = inset, insetTop = inset + titleSize, insetRight = inset } = options;
  return Object.assign(Object.assign({}, options), { insetLeft, insetBottom, insetTop, insetRight });
}
function computePadding(components, crossSize, crossPadding, positions, options, theme, library3) {
  const positionComponents = group(components, (d4) => d4.position);
  const { padding = theme.padding, paddingLeft = padding, paddingRight = padding, paddingBottom = padding, paddingTop = padding } = options;
  const layout = {
    paddingBottom,
    paddingLeft,
    paddingTop,
    paddingRight
  };
  for (const position of positions) {
    const key = `padding${capitalizeFirst(camelCase(position))}`;
    const components2 = positionComponents.get(position) || [];
    const value2 = layout[key];
    const defaultSizeOf = (d4) => {
      if (d4.size === void 0)
        d4.size = d4.defaultSize;
    };
    const sizeOf3 = (d4) => {
      if (d4.type === "group") {
        d4.children.forEach(defaultSizeOf);
        d4.size = max5(d4.children, (d5) => d5.size);
      } else {
        d4.size = d4.defaultSize;
      }
    };
    const autoSizeOf = (d4) => {
      if (d4.size)
        return;
      if (value2 !== "auto")
        sizeOf3(d4);
      else {
        computeComponentSize(d4, crossSize, crossPadding, position, theme, library3);
        defaultSizeOf(d4);
      }
    };
    const maybeHide = (d4) => {
      if (!d4.type.startsWith("axis"))
        return;
      if (d4.labelAutoHide === void 0)
        d4.labelAutoHide = true;
    };
    const isHorizontal3 = position === "bottom" || position === "top";
    const minOrder = min4(components2, (d4) => d4.order);
    const axes = components2.filter((d4) => d4.type.startsWith("axis") && d4.order == minOrder);
    if (axes.length)
      axes[0].crossPadding = 0;
    if (typeof value2 === "number") {
      components2.forEach(defaultSizeOf);
      components2.forEach(maybeHide);
    } else {
      if (components2.length === 0) {
        layout[key] = 0;
      } else {
        const size3 = isHorizontal3 ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;
        const grouped = groupComponents(components2, size3);
        grouped.forEach(autoSizeOf);
        const totalSize = grouped.reduce((sum4, { size: size4, crossPadding: crossPadding2 = 12 }) => sum4 + size4 + crossPadding2, 0);
        layout[key] = totalSize;
      }
    }
  }
  return layout;
}
function placeComponents(components, coordinate, layout) {
  const positionComponents = group(components, (d4) => `${d4.plane || "xy"}-${d4.position}`);
  const { paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop, height, width, depth } = layout;
  const planes = {
    xy: createSection({
      width,
      height,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingBottom,
      marginLeft,
      marginTop,
      marginBottom,
      marginRight,
      innerHeight,
      innerWidth,
      insetBottom,
      insetLeft,
      insetRight,
      insetTop
    }),
    yz: createSection({
      width: depth,
      height,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: depth,
      innerHeight: height,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    }),
    xz: createSection({
      width,
      height: depth,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      marginLeft: 0,
      marginTop: 0,
      marginBottom: 0,
      marginRight: 0,
      innerWidth: width,
      innerHeight: depth,
      insetBottom: 0,
      insetLeft: 0,
      insetRight: 0,
      insetTop: 0
    })
  };
  for (const [key, components2] of positionComponents.entries()) {
    const [plane, position] = key.split("-");
    const area2 = planes[plane][position];
    const [nonEntityComponents, entityComponents] = divide4(components2, (component) => {
      if (typeof component.type !== "string")
        return false;
      if (position === "center")
        return true;
      if (component.type.startsWith("axis") && ["inner", "outer"].includes(position)) {
        return true;
      }
      return false;
    });
    if (nonEntityComponents.length) {
      placeNonEntityComponents(nonEntityComponents, coordinate, area2, position);
    }
    if (entityComponents.length) {
      placePaddingArea(components2, coordinate, area2);
    }
  }
}
function createSection({ width, height, paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop }) {
  const pl = paddingLeft + marginLeft;
  const pt = paddingTop + marginTop;
  const pr = paddingRight + marginRight;
  const pb = paddingBottom + marginBottom;
  const plotWidth = width - marginLeft - marginRight;
  const centerSection = [
    pl + insetLeft,
    pt + insetTop,
    innerWidth - insetLeft - insetRight,
    innerHeight - insetTop - insetBottom,
    "center",
    null,
    null
  ];
  const xySection = {
    top: [
      pl,
      0,
      innerWidth,
      pt,
      "vertical",
      true,
      ascending,
      marginLeft,
      plotWidth
    ],
    right: [width - pr, pt, pr, innerHeight, "horizontal", false, ascending],
    bottom: [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending,
      marginLeft,
      plotWidth
    ],
    left: [0, pt, pl, innerHeight, "horizontal", true, ascending],
    "top-left": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "top-right": [pl, 0, innerWidth, pt, "vertical", true, ascending],
    "bottom-left": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    "bottom-right": [
      pl,
      height - pb,
      innerWidth,
      pb,
      "vertical",
      false,
      ascending
    ],
    center: centerSection,
    inner: centerSection,
    outer: centerSection
  };
  return xySection;
}
function placeNonEntityComponents(components, coordinate, area2, position) {
  const [axisComponents, nonAxisComponents] = divide4(components, (component) => {
    if (typeof component.type === "string" && component.type.startsWith("axis")) {
      return true;
    }
    return false;
  });
  placeNonEntityAxis(axisComponents, coordinate, area2, position);
  placeCenter(nonAxisComponents, coordinate, area2);
}
function placeNonEntityAxis(components, coordinate, area2, position) {
  if (position === "center") {
    if (isRadar(coordinate)) {
      placeAxisRadar(components, coordinate, area2, position);
    } else if (isPolar(coordinate)) {
      placeArcLinear(components, coordinate, area2);
    } else if (isParallel(coordinate)) {
      placeAxisParallel(components, coordinate, area2, components[0].orientation);
    }
  } else if (position === "inner") {
    placeAxisArcInner(components, coordinate, area2);
  } else if (position === "outer") {
    placeAxisArcOuter(components, coordinate, area2);
  }
}
function placeAxisArcInner(components, coordinate, area2) {
  const [x3, y4, , height] = area2;
  const [cx, cy] = coordinate.getCenter();
  const [innerRadius] = radiusOf(coordinate);
  const r2 = height / 2;
  const size3 = innerRadius * r2;
  const x05 = cx - size3;
  const y05 = cy - size3;
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    component.bbox = {
      x: x3 + x05,
      y: y4 + y05,
      width: size3 * 2,
      height: size3 * 2
    };
  }
}
function placeAxisArcOuter(components, coordinate, area2) {
  const [x3, y4, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y4, width, height };
  }
}
function placeArcLinear(components, coordinate, area2) {
  const [x3, y4, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y4, width, height };
  }
}
function placeAxisParallel(components, coordinate, area2, orientation) {
  if (orientation === "horizontal") {
    placeAxisParallelHorizontal(components, coordinate, area2);
  } else if (orientation === "vertical") {
    placeAxisParallelVertical(components, coordinate, area2);
  }
}
function placeAxisParallelVertical(components, coordinate, area2) {
  const [x3, y4, , height] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate.map(vector);
  const X = points.filter((_2, i2) => i2 % 2 === 0).map((d4) => d4 + x3);
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    const x4 = X[i2];
    const width = X[i2 + 1] - x4;
    component.bbox = { x: x4, y: y4, width, height };
  }
}
function placeAxisParallelHorizontal(components, coordinate, area2) {
  const [x3, y4, width] = area2;
  const vector = new Array(components.length).fill(0);
  const points = coordinate.map(vector);
  const Y = points.filter((_2, i2) => i2 % 2 === 1).map((d4) => d4 + y4);
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    const y5 = Y[i2];
    const height = Y[i2 + 1] - y5;
    component.bbox = { x: x3, y: y5, width, height };
  }
}
function placeAxisRadar(components, coordinate, area2, position) {
  const [x3, y4, width, height] = area2;
  for (const component of components) {
    component.bbox = { x: x3, y: y4, width, height };
    component.radar = {
      index: components.indexOf(component),
      count: components.length
    };
  }
}
function placePaddingArea(components, coordinate, area2) {
  const [x3, y4, width, height, direction3, reverse2, comparator, minX, totalSize] = area2;
  const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction3 === "vertical" ? ["y", y4, "x", x3, "height", height, "width", width] : ["x", x3, "y", y4, "width", width, "height", height];
  components.sort((a5, b) => comparator === null || comparator === void 0 ? void 0 : comparator(a5.order, b.order));
  const isLarge = (type) => type === "title" || type === "group" || type.startsWith("legend");
  const crossSizeOf = (type, small, bigger) => {
    if (bigger === void 0)
      return small;
    if (isLarge(type))
      return bigger;
    return small;
  };
  const crossStartOf = (type, x4, minX2) => {
    if (minX2 === void 0)
      return x4;
    if (isLarge(type))
      return minX2;
    return x4;
  };
  const startValue = reverse2 ? mainStartValue + mainSizeValue : mainStartValue;
  for (let i2 = 0, start = startValue; i2 < components.length; i2++) {
    const component = components[i2];
    const { crossPadding = 0, type } = component;
    const { size: size3 } = component;
    component.bbox = {
      [mainStartKey]: reverse2 ? start - size3 - crossPadding : start + crossPadding,
      [crossStartKey]: crossStartOf(type, crossStartValue, minX),
      [mainSizeKey]: size3,
      [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)
    };
    start += (size3 + crossPadding) * (reverse2 ? -1 : 1);
  }
  const groupComponents2 = components.filter((d4) => d4.type === "group");
  for (const group3 of groupComponents2) {
    const { bbox, children } = group3;
    const size3 = bbox[crossSizeKey];
    const step2 = size3 / children.length;
    const justifyContent = children.reduce((j, child) => {
      var _a2;
      const j0 = (_a2 = child.layout) === null || _a2 === void 0 ? void 0 : _a2.justifyContent;
      return j0 ? j0 : j;
    }, "flex-start");
    const L = children.map((d4, i2) => {
      const { length: length5 = step2, padding = 0 } = d4;
      return length5 + (i2 === children.length - 1 ? 0 : padding);
    });
    const totalLength = sum(L);
    const diff = size3 - totalLength;
    const offset2 = justifyContent === "flex-start" ? 0 : justifyContent === "center" ? diff / 2 : diff;
    for (let i2 = 0, start = bbox[crossStartKey] + offset2; i2 < children.length; i2++) {
      const component = children[i2];
      const { padding = 0 } = component;
      const interval2 = i2 === children.length - 1 ? 0 : padding;
      component.bbox = {
        [mainSizeKey]: bbox[mainSizeKey],
        [mainStartKey]: bbox[mainStartKey],
        [crossStartKey]: start,
        [crossSizeKey]: L[i2] - interval2
      };
      deep_mix_default(component, { layout: { justifyContent } });
      start += L[i2];
    }
  }
}
function placeCenter(components, coordinate, area2) {
  if (components.length === 0)
    return;
  const [x3, y4, width, height] = area2;
  const [innerRadius] = radiusOf(coordinate);
  const r2 = height / 2 * innerRadius / Math.sqrt(2);
  const cx = x3 + width / 2;
  const cy = y4 + height / 2;
  for (let i2 = 0; i2 < components.length; i2++) {
    const component = components[i2];
    component.bbox = { x: cx - r2, y: cy - r2, width: r2 * 2, height: r2 * 2 };
  }
}

// node_modules/@antv/g2/esm/runtime/transform.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest73 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var CALLBACK_ITEM_SYMBOL = Symbol("CALLBACK_ITEM");
function applyDefaults(I, mark2, context) {
  const { encode = {}, scale: scale12 = {}, transform: transform2 = [] } = mark2, rest = __rest73(mark2, ["encode", "scale", "transform"]);
  return [I, Object.assign(Object.assign({}, rest), { encode, scale: scale12, transform: transform2 })];
}
function applyDataTransform(I, mark2, context) {
  return __awaiter3(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { data: data2 } = mark2;
    const [useData] = useLibrary("data", library3);
    const descriptor = normalizedDataSource(data2);
    const { transform: T2 = [] } = descriptor, connector = __rest73(descriptor, ["transform"]);
    const transform2 = [connector, ...T2];
    const transformFunctions2 = transform2.map((t) => useData(t, context));
    const transformedData = yield composeAsync(transformFunctions2)(data2);
    const newData = data2 && !Array.isArray(data2) && !Array.isArray(transformedData) ? { value: transformedData } : transformedData;
    return [
      Array.isArray(transformedData) ? indexOf3(transformedData) : [],
      Object.assign(Object.assign({}, mark2), { data: newData })
    ];
  });
}
function flatEncode(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const flattenEncode = {};
  for (const [key, value2] of Object.entries(encode)) {
    if (Array.isArray(value2)) {
      for (let i2 = 0; i2 < value2.length; i2++) {
        const name2 = `${key}${i2 === 0 ? "" : i2}`;
        flattenEncode[name2] = value2[i2];
      }
    } else {
      flattenEncode[key] = value2;
    }
  }
  return [I, Object.assign(Object.assign({}, mark2), { encode: flattenEncode })];
}
function inferChannelsType(I, mark2, context) {
  const { encode, data: data2 } = mark2;
  if (!encode)
    return [I, mark2];
  const typedEncode = mapObject(encode, (channel) => {
    if (isTypedChannel(channel))
      return channel;
    const type = inferChannelType(data2, channel);
    return { type, value: channel };
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: typedEncode })];
}
function maybeVisualChannel(I, mark2, context) {
  const { encode } = mark2;
  if (!encode)
    return [I, mark2];
  const newEncode = mapObject(encode, (channel, name2) => {
    const { type } = channel;
    if (type !== "constant" || isPosition(name2))
      return channel;
    return Object.assign(Object.assign({}, channel), { constant: true });
  });
  return [I, Object.assign(Object.assign({}, mark2), { encode: newEncode })];
}
function extractColumns(I, mark2, context) {
  const { encode, data: data2 } = mark2;
  if (!encode)
    return [I, mark2];
  const { library: library3 } = context;
  const columnOf2 = createColumnOf(library3);
  const valuedEncode = mapObject(encode, (channel) => columnOf2(data2, channel));
  return [I, Object.assign(Object.assign({}, mark2), { encode: valuedEncode })];
}
function normalizeTooltip(I, mark2, context) {
  const { tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  if (Array.isArray(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: tooltip2 } })];
  }
  if (isStrictObject(tooltip2) && isFullTooltip(tooltip2)) {
    return [I, Object.assign(Object.assign({}, mark2), { tooltip: tooltip2 })];
  }
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: { items: [tooltip2] } })];
}
function extractTooltip(I, mark2, context) {
  const { data: data2, encode, tooltip: tooltip2 = {} } = mark2;
  if (isUnset(tooltip2))
    return [I, mark2];
  const valueOf4 = (item) => {
    if (!item)
      return item;
    if (typeof item === "string") {
      return I.map((i2) => ({ name: item, value: data2[i2][item] }));
    }
    if (isStrictObject(item)) {
      const { field: field3, channel, color: color3, name: name2 = field3, valueFormatter = (d4) => d4 } = item;
      const normalizedValueFormatter = typeof valueFormatter === "string" ? format2(valueFormatter) : valueFormatter;
      const definedChannel = channel && encode[channel];
      const channelField = definedChannel && encode[channel].field;
      const name1 = name2 || channelField || channel;
      const values4 = [];
      for (const i2 of I) {
        const value1 = field3 ? data2[i2][field3] : definedChannel ? encode[channel].value[i2] : null;
        values4[i2] = {
          name: name1,
          color: color3,
          value: normalizedValueFormatter(value1)
        };
      }
      return values4;
    }
    if (typeof item === "function") {
      const values4 = [];
      for (const i2 of I) {
        const v = item(data2[i2], i2, data2, encode);
        if (isStrictObject(v))
          values4[i2] = Object.assign(Object.assign({}, v), { [CALLBACK_ITEM_SYMBOL]: true });
        else
          values4[i2] = { value: v };
      }
      return values4;
    }
    return item;
  };
  const { title, items = [] } = tooltip2, rest = __rest73(tooltip2, ["title", "items"]);
  const newTooltip = Object.assign({ title: valueOf4(title), items: Array.isArray(items) ? items.map(valueOf4) : [] }, rest);
  return [I, Object.assign(Object.assign({}, mark2), { tooltip: newTooltip })];
}
function maybeArrayField(I, mark2, context) {
  const { encode } = mark2, rest = __rest73(mark2, ["encode"]);
  if (!encode)
    return [I, mark2];
  const columns = Object.entries(encode);
  const arrayColumns = columns.filter(([, channel]) => {
    const { value: V } = channel;
    return Array.isArray(V[0]);
  }).flatMap(([key, V]) => {
    const columns2 = [[key, new Array(I.length).fill(void 0)]];
    const { value: rows } = V, rest2 = __rest73(V, ["value"]);
    for (let i2 = 0; i2 < rows.length; i2++) {
      const row2 = rows[i2];
      if (Array.isArray(row2)) {
        for (let j = 0; j < row2.length; j++) {
          const column2 = columns2[j] || [
            `${key}${j}`,
            new Array(I).fill(void 0)
          ];
          column2[1][i2] = row2[j];
          columns2[j] = column2;
        }
      }
    }
    return columns2.map(([key2, value2]) => [
      key2,
      Object.assign({ type: "column", value: value2 }, rest2)
    ]);
  });
  const newEncode = Object.fromEntries([...columns, ...arrayColumns]);
  return [I, Object.assign(Object.assign({}, rest), { encode: newEncode })];
}
function addGuideToScale(I, mark2, context) {
  const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark2;
  const normalize10 = (guide, channel) => {
    if (typeof guide === "boolean")
      return guide ? {} : null;
    const eachGuide = guide[channel];
    return eachGuide === void 0 || eachGuide ? eachGuide : null;
  };
  const axisChannels = typeof axis === "object" ? Array.from(/* @__PURE__ */ new Set(["x", "y", "z", ...Object.keys(axis)])) : ["x", "y", "z"];
  deep_mix_default(mark2, {
    scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map((channel) => {
      const scrollbarOptions = normalize10(scrollbar, channel);
      return [
        channel,
        Object.assign({ guide: normalize10(axis, channel), slider: normalize10(slider, channel), scrollbar: scrollbarOptions }, scrollbarOptions && {
          ratio: scrollbarOptions.ratio === void 0 ? 0.5 : scrollbarOptions.ratio
        })
      ];
    }))), {
      color: { guide: normalize10(legend, "color") },
      size: { guide: normalize10(legend, "size") },
      shape: { guide: normalize10(legend, "shape") },
      // fixme: opacity is conflict with DisplayObject.opacity
      // to be confirm.
      opacity: { guide: normalize10(legend, "opacity") }
    })
  });
  return [I, mark2];
}
function maybeNonAnimate(I, mark2, context) {
  const { animate: animate2 } = mark2;
  if (animate2 || animate2 === void 0)
    return [I, mark2];
  deep_mix_default(mark2, {
    animate: {
      enter: { type: null },
      exit: { type: null },
      update: { type: null }
    }
  });
  return [I, mark2];
}
function isTypedChannel(channel) {
  if (typeof channel !== "object" || channel instanceof Date || channel === null) {
    return false;
  }
  const { type } = channel;
  return defined(type);
}
function inferChannelType(data2, channel) {
  if (typeof channel === "function")
    return "transform";
  if (typeof channel === "string" && isField(data2, channel))
    return "field";
  return "constant";
}
function isField(data2, value2) {
  if (!Array.isArray(data2))
    return false;
  return data2.some((d4) => d4[value2] !== void 0);
}
function normalizedDataSource(data2) {
  if (isNumber(data2))
    return { type: "inline", value: data2 };
  if (!data2)
    return { type: "inline", value: null };
  if (Array.isArray(data2))
    return { type: "inline", value: data2 };
  const { type = "inline" } = data2, rest = __rest73(data2, ["type"]);
  return Object.assign(Object.assign({}, rest), { type });
}

// node_modules/@antv/g2/esm/runtime/mark.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest74 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function initializeMark(partialMark, partialProps, context) {
  return __awaiter4(this, void 0, void 0, function* () {
    const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);
    const { encode, scale: scale12, data: data2, tooltip: tooltip2 } = transformedMark;
    if (Array.isArray(data2) === false) {
      return null;
    }
    const { channels: channelDescriptors } = partialProps;
    const nameChannels = rollups(Object.entries(encode).filter(([, value2]) => defined(value2)), (values4) => values4.map(([key, options]) => Object.assign({ name: key }, options)), ([key]) => {
      var _a2;
      const prefix = (_a2 = /([^\d]+)\d*$/.exec(key)) === null || _a2 === void 0 ? void 0 : _a2[1];
      const descriptor = channelDescriptors.find((d4) => d4.name === prefix);
      if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent)
        return key;
      return prefix;
    });
    const channels = channelDescriptors.filter((descriptor) => {
      const { name: name2, required: required2 } = descriptor;
      if (nameChannels.find(([d4]) => d4 === name2))
        return true;
      if (required2)
        throw new Error(`Missing encoding for channel: ${name2}.`);
      return false;
    }).flatMap((descriptor) => {
      const { name: name2, scale: scaleType, scaleKey, range: range3, quantitative, ordinal } = descriptor;
      const valuesArray = nameChannels.filter(([channel]) => channel.startsWith(name2));
      return valuesArray.map(([channel, values4], i2) => {
        const visual = values4.some((d4) => d4.visual);
        const constant4 = values4.some((d4) => d4.constant);
        const _a2 = scale12[channel] || {}, {
          independent = false,
          // Use channel name as default scale key.
          key = scaleKey || channel,
          // Visual channel use identity scale.
          type = constant4 ? "constant" : visual ? "identity" : scaleType
        } = _a2, scaleOptions = __rest74(_a2, ["independent", "key", "type"]);
        const isConstant = type === "constant";
        const finalRange = isConstant ? void 0 : range3;
        return {
          name: channel,
          values: values4,
          // Generate a unique key for independent channel,
          // which will not group with any other channels.
          scaleKey: independent || isConstant ? Symbol("independent") : key,
          scale: Object.assign(Object.assign({ type, range: finalRange }, scaleOptions), {
            quantitative,
            ordinal
          })
        };
      });
    });
    return [transformedMark, Object.assign(Object.assign({}, partialProps), { index: I, channels, tooltip: tooltip2 })];
  });
}
function createColumnOf(library3) {
  const [useEncode] = useLibrary("encode", library3);
  return (data2, encode) => {
    if (encode === void 0)
      return null;
    if (data2 === void 0)
      return null;
    return Object.assign(Object.assign({}, encode), { type: "column", value: useEncode(encode)(data2), field: fieldOf(encode) });
  };
}
function applyMarkTransform(mark2, props, context) {
  return __awaiter4(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTransform] = useLibrary("transform", library3);
    const { preInference = [], postInference = [] } = props;
    const { transform: transform2 = [] } = mark2;
    const transforms = [
      applyDefaults,
      applyDataTransform,
      flatEncode,
      inferChannelsType,
      maybeVisualChannel,
      extractColumns,
      maybeArrayField,
      maybeNonAnimate,
      addGuideToScale,
      normalizeTooltip,
      ...preInference.map(useTransform),
      ...transform2.map(useTransform),
      ...postInference.map(useTransform),
      extractTooltip
    ];
    let index3 = [];
    let transformedMark = mark2;
    for (const t of transforms) {
      [index3, transformedMark] = yield t(index3, transformedMark, context);
    }
    return [index3, transformedMark];
  });
}
function fieldOf(encode) {
  const { type, value: value2 } = encode;
  if (type === "field" && typeof value2 === "string")
    return value2;
  return null;
}

// node_modules/@antv/g2/esm/runtime/plot.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest75 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function plot(options, selection, context) {
  var _a2;
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useComposition] = useLibrary("composition", library3);
    const [useInteraction] = useLibrary("interaction", library3);
    const marks = new Set(Object.keys(library3).map((d4) => {
      var _a3;
      return (_a3 = /mark\.(.*)/.exec(d4)) === null || _a3 === void 0 ? void 0 : _a3[1];
    }).filter(defined));
    const staticMarks = new Set(Object.keys(library3).map((d4) => {
      var _a3;
      return (_a3 = /component\.(.*)/.exec(d4)) === null || _a3 === void 0 ? void 0 : _a3[1];
    }).filter(defined));
    const typeOf = (node) => {
      const { type } = node;
      if (typeof type === "function") {
        const { props = {} } = type;
        const { composite = true } = props;
        if (composite)
          return "mark";
      }
      if (typeof type !== "string")
        return type;
      if (marks.has(type) || staticMarks.has(type))
        return "mark";
      return type;
    };
    const isMark2 = (node) => typeOf(node) === "mark";
    const isStandardView = (node) => typeOf(node) === "standardView";
    const isStaticMark = (node) => {
      const { type } = node;
      if (typeof type !== "string")
        return false;
      if (staticMarks.has(type))
        return true;
      return false;
    };
    const transform2 = (node) => {
      if (isStandardView(node))
        return [node];
      const type = typeOf(node);
      const composition = useComposition({ type, static: isStaticMark(node) });
      return composition(node);
    };
    const views = [];
    const viewNode = /* @__PURE__ */ new Map();
    const nodeState = /* @__PURE__ */ new Map();
    const discovered = [options];
    const nodeGenerators = [];
    while (discovered.length) {
      const node = discovered.shift();
      if (isStandardView(node)) {
        const state = nodeState.get(node);
        const [view, children] = state ? initializeState(state, node, library3) : yield initializeView(node, context);
        viewNode.set(view, node);
        views.push(view);
        const transformedNodes = children.flatMap(transform2).map((d4) => coordinate2Transform(d4, library3));
        discovered.push(...transformedNodes);
        if (transformedNodes.every(isStandardView)) {
          const states = yield Promise.all(transformedNodes.map((d4) => initializeMarks(d4, context)));
          syncFacetsScales(states);
          for (let i2 = 0; i2 < transformedNodes.length; i2++) {
            const nodeT = transformedNodes[i2];
            const state2 = states[i2];
            nodeState.set(nodeT, state2);
          }
        }
      } else {
        const n2 = isMark2(node) ? node : yield applyTransform(node, context);
        const N = transform2(n2);
        if (Array.isArray(N))
          discovered.push(...N);
        else if (typeof N === "function")
          nodeGenerators.push(N());
      }
    }
    context.emitter.emit(ChartEvent.BEFORE_PAINT);
    const enterContainer = /* @__PURE__ */ new Map();
    const updateContainer = /* @__PURE__ */ new Map();
    const transitions = [];
    selection.selectAll(className(VIEW_CLASS_NAME)).data(views, (d4) => d4.key).join((enter) => enter.append("g").attr("className", VIEW_CLASS_NAME).attr("id", (view) => view.key).call(applyTranslate).each(function(view, i2, element) {
      plotView(view, select(element), transitions, context);
      enterContainer.set(view, element);
    }), (update2) => update2.call(applyTranslate).each(function(view, i2, element) {
      plotView(view, select(element), transitions, context);
      updateContainer.set(view, element);
    }), (exit) => exit.each(function(d4, i2, element) {
      const interactions = element["nameInteraction"].values();
      for (const interaction of interactions) {
        interaction.destroy();
      }
    }).remove());
    const viewInstanceof = (viewContainer, updateInteractions2, oldStore) => {
      return Array.from(viewContainer.entries()).map(([view, container]) => {
        const store = oldStore || /* @__PURE__ */ new Map();
        const setState = (key, reducer = (x3) => x3) => store.set(key, reducer);
        const options2 = viewNode.get(view);
        const update2 = createUpdateView(select(container), options2, context);
        return {
          view,
          container,
          options: options2,
          setState,
          update: (from, updateTypes) => __awaiter5(this, void 0, void 0, function* () {
            const reducer = compose2(Array.from(store.values()));
            const newOptions = reducer(options2);
            return yield update2(newOptions, from, () => {
              if (isArray(updateTypes)) {
                updateInteractions2(viewContainer, updateTypes, store);
              }
            });
          })
        };
      });
    };
    const updateInteractions = (container = updateContainer, updateType, oldStore) => {
      var _a3;
      const updateViewInstances = viewInstanceof(container, updateInteractions, oldStore);
      for (const target of updateViewInstances) {
        const { options: options2, container: container2 } = target;
        const nameInteraction = container2["nameInteraction"];
        let typeOptions = inferInteraction(options2);
        if (updateType) {
          typeOptions = typeOptions.filter((v) => updateType.includes(v[0]));
        }
        for (const typeOption of typeOptions) {
          const [type, option] = typeOption;
          const prevInteraction = nameInteraction.get(type);
          if (prevInteraction)
            (_a3 = prevInteraction.destroy) === null || _a3 === void 0 ? void 0 : _a3.call(prevInteraction);
          if (option) {
            const interaction = useThemeInteraction(target.view, type, option, useInteraction);
            const destroy2 = interaction(target, updateViewInstances, context.emitter);
            nameInteraction.set(type, { destroy: destroy2 });
          }
        }
      }
    };
    const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);
    for (const target of enterViewInstances) {
      const { options: options2 } = target;
      const nameInteraction = /* @__PURE__ */ new Map();
      target.container["nameInteraction"] = nameInteraction;
      for (const typeOption of inferInteraction(options2)) {
        const [type, option] = typeOption;
        if (option) {
          const interaction = useThemeInteraction(target.view, type, option, useInteraction);
          const destroy2 = interaction(target, enterViewInstances, context.emitter);
          nameInteraction.set(type, { destroy: destroy2 });
        }
      }
    }
    updateInteractions();
    const { width, height } = options;
    const keyframes = [];
    for (const nodeGenerator of nodeGenerators) {
      const keyframe = new Promise((resolve) => __awaiter5(this, void 0, void 0, function* () {
        for (const node of nodeGenerator) {
          const sizedNode = Object.assign({ width, height }, node);
          yield plot(sizedNode, selection, context);
        }
        resolve();
      }));
      keyframes.push(keyframe);
    }
    context.views = views;
    (_a2 = context.animations) === null || _a2 === void 0 ? void 0 : _a2.forEach((animation) => animation === null || animation === void 0 ? void 0 : animation.cancel());
    context.animations = transitions;
    context.emitter.emit(ChartEvent.AFTER_PAINT);
    const finished = transitions.filter(defined).map(cancel).map((d4) => d4.finished);
    return Promise.all([...finished, ...keyframes]);
  });
}
function applyTranslate(selection) {
  selection.style("transform", (d4) => `translate(${d4.layout.x}, ${d4.layout.y})`);
}
function definedInteraction(library3) {
  const [, createInteraction] = useLibrary("interaction", library3);
  return (d4) => {
    const [name2, options] = d4;
    try {
      return [name2, createInteraction(name2)];
    } catch (_a2) {
      return [name2, options.type];
    }
  };
}
function createUpdateView(selection, options, context) {
  const { library: library3 } = context;
  const createDefinedInteraction = definedInteraction(library3);
  const filter3 = (d4) => d4[1] && d4[1].props && d4[1].props.reapplyWhenUpdate;
  const interactions = inferInteraction(options);
  const updates = interactions.map(createDefinedInteraction).filter(filter3).map((d4) => d4[0]);
  return (newOptions, source, callback) => __awaiter5(this, void 0, void 0, function* () {
    const transitions = [];
    const [newView, newChildren] = yield initializeView(newOptions, context);
    plotView(newView, selection, transitions, context);
    for (const name2 of updates.filter((d4) => d4 !== source)) {
      updateInteraction(name2, selection, newOptions, newView, context);
    }
    for (const child of newChildren) {
      plot(child, selection, context);
    }
    callback();
    return { options: newOptions, view: newView };
  });
}
function updateInteraction(name2, selection, options, view, context) {
  var _a2;
  const { library: library3 } = context;
  const [useInteraction] = useLibrary("interaction", library3);
  const container = selection.node();
  const nameInteraction = container["nameInteraction"];
  const interactionOptions = inferInteraction(options).find(([d4]) => d4 === name2);
  const interaction = nameInteraction.get(name2);
  if (!interaction)
    return;
  (_a2 = interaction.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(interaction);
  if (!interactionOptions[1])
    return;
  const applyInteraction = useThemeInteraction(view, name2, interactionOptions[1], useInteraction);
  const target = {
    options,
    view,
    container: selection.node(),
    update: (options2) => Promise.resolve(options2)
  };
  const destroy2 = applyInteraction(target, [], context.emitter);
  nameInteraction.set(name2, { destroy: destroy2 });
}
function initializeView(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const flattenOptions = yield transformMarks(options, context);
    const mergedOptions = bubbleOptions(flattenOptions);
    options.interaction = mergedOptions.interaction;
    options.coordinate = mergedOptions.coordinate;
    options.marks = [...mergedOptions.marks, ...mergedOptions.components];
    const transformedOptions = coordinate2Transform(mergedOptions, library3);
    const state = yield initializeMarks(transformedOptions, context);
    return initializeState(state, transformedOptions, library3);
  });
}
function bubbleOptions(options) {
  const { coordinate: viewCoordinate = {}, interaction: viewInteraction = {}, style: viewStyle = {}, marks } = options, rest = __rest75(options, ["coordinate", "interaction", "style", "marks"]);
  const markCoordinates = marks.map((d4) => d4.coordinate || {});
  const markInteractions = marks.map((d4) => d4.interaction || {});
  const markViewStyles = marks.map((d4) => d4.viewStyle || {});
  const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight((prev, cur) => deep_mix_default(prev, cur), {});
  const newInteraction = [viewInteraction, ...markInteractions].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  const newStyle = [...markViewStyles, viewStyle].reduce((prev, cur) => deep_mix_default(prev, cur), {});
  return Object.assign(Object.assign({}, rest), { marks, coordinate: newCoordinate, interaction: newInteraction, style: newStyle });
}
function transformMarks(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useMark, createMark] = useLibrary("mark", library3);
    const staticMarks = new Set(Object.keys(library3).map((d4) => {
      var _a2;
      return (_a2 = /component\.(.*)/.exec(d4)) === null || _a2 === void 0 ? void 0 : _a2[1];
    }).filter(defined));
    const { marks } = options;
    const flattenMarks = [];
    const components = [];
    const discovered = [...marks];
    const { width, height } = computeRoughPlotSize(options);
    const markOptions = { options, width, height };
    while (discovered.length) {
      const [node] = discovered.splice(0, 1);
      const mark2 = yield applyTransform(node, context);
      const { type = error("G2Mark type is required."), key } = mark2;
      if (staticMarks.has(type))
        components.push(mark2);
      else {
        const { props = {} } = createMark(type);
        const { composite = true } = props;
        if (!composite)
          flattenMarks.push(mark2);
        else {
          const { data: data2 } = mark2;
          const newMark = Object.assign(Object.assign({}, mark2), { data: data2 ? Array.isArray(data2) ? data2 : data2.value : data2 });
          const marks2 = yield useMark(newMark, markOptions);
          const M2 = Array.isArray(marks2) ? marks2 : [marks2];
          discovered.unshift(...M2.map((d4, i2) => Object.assign(Object.assign({}, d4), { key: `${key}-${i2}` })));
        }
      }
    }
    return Object.assign(Object.assign({}, options), { marks: flattenMarks, components });
  });
}
function initializeMarks(options, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const [useTheme] = useLibrary("theme", library3);
    const [, createMark] = useLibrary("mark", library3);
    const { theme: partialTheme, marks: partialMarks, coordinates = [] } = options;
    const theme = useTheme(inferTheme(partialTheme));
    const markState = /* @__PURE__ */ new Map();
    for (const markOptions of partialMarks) {
      const { type } = markOptions;
      const { props = {} } = createMark(type);
      const markAndState = yield initializeMark(markOptions, props, context);
      if (markAndState) {
        const [initializedMark, state] = markAndState;
        markState.set(initializedMark, state);
      }
    }
    const scaleChannels = group(Array.from(markState.values()).flatMap((d4) => d4.channels), ({ scaleKey }) => scaleKey);
    for (const channels of scaleChannels.values()) {
      const scaleOptions = channels.reduce((total, { scale: scale13 }) => deep_mix_default(total, scale13), {});
      const { scaleKey } = channels[0];
      const { values: FV } = channels[0];
      const fields = Array.from(new Set(FV.map((d4) => d4.field).filter(defined)));
      const options2 = deep_mix_default({
        guide: { title: fields.length === 0 ? void 0 : fields },
        field: fields[0]
      }, scaleOptions);
      const { name: name2 } = channels[0];
      const values4 = channels.flatMap(({ values: values5 }) => values5.map((d4) => d4.value));
      const scale12 = Object.assign(Object.assign({}, inferScale(name2, values4, options2, coordinates, theme, library3)), { uid: Symbol("scale"), key: scaleKey });
      channels.forEach((channel) => channel.scale = scale12);
    }
    return markState;
  });
}
function useThemeInteraction(view, type, option, useInteraction) {
  const theme = view.theme;
  const defaults4 = typeof type === "string" ? theme[type] || {} : {};
  const interaction = useInteraction(deep_mix_default(defaults4, Object.assign({ type }, option)));
  return interaction;
}
function initializeState(markState, options, library3) {
  var _a2;
  const [useMark] = useLibrary("mark", library3);
  const [useTheme] = useLibrary("theme", library3);
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { key, frame: frame2 = false, theme: partialTheme, clip, style = {}, labelTransform = [] } = options;
  const theme = useTheme(inferTheme(partialTheme));
  const states = Array.from(markState.values());
  const scales = collectScales(states, options);
  const components = normalizeComponents(inferComponent(inferComponentScales(Array.from(scales), states, markState), options, library3));
  const layout = computeLayout(components, options, theme, library3);
  const coordinate = createCoordinate(layout, options, library3);
  const framedStyle = frame2 ? deep_mix_default({ mainLineWidth: 1, mainStroke: "#000" }, style) : style;
  placeComponents(groupComponents(components), coordinate, layout);
  processAxisZ(components);
  const uidScale = new Map(Array.from(markState.values()).flatMap((state) => {
    const { channels } = state;
    return channels.map(({ scale: scale12 }) => [
      scale12.uid,
      useRelationScale(scale12, library3)
    ]);
  }));
  groupTransform(markState, uidScale);
  const scaleInstance = {};
  for (const component of components) {
    const { scales: scaleDescriptors = [] } = component;
    const scales2 = [];
    for (const descriptor of scaleDescriptors) {
      const { name: name2, uid } = descriptor;
      const scale12 = (_a2 = uidScale.get(uid)) !== null && _a2 !== void 0 ? _a2 : useRelationScale(descriptor, library3);
      scales2.push(scale12);
      if (name2 === "y") {
        scale12.update(Object.assign(Object.assign({}, scale12.getOptions()), { xScale: scaleInstance.x }));
      }
      assignScale(scaleInstance, { [name2]: scale12 });
    }
    component.scaleInstances = scales2;
  }
  const children = [];
  const dataMap = /* @__PURE__ */ new Map();
  for (const [mark2, state] of markState.entries()) {
    const {
      // scale,
      // Callback to create children options based on this mark.
      children: createChildren,
      // The total count of data (both show and hide)for this facet.
      // This is for unit visualization to sync data domain.
      dataDomain,
      modifier,
      key: markKey,
      data: data2
    } = mark2;
    dataMap.set(markKey, data2);
    const { index: index3, channels, tooltip: tooltip2 } = state;
    const scale12 = Object.fromEntries(channels.map(({ name: name2, scale: scale13 }) => [name2, scale13]));
    const markScaleInstance = mapObject(scale12, ({ uid }) => uidScale.get(uid));
    assignScale(scaleInstance, markScaleInstance);
    const value2 = applyScale(channels, markScaleInstance);
    const calcPoints = useMark(mark2);
    const [I, P, S] = filterValid(calcPoints(index3, markScaleInstance, value2, coordinate));
    const count4 = dataDomain || I.length;
    const T2 = modifier ? modifier(P, count4, layout) : [];
    const titleOf = (i2) => {
      var _a3, _b;
      return (_b = (_a3 = tooltip2.title) === null || _a3 === void 0 ? void 0 : _a3[i2]) === null || _b === void 0 ? void 0 : _b.value;
    };
    const itemsOf2 = (i2) => tooltip2.items.map((V) => V[i2]);
    const visualData = I.map((d4, i2) => {
      const datum = Object.assign({ points: P[i2], transform: T2[i2], index: d4, markKey, viewKey: key, data: data2[d4] }, tooltip2 && {
        title: titleOf(d4),
        items: itemsOf2(d4)
      });
      for (const [k2, V] of Object.entries(value2)) {
        datum[k2] = V[d4];
        if (S)
          datum[`series${upper_first_default(k2)}`] = S[i2].map((i3) => V[i3]);
      }
      if (S)
        datum["seriesIndex"] = S[i2];
      if (S && tooltip2) {
        datum["seriesItems"] = S[i2].map((si) => itemsOf2(si));
        datum["seriesTitle"] = S[i2].map((si) => titleOf(si));
      }
      return datum;
    });
    state.data = visualData;
    state.index = I;
    const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);
    children.push(...markChildren || []);
  }
  const view = {
    layout,
    theme,
    coordinate,
    markState,
    key,
    clip,
    scale: scaleInstance,
    style: framedStyle,
    components,
    data: dataMap,
    labelTransform: compose2(labelTransform.map(useLabelTransform))
  };
  return [view, children];
}
function plotView(view, selection, transitions, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { library: library3 } = context;
    const { components, theme, layout, markState, coordinate, key, style, clip, scale: scale12 } = view;
    const { x: x3, y: y4, width, height } = layout, rest = __rest75(layout, ["x", "y", "width", "height"]);
    const areaKeys = ["view", "plot", "main", "content"];
    const I = areaKeys.map((_2, i2) => i2);
    const sizeKeys = ["a", "margin", "padding", "inset"];
    const areaStyles = areaKeys.map((d4) => maybeSubObject(Object.assign({}, theme.view, style), d4));
    const areaSizes = sizeKeys.map((d4) => subObject(rest, d4));
    const styleArea = (selection2) => selection2.style("x", (i2) => areaLayouts[i2].x).style("y", (i2) => areaLayouts[i2].y).style("width", (i2) => areaLayouts[i2].width).style("height", (i2) => areaLayouts[i2].height).each(function(i2, d4, element) {
      applyStyle2(select(element), areaStyles[i2]);
    });
    let px2 = 0;
    let py = 0;
    let pw = width;
    let ph = height;
    const areaLayouts = I.map((i2) => {
      const size3 = areaSizes[i2];
      const { left: left2 = 0, top = 0, bottom = 0, right: right2 = 0 } = size3;
      px2 += left2;
      py += top;
      pw -= left2 + right2;
      ph -= top + bottom;
      return {
        x: px2,
        y: py,
        width: pw,
        height: ph
      };
    });
    selection.selectAll(className(AREA_CLASS_NAME)).data(
      // Only render area with defined style.
      I.filter((i2) => defined(areaStyles[i2])),
      (i2) => areaKeys[i2]
    ).join((enter) => enter.append("rect").attr("className", AREA_CLASS_NAME).style("zIndex", -2).call(styleArea), (update2) => update2.call(styleArea), (exit) => exit.remove());
    const animationExtent = computeAnimationExtent(markState);
    const componentAnimateOptions = animationExtent ? { duration: animationExtent[1] } : false;
    for (const [, C4] of groups(components, (d4) => `${d4.type}-${d4.position}`)) {
      C4.forEach((d4, i2) => d4.index = i2);
    }
    const componentsTransitions = selection.selectAll(className(COMPONENT_CLASS_NAME)).data(components, (d4) => `${d4.type}-${d4.position}-${d4.index}`).join((enter) => enter.append("g").style("zIndex", ({ zIndex }) => zIndex || -1).attr("className", COMPONENT_CLASS_NAME).append((options) => renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale12 }, options), coordinate, theme, library3, markState)), (update2) => update2.transition(function(options, i2, element) {
      const { preserve = false } = options;
      if (preserve)
        return;
      const newComponent = renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale12 }, options), coordinate, theme, library3, markState);
      const { attributes } = newComponent;
      const [node] = element.childNodes;
      return node.update(attributes, false);
    })).transitions();
    transitions.push(...componentsTransitions.flat().filter(defined));
    const T2 = selection.selectAll(className(PLOT_CLASS_NAME)).data([layout], () => key).join((enter) => enter.append("rect").style("zIndex", 0).style("fill", "transparent").attr("className", PLOT_CLASS_NAME).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), (update2) => update2.call(updateLayers, Array.from(markState.keys())).call((selection2) => {
      return animationExtent ? animateBBox(selection2, animationExtent) : updateBBox(selection2);
    }).call(applyClip, clip)).transitions();
    transitions.push(...T2.flat());
    for (const [mark2, state] of markState.entries()) {
      const { data: data2 } = state;
      const { key: key2, class: cls, type } = mark2;
      const viewNode = selection.select(`#${key2}`);
      const shapeFunction = createMarkShapeFunction(mark2, state, view, context);
      const enterFunction = createEnterFunction(mark2, state, view, library3);
      const updateFunction = createUpdateFunction(mark2, state, view, library3);
      const exitFunction = createExitFunction(mark2, state, view, library3);
      const facetElements = selectFacetElements(selection, viewNode, cls, "element");
      const T3 = viewNode.selectAll(className(ELEMENT_CLASS_NAME)).selectFacetAll(facetElements).data(data2, (d4) => d4.key, (d4) => d4.groupKey).join((enter) => enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i2, element) {
        return enterFunction(data3, [element]);
      }), (update2) => update2.call((selection2) => {
        const parent = selection2.parent();
        const origin = useMemo((node) => {
          const [x4, y5] = node.getBounds().min;
          return [x4, y5];
        });
        selection2.transition(function(data3, index3, element) {
          maybeFacetElement(element, parent, origin);
          const node = shapeFunction(data3, index3);
          const animation = updateFunction(data3, [element], [node]);
          if (animation === null || animation === void 0 ? void 0 : animation.length)
            return animation;
          if (element.nodeName === node.nodeName && node.nodeName !== "g") {
            copyAttributes(element, node);
          } else {
            element.parentNode.replaceChild(node, element);
            node.className = ELEMENT_CLASS_NAME;
            node.markType = type;
            node.__data__ = element.__data__;
          }
          return animation;
        }).attr("markType", type).attr("className", ELEMENT_CLASS_NAME);
      }), (exit) => {
        return exit.each(function(d4, i2, element) {
          element.__removed__ = true;
        }).transition(function(data3, i2, element) {
          return exitFunction(data3, [element]);
        }).remove();
      }, (merge2) => merge2.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i2, element) {
        const { __fromElements__: fromElements } = element;
        const transition2 = updateFunction(data3, fromElements, [element]);
        const exit = new Selection(fromElements, null, element.parentNode);
        exit.transition(transition2).remove();
        return transition2;
      }), (split) => split.transition(function(data3, i2, element) {
        const enter = new Selection([], element.__toData__, element.parentNode);
        const toElements = enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).nodes();
        return updateFunction(data3, [element], toElements);
      }).remove()).transitions();
      transitions.push(...T3.flat());
    }
    plotLabel(view, selection, transitions, library3, context);
  });
}
function plotLabel(view, selection, transitions, library3, context) {
  const [useLabelTransform] = useLibrary("labelTransform", library3);
  const { markState, labelTransform } = view;
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  const labelShapeFunction = /* @__PURE__ */ new Map();
  const labelDescriptor = /* @__PURE__ */ new Map();
  const labels = Array.from(markState.entries()).flatMap(([mark2, state]) => {
    const { labels: labelOptions = [], key } = mark2;
    const shapeFunction = createLabelShapeFunction(mark2, state, view, library3, context);
    const elements = selection.select(`#${key}`).selectAll(className(ELEMENT_CLASS_NAME)).nodes().filter((n2) => !n2.__removed__);
    return labelOptions.flatMap((labelOption, i2) => {
      const { transform: transform2 = [] } = labelOption, options = __rest75(labelOption, ["transform"]);
      return elements.flatMap((e3) => {
        const L = getLabels(options, i2, e3);
        L.forEach((l2) => {
          labelShapeFunction.set(l2, (data2) => shapeFunction(Object.assign(Object.assign({}, data2), { element: e3 })));
          labelDescriptor.set(l2, labelOption);
        });
        return L;
      });
    });
  });
  const labelShapes = select(labelLayer).selectAll(className(LABEL_CLASS_NAME)).data(labels, (d4) => d4.key).join((enter) => enter.append((d4) => labelShapeFunction.get(d4)(d4)).attr("className", LABEL_CLASS_NAME), (update2) => update2.each(function(d4, i2, element) {
    const shapeFunction = labelShapeFunction.get(d4);
    const node = shapeFunction(d4);
    copyAttributes(element, node);
  }), (exit) => exit.remove()).nodes();
  const labelGroups = group(labelShapes, (d4) => labelDescriptor.get(d4.__data__));
  const { coordinate, layout } = view;
  const labelTransformContext = {
    canvas: context.canvas,
    coordinate,
    layout
  };
  for (const [label, shapes] of labelGroups) {
    const { transform: transform2 = [] } = label;
    const transformFunction = compose2(transform2.map(useLabelTransform));
    transformFunction(shapes, labelTransformContext);
  }
  if (labelTransform) {
    labelTransform(labelShapes, labelTransformContext);
  }
}
function getLabels(label, labelIndex, element) {
  const { seriesIndex: SI, seriesKey, points, key, index: index3 } = element.__data__;
  const bounds = getLocalBounds(element);
  if (!SI) {
    return [
      Object.assign(Object.assign({}, label), {
        key: `${key}-${labelIndex}`,
        bounds,
        index: index3,
        points,
        dependentElement: element
      })
    ];
  }
  const selector = normalizeLabelSelector(label);
  const F = SI.map((index4, i2) => Object.assign(Object.assign({}, label), {
    key: `${seriesKey[i2]}-${labelIndex}`,
    bounds: [points[i2]],
    index: index4,
    points,
    dependentElement: element
  }));
  return selector ? selector(F) : F;
}
function filterValid([I, P, S]) {
  if (S)
    return [I, P, S];
  const definedIndex = [];
  const definedPoints = [];
  for (let i2 = 0; i2 < I.length; i2++) {
    const d4 = I[i2];
    const p3 = P[i2];
    if (p3.every(([x3, y4]) => defined(x3) && defined(y4))) {
      definedIndex.push(d4);
      definedPoints.push(p3);
    }
  }
  return [definedIndex, definedPoints];
}
function normalizeLabelSelector(label) {
  const { selector } = label;
  if (!selector)
    return null;
  if (typeof selector === "function")
    return selector;
  if (selector === "first")
    return (I) => [I[0]];
  if (selector === "last")
    return (I) => [I[I.length - 1]];
  throw new Error(`Unknown selector: ${selector}`);
}
function getLocalBounds(element) {
  const cloneElement = element.cloneNode(true);
  const animations = element.getAnimations();
  cloneElement.style.visibility = "hidden";
  animations.forEach((animation) => {
    const keyframes = animation.effect.getKeyframes();
    cloneElement.attr(keyframes[keyframes.length - 1]);
  });
  element.parentNode.appendChild(cloneElement);
  const bounds = cloneElement.getLocalBounds();
  cloneElement.destroy();
  const { min: min10, max: max11 } = bounds;
  return [min10, max11];
}
function createLabelShapeFunction(mark2, state, view, library3, context) {
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData, encode } = mark2;
  const { data: visualData, defaultLabelShape } = state;
  const point2d = visualData.map((d4) => d4.points);
  const channel = mapObject(encode, (d4) => d4.value);
  const { theme, coordinate } = view;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    theme,
    coordinate
  });
  return (options) => {
    const { index: index3, points } = options;
    const datum = abstractData[index3];
    const { formatter: formatter2 = (d4) => `${d4}`, transform: transform2, style: abstractStyle, render: render3, selector, element } = options, abstractOptions = __rest75(options, ["formatter", "transform", "style", "render", "selector", "element"]);
    const visualOptions = mapObject(Object.assign(Object.assign({}, abstractOptions), abstractStyle), (d4) => valueOf2(d4, datum, index3, abstractData, {
      channel,
      element
    }));
    const { shape: shape23 = defaultLabelShape, text } = visualOptions, style = __rest75(visualOptions, ["shape", "text"]);
    const f2 = typeof formatter2 === "string" ? format2(formatter2) : formatter2;
    const value2 = Object.assign(Object.assign({}, style), { text: f2(text, datum, index3, abstractData), datum });
    const shapeOptions = Object.assign({ type: `label.${shape23}`, render: render3 }, style);
    const shapeFunction = useShape(shapeOptions, shapeContext);
    const defaults4 = getDefaultsStyle(theme, "label", shape23, "label");
    return shapeFunction(points, value2, defaults4, point2d);
  };
}
function valueOf2(value2, datum, i2, data2, options) {
  if (typeof value2 === "function")
    return value2(datum, i2, data2, options);
  if (typeof value2 !== "string")
    return value2;
  if (isStrictObject(datum) && datum[value2] !== void 0)
    return datum[value2];
  return value2;
}
function computeAnimationExtent(markState) {
  let maxDuration = -Infinity;
  let minDelay = Infinity;
  for (const [mark2, state] of markState) {
    const { animate: animate2 = {} } = mark2;
    const { data: data2 } = state;
    const { enter = {}, update: update2 = {}, exit = {} } = animate2;
    const { type: defaultUpdateType, duration: defaultUpdateDuration = 300, delay: defaultUpdateDelay = 0 } = update2;
    const { type: defaultEnterType, duration: defaultEnterDuration = 300, delay: defaultEnterDelay = 0 } = enter;
    const { type: defaultExitType, duration: defaultExitDuration = 300, delay: defaultExitDelay = 0 } = exit;
    for (const d4 of data2) {
      const { updateType = defaultUpdateType, updateDuration = defaultUpdateDuration, updateDelay = defaultUpdateDelay, enterType = defaultEnterType, enterDuration = defaultEnterDuration, enterDelay = defaultEnterDelay, exitDuration = defaultExitDuration, exitDelay = defaultExitDelay, exitType = defaultExitType } = d4;
      if (updateType === void 0 || updateType) {
        maxDuration = Math.max(maxDuration, updateDuration + updateDelay);
        minDelay = Math.min(minDelay, updateDelay);
      }
      if (exitType === void 0 || exitType) {
        maxDuration = Math.max(maxDuration, exitDuration + exitDelay);
        minDelay = Math.min(minDelay, exitDelay);
      }
      if (enterType === void 0 || enterType) {
        maxDuration = Math.max(maxDuration, enterDuration + enterDelay);
        minDelay = Math.min(minDelay, enterDelay);
      }
    }
  }
  if (maxDuration === -Infinity)
    return null;
  return [minDelay, maxDuration - minDelay];
}
function selectFacetElements(selection, current, facetClassName, elementClassName) {
  const group3 = selection.node().parentElement;
  if (!group3 || typeof group3.findAll !== "function")
    return [];
  return group3.findAll((node) => node.style.facet !== void 0 && node.style.facet === facetClassName && node !== current.node()).flatMap((node) => node.getElementsByClassName(elementClassName));
}
function maybeFacetElement(element, parent, originOf) {
  if (!element.__facet__)
    return;
  const prePlot = element.parentNode.parentNode;
  const newPlot = parent.parentNode;
  const [px2, py] = originOf(prePlot);
  const [x3, y4] = originOf(newPlot);
  const translate6 = `translate(${px2 - x3}, ${py - y4})`;
  appendTransform(element, translate6);
  parent.append(element);
}
function createMarkShapeFunction(mark2, state, view, context) {
  const { library: library3 } = context;
  const [useShape] = useLibrary("shape", library3);
  const { data: abstractData, encode } = mark2;
  const { defaultShape, data: data2, shape: shapeLibrary } = state;
  const channel = mapObject(encode, (d4) => d4.value);
  const point2d = data2.map((d4) => d4.points);
  const { theme, coordinate } = view;
  const { type: markType, style = {} } = mark2;
  const shapeContext = Object.assign(Object.assign({}, context), {
    document: documentOf(context),
    coordinate,
    theme
  });
  return (data3) => {
    const { shape: styleShape = defaultShape } = style;
    const { shape: shape23 = styleShape, points, seriesIndex, index: i2 } = data3, v = __rest75(data3, ["shape", "points", "seriesIndex", "index"]);
    const value2 = Object.assign(Object.assign({}, v), { index: i2 });
    const abstractDatum = seriesIndex ? seriesIndex.map((i3) => abstractData[i3]) : abstractData[i2];
    const I = seriesIndex ? seriesIndex : i2;
    const visualStyle = mapObject(style, (d4) => valueOf2(d4, abstractDatum, I, abstractData, { channel }));
    const shapeFunction = shapeLibrary[shape23] ? shapeLibrary[shape23](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), { type: shapeName(mark2, shape23) }), shapeContext);
    const defaults4 = getDefaultsStyle(theme, markType, shape23, defaultShape);
    return shapeFunction(points, value2, defaults4, point2d);
  };
}
function getDefaultsStyle(theme, mark2, shape23, defaultShape) {
  if (typeof mark2 !== "string")
    return;
  const { color: color3 } = theme;
  const markTheme = theme[mark2] || {};
  const shapeTheme = markTheme[shape23] || markTheme[defaultShape];
  return Object.assign({ color: color3 }, shapeTheme);
}
function createAnimationFunction(type, mark2, state, view, library3) {
  var _a2, _b;
  const [, createShape] = useLibrary("shape", library3);
  const [useAnimation] = useLibrary("animation", library3);
  const { defaultShape, shape: shapeLibrary } = state;
  const { theme, coordinate } = view;
  const upperType = upper_first_default(type);
  const key = `default${upperType}Animation`;
  const { [key]: defaultAnimation } = ((_a2 = shapeLibrary[defaultShape]) === null || _a2 === void 0 ? void 0 : _a2.props) || createShape(shapeName(mark2, defaultShape)).props;
  const { [type]: defaultEffectTiming = {} } = theme;
  const animate2 = ((_b = mark2.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};
  const context = { coordinate };
  return (data2, from, to) => {
    const { [`${type}Type`]: animation, [`${type}Delay`]: delay, [`${type}Duration`]: duration, [`${type}Easing`]: easing } = data2;
    const options = Object.assign({ type: animation || defaultAnimation }, animate2);
    if (!options.type)
      return null;
    const animateFunction = useAnimation(options, context);
    const value2 = { delay, duration, easing };
    const A6 = animateFunction(from, to, deep_mix_default(defaultEffectTiming, value2));
    let an = [];
    if (!Array.isArray(A6)) {
      an = [A6];
    } else {
      an = A6;
    }
    return an.filter(Boolean);
  };
}
function createEnterFunction(mark2, state, view, library3) {
  return createAnimationFunction("enter", mark2, state, view, library3);
}
function cancel(animation) {
  animation.finished.then(() => {
    animation.cancel();
  });
  return animation;
}
function createUpdateFunction(mark2, state, view, library3) {
  return createAnimationFunction("update", mark2, state, view, library3);
}
function createExitFunction(mark2, state, view, library3) {
  return createAnimationFunction("exit", mark2, state, view, library3);
}
function inferTheme(theme = {}) {
  if (typeof theme === "string")
    return { type: theme };
  const { type = "light" } = theme, rest = __rest75(theme, ["type"]);
  return Object.assign(Object.assign({}, rest), { type });
}
function inferInteraction(view) {
  const defaults4 = {
    event: true,
    tooltip: true,
    // @todo Inferred by slider self.
    sliderFilter: true,
    legendFilter: true,
    scrollbarFilter: true
  };
  const { interaction = {} } = view;
  return Object.entries(deep_mix_default(defaults4, interaction)).reverse();
}
function applyTransform(node, context) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { data: data2 } = node, rest = __rest75(node, ["data"]);
    if (data2 == void 0)
      return node;
    const [, { data: newData }] = yield applyDataTransform([], { data: data2 }, context);
    return Object.assign({ data: newData }, rest);
  });
}
function updateBBox(selection) {
  selection.style("transform", (d4) => `translate(${d4.paddingLeft + d4.marginLeft}, ${d4.paddingTop + d4.marginTop})`).style("width", (d4) => d4.innerWidth).style("height", (d4) => d4.innerHeight);
}
function animateBBox(selection, extent2) {
  const [delay, duration] = extent2;
  selection.transition(function(data2, i2, element) {
    const { transform: transform2, width, height } = element.style;
    const { paddingLeft, paddingTop, innerWidth, innerHeight, marginLeft, marginTop } = data2;
    const keyframes = [
      {
        transform: transform2,
        width,
        height
      },
      {
        transform: `translate(${paddingLeft + marginLeft}, ${paddingTop + marginTop})`,
        width: innerWidth,
        height: innerHeight
      }
    ];
    return element.animate(keyframes, { delay, duration, fill: "both" });
  });
}
function shapeName(mark2, name2) {
  const { type } = mark2;
  if (typeof name2 === "string")
    return `${type}.${name2}`;
  return name2;
}
function updateLayers(selection, marks) {
  const facet = (d4) => d4.class !== void 0 ? `${d4.class}` : "";
  const nodes = selection.nodes();
  if (nodes.length === 0)
    return;
  selection.selectAll(className(MAIN_LAYER_CLASS_NAME)).data(marks, (d4) => d4.key).join((enter) => enter.append("g").attr("className", MAIN_LAYER_CLASS_NAME).attr("id", (d4) => d4.key).style("facet", facet).style("fill", "transparent").style("zIndex", (d4) => {
    var _a2;
    return (_a2 = d4.zIndex) !== null && _a2 !== void 0 ? _a2 : 0;
  }), (update2) => update2.style("facet", facet).style("fill", "transparent").style("zIndex", (d4) => {
    var _a2;
    return (_a2 = d4.zIndex) !== null && _a2 !== void 0 ? _a2 : 0;
  }), (exit) => exit.remove());
  const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
  if (labelLayer)
    return;
  selection.append("g").attr("className", LABEL_LAYER_CLASS_NAME).style("zIndex", 0);
}
function className(...names) {
  return names.map((d4) => `.${d4}`).join("");
}
function applyClip(selection, clip) {
  if (!selection.node())
    return;
  selection.style("clipPath", (data2) => {
    if (!clip)
      return null;
    const { paddingTop: y4, paddingLeft: x3, marginLeft: x12, marginTop: y12, innerWidth: width, innerHeight: height } = data2;
    return new Rect({ style: { x: x3 + x12, y: y4 + y12, width, height } });
  });
}
function inferComponentScales(scales, states, markState) {
  var _a2;
  for (const [key] of markState.entries()) {
    if (key.type === "cell") {
      return scales.filter((scale12) => scale12.name !== "shape");
    }
  }
  if (states.length !== 1 || scales.some((scale12) => scale12.name === "shape")) {
    return scales;
  }
  const { defaultShape: shape23 } = states[0];
  const acceptMarkTypes = ["point", "line", "rect", "hollow"];
  if (!acceptMarkTypes.includes(shape23))
    return scales;
  const shapeMap = {
    point: "point",
    line: "hyphen",
    rect: "square",
    hollow: "hollow"
  };
  const field3 = ((_a2 = scales.find((scale12) => scale12.name === "color")) === null || _a2 === void 0 ? void 0 : _a2.field) || null;
  const shapeScale = {
    field: field3,
    name: "shape",
    type: "constant",
    domain: [],
    range: [shapeMap[shape23]]
  };
  return [...scales, shapeScale];
}
function applyStyle2(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}

// node_modules/@antv/g2/esm/utils/flow.js
function flow(...flows) {
  return (param) => {
    return flows.reduce((result, f2) => {
      return f2(result);
    }, param);
  };
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/style.js
function columnWidthRatio(options) {
  const { style, scale: scale12, type } = options;
  const scaleOption = {};
  const columnWidthRatio2 = get_default(style, "columnWidthRatio");
  if (columnWidthRatio2 && type === "interval") {
    scaleOption.x = Object.assign(Object.assign({}, scale12 === null || scale12 === void 0 ? void 0 : scale12.x), { padding: 1 - columnWidthRatio2 });
  }
  return Object.assign(Object.assign({}, options), { scale: Object.assign(Object.assign({}, scale12), scaleOption) });
}

// node_modules/@antv/g2/esm/runtime/option-preprocess/index.js
function preprocessOption(options) {
  const convertedOptions = adapter(options);
  if (convertedOptions.children && Array.isArray(convertedOptions.children)) {
    convertedOptions.children = convertedOptions.children.map((child) => preprocessOption(child));
  }
  return convertedOptions;
}
function adapter(options) {
  return flow(columnWidthRatio)(options);
}

// node_modules/@antv/g2/esm/runtime/render.js
function inferKeys(options) {
  const root2 = deep_mix_default({}, options);
  const nodeParent = /* @__PURE__ */ new Map([[root2, null]]);
  const nodeIndex = /* @__PURE__ */ new Map([[null, -1]]);
  const discovered = [root2];
  while (discovered.length) {
    const node = discovered.shift();
    if (node.key === void 0) {
      const parent = nodeParent.get(node);
      const index3 = nodeIndex.get(node);
      const key = parent === null ? `${0}` : `${parent.key}-${index3}`;
      node.key = key;
    }
    const { children = [] } = node;
    if (Array.isArray(children)) {
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = deep_mix_default({}, children[i2]);
        children[i2] = child;
        nodeParent.set(child, node);
        nodeIndex.set(child, i2);
        discovered.push(child);
      }
    }
  }
  return root2;
}
function Canvas2(width, height) {
  const renderer = new Renderer();
  renderer.registerPlugin(new Plugin7());
  return new Canvas({
    width,
    height,
    container: document.createElement("div"),
    renderer
  });
}
function render(options, context = {}, resolve = () => {
}, reject = (e3) => {
  throw e3;
}) {
  const afterParsedOptions = parseOptionsExpr(options);
  const { width = 640, height = 480, depth = 0 } = afterParsedOptions;
  const preprocessedOption = preprocessOption(afterParsedOptions);
  const keyed2 = inferKeys(preprocessedOption);
  const { canvas = Canvas2(width, height), emitter = new esm_default(), library: library3 } = context;
  context.canvas = canvas;
  context.emitter = emitter;
  const { width: prevWidth, height: prevHeight } = canvas.getConfig();
  if (prevWidth !== width || prevHeight !== height) {
    canvas.resize(width, height);
  }
  emitter.emit(ChartEvent.BEFORE_RENDER);
  const selection = select(canvas.document.documentElement);
  canvas.ready.then(() => plot(Object.assign(Object.assign({}, keyed2), { width, height, depth }), selection, context)).then(() => {
    if (depth) {
      const [x3, y4] = canvas.document.documentElement.getPosition();
      canvas.document.documentElement.setPosition(x3, y4, -depth / 2);
    }
    canvas.requestAnimationFrame(() => {
      canvas.requestAnimationFrame(() => {
        emitter.emit(ChartEvent.AFTER_RENDER);
        resolve === null || resolve === void 0 ? void 0 : resolve();
      });
    });
  }).catch((e3) => {
    reject === null || reject === void 0 ? void 0 : reject(e3);
  });
  return normalizeContainer(canvas.getConfig().container);
}
function renderToMountedElement(options, context = {}, resolve = () => {
}, reject = (e3) => {
  throw e3;
}) {
  var _a2;
  const { width = 640, height = 480 } = options;
  const keyed2 = inferKeys(options);
  const { group: group3 = new Group2(), emitter = new esm_default(), library: library3 } = context;
  if (!(group3 === null || group3 === void 0 ? void 0 : group3.parentElement)) {
    error(`renderToMountedElement can't render chart to unmounted group.`);
  }
  const selection = select(group3);
  context.group = group3;
  context.emitter = emitter;
  context.canvas = context.canvas || ((_a2 = group3 === null || group3 === void 0 ? void 0 : group3.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView);
  emitter.emit(ChartEvent.BEFORE_RENDER);
  plot(Object.assign(Object.assign({}, keyed2), { width, height }), selection, context).then(() => {
    var _a3;
    (_a3 = context.canvas) === null || _a3 === void 0 ? void 0 : _a3.requestAnimationFrame(() => {
      emitter.emit(ChartEvent.AFTER_RENDER);
      resolve === null || resolve === void 0 ? void 0 : resolve();
    });
  }).catch((e3) => {
    reject === null || reject === void 0 ? void 0 : reject(e3);
  });
  return group3;
}
function destroy(options, context = {}, isDestroyCanvas = false, isClearEvents = true) {
  const { canvas, emitter } = context;
  if (canvas) {
    destroyAllInteractions(canvas);
    isDestroyCanvas ? canvas.destroy() : canvas.destroyChildren();
  }
  if (isClearEvents) {
    emitter.off();
  }
}
function destroyAllInteractions(canvas) {
  const viewGroups = canvas.getRoot().querySelectorAll(`.${VIEW_CLASS_NAME}`);
  viewGroups === null || viewGroups === void 0 ? void 0 : viewGroups.forEach((group3) => {
    const { nameInteraction = /* @__PURE__ */ new Map() } = group3;
    if ((nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.size) > 0) {
      Array.from(nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.values()).forEach((value2) => {
        value2 === null || value2 === void 0 ? void 0 : value2.destroy();
      });
    }
  });
}
function normalizeContainer(container) {
  return typeof container === "string" ? document.getElementById(container) : container;
}

// node_modules/@antv/g2/esm/utils/traverse-elements.js
function traverseElements(element, visitor) {
  if (visitor(element))
    return true;
  if (element.tagName === "g") {
    const { childNodes = [] } = element;
    for (const child of childNodes) {
      if (traverseElements(child, visitor))
        return true;
    }
  }
  return false;
}

// node_modules/@antv/g2/esm/utils/style.js
var defaultStyle = {
  visibility: "visible",
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1
};
function getStyle2(element, key) {
  let value2;
  traverseElements(element, (el) => {
    var _a2;
    if (el.tagName !== "g" && ((_a2 = el.style) === null || _a2 === void 0 ? void 0 : _a2[key]) !== void 0) {
      value2 = el.style[key];
      return true;
    }
    return false;
  });
  return value2 !== null && value2 !== void 0 ? value2 : defaultStyle[key];
}
function setStyle2(element, key, value2, recursive) {
  element.style[key] = value2;
  if (recursive) {
    element.children.forEach((child) => setStyle2(child, key, value2, recursive));
  }
}
function hide2(element) {
  setStyle2(element, "visibility", "hidden", true);
}
function show2(element) {
  setStyle2(element, "visibility", "visible", true);
}

// node_modules/@antv/g2/esm/interaction/utils.js
var __rest76 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function selectG2Elements(root2) {
  return select(root2).selectAll(`.${ELEMENT_CLASS_NAME}`).nodes().filter((d4) => !d4.__removed__);
}
function selectFacetG2Elements(target, viewInstances) {
  return selectFacetViews(target, viewInstances).flatMap(({ container }) => selectG2Elements(container));
}
function selectFacetViews(target, viewInstances) {
  return viewInstances.filter((d4) => d4 !== target && d4.options.parentKey === target.options.key);
}
function selectPlotArea(root2) {
  return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
}
function bboxOf(element) {
  if (element.tagName === "g")
    return element.getRenderBounds();
  const bounds = element.getGeometryBounds();
  const aabb = new AABB();
  aabb.setFromTransformedAABB(bounds, element.getWorldTransform());
  return aabb;
}
function mousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const bbox = bboxOf(target);
  const { min: [x3, y4], max: [x12, y12] } = bbox;
  const isOutX = offsetX < x3 || offsetX > x12;
  const isOutY = offsetY < y4 || offsetY > y12;
  if (isOutX || isOutY)
    return null;
  return [offsetX - x3, offsetY - y4];
}
function brushMousePosition(target, event) {
  const { offsetX, offsetY } = event;
  const [x3, y4, x12, y12] = boundsOfBrushArea(target);
  return [
    Math.min(x12, Math.max(x3, offsetX)) - x3,
    Math.min(y12, Math.max(y4, offsetY)) - y4
  ];
}
function boundsOfBrushArea(target) {
  const bbox = target.getRenderBounds();
  const { min: [x05, y05], max: [x12, y12] } = bbox;
  return [x05, y05, x12, y12];
}
function createColorKey(view) {
  return (element) => element.__data__.color;
}
function createXKey(view) {
  return (element) => element.__data__.x;
}
function createDatumof(view) {
  const views = Array.isArray(view) ? view : [view];
  const keyData = new Map(views.flatMap((view2) => {
    const marks = Array.from(view2.markState.keys());
    return marks.map((mark2) => [keyed(view2.key, mark2.key), mark2.data]);
  }));
  return (element) => {
    const { index: index3, markKey, viewKey } = element.__data__;
    const data2 = keyData.get(keyed(viewKey, markKey));
    return data2[index3];
  };
}
var STATE_PRIORITIES = {
  selected: 3,
  unselected: 3,
  active: 2,
  inactive: 2,
  default: 1
};
var STATE_GROUPS = {
  selection: ["selected", "unselected"],
  highlight: ["active", "inactive"]
};
var setElementAttribute = (element, k2, v) => {
  traverseElements(element, (el) => {
    if ("setAttribute" in el && typeof el.setAttribute === "function") {
      el.setAttribute(k2, v);
    }
  });
};
function createUseState(style, elements) {
  elements.forEach((element) => {
    const currentStyle = element.__interactionStyle__;
    if (currentStyle) {
      element.__interactionStyle__ = Object.assign(Object.assign({}, currentStyle), style);
    } else {
      element.__interactionStyle__ = style;
    }
  });
  return (valueof2 = (d4, element) => d4, setAttribute = setElementAttribute) => useState(void 0, valueof2, setAttribute);
}
function useState(style, valueof2 = (d4, element) => d4, setAttribute = setElementAttribute) {
  const STATES = "__states__";
  const ORIGINAL = "__ordinal__";
  const getStatePriority = (stateName) => STATE_PRIORITIES[stateName] || STATE_PRIORITIES.default;
  const getStateGroup = (stateName) => {
    var _a2;
    return (_a2 = Object.entries(STATE_GROUPS).find(([_2, states]) => states.includes(stateName))) === null || _a2 === void 0 ? void 0 : _a2[0];
  };
  const applyState = (element) => {
    var _a2;
    const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
    const sortedStates = [...states].sort((a5, b) => getStatePriority(b) - getStatePriority(a5));
    const styleAttributeMap = /* @__PURE__ */ new Map();
    for (const state of sortedStates) {
      const stateStyles = ((_a2 = style !== null && style !== void 0 ? style : element.__interactionStyle__) === null || _a2 === void 0 ? void 0 : _a2[state]) || {};
      for (const [key, value2] of Object.entries(stateStyles)) {
        if (!styleAttributeMap.has(key)) {
          styleAttributeMap.set(key, value2);
        }
      }
    }
    const finalStyle = Object.assign({}, original);
    for (const [key, value2] of styleAttributeMap.entries()) {
      finalStyle[key] = value2;
    }
    if (Object.keys(finalStyle).length === 0)
      return;
    for (const [key, value2] of Object.entries(finalStyle)) {
      const currentValue = getStyle2(element, key);
      const v = valueof2(value2, element);
      setAttribute(element, key, v);
      if (!(key in original))
        original[key] = currentValue;
    }
    element[ORIGINAL] = original;
  };
  const initState = (element) => {
    if (element[STATES])
      return;
    element[STATES] = [];
    return;
  };
  const updateState = (element, ...states) => {
    initState(element);
    const currentStates = element[STATES];
    const newStateGroups = new Set(states.map((state) => getStateGroup(state)).filter((group3) => group3 !== void 0));
    const remainingStates = currentStates.filter((existingState) => !newStateGroups.has(getStateGroup(existingState)));
    element[STATES] = [...remainingStates, ...states];
    applyState(element);
  };
  const setState = (element, ...states) => {
    initState(element);
    element[STATES] = [...states];
    applyState(element);
  };
  const removeState = (element, ...states) => {
    initState(element);
    for (const state of states) {
      const index3 = element[STATES].indexOf(state);
      if (index3 !== -1) {
        element[STATES].splice(index3, 1);
      }
    }
    applyState(element);
  };
  const hasState = (element, state) => {
    initState(element);
    return element[STATES].indexOf(state) !== -1;
  };
  return {
    setState,
    updateState,
    removeState,
    hasState
  };
}
function isEmptyObject(obj) {
  if (obj === void 0)
    return true;
  if (typeof obj !== "object")
    return false;
  return Object.keys(obj).length === 0;
}
function keyed(viewKey, markKey) {
  return `${viewKey},${markKey}`;
}
function mergeState(options, states) {
  const views = Array.isArray(options) ? options : [options];
  const markState = views.flatMap((view) => view.marks.map((mark2) => [keyed(view.key, mark2.key), mark2.state]));
  const state = {};
  for (const descriptor of states) {
    const [key, defaults4] = Array.isArray(descriptor) ? descriptor : [descriptor, {}];
    state[key] = markState.reduce((merged, mark2) => {
      const [markKey, markState2 = {}] = mark2;
      const selectedState = isEmptyObject(markState2[key]) ? defaults4 : markState2[key];
      for (const [attr2, value2] of Object.entries(selectedState)) {
        const oldValue = merged[attr2];
        const newValue = (data2, index3, array2, element) => {
          const k2 = keyed(element.__data__.viewKey, element.__data__.markKey);
          if (markKey !== k2)
            return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data2, index3, array2, element);
          if (typeof value2 !== "function")
            return value2;
          return value2(data2, index3, array2, element);
        };
        merged[attr2] = newValue;
      }
      return merged;
    }, {});
  }
  return state;
}
function createValueof(elements, datum) {
  const elementIndex = new Map(elements.map((d4, i2) => [d4, i2]));
  const fa = datum ? elements.map(datum) : elements;
  return (d4, e3) => {
    if (typeof d4 !== "function")
      return d4;
    const i2 = elementIndex.get(e3);
    const fe = datum ? datum(e3) : e3;
    return d4(fe, i2, fa, e3);
  };
}
function renderLink(_a2) {
  var { link: link3 = false, valueof: valueof2 = (d4, element) => d4, coordinate } = _a2, style = __rest76(_a2, ["link", "valueof", "coordinate"]);
  const LINK_CLASS_NAME = "element-link";
  if (!link3)
    return [() => {
    }, () => {
    }];
  const pointsOf = (element) => element.__data__.points;
  const pathPointsOf = (P0, P1) => {
    const [, p1, p22] = P0;
    const [p0, , , p3] = P1;
    const P = [p1, p0, p3, p22];
    return P;
  };
  const append3 = (elements) => {
    var _a3;
    if (elements.length <= 1)
      return;
    const sortedElements = sort(elements, (e0, e1) => {
      const { x: x05 } = e0.__data__;
      const { x: x12 } = e1.__data__;
      const dx = x05 - x12;
      return dx;
    });
    for (let i2 = 1; i2 < sortedElements.length; i2++) {
      const p3 = path();
      const e0 = sortedElements[i2 - 1];
      const e1 = sortedElements[i2];
      const [p0, p1, p22, p32] = pathPointsOf(pointsOf(e0), pointsOf(e1));
      p3.moveTo(...p0);
      p3.lineTo(...p1);
      p3.lineTo(...p22);
      p3.lineTo(...p32);
      p3.closePath();
      const _b = mapObject(style, (d4) => valueof2(d4, e0)), { fill = e0.getAttribute("fill") } = _b, rest = __rest76(_b, ["fill"]);
      const link4 = new Path2({
        className: LINK_CLASS_NAME,
        style: Object.assign({ d: p3.toString(), fill, zIndex: -2 }, rest)
      });
      (_a3 = e0.link) === null || _a3 === void 0 ? void 0 : _a3.remove();
      e0.parentNode.appendChild(link4);
      e0.link = link4;
    }
  };
  const remove2 = (element) => {
    var _a3;
    (_a3 = element.link) === null || _a3 === void 0 ? void 0 : _a3.remove();
    element.link = null;
  };
  return [append3, remove2];
}
function offsetTransform(element, offset2, coordinate) {
  const append3 = (t) => {
    const { transform: transform2 } = element.style;
    return transform2 ? `${transform2} ${t}` : t;
  };
  if (isPolar(coordinate)) {
    const { points } = element.__data__;
    const [p0, p1] = isTranspose(coordinate) ? reorder(points) : points;
    const center2 = coordinate.getCenter();
    const v0 = sub6(p0, center2);
    const v1 = sub6(p1, center2);
    const a0 = angle3(v0);
    const da = angleBetween2(v0, v1);
    const amid = a0 + da / 2;
    const dx = offset2 * Math.cos(amid);
    const dy = offset2 * Math.sin(amid);
    return append3(`translate(${dx}, ${dy})`);
  }
  if (isTranspose(coordinate))
    return append3(`translate(${offset2}, 0)`);
  return append3(`translate(0, ${-offset2})`);
}
function renderBackground(_a2) {
  var { document: document2, background, scale: scale12, coordinate, valueof: valueof2 } = _a2, rest = __rest76(_a2, ["document", "background", "scale", "coordinate", "valueof"]);
  const BACKGROUND_CLASS_NAME = "element-background";
  if (!background)
    return [() => {
    }, () => {
    }];
  const extentOf2 = (scale13, x3, padding) => {
    const ax = scale13.invert(x3);
    const mid2 = x3 + scale13.getBandWidth(ax) / 2;
    const half = scale13.getStep(ax) / 2;
    const offset2 = half * padding;
    return [mid2 - half + offset2, mid2 + half - offset2];
  };
  const sizeXOf = (element, padding) => {
    const { x: scaleX2 } = scale12;
    if (!isOrdinalScale(scaleX2))
      return [0, 1];
    const { __data__: data2 } = element;
    const { x: x3 } = data2;
    const [e1, e23] = extentOf2(scaleX2, x3, padding);
    return [e1, e23];
  };
  const sizeYOf = (element, padding) => {
    const { y: scaleY2 } = scale12;
    if (!isOrdinalScale(scaleY2))
      return [0, 1];
    const { __data__: data2 } = element;
    const { y: y4 } = data2;
    const [e1, e23] = extentOf2(scaleY2, y4, padding);
    return [e1, e23];
  };
  const bandShapeOf = (element, style) => {
    const { padding } = style;
    const [x12, x22] = sizeXOf(element, padding);
    const [y12, y22] = sizeYOf(element, padding);
    const points = [
      [x12, y12],
      [x22, y12],
      [x22, y22],
      [x12, y22]
    ].map((d4) => coordinate.map(d4));
    const { __data__: data2 } = element;
    const { y: dy, y1: dy1 } = data2;
    return rect(document2, points, { y: dy, y1: dy1 }, coordinate, style);
  };
  const cloneShapeOf = (element, style) => {
    const { transform: transform2 = "scale(1.2, 1.2)", transformOrigin = "center center", stroke: stroke2 = "" } = style, rest2 = __rest76(style, ["transform", "transformOrigin", "stroke"]);
    const finalStyle = Object.assign({ transform: transform2, transformOrigin, stroke: stroke2 }, rest2);
    const shape23 = element.cloneNode(true);
    for (const [key, value2] of Object.entries(finalStyle)) {
      shape23.style[key] = value2;
    }
    return shape23;
  };
  const isOrdinalShape = () => {
    const { x: x3, y: y4 } = scale12;
    return [x3, y4].some(isOrdinalScale);
  };
  const append3 = (element) => {
    if (element.background)
      element.background.remove();
    const _a3 = mapObject(rest, (d4) => valueof2(d4, element)), { fill = "#CCD6EC", fillOpacity = 0.3, zIndex = -2, padding = 1e-3, lineWidth = 0 } = _a3, style = __rest76(_a3, ["fill", "fillOpacity", "zIndex", "padding", "lineWidth"]);
    const finalStyle = Object.assign(Object.assign({}, style), {
      fill,
      fillOpacity,
      zIndex,
      padding,
      lineWidth
    });
    const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
    const shape23 = shapeOf(element, finalStyle);
    shape23.className = BACKGROUND_CLASS_NAME;
    element.parentNode.parentNode.appendChild(shape23);
    element.background = shape23;
  };
  const remove2 = (element) => {
    var _a3;
    (_a3 = element.background) === null || _a3 === void 0 ? void 0 : _a3.remove();
    element.background = null;
  };
  const is = (element) => {
    return element.className === BACKGROUND_CLASS_NAME;
  };
  return [append3, remove2, is];
}
function setCursor(root2, cursor) {
  const canvas = root2.getRootNode().defaultView;
  const dom2 = canvas.getContextService().getDomElement();
  if (dom2 === null || dom2 === void 0 ? void 0 : dom2.style) {
    root2.cursor = dom2.style.cursor;
    dom2.style.cursor = cursor;
  }
}
function restoreCursor(root2) {
  setCursor(root2, root2.cursor);
}
function selectElementByData(elements, data2, datum) {
  return elements.find((d4) => Object.entries(data2).every(([key, value2]) => datum(d4)[key] === value2));
}
function getPointsR(point7, nextPoint) {
  return Math.sqrt(Math.pow(point7[0] - nextPoint[0], 2) + Math.pow(point7[1] - nextPoint[1], 2));
}
function getPointsPath(points, isClose = false) {
  const path2 = filter_default(points, (d4) => !!d4).map((d4, i2) => {
    return [i2 === 0 ? "M" : "L", ...d4];
  });
  if (isClose) {
    path2.push(["Z"]);
  }
  return path2;
}
function getElements(plot2) {
  return plot2.querySelectorAll(".element");
}
function getThetaPath(center2, points, isBig = 0) {
  const path2 = [["M", ...points[1]]];
  const innerRadius = getPointsR(center2, points[1]);
  const outerRadius = getPointsR(center2, points[0]);
  if (innerRadius === 0) {
    path2.push(["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
  } else {
    path2.push(["A", innerRadius, innerRadius, 0, isBig, 0, ...points[2]], ["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
  }
  return path2;
}
function maybeRoot(node, rootOf) {
  if (rootOf(node))
    return node;
  let root2 = node.parent;
  while (root2 && !rootOf(root2))
    root2 = root2.parent;
  return root2;
}
var VALID_FIND_BY_X_MARKS = ["interval", "point", "density"];
function createFindElementByEvent({ elementsof, root: root2, coordinate, scale: scale12, validFindByXMarks = VALID_FIND_BY_X_MARKS }) {
  var _a2, _b;
  let elements = elementsof(root2);
  const getValidFindByXMarks = (d4) => validFindByXMarks.includes(d4.markType);
  const hasValidFindByXMarks = elements.find(getValidFindByXMarks);
  if (hasValidFindByXMarks) {
    elements = elements.filter(getValidFindByXMarks);
    const scaleX2 = scale12.x;
    const scaleSeries = scale12.series;
    const bandWidth3 = (_b = (_a2 = scaleX2 === null || scaleX2 === void 0 ? void 0 : scaleX2.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scaleX2)) !== null && _b !== void 0 ? _b : 0;
    const xof = scaleSeries ? (d4) => {
      var _a3, _b2;
      const seriesCount = Math.round(1 / ((_a3 = scaleSeries.valueBandWidth) !== null && _a3 !== void 0 ? _a3 : 1));
      return d4.__data__.x + ((_b2 = d4.__data__.series) !== null && _b2 !== void 0 ? _b2 : 0) * bandWidth3 + bandWidth3 / (seriesCount * 2);
    } : (d4) => d4.__data__.x + bandWidth3 / 2;
    elements.sort((a5, b) => xof(a5) - xof(b));
    return (event) => {
      const mouse = mousePosition(root2, event);
      if (!mouse)
        return;
      const [abstractX] = coordinate.invert(mouse);
      const search2 = bisector(xof).center;
      const i2 = search2(elements, abstractX);
      const target = elements[i2];
      return target;
    };
  }
  return (event) => {
    const { target } = event;
    return maybeRoot(target, (node) => {
      if (!node.classList)
        return false;
      return node.classList.includes("element");
    });
  };
}

// node_modules/@antv/g2/esm/interaction/elementHighlight.js
var __rest77 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function elementHighlight(root2, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey: eleGroupKey = (d4) => d4,
  // group elements by specified key
  regionGroupKey = (d4) => d4,
  // how to group elements when hover region
  link: link3 = false,
  // draw link or not
  background = false,
  // draw background or not
  delay = 60,
  // delay to unhighlighted element
  scale: scale12,
  coordinate,
  emitter,
  state = {},
  region = false,
  regionEleFilter = (el) => VALID_FIND_BY_X_MARKS.includes(el.markType)
  // some elements can not be highlighted by region, like shapes in pie.
}) {
  var _a2, _b;
  const allElements = (_a2 = elementsof(root2)) !== null && _a2 !== void 0 ? _a2 : [];
  const elements = region ? allElements.filter(regionEleFilter) : allElements;
  const elementSet = new Set(elements);
  const groupKey = region ? regionGroupKey : eleGroupKey;
  const keyGroup = group(elements, groupKey);
  const findElement = createFindElementByEvent({
    elementsof,
    root: root2,
    coordinate,
    scale: scale12
  });
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    elements,
    valueof: valueof2,
    link: link3,
    coordinate
  }, subObject(state.active, "link")));
  const [appendBackground, removeBackground, isBackground] = renderBackground(Object.assign({
    document: root2.ownerDocument,
    scale: scale12,
    coordinate,
    background,
    valueof: valueof2
  }, subObject(state.active, "background")));
  const elementStyle = deep_mix_default(state, {
    active: Object.assign({}, ((_b = state.active) === null || _b === void 0 ? void 0 : _b.offset) && {
      //Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.active.offset(...params);
        const [, i2] = params;
        return offsetTransform(elements[i2], value2, coordinate);
      }
    })
  });
  const useState2 = createUseState(elementStyle, elements);
  const { updateState, removeState, hasState } = useState2(valueof2);
  let out;
  const pointerover = (event) => {
    const { nativeEvent = true } = event;
    let element = event.target;
    if (region) {
      element = findElement(event);
    }
    if (!elementSet.has(element))
      return;
    if (out)
      clearTimeout(out);
    const k2 = groupKey(element);
    const group3 = keyGroup.get(k2);
    const groupSet = new Set(group3);
    for (const e3 of elements) {
      if (groupSet.has(e3)) {
        if (!hasState(e3, "active"))
          updateState(e3, "active");
      } else {
        updateState(e3, "inactive");
        removeLink(e3);
      }
      if (e3 !== element)
        removeBackground(e3);
    }
    appendBackground(element);
    appendLink(group3);
    if (!nativeEvent)
      return;
    emitter.emit("element:highlight", {
      nativeEvent,
      data: {
        data: datum(element),
        group: group3.map(datum)
      }
    });
  };
  const delayUnhighlighted = () => {
    if (out)
      clearTimeout(out);
    out = setTimeout(() => {
      unhighlighted();
      out = null;
    }, delay);
  };
  const unhighlighted = (nativeEvent = true) => {
    for (const e3 of elements) {
      removeState(e3, "active", "inactive");
      removeBackground(e3);
      removeLink(e3);
    }
    if (nativeEvent) {
      emitter.emit("element:unhighlight", { nativeEvent });
    }
  };
  const pointerout = (event) => {
    let element = event.target;
    if (region) {
      element = findElement(event);
    }
    if (!element) {
      if (delay > 0)
        delayUnhighlighted();
      else
        unhighlighted();
      return;
    }
    if (background && !isBackground(element))
      return;
    if (!background && !elementSet.has(element))
      return;
    if (delay > 0)
      delayUnhighlighted();
    else
      unhighlighted();
  };
  const pointerleave = () => {
    unhighlighted();
  };
  root2.addEventListener("pointerover", pointerover);
  root2.addEventListener("pointermove", pointerover);
  root2.addEventListener("pointerout", pointerout);
  root2.addEventListener("pointerleave", pointerleave);
  const onRest = (e3) => {
    const { nativeEvent } = e3;
    if (nativeEvent)
      return;
    unhighlighted(false);
  };
  const onHighlight = (e3) => {
    const { nativeEvent } = e3;
    if (nativeEvent)
      return;
    const { data: data2 } = e3.data;
    const element = selectElementByData(elements, data2, datum);
    if (!element)
      return;
    pointerover({ target: element, nativeEvent: false });
  };
  emitter.on("element:highlight", onHighlight);
  emitter.on("element:unhighlight", onRest);
  return () => {
    root2.removeEventListener("pointerover", pointerover);
    root2.removeEventListener("pointermove", pointerover);
    root2.removeEventListener("pointerout", pointerout);
    root2.removeEventListener("pointerleave", pointerleave);
    emitter.off("element:highlight", onHighlight);
    emitter.off("element:unhighlight", onRest);
    for (const e3 of elements) {
      removeBackground(e3);
      removeLink(e3);
    }
  };
}
function ElementHighlight(_a2) {
  var { delay, createGroup, createRegionGroup, background = false, link: link3 = false } = _a2, rest = __rest77(_a2, ["delay", "createGroup", "createRegionGroup", "background", "link"]);
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const { scale: scale12, coordinate } = view;
    const plotArea = selectPlotArea(container);
    return elementHighlight(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      regionGroupKey: createRegionGroup ? createRegionGroup(view) : createXKey(view),
      coordinate,
      scale: scale12,
      state: mergeState(options, [
        ["active", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "inactive"
      ]),
      background,
      link: link3,
      delay,
      emitter
    }, rest));
  };
}
ElementHighlight.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByX.js
function ElementHighlightByX(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementHighlightByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js
function ElementHighlightByColor(options) {
  return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementHighlightByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelect.js
var __rest78 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function elementSelect(root2, {
  elements: elementsof,
  // given the root of chart returns elements to be manipulated
  datum,
  // given each element returns the datum of it
  groupKey = (d4) => d4,
  // group elements by specified key
  regionGroupKey = (d4) => d4,
  // how to group elements when click region
  link: link3 = false,
  // draw link or not
  single = false,
  // single select or not
  multipleSelectHotkey,
  // hotkey for multi-select mode
  coordinate,
  background = false,
  scale: scale12,
  emitter,
  state = {},
  region = false,
  regionEleFilter = (el) => VALID_FIND_BY_X_MARKS.includes(el.markType)
}) {
  var _a2;
  const elements = elementsof(root2);
  const elementSet = new Set(elements);
  const findElement = createFindElementByEvent({
    elementsof,
    root: root2,
    coordinate,
    scale: scale12
  });
  const keyGroup = group(elements, groupKey);
  const regionGroup = group(elements, regionGroupKey);
  const valueof2 = createValueof(elements, datum);
  const [appendLink, removeLink] = renderLink(Object.assign({
    link: link3,
    elements,
    valueof: valueof2,
    coordinate
  }, subObject(state.selected, "link")));
  const [appendBackground, removeBackground] = renderBackground(Object.assign({
    document: root2.ownerDocument,
    background,
    coordinate,
    scale: scale12,
    valueof: valueof2
  }, subObject(state.selected, "background")));
  const elementStyle = deep_mix_default(state, {
    selected: Object.assign({}, ((_a2 = state.selected) === null || _a2 === void 0 ? void 0 : _a2.offset) && {
      // Apply translate to mock slice out.
      transform: (...params) => {
        const value2 = state.selected.offset(...params);
        const [, i2] = params;
        return offsetTransform(elements[i2], value2, coordinate);
      }
    })
  });
  const useState2 = createUseState(elementStyle, elements);
  const { updateState, removeState, hasState } = useState2(valueof2);
  let isMultiSelectMode = !single;
  let activeHotkey = null;
  const clear = (nativeEvent = true) => {
    for (const e3 of elements) {
      removeState(e3, "selected", "unselected");
      removeLink(e3);
      removeBackground(e3);
    }
    if (nativeEvent)
      emitter.emit("element:unselect", { nativeEvent: true });
    return;
  };
  const singleSelect = ({ event, element, nativeEvent = true, filter: filter3 = (el) => true, groupBy: groupBy3 = groupKey, groupMap = keyGroup }) => {
    const filteredElements = elements.filter(filter3);
    if (hasState(element, "selected"))
      clear();
    else {
      const k2 = groupBy3(element);
      const group3 = groupMap.get(k2);
      const groupSet = new Set(group3);
      for (const e3 of filteredElements) {
        if (groupSet.has(e3))
          updateState(e3, "selected");
        else {
          updateState(e3, "unselected");
          removeLink(e3);
        }
        if (e3 !== element)
          removeBackground(e3);
      }
      appendLink(group3);
      appendBackground(element);
      if (!nativeEvent)
        return;
      emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
        data: [datum(element), ...group3.map(datum)]
      } }));
    }
  };
  const multipleSelect = ({ event, element, nativeEvent = true, filter: filter3 = (el) => true, groupBy: groupBy3 = groupKey, groupMap = keyGroup }) => {
    const k2 = groupBy3(element);
    const group3 = groupMap.get(k2);
    const groupSet = new Set(group3);
    const filteredElements = elements.filter(filter3);
    if (!hasState(element, "selected")) {
      const hasSelectedGroup = group3.some((e3) => hasState(e3, "selected"));
      for (const e3 of filteredElements) {
        if (groupSet.has(e3))
          updateState(e3, "selected");
        else if (!hasState(e3, "selected"))
          updateState(e3, "unselected");
      }
      if (!hasSelectedGroup && link3)
        appendLink(group3);
      appendBackground(element);
    } else {
      const hasSelected = elements.some((e3) => !groupSet.has(e3) && hasState(e3, "selected"));
      if (!hasSelected)
        return clear();
      for (const e3 of group3) {
        updateState(e3, "unselected");
        removeLink(e3);
        removeBackground(e3);
      }
    }
    if (!nativeEvent)
      return;
    emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
      data: elements.filter((e3) => hasState(e3, "selected")).map(datum)
    } }));
  };
  const isClickElementOrGroup = (element) => {
    if (elementSet.has(element))
      return true;
    for (const group3 of elementSet) {
      const found = traverseElements(group3, (el) => el === element);
      if (found)
        return true;
    }
    return false;
  };
  const getRealElement = (element) => {
    if (elementSet.has(element))
      return element;
    for (const group3 of elementSet) {
      let match = null;
      traverseElements(group3, (el) => {
        if (el === element)
          match = group3;
      });
      if (match)
        return match;
    }
    return element;
  };
  const click = (event) => {
    const { target: element, nativeEvent = true } = event;
    const select3 = !isMultiSelectMode ? singleSelect : multipleSelect;
    let el = element;
    const isClickElement = isClickElementOrGroup(element);
    if (!region || isClickElement) {
      if (!isClickElement)
        return clear();
      return select3({
        event,
        element: getRealElement(el),
        nativeEvent,
        groupBy: groupKey
      });
    } else {
      el = findElement(event);
      if (!elementSet.has(el))
        return clear();
      return select3({
        event,
        element: el,
        nativeEvent,
        filter: regionEleFilter,
        groupBy: regionGroupKey,
        groupMap: regionGroup
      });
    }
  };
  const hotkeys = Array.isArray(multipleSelectHotkey) ? multipleSelectHotkey : [multipleSelectHotkey];
  const handleKeyDown = (event) => {
    if (hotkeys.includes(event.code) && !activeHotkey) {
      activeHotkey = event.code;
      isMultiSelectMode = true;
    }
  };
  const handleKeyUp = (event) => {
    if (event.code === activeHotkey) {
      activeHotkey = null;
      isMultiSelectMode = false;
    }
  };
  root2.addEventListener("click", click);
  if (multipleSelectHotkey) {
    isMultiSelectMode = false;
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
  }
  const onSelect = (e3) => {
    const { nativeEvent, data: data2 } = e3;
    if (nativeEvent)
      return;
    const selectedData = !isMultiSelectMode ? data2.data.slice(0, 1) : data2.data;
    for (const d4 of selectedData) {
      const element = selectElementByData(elements, d4, datum);
      click({ target: element, nativeEvent: false });
    }
  };
  const onUnSelect = () => {
    clear(false);
  };
  emitter.on("element:select", onSelect);
  emitter.on("element:unselect", onUnSelect);
  return () => {
    for (const e3 of elements)
      removeLink(e3);
    root2.removeEventListener("click", click);
    if (multipleSelectHotkey) {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
    }
    emitter.off("element:select", onSelect);
    emitter.off("element:unselect", onUnSelect);
  };
}
function ElementSelect(_a2) {
  var { createGroup, createRegionGroup, background = false, link: link3 = false } = _a2, rest = __rest78(_a2, ["createGroup", "createRegionGroup", "background", "link"]);
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const { coordinate, scale: scale12 } = view;
    const plotArea = selectPlotArea(container);
    return elementSelect(plotArea, Object.assign({
      elements: selectG2Elements,
      datum: createDatumof(view),
      groupKey: createGroup ? createGroup(view) : void 0,
      regionGroupKey: createRegionGroup ? createRegionGroup(view) : createXKey(view),
      coordinate,
      scale: scale12,
      state: mergeState(options, [
        ["selected", background ? {} : { lineWidth: "1", stroke: "#000" }],
        "unselected"
      ]),
      background,
      link: link3,
      emitter
    }, rest));
  };
}
ElementSelect.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByX.js
function ElementSelectByX(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
}
ElementSelectByX.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/elementSelectByColor.js
function ElementSelectByColor(options) {
  return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
}
ElementSelectByColor.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/chartIndex.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest79 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function maybeTransform(options) {
  const { transform: transform2 = [] } = options;
  const normalizeY = transform2.find((d4) => d4.type === "normalizeY");
  if (normalizeY)
    return normalizeY;
  const newNormalizeY = { type: "normalizeY" };
  transform2.push(newNormalizeY);
  options.transform = transform2;
  return newNormalizeY;
}
function markValue2(markState, markName, channels) {
  const [value2] = Array.from(markState.entries()).filter(([mark2]) => mark2.type === markName).map(([mark2]) => {
    const { encode } = mark2;
    const channel = (name2) => {
      const channel2 = encode[name2];
      return [name2, channel2 ? channel2.value : void 0];
    };
    return Object.fromEntries(channels.map(channel));
  });
  return value2;
}
function ChartIndex(_a2) {
  var { wait = 20, leading, trailing = false, labelFormatter: labelFormatter2 = (date) => `${date}` } = _a2, style = __rest79(_a2, ["wait", "leading", "trailing", "labelFormatter"]);
  return (context) => {
    const { view, container, update: update2, setState } = context;
    const { markState, scale: scale12, coordinate } = view;
    const value2 = markValue2(markState, "line", ["x", "y", "series"]);
    if (!value2)
      return;
    const { y: Y, x: X, series: S = [] } = value2;
    const I = Y.map((_2, i2) => i2);
    const sortedX = sort(I.map((i2) => X[i2]));
    const plotArea = selectPlotArea(container);
    const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);
    const labels = container.getElementsByClassName(LABEL_CLASS_NAME);
    const keyofLabel = (d4) => d4.__data__.key.split("-")[0];
    const keyLabels = group(labels, keyofLabel);
    const rule = new Line({
      style: Object.assign({ x1: 0, y1: 0, x2: 0, y2: plotArea.getAttribute("height"), stroke: "black", lineWidth: 1 }, subObject(style, "rule"))
    });
    const text = new Text({
      style: Object.assign({ x: 0, y: plotArea.getAttribute("height"), text: "", fontSize: 10 }, subObject(style, "label"))
    });
    rule.append(text);
    plotArea.appendChild(rule);
    const dateByFocus = (coordinate2, scaleX2, focus2) => {
      const [normalizedX] = coordinate2.invert(focus2);
      const date = scaleX2.invert(normalizedX);
      return sortedX[bisectCenter(sortedX, date)];
    };
    const updateRule = (focus2, date) => {
      rule.setAttribute("x1", focus2[0]);
      rule.setAttribute("x2", focus2[0]);
      text.setAttribute("text", labelFormatter2(date));
    };
    let newView;
    const updateBasisByRerender = (focus2) => __awaiter6(this, void 0, void 0, function* () {
      const { x: scaleX2 } = scale12;
      const date = dateByFocus(coordinate, scaleX2, focus2);
      updateRule(focus2, date);
      setState("chartIndex", (options) => {
        const clonedOptions = deep_mix_default({}, options);
        const lineMark = clonedOptions.marks.find((d4) => d4.type === "line");
        const r2 = (I2) => max5(I2, (i2) => +Y[i2]) / min4(I2, (i2) => +Y[i2]);
        const k2 = max5(rollup(I, r2, (i2) => S[i2]).values());
        const domainY = [1 / k2, k2];
        deep_mix_default(lineMark, {
          scale: { y: { domain: domainY } }
        });
        const normalizeY = maybeTransform(lineMark);
        normalizeY.groupBy = "color";
        normalizeY.basis = (I2, Y3) => {
          const i2 = I2[bisector((i3) => X[+i3]).center(I2, date)];
          return Y3[i2];
        };
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        return clonedOptions;
      });
      const newState = yield update2("chartIndex");
      newView = newState.view;
    });
    const updateBasisByTranslate = (focus2) => {
      const { scale: scale13, coordinate: coordinate2 } = newView;
      const { x: scaleX2, y: scaleY2 } = scale13;
      const date = dateByFocus(coordinate2, scaleX2, focus2);
      updateRule(focus2, date);
      for (const line4 of lines) {
        const { seriesIndex: SI, key } = line4.__data__;
        const i2 = SI[bisector((i3) => X[+i3]).center(SI, date)];
        const p0 = [0, scaleY2.map(1)];
        const p1 = [0, scaleY2.map(Y[i2] / Y[SI[0]])];
        const [, y05] = coordinate2.map(p0);
        const [, y12] = coordinate2.map(p1);
        const dy = y05 - y12;
        line4.setAttribute("transform", `translate(0, ${dy})`);
        const labels2 = keyLabels.get(key) || [];
        for (const label of labels2) {
          label.setAttribute("dy", dy);
        }
      }
    };
    const updateBasis = throttle_default((event) => {
      const focus2 = mousePosition(plotArea, event);
      if (!focus2)
        return;
      updateBasisByTranslate(focus2);
    }, wait, { leading, trailing });
    updateBasisByRerender([0, 0]);
    plotArea.addEventListener("pointerenter", updateBasis);
    plotArea.addEventListener("pointermove", updateBasis);
    plotArea.addEventListener("pointerleave", updateBasis);
    return () => {
      rule.remove();
      plotArea.removeEventListener("pointerenter", updateBasis);
      plotArea.removeEventListener("pointermove", updateBasis);
      plotArea.removeEventListener("pointerleave", updateBasis);
    };
  };
}
ChartIndex.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/fisheye.js
function maybeCoordinate(options) {
  const { coordinate = {} } = options;
  const { transform: transform2 = [] } = coordinate;
  const fisheye2 = transform2.find((d4) => d4.type === "fisheye");
  if (fisheye2)
    return fisheye2;
  const newFisheye = { type: "fisheye" };
  transform2.push(newFisheye);
  coordinate.transform = transform2;
  options.coordinate = coordinate;
  return newFisheye;
}
function Fisheye2({ wait = 30, leading, trailing = false }) {
  return (context) => {
    const { options, update: update2, setState, container } = context;
    const plotArea = selectPlotArea(container);
    const updateFocus = throttle_default((event) => {
      const focus2 = mousePosition(plotArea, event);
      if (!focus2) {
        setState("fisheye");
        update2();
        return;
      }
      setState("fisheye", (options2) => {
        const clonedOptions = deep_mix_default({}, options2, {
          interaction: { tooltip: { preserve: true } }
        });
        for (const mark2 of clonedOptions.marks)
          mark2.animate = false;
        const [x3, y4] = focus2;
        const fisheye2 = maybeCoordinate(clonedOptions);
        fisheye2.focusX = x3;
        fisheye2.focusY = y4;
        fisheye2.visual = true;
        return clonedOptions;
      });
      update2();
    }, wait, { leading, trailing });
    plotArea.addEventListener("pointerenter", updateFocus);
    plotArea.addEventListener("pointermove", updateFocus);
    plotArea.addEventListener("pointerleave", updateFocus);
    return () => {
      plotArea.removeEventListener("pointerenter", updateFocus);
      plotArea.removeEventListener("pointermove", updateFocus);
      plotArea.removeEventListener("pointerleave", updateFocus);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/tooltip.js
var __rest80 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function getContainer(group3, mount) {
  var _a2;
  if (mount) {
    return typeof mount === "string" ? document.querySelector(mount) : mount;
  }
  const view = (_a2 = group3.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
  if (!view)
    return;
  const canvas = view.getContextService().getDomElement();
  return canvas.parentElement;
}
function getBounding(root2) {
  const bbox = root2.getRenderBounds();
  const { min: [x12, y12], max: [x22, y22] } = bbox;
  return {
    x: x12,
    y: y12,
    width: x22 - x12,
    height: y22 - y12
  };
}
function getContainerOffset(container1, container2) {
  const r1 = container1.getBoundingClientRect();
  const r2 = container2.getBoundingClientRect();
  return {
    x: r1.x - r2.x,
    y: r1.y - r2.y
  };
}
function createTooltip(container, x05, y05, position, enterable, bounding, containerOffset, css = {}, offset2 = [10, 10]) {
  const defaults4 = {
    ".g2-tooltip": {},
    ".g2-tooltip-title": {
      overflow: "hidden",
      "white-space": "nowrap",
      "text-overflow": "ellipsis"
    }
  };
  const tooltipElement = new Tooltip({
    className: "tooltip",
    style: {
      x: x05,
      y: y05,
      container: containerOffset,
      data: [],
      bounding,
      position,
      enterable,
      title: "",
      offset: offset2,
      template: {
        prefixCls: "g2-"
      },
      style: deep_mix_default(defaults4, css)
    }
  });
  container.appendChild(tooltipElement.HTMLTooltipElement);
  return tooltipElement;
}
function showTooltip({ root: root2, data: data2, x: x3, y: y4, render: render3, event, single, position = "right-bottom", enterable = false, css, mount, bounding, offset: offset2 }) {
  const container = getContainer(root2, mount);
  const canvasContainer = getContainer(root2);
  const parent = single ? canvasContainer : root2;
  const b = bounding || getBounding(root2);
  const containerOffset = getContainerOffset(canvasContainer, container);
  const { tooltipElement = createTooltip(container, x3, y4, position, enterable, b, containerOffset, css, offset2) } = parent;
  const { items, title = "" } = data2;
  tooltipElement.update(Object.assign({
    x: x3,
    y: y4,
    data: items,
    title,
    position,
    enterable,
    container: containerOffset
  }, render3 !== void 0 && {
    content: render3(event, { items, title })
  }));
  parent.tooltipElement = tooltipElement;
}
function hideTooltip({ root: root2, single, emitter, nativeEvent = true, event = null }) {
  if (nativeEvent) {
    emitter.emit("tooltip:hide", { nativeEvent });
  }
  const container = getContainer(root2);
  const parent = single ? container : root2;
  const { tooltipElement } = parent;
  if (tooltipElement) {
    tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
  }
  hideRuleY(root2);
  hideRuleX(root2);
  hideMarker(root2);
}
function destroyTooltip({ root: root2, single }) {
  const container = getContainer(root2);
  const parent = single ? container : root2;
  if (!parent)
    return;
  const { tooltipElement } = parent;
  if (tooltipElement) {
    tooltipElement.destroy();
    parent.tooltipElement = void 0;
  }
  hideRuleY(root2);
  hideRuleX(root2);
  hideMarker(root2);
}
function showUndefined(item) {
  const { value: value2 } = item;
  return Object.assign(Object.assign({}, item), { value: value2 === void 0 ? "undefined" : value2 });
}
function heatmapItem(element) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const datum = element.__data__;
  const normalizedX = (_b = (_a2 = datum === null || datum === void 0 ? void 0 : datum.normalized) === null || _a2 === void 0 ? void 0 : _a2.x) !== null && _b !== void 0 ? _b : 0;
  const originalDatum = (_c = element.parentNode) === null || _c === void 0 ? void 0 : _c.__data__;
  const encode = (_d = originalDatum === null || originalDatum === void 0 ? void 0 : originalDatum.encode) !== null && _d !== void 0 ? _d : {};
  const { x: x3 = {}, y: y4 = {}, color: color3 = {} } = encode;
  const { value: vx = [] } = x3;
  const { value: vy = [] } = y4;
  const { value: vc = [] } = color3;
  const index3 = Math.min(Math.round(vx.length * normalizedX), vx.length - 1);
  return {
    title: `${vx[index3]}, ${vy[index3]}`,
    items: [
      {
        name: (_e = color3.field) !== null && _e !== void 0 ? _e : "value",
        value: vc[index3],
        color: ((_f = element.style) === null || _f === void 0 ? void 0 : _f.fill) || ((_g = element.getAttribute) === null || _g === void 0 ? void 0 : _g.call(element, "color")) || "#000"
      }
    ]
  };
}
function singleItem(element) {
  const { __data__: datum } = element;
  if (isHeatmap(element))
    return heatmapItem(element);
  const { title, items = [] } = datum;
  const newItems = items.filter(defined).map((_a2) => {
    var { color: color3 = itemColorOf(element) } = _a2, item = __rest80(_a2, ["color"]);
    return Object.assign(Object.assign({}, item), { color: color3 });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, title && { title }), { items: newItems });
}
function itemColorOf(element) {
  const fill = element.getAttribute("fill");
  const stroke2 = element.getAttribute("stroke");
  const { __data__: datum } = element;
  const { color: color3 = fill && fill !== "transparent" ? fill : stroke2 } = datum;
  return color3;
}
function unique2(items, key = (d4) => d4) {
  const valueName = new Map(items.map((d4) => [key(d4), d4]));
  return Array.from(valueName.values());
}
function groupItems(elements, scale12, groupName, data2 = elements.map((d4) => d4["__data__"]), theme = {}) {
  const key = (d4) => d4 instanceof Date ? +d4 : d4;
  const T2 = unique2(data2.map((d4) => d4.title), key).filter(defined);
  const newItems = data2.flatMap((datum, i2) => {
    const element = datum.element || elements[i2];
    const { items = [], title } = datum;
    const definedItems = items.filter(defined);
    const useGroupName = groupName !== void 0 ? groupName : items.length <= 1 ? true : false;
    return definedItems.map((_a2) => {
      var { color: color3 = itemColorOf(element) || theme.color, name: name2 } = _a2, item = __rest80(_a2, ["color", "name"]);
      const groupName2 = groupNameOf(scale12, datum);
      const name1 = useGroupName && !(CALLBACK_ITEM_SYMBOL in item) ? groupName2 || name2 : name2 || groupName2;
      return Object.assign(Object.assign({}, item), { color: color3, name: name1 || title });
    });
  }).map(showUndefined);
  return Object.assign(Object.assign({}, T2.length > 0 && { title: T2.join(",") }), { items: unique2(newItems, (d4) => `(${key(d4.name)}, ${key(d4.value)}, ${key(d4.color)})`) });
}
function updateRuleX(root2, points, mouse, _a2) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a2, rest = __rest80(_a2, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults4 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
  const createCircle = (cx, cy, r2) => {
    const circle3 = new Circle({
      style: Object.assign({
        cx,
        cy,
        r: r2
      }, defaults4)
    });
    root2.appendChild(circle3);
    return circle3;
  };
  const createLine = (x12, x22, y12, y22) => {
    const line4 = new Line({
      style: Object.assign({
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22
      }, defaults4)
    });
    root2.appendChild(line4);
    return line4;
  };
  const minDistPoint = (mouse2, points2) => {
    if (points2.length === 1) {
      return points2[0];
    }
    const dists = points2.map((p3) => dist4(p3, mouse2));
    const minDistIndex = minIndex(dists, (d4) => d4);
    return points2[minDistIndex];
  };
  const target = minDistPoint(mouse, points);
  const pointsOf = () => {
    if (transposed)
      return [
        startX + target[0],
        startX + target[0],
        startY,
        startY + plotHeight
      ];
    return [startX, startX + plotWidth, target[1] + startY, target[1] + startY];
  };
  const pointsOfPolar = () => {
    const cx = startX + insetLeft + mainWidth / 2;
    const cy = startY + insetTop + mainHeight / 2;
    const cdist = dist4([cx, cy], target);
    return [cx, cy, cdist];
  };
  if (polar2) {
    const [cx, cy, r2] = pointsOfPolar();
    const ruleX = root2.ruleX || createCircle(cx, cy, r2);
    ruleX.style.cx = cx;
    ruleX.style.cy = cy;
    ruleX.style.r = r2;
    root2.ruleX = ruleX;
  } else {
    const [x12, x22, y12, y22] = pointsOf();
    const ruleX = root2.ruleX || createLine(x12, x22, y12, y22);
    ruleX.style.x1 = x12;
    ruleX.style.x2 = x22;
    ruleX.style.y1 = y12;
    ruleX.style.y2 = y22;
    root2.ruleX = ruleX;
  }
}
function updateRuleY(root2, points, _a2) {
  var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar: polar2, insetLeft, insetTop } = _a2, rest = __rest80(_a2, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
  const defaults4 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
  const Y = points.map((p3) => p3[1]);
  const X = points.map((p3) => p3[0]);
  const y4 = mean(Y);
  const x3 = mean(X);
  const pointsOf = () => {
    if (polar2) {
      const r2 = Math.min(mainWidth, mainHeight) / 2;
      const cx = startX + insetLeft + mainWidth / 2;
      const cy = startY + insetTop + mainHeight / 2;
      const a5 = angle3(sub6([x3, y4], [cx, cy]));
      const x05 = cx + r2 * Math.cos(a5);
      const y05 = cy + r2 * Math.sin(a5);
      return [cx, x05, cy, y05];
    }
    if (transposed)
      return [startX, startX + plotWidth, y4 + startY, y4 + startY];
    return [x3 + startX, x3 + startX, startY, startY + plotHeight];
  };
  const [x12, x22, y12, y22] = pointsOf();
  const createLine = () => {
    const line4 = new Line({
      style: Object.assign({
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22
      }, defaults4)
    });
    root2.appendChild(line4);
    return line4;
  };
  if (X.length > 0) {
    const ruleY = root2.ruleY || createLine();
    ruleY.style.x1 = x12;
    ruleY.style.x2 = x22;
    ruleY.style.y1 = y12;
    ruleY.style.y2 = y22;
    root2.ruleY = ruleY;
  }
}
function hideRuleY(root2) {
  if (root2.ruleY) {
    root2.ruleY.remove();
    root2.ruleY = void 0;
  }
}
function hideRuleX(root2) {
  if (root2.ruleX) {
    root2.ruleX.remove();
    root2.ruleX = void 0;
  }
}
function updateMarker(root2, { data: data2, style, theme }) {
  if (root2.markers)
    root2.markers.forEach((d4) => d4.remove());
  const { type = "" } = style;
  const markers = data2.filter((d4) => {
    const [{ x: x3, y: y4 }] = d4;
    return defined(x3) && defined(y4);
  }).map((d4) => {
    const [{ color: color3, element }, point7] = d4;
    const originColor = color3 || // encode value
    element.style.fill || element.style.stroke || theme.color;
    const fill = type === "hollow" ? "transparent" : originColor;
    const stroke2 = type === "hollow" ? originColor : "#fff";
    const shape23 = new Circle({
      className: "g2-tooltip-marker",
      style: Object.assign({
        cx: point7[0],
        cy: point7[1],
        fill,
        r: 4,
        stroke: stroke2,
        lineWidth: 2,
        // Prevents blocking clicks on elements behind.
        pointerEvents: "none"
      }, style)
    });
    return shape23;
  });
  for (const marker of markers)
    root2.appendChild(marker);
  root2.markers = markers;
}
function hideMarker(root2) {
  if (root2.markers) {
    root2.markers.forEach((d4) => d4.remove());
    root2.markers = [];
  }
}
function interactionKeyof(markState, key) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d4) => {
      var _a2;
      return (_a2 = d4.interaction) === null || _a2 === void 0 ? void 0 : _a2[key];
    }
  );
}
function maybeValue(specified, defaults4) {
  return specified === void 0 ? defaults4 : specified;
}
function isEmptyTooltipData(data2) {
  const { title, items } = data2;
  if (items.length === 0 && title === void 0)
    return true;
  return false;
}
function hasSeries(markState) {
  return Array.from(markState.values()).some(
    // @ts-ignore
    (d4) => {
      var _a2;
      return ((_a2 = d4.interaction) === null || _a2 === void 0 ? void 0 : _a2.seriesTooltip) && d4.tooltip;
    }
  );
}
function normalizedPosition(coordinate, position) {
  const { innerWidth, innerHeight, marginLeft, paddingLeft, insetLeft, marginTop, paddingTop, insetTop } = coordinate.getOptions();
  return {
    x: (position.x - marginLeft - paddingLeft - insetLeft) / innerWidth,
    y: (position.y - marginTop - paddingTop - insetTop) / innerHeight
  };
}
function findSingleElement({ root: root2, event, elements = [], coordinate, scale: scale12, shared }) {
  var _a2, _b;
  const inInterval = (d4) => d4.markType === "interval";
  const isBar = elements.every(inInterval) && !isPolar(coordinate);
  const scaleX2 = scale12.x;
  const scaleSeries = scale12.series;
  const bandWidth3 = (_b = (_a2 = scaleX2 === null || scaleX2 === void 0 ? void 0 : scaleX2.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scaleX2)) !== null && _b !== void 0 ? _b : 0;
  const xof = scaleSeries ? (d4) => {
    const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);
    return d4.__data__.x + d4.__data__.series * bandWidth3 + bandWidth3 / (seriesCount * 2);
  } : (d4) => d4.__data__.x + bandWidth3 / 2;
  if (isBar)
    elements.sort((a5, b) => xof(a5) - xof(b));
  const findElementByTarget = (event2) => {
    const { target = last(elements) } = event2;
    return maybeRoot(target, (node) => {
      if (!node.classList)
        return false;
      if (isHeatmap(node)) {
        set_default(node, "__data__.normalized", normalizedPosition(coordinate, {
          x: event2.offsetX,
          y: event2.offsetY
        }));
      }
      return node.classList.includes("element");
    });
  };
  const element = isBar ? (event2) => {
    const mouse = mousePosition(root2, event2);
    if (!mouse)
      return;
    const [abstractX] = coordinate.invert(mouse);
    const search2 = bisector(xof).center;
    const i2 = search2(elements, abstractX);
    const target = elements[i2];
    if (!shared) {
      const isGrouped = elements.find((d4) => d4 !== target && xof(d4) === xof(target));
      if (isGrouped)
        return findElementByTarget(event2);
    }
    return target;
  } : findElementByTarget;
  return element(event);
}
function findSeriesElement({ root: root2, event, elements, coordinate, scale: scale12, startX, startY }) {
  const transposed = isTranspose(coordinate);
  const seriesElements = [];
  const itemElements = [];
  for (const element of elements) {
    const { __data__: data2 } = element;
    const { seriesX, title, items } = data2;
    if (seriesX)
      seriesElements.push(element);
    else if (title || items)
      itemElements.push(element);
  }
  const inInterval = (d4) => d4.markType === "interval";
  const isBar = itemElements.length && itemElements.every(inInterval) && !isPolar(coordinate);
  const xof = (d4) => d4.__data__.x;
  const isBandScale = !!scale12.x.getBandWidth;
  const closest = isBandScale && itemElements.length > 0;
  seriesElements.sort((a5, b) => {
    const index3 = transposed ? 0 : 1;
    const minY = (d4) => d4.getBounds().min[index3];
    return transposed ? minY(b) - minY(a5) : minY(a5) - minY(b);
  });
  const extent2 = (d4) => {
    const index3 = transposed ? 1 : 0;
    const { min: min10, max: max11 } = d4.getLocalBounds();
    return sort([min10[index3], max11[index3]]);
  };
  if (isBar)
    elements.sort((a5, b) => xof(a5) - xof(b));
  else {
    itemElements.sort((a5, b) => {
      const [minA, maxA] = extent2(a5);
      const [minB, maxB] = extent2(b);
      const midA = (minA + maxA) / 2;
      const midB = (minB + maxB) / 2;
      return transposed ? midB - midA : midA - midB;
    });
  }
  const elementSortedX = new Map(seriesElements.map((element) => {
    const { __data__: data2 } = element;
    const { seriesX } = data2;
    const seriesIndex = seriesX.map((_2, i2) => i2);
    const sortedIndex2 = sort(seriesIndex, (i2) => seriesX[+i2]);
    return [element, [sortedIndex2, seriesX]];
  }));
  const { x: scaleX2 } = scale12;
  const offsetX = (scaleX2 === null || scaleX2 === void 0 ? void 0 : scaleX2.getBandWidth) ? scaleX2.getBandWidth() / 2 : 0;
  const abstractX = (focus3) => {
    const [normalizedX] = coordinate.invert(focus3);
    return normalizedX - offsetX;
  };
  const indexByFocus = (event2, focus3, I, X) => {
    const { _x } = event2;
    const finalX = _x !== void 0 ? scaleX2.map(_x) : abstractX(focus3);
    const DX = X.filter(defined);
    const [minX, maxX] = sort([DX[0], DX[DX.length - 1]]);
    const isOnlyOneElement = minX === maxX;
    if (!closest && (finalX < minX || finalX > maxX) && !isOnlyOneElement)
      return null;
    const search2 = bisector((i3) => X[+i3]).center;
    const i2 = search2(I, finalX);
    return I[i2];
  };
  const elementsByFocus = isBar ? (focus3, elements2) => {
    const search2 = bisector(xof).center;
    const i2 = search2(elements2, abstractX(focus3));
    const find6 = elements2[i2];
    const groups2 = group(elements2, xof);
    const selected = groups2.get(xof(find6));
    return selected;
  } : (focus3, elements2) => {
    const index3 = transposed ? 1 : 0;
    const x3 = focus3[index3];
    const filtered = elements2.filter((element) => {
      const [min10, max11] = extent2(element);
      return x3 >= min10 && x3 <= max11;
    });
    if (!closest || filtered.length > 0)
      return filtered;
    const search2 = bisector((element) => {
      const [min10, max11] = extent2(element);
      return (min10 + max11) / 2;
    }).center;
    const i2 = search2(elements2, x3);
    return [elements2[i2]].filter(defined);
  };
  const seriesData = (element, index3) => {
    const { __data__: data2 } = element;
    return Object.fromEntries(Object.entries(data2).filter(([key]) => key.startsWith("series") && key !== "series").map(([key, V]) => {
      const d4 = V[index3];
      return [lower_first_default(key.replace("series", "")), d4];
    }));
  };
  const mouse = mousePosition(root2, event);
  if (!mouse)
    return;
  const focus2 = [mouse[0] - startX, mouse[1] - startY];
  if (!focus2)
    return;
  const selectedItems = elementsByFocus(focus2, itemElements);
  const selectedSeriesElements = [];
  const selectedSeriesData = [];
  for (const element of seriesElements) {
    const [sortedIndex2, X] = elementSortedX.get(element);
    const index3 = indexByFocus(event, focus2, sortedIndex2, X);
    if (index3 !== null) {
      selectedSeriesElements.push(element);
      const d4 = seriesData(element, index3);
      const { x: x3, y: y4 } = d4;
      const p3 = coordinate.map([(x3 || 0) + offsetX, y4 || 0]);
      selectedSeriesData.push([Object.assign(Object.assign({}, d4), { element }), p3]);
    }
  }
  const SX = Array.from(new Set(selectedSeriesData.map((d4) => d4[0].x)));
  const closestX = SX[minIndex(SX, (x3) => Math.abs(x3 - abstractX(focus2)))];
  const filteredSeriesData = selectedSeriesData.filter((d4) => d4[0].x === closestX);
  const selectedData = [
    ...filteredSeriesData.map((d4) => d4[0]),
    ...selectedItems.map((d4) => d4.__data__)
  ];
  const selectedElements = [...selectedSeriesElements, ...selectedItems];
  return { selectedElements, selectedData, filteredSeriesData, abstractX };
}
function seriesTooltip(root2, _a2) {
  var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale: scale12, coordinate, crosshairs, crosshairsX, crosshairsY, render: render3, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount, bounding, theme, offset: offset2, disableNative = false, marker = true, preserve = false, style: _style = {}, css = {} } = _a2, rest = __rest80(_a2, ["elements", "sort", "filter", "scale", "coordinate", "crosshairs", "crosshairsX", "crosshairsY", "render", "groupName", "emitter", "wait", "leading", "trailing", "startX", "startY", "body", "single", "position", "enterable", "mount", "bounding", "theme", "offset", "disableNative", "marker", "preserve", "style", "css"]);
  const elements = elementsof(root2);
  const style = deep_mix_default(_style, rest);
  const polar2 = isPolar(coordinate);
  const transposed = isTranspose(coordinate);
  const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate.getOptions();
  const update2 = throttle_default((event) => {
    var _a3;
    const mouse = mousePosition(root2, event);
    if (!mouse)
      return;
    const bbox = bboxOf(root2);
    const x3 = bbox.min[0];
    const y4 = bbox.min[1];
    const { selectedElements, selectedData, filteredSeriesData, abstractX } = findSeriesElement({
      root: root2,
      event,
      elements,
      coordinate,
      scale: scale12,
      startX,
      startY
    });
    const tooltipData = groupItems(selectedElements, scale12, groupName, selectedData, theme);
    if (sortFunction) {
      tooltipData.items.sort((a5, b) => sortFunction(a5) - sortFunction(b));
    }
    if (filterFunction) {
      tooltipData.items = tooltipData.items.filter(filterFunction);
    }
    if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
      hide3(event);
      return;
    }
    if (body) {
      showTooltip({
        root: root2,
        data: tooltipData,
        x: mouse[0] + x3,
        y: mouse[1] + y4,
        render: render3,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css,
        offset: offset2
      });
    }
    if (crosshairs || crosshairsX || crosshairsY) {
      const ruleStyle = subObject(style, "crosshairs");
      const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsX"));
      const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsY"));
      const points = filteredSeriesData.map((d4) => d4[1]);
      if (crosshairsX) {
        updateRuleX(root2, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {
          plotWidth,
          plotHeight,
          mainWidth,
          mainHeight,
          insetLeft,
          insetTop,
          startX,
          startY,
          transposed,
          polar: polar2
        }));
      }
      if (crosshairsY) {
        updateRuleY(root2, points, Object.assign(Object.assign({}, ruleStyleY), {
          plotWidth,
          plotHeight,
          mainWidth,
          mainHeight,
          insetLeft,
          insetTop,
          startX,
          startY,
          transposed,
          polar: polar2
        }));
      }
    }
    if (marker) {
      const markerStyles = subObject(style, "marker");
      updateMarker(root2, {
        data: filteredSeriesData,
        style: markerStyles,
        theme
      });
    }
    const firstX = (_a3 = filteredSeriesData[0]) === null || _a3 === void 0 ? void 0 : _a3[0].x;
    const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, tooltipData), { data: { x: invert4(scale12.x, transformedX, true) } }) }));
  }, wait, { leading, trailing });
  const hide3 = (event) => {
    hideTooltip({ root: root2, single, emitter, event });
  };
  const destroy2 = () => {
    destroyTooltip({ root: root2, single });
  };
  const onTooltipShow = (_a3) => {
    var _b;
    var { nativeEvent, data: data2, offsetX, offsetY } = _a3, rest2 = __rest80(_a3, ["nativeEvent", "data", "offsetX", "offsetY"]);
    if (nativeEvent)
      return;
    const x3 = (_b = data2 === null || data2 === void 0 ? void 0 : data2.data) === null || _b === void 0 ? void 0 : _b.x;
    const scaleX2 = scale12.x;
    const x12 = scaleX2.map(x3);
    const [x22, y22] = coordinate.map([x12, 0.5]);
    const rootBounds = root2.getRenderBounds();
    const minX = rootBounds.min[0];
    const minY = rootBounds.min[1];
    update2(Object.assign(Object.assign({}, rest2), { offsetX: offsetX !== void 0 ? offsetX : minX + x22, offsetY: offsetY !== void 0 ? offsetY : minY + y22, _x: x3 }));
  };
  const onTooltipHide = () => {
    hideTooltip({ root: root2, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroy2();
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root2.addEventListener("pointerdown", update2);
      root2.addEventListener("pointerenter", update2);
      root2.addEventListener("pointermove", update2);
      root2.addEventListener("pointerleave", (e3) => {
        if (mousePosition(root2, e3))
          return;
        hide3(e3);
      });
      root2.addEventListener("pointerup", hide3);
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root2.removeEventListener("pointerdown", update2);
      root2.removeEventListener("pointerenter", update2);
      root2.removeEventListener("pointermove", update2);
      root2.removeEventListener("pointerleave", hide3);
      root2.removeEventListener("pointerup", hide3);
    }
  };
  addEventListeners();
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:disable", onTooltipDisable);
  emitter.on("tooltip:enable", onTooltipEnable);
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    emitter.off("tooltip:disable", onTooltipDisable);
    emitter.off("tooltip:enable", onTooltipEnable);
    if (preserve) {
      hideTooltip({ root: root2, single, emitter, nativeEvent: false });
    } else {
      destroy2();
    }
  };
}
function tooltip(root2, {
  elements: elementsof,
  coordinate,
  scale: scale12,
  render: render3,
  groupName,
  sort: sortFunction,
  filter: filterFunction,
  emitter,
  wait = 50,
  leading = true,
  trailing = false,
  groupKey = (d4) => d4,
  // group elements by specified key
  single = true,
  position,
  enterable,
  datum,
  view,
  mount,
  bounding,
  theme,
  offset: offset2,
  shared = false,
  body = true,
  disableNative = false,
  preserve = false,
  css = {}
}) {
  const elements = elementsof(root2);
  const keyGroup = group(elements, groupKey);
  const pointermove = throttle_default((event) => {
    const element = findSingleElement({
      root: root2,
      event,
      elements,
      coordinate,
      scale: scale12,
      shared
    });
    if (!element) {
      hideTooltip({ root: root2, single, emitter, event });
      return;
    }
    const k2 = groupKey(element);
    const group3 = keyGroup.get(k2);
    if (!group3) {
      return;
    }
    const data2 = group3.length === 1 && !shared ? singleItem(group3[0]) : groupItems(group3, scale12, groupName, void 0, theme);
    if (sortFunction) {
      data2.items.sort((a5, b) => sortFunction(a5) - sortFunction(b));
    }
    if (filterFunction) {
      data2.items = data2.items.filter(filterFunction);
    }
    if (isEmptyTooltipData(data2)) {
      hideTooltip({ root: root2, single, emitter, event });
      return;
    }
    const { offsetX, offsetY } = event;
    if (body) {
      showTooltip({
        root: root2,
        data: data2,
        x: offsetX,
        y: offsetY,
        render: render3,
        event,
        single,
        position,
        enterable,
        mount,
        bounding,
        css,
        offset: offset2
      });
    }
    emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, data2), { data: dataOf(element, view) }) }));
  }, wait, { leading, trailing });
  const pointerleave = (event) => {
    hideTooltip({ root: root2, single, emitter, event });
  };
  const addEventListeners = () => {
    if (!disableNative) {
      root2.addEventListener("pointerdown", pointermove);
      root2.addEventListener("pointermove", pointermove);
      root2.addEventListener("pointerleave", pointerleave);
      root2.addEventListener("pointerup", pointerleave);
    }
  };
  const removeEventListeners = () => {
    if (!disableNative) {
      root2.removeEventListener("pointerdown", pointermove);
      root2.removeEventListener("pointermove", pointermove);
      root2.removeEventListener("pointerleave", pointerleave);
      root2.removeEventListener("pointerup", pointerleave);
    }
  };
  const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw }) => {
    if (nativeEvent)
      return;
    const { data: data2 } = raw;
    const element = selectElementByData(elements, data2, datum);
    if (!element)
      return;
    const bbox = element.getBBox();
    const { x: x3, y: y4, width, height } = bbox;
    const rootBBox = root2.getBBox();
    pointermove({
      target: element,
      offsetX: offsetX !== void 0 ? offsetX + rootBBox.x : x3 + width / 2,
      offsetY: offsetY !== void 0 ? offsetY + rootBBox.y : y4 + height / 2
    });
  };
  const onTooltipHide = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    hideTooltip({ root: root2, single, emitter, nativeEvent: false });
  };
  const onTooltipDisable = () => {
    removeEventListeners();
    destroyTooltip({ root: root2, single });
  };
  const onTooltipEnable = () => {
    addEventListeners();
  };
  emitter.on("tooltip:show", onTooltipShow);
  emitter.on("tooltip:hide", onTooltipHide);
  emitter.on("tooltip:enable", onTooltipEnable);
  emitter.on("tooltip:disable", onTooltipDisable);
  addEventListeners();
  return () => {
    removeEventListeners();
    emitter.off("tooltip:show", onTooltipShow);
    emitter.off("tooltip:hide", onTooltipHide);
    emitter.off("tooltip:enable", onTooltipEnable);
    emitter.off("tooltip:disable", onTooltipDisable);
    if (preserve) {
      hideTooltip({ root: root2, single, emitter, nativeEvent: false });
    } else {
      destroyTooltip({ root: root2, single });
    }
  };
}
function Tooltip2(options) {
  const { shared, crosshairs, crosshairsX, crosshairsY, series, name: name2, item = () => ({}), facet = false } = options, rest = __rest80(options, ["shared", "crosshairs", "crosshairsX", "crosshairsY", "series", "name", "item", "facet"]);
  return (target, viewInstances, emitter) => {
    const { container, view } = target;
    const { scale: scale12, markState, coordinate, theme } = view;
    const defaultSeries = interactionKeyof(markState, "seriesTooltip");
    const defaultShowCrosshairs = interactionKeyof(markState, "crosshairs");
    const plotArea = selectPlotArea(container);
    const isSeries = maybeValue(series, defaultSeries);
    const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);
    if (isSeries && hasSeries(markState) && !facet) {
      return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {
        theme,
        elements: selectG2Elements,
        scale: scale12,
        coordinate,
        crosshairs: crosshairsSetting,
        // the crosshairsX settings level: crosshairsX > crosshairs > false
        // it means crosshairsX default is false
        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
        // crosshairsY default depend on the crossharisSettings
        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
        item,
        emitter
      }));
    }
    if (isSeries && facet) {
      const facetInstances = viewInstances.filter((d4) => d4 !== target && d4.options.parentKey === target.options.key);
      const elements = selectFacetG2Elements(target, viewInstances);
      const scale13 = facetInstances[0].view.scale;
      const bbox = plotArea.getBounds();
      const startX = bbox.min[0];
      const startY = bbox.min[1];
      Object.assign(scale13, { facet: true });
      return seriesTooltip(plotArea.parentNode.parentNode, Object.assign(Object.assign({}, rest), {
        theme,
        elements: () => elements,
        scale: scale13,
        coordinate,
        crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
        // the crosshairsX settings level: crosshairsX > crosshairs > false
        // it means crosshairsX default is false
        crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
        crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
        item,
        startX,
        startY,
        emitter
      }));
    }
    return tooltip(plotArea, Object.assign(Object.assign({}, rest), {
      datum: createDatumof(view),
      elements: selectG2Elements,
      scale: scale12,
      coordinate,
      groupKey: shared ? createXKey(view) : void 0,
      item,
      emitter,
      view,
      theme,
      shared
    }));
  };
}
Tooltip2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/legendFilter.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CATEGORY_LEGEND_CLASS_NAME = "legend-category";
var CONTINUOUS_LEGEND_CLASS_NAME = "legend-continuous";
var LEGEND_ITEMS_CLASS_NAME = "items-item";
var LEGEND_MAKER_CLASS_NAME = "legend-category-item-marker";
var LEGEND_LABEL_CLASS_NAME = "legend-category-item-label";
function markerOf(item) {
  return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
}
function labelOf(item) {
  return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
}
function itemsOf(root2) {
  return root2.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
}
function legendsOf(root2) {
  return root2.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
}
function legendsContinuousOf(root2) {
  return root2.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
}
function legendClearSetState(root2, setState) {
  const legends = [...legendsOf(root2), ...legendsContinuousOf(root2)];
  legends.forEach((legend) => {
    setState(legend, (v) => v);
  });
}
function dataOf2(root2) {
  let parent = root2.parentNode;
  while (parent && !parent.__data__) {
    parent = parent.parentNode;
  }
  return parent.__data__;
}
function legendFilterOrdinal(root2, {
  legends,
  // given the root of chart returns legends to be manipulated
  marker: markerOf2,
  // given the legend returns the marker
  label: labelOf2,
  // given the legend returns the label
  datum,
  // given the legend returns the value
  filter: filter3,
  // invoke when dispatch filter event,
  emitter,
  channel,
  state = {}
  // state options
}) {
  const itemClick = /* @__PURE__ */ new Map();
  const itemPointerenter = /* @__PURE__ */ new Map();
  const itemPointerout = /* @__PURE__ */ new Map();
  const { unselected = {
    markerStroke: "#aaa",
    markerFill: "#aaa",
    labelFill: "#aaa"
  } } = state;
  const markerStyle = { unselected: subObject(unselected, "marker") };
  const labelStyle = { unselected: subObject(unselected, "label") };
  const { setState: setM, removeState: removeM } = useState(markerStyle, void 0);
  const { setState: setL, removeState: removeL } = useState(labelStyle, void 0);
  const items = Array.from(legends(root2));
  let selectedValues = items.map(datum);
  const updateLegendState = () => {
    for (const item of items) {
      const value2 = datum(item);
      const marker = markerOf2(item);
      const label = labelOf2(item);
      if (!selectedValues.includes(value2)) {
        setM(marker, "unselected");
        setL(label, "unselected");
      } else {
        removeM(marker, "unselected");
        removeL(label, "unselected");
      }
    }
  };
  for (const item of items) {
    const pointerenter = () => {
      setCursor(root2, "pointer");
    };
    const pointerout = () => {
      restoreCursor(root2);
    };
    const click = (event) => __awaiter7(this, void 0, void 0, function* () {
      const value2 = datum(item);
      const index3 = selectedValues.indexOf(value2);
      if (index3 === -1)
        selectedValues.push(value2);
      else
        selectedValues.splice(index3, 1);
      yield filter3(selectedValues);
      updateLegendState();
      const { nativeEvent = true } = event;
      if (!nativeEvent)
        return;
      if (selectedValues.length === items.length) {
        emitter.emit("legend:reset", { nativeEvent });
      } else {
        emitter.emit("legend:filter", Object.assign(Object.assign({}, event), { nativeEvent, data: {
          channel,
          values: selectedValues
        } }));
      }
    });
    item.addEventListener("click", click);
    item.addEventListener("pointerenter", pointerenter);
    item.addEventListener("pointerout", pointerout);
    itemClick.set(item, click);
    itemPointerenter.set(item, pointerenter);
    itemPointerout.set(item, pointerout);
  }
  const onFilter = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { data: data2 } = event;
    const { channel: specifiedChannel, values: values4 } = data2;
    if (specifiedChannel !== channel)
      return;
    selectedValues = values4;
    yield filter3(selectedValues);
    updateLegendState();
  });
  const onEnd = (event) => __awaiter7(this, void 0, void 0, function* () {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    selectedValues = items.map(datum);
    yield filter3(selectedValues);
    updateLegendState();
  });
  emitter.on("legend:filter", onFilter);
  emitter.on("legend:reset", onEnd);
  return () => {
    for (const item of items) {
      item.removeEventListener("click", itemClick.get(item));
      item.removeEventListener("pointerenter", itemPointerenter.get(item));
      item.removeEventListener("pointerout", itemPointerout.get(item));
      emitter.off("legend:filter", onFilter);
      emitter.off("legend:reset", onEnd);
    }
  };
}
function legendFilterContinuous(_2, { legend, filter: filter3, emitter, channel }) {
  const onValueChange = ({ detail: { value: value2 } }) => {
    filter3(value2);
    emitter.emit({
      nativeEvent: true,
      data: {
        channel,
        values: value2
      }
    });
  };
  legend.addEventListener("valuechange", onValueChange);
  return () => {
    legend.removeEventListener("valuechange", onValueChange);
  };
}
function filterView(context, {
  legend,
  // Legend instance.
  channel,
  // Filter Channel.
  value: value2,
  // Filtered Values.
  ordinal,
  // Data type of the legend.
  channels,
  // Channels for this legend.
  allChannels,
  // Channels for all legends.
  facet = false
  // For facet.
}) {
  return __awaiter7(this, void 0, void 0, function* () {
    const { view, update: update2, setState } = context;
    setState(legend, (viewOptions) => {
      const { marks } = viewOptions;
      const newMarks = marks.map((mark2) => {
        if (mark2.type === "legends")
          return mark2;
        const { transform: transform2 = [], data: data2 = [] } = mark2;
        const index3 = transform2.findIndex(({ type }) => type.startsWith("group") || type.startsWith("bin"));
        const newTransform = [...transform2];
        if (data2.length) {
          newTransform.splice(index3 + 1, 0, {
            type: "filter",
            [channel]: { value: value2, ordinal }
          });
        }
        const newScale = Object.fromEntries(channels.map((channel2) => [
          channel2,
          { domain: view.scale[channel2].getOptions().domain }
        ]));
        return deep_mix_default({}, mark2, Object.assign(Object.assign({ transform: newTransform, scale: newScale }, !ordinal && { animate: false }), { legend: facet ? false : Object.fromEntries(allChannels.map((d4) => [d4, { preserve: true }])) }));
      });
      return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
    });
    yield update2();
  });
}
function filterFacets(facets, options) {
  for (const facet of facets) {
    filterView(facet, Object.assign(Object.assign({}, options), { facet: true }));
  }
}
function LegendFilter() {
  return (context, contexts, emitter) => {
    const { container } = context;
    const facets = contexts.filter((d4) => d4 !== context);
    const isFacet = facets.length > 0;
    const channelsOf = (legend) => {
      return dataOf2(legend).scales.map((d4) => d4.name);
    };
    const legends = [
      ...legendsOf(container),
      ...legendsContinuousOf(container)
    ];
    const allChannels = legends.flatMap(channelsOf);
    const filter3 = isFacet ? throttle_default(filterFacets, 50, { trailing: true }) : throttle_default(filterView, 50, { trailing: true });
    const removes = legends.map((legend) => {
      const { name: channel, domain } = dataOf2(legend).scales[0];
      const channels = channelsOf(legend);
      const common = {
        legend,
        channel,
        channels,
        allChannels
      };
      if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
        return legendFilterOrdinal(container, {
          legends: itemsOf,
          marker: markerOf,
          label: labelOf,
          datum: (d4) => {
            const { __data__: datum } = d4;
            const { index: index3 } = datum;
            return domain[index3];
          },
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: true });
            if (isFacet)
              filter3(facets, options);
            else
              filter3(context, options);
          },
          state: legend.attributes.state,
          channel,
          emitter
        });
      } else {
        return legendFilterContinuous(container, {
          legend,
          filter: (value2) => {
            const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: false });
            if (isFacet)
              filter3(facets, options);
            else
              filter3(context, options);
          },
          emitter,
          channel
        });
      }
    });
    return () => {
      removes.forEach((remove2) => remove2());
    };
  };
}

// node_modules/@antv/g2/esm/interaction/legendHighlight.js
function LegendHighlight() {
  return (context, _2, emitter) => {
    const { container, view, options } = context;
    const legends = legendsOf(container);
    const elements = selectG2Elements(container);
    const channelOf = (legend) => {
      return dataOf2(legend).scales[0].name;
    };
    const scaleOf2 = (channel) => {
      const { scale: { [channel]: scale12 } } = view;
      return scale12;
    };
    const markState = mergeState(options, ["active", "inactive"]);
    const valueof2 = createValueof(elements, createDatumof(view));
    const destroys = [];
    for (const legend of legends) {
      const datumOf = (item) => {
        const { data: data2 } = legend.attributes;
        const { __data__: datum } = item;
        const { index: index3 } = datum;
        return data2[index3].label;
      };
      const channel = channelOf(legend);
      const items = itemsOf(legend);
      const scale12 = scaleOf2(channel);
      const elementGroup = group(elements, (d4) => scale12.invert(d4.__data__[channel]));
      const { state: legendState = {} } = legend.attributes;
      const { inactive = {} } = legendState;
      const { setState, removeState } = useState(markState, valueof2);
      const markerStyle = { inactive: subObject(inactive, "marker") };
      const labelStyle = { inactive: subObject(inactive, "label") };
      const { setState: setM, removeState: removeM } = useState(markerStyle);
      const { setState: setL, removeState: removeL } = useState(labelStyle);
      const updateLegendState = (highlight) => {
        for (const item of items) {
          const marker = markerOf(item);
          const label = labelOf(item);
          if (item === highlight || highlight === null) {
            removeM(marker, "inactive");
            removeL(label, "inactive");
          } else {
            setM(marker, "inactive");
            setL(label, "inactive");
          }
        }
      };
      const highlightItem = (event, item) => {
        const value2 = datumOf(item);
        const elementSet = new Set(elementGroup.get(value2));
        for (const e3 of elements) {
          if (elementSet.has(e3))
            setState(e3, "active");
          else
            setState(e3, "inactive");
        }
        updateLegendState(item);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:highlight", Object.assign(Object.assign({}, event), { nativeEvent, data: { channel, value: value2 } }));
      };
      const itemPointerover = /* @__PURE__ */ new Map();
      for (const item of items) {
        const pointerover = (event) => {
          highlightItem(event, item);
        };
        item.addEventListener("pointerover", pointerover);
        itemPointerover.set(item, pointerover);
      }
      const pointerleave = (event) => {
        for (const e3 of elements)
          removeState(e3, "inactive", "active");
        updateLegendState(null);
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        emitter.emit("legend:unhighlight", { nativeEvent });
      };
      const onHighlight = (event) => {
        const { nativeEvent, data: data2 } = event;
        if (nativeEvent)
          return;
        const { channel: specifiedChannel, value: value2 } = data2;
        if (specifiedChannel !== channel)
          return;
        const item = items.find((d4) => datumOf(d4) === value2);
        if (!item)
          return;
        highlightItem({ nativeEvent: false }, item);
      };
      const onUnHighlight = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        pointerleave({ nativeEvent: false });
      };
      legend.addEventListener("pointerleave", pointerleave);
      emitter.on("legend:highlight", onHighlight);
      emitter.on("legend:unhighlight", onUnHighlight);
      const destroy2 = () => {
        legend.removeEventListener(pointerleave);
        emitter.off("legend:highlight", onHighlight);
        emitter.off("legend:unhighlight", onUnHighlight);
        for (const [item, pointerover] of itemPointerover) {
          item.removeEventListener(pointerover);
        }
      };
      destroys.push(destroy2);
    }
    return () => destroys.forEach((d4) => d4());
  };
}

// node_modules/@antv/g2/esm/interaction/brushHighlight.js
var __rest81 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function intersect3(bbox1, bbox2) {
  const [minX1, minY1, maxX1, maxY1] = bbox1;
  const [minX2, minY2, maxX2, maxY2] = bbox2;
  return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
}
function normalizeBounds(x3, y4, x12, y12, extent2) {
  const [minX, minY, maxX, maxY2] = extent2;
  return [
    Math.max(minX, Math.min(x3, x12)),
    Math.max(minY, Math.min(y4, y12)),
    Math.min(maxX, Math.max(x3, x12)),
    Math.min(maxY2, Math.max(y4, y12))
  ];
}
function bboxOf2(root2) {
  const { width, height } = root2.getBBox();
  return [0, 0, width, height];
}
function applyStyle3(selection, style) {
  for (const [key, value2] of Object.entries(style)) {
    selection.style(key, value2);
  }
}
var ResizableMask = createElement((g) => {
  const _a2 = g.attributes, { x: x3, y: y4, width, height, class: className2, renders = {}, handleSize: size3 = 10, document: document2 } = _a2, style = __rest81(_a2, ["x", "y", "width", "height", "class", "renders", "handleSize", "document"]);
  if (!document2 || width === void 0 || height === void 0 || x3 === void 0 || y4 === void 0)
    return;
  const half = size3 / 2;
  const renderRect = (g2, options, document3) => {
    if (!g2.handle) {
      g2.handle = document3.createElement("rect");
      g2.append(g2.handle);
    }
    const { handle } = g2;
    handle.attr(options);
    return handle;
  };
  const _b = subObject(omitPrefixObject(style, "handleNW", "handleNE"), "handleN"), { render: handleNRender = renderRect } = _b, handleNStyle = __rest81(_b, ["render"]);
  const _c = subObject(style, "handleE"), { render: handleERender = renderRect } = _c, handleEStyle = __rest81(_c, ["render"]);
  const _d = subObject(omitPrefixObject(style, "handleSE", "handleSW"), "handleS"), { render: handleSRender = renderRect } = _d, handleSStyle = __rest81(_d, ["render"]);
  const _e = subObject(style, "handleW"), { render: handleWRender = renderRect } = _e, handleWStyle = __rest81(_e, ["render"]);
  const _f = subObject(style, "handleNW"), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest81(_f, ["render"]);
  const _g = subObject(style, "handleNE"), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest81(_g, ["render"]);
  const _h = subObject(style, "handleSE"), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest81(_h, ["render"]);
  const _j = subObject(style, "handleSW"), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest81(_j, ["render"]);
  const renderHandle = (g2, renderNode) => {
    const { id: id4 } = g2;
    const handle = renderNode(g2, g2.attributes, document2);
    handle.id = id4;
    handle.style.draggable = true;
  };
  const appendHandle = (handleRender) => {
    return () => {
      const Node5 = createElement((g2) => renderHandle(g2, handleRender));
      return new Node5({});
    };
  };
  const container = select(g).attr("className", className2).style("transform", `translate(${x3}, ${y4})`).style("draggable", true);
  container.maybeAppend("selection", "rect").style("draggable", true).style("fill", "transparent").call(applyStyle3, Object.assign(Object.assign({
    width,
    height
  }, omitPrefixObject(style, "handle")), { transform: void 0 }));
  container.maybeAppend("handle-n", appendHandle(handleNRender)).style("x", half).style("y", -half).style("width", width - size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNStyle);
  container.maybeAppend("handle-e", appendHandle(handleERender)).style("x", width - half).style("y", half).style("width", size3).style("height", height - size3).style("fill", "transparent").call(applyStyle3, handleEStyle);
  container.maybeAppend("handle-s", appendHandle(handleSRender)).style("x", half).style("y", height - half).style("width", width - size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSStyle);
  container.maybeAppend("handle-w", appendHandle(handleWRender)).style("x", -half).style("y", half).style("width", size3).style("height", height - size3).style("fill", "transparent").call(applyStyle3, handleWStyle);
  container.maybeAppend("handle-nw", appendHandle(handleNWRender)).style("x", -half).style("y", -half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNWStyle);
  container.maybeAppend("handle-ne", appendHandle(handleNERender)).style("x", width - half).style("y", -half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleNEStyle);
  container.maybeAppend("handle-se", appendHandle(handleSERender)).style("x", width - half).style("y", height - half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSEStyle);
  container.maybeAppend("handle-sw", appendHandle(handleSWRender)).style("x", -half).style("y", height - half).style("width", size3).style("height", size3).style("fill", "transparent").call(applyStyle3, handleSWStyle);
});
function brush(root2, _a2) {
  var { brushed = () => {
  }, brushended = () => {
  }, brushcreated = () => {
  }, brushstarted = () => {
  }, brushupdated = () => {
  }, extent: extent2 = bboxOf2(root2), brushRegion = (x3, y4, x12, y12, extent3) => [x3, y4, x12, y12], reverse: reverse2 = false, fill = "#777", fillOpacity = "0.3", stroke: stroke2 = "#fff", selectedHandles = [
    "handle-n",
    "handle-e",
    "handle-s",
    "handle-w",
    "handle-nw",
    "handle-ne",
    "handle-se",
    "handle-sw"
  ] } = _a2, style = __rest81(_a2, ["brushed", "brushended", "brushcreated", "brushstarted", "brushupdated", "extent", "brushRegion", "reverse", "fill", "fillOpacity", "stroke", "selectedHandles"]);
  let start = null;
  let end = null;
  let moveStart = null;
  let mask = null;
  let background = null;
  let creating = false;
  const [originX, originY, width, height] = extent2;
  setCursor(root2, "crosshair");
  root2.style.draggable = true;
  const initMask = (x3, y4, event) => {
    brushstarted(event);
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = [x3, y4];
    if (reverse2)
      return initReverseMask();
    initNormalMask();
  };
  const initReverseMask = () => {
    background = new Path2({
      style: Object.assign(Object.assign({}, style), {
        fill,
        fillOpacity,
        stroke: stroke2,
        pointerEvents: "none"
      })
    });
    mask = new ResizableMask({
      // @ts-ignore
      style: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        draggable: true,
        document: root2.ownerDocument
      },
      className: "mask"
    });
    root2.appendChild(background);
    root2.appendChild(mask);
  };
  const initNormalMask = () => {
    mask = new ResizableMask({
      // @ts-ignore
      style: Object.assign(Object.assign({ document: root2.ownerDocument, x: 0, y: 0 }, style), {
        fill,
        fillOpacity,
        stroke: stroke2,
        draggable: true
      }),
      className: "mask"
    });
    root2.appendChild(mask);
  };
  const removeMask = (emit = true) => {
    if (mask)
      mask.remove();
    if (background)
      background.remove();
    start = null;
    end = null;
    moveStart = null;
    creating = false;
    mask = null;
    background = null;
    brushended(emit);
  };
  const updateMask = (start2, end2, emit = true) => {
    const [x3, y4, x12, y12] = normalizeBounds(start2[0], start2[1], end2[0], end2[1], extent2);
    const [fx, fy, fx1, fy1] = brushRegion(x3, y4, x12, y12, extent2);
    if (reverse2)
      updateReverseMask(fx, fy, fx1, fy1);
    else
      updateNormalMask(fx, fy, fx1, fy1);
    brushed(fx, fy, fx1, fy1, emit);
    return [fx, fy, fx1, fy1];
  };
  const updateNormalMask = (x3, y4, x12, y12) => {
    mask.style.x = x3;
    mask.style.y = y4;
    mask.style.width = x12 - x3;
    mask.style.height = y12 - y4;
  };
  const updateReverseMask = (x3, y4, x12, y12) => {
    background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x3},${y4}L${x3},${y12}L${x12},${y12}L${x12},${y4}Z
    `;
    mask.style.x = x3;
    mask.style.y = y4;
    mask.style.width = x12 - x3;
    mask.style.height = y12 - y4;
  };
  const moveMask = (current) => {
    const clip = (dt, start2, end2, min10, max11) => {
      if (dt + start2 < min10)
        return min10 - start2;
      if (dt + end2 > max11)
        return max11 - end2;
      return dt;
    };
    const dx = current[0] - moveStart[0];
    const dy = current[1] - moveStart[1];
    const dx1 = clip(dx, start[0], end[0], originX, width);
    const dy1 = clip(dy, start[1], end[1], originY, height);
    const currentStart = [start[0] + dx1, start[1] + dy1];
    const currentEnd = [end[0] + dx1, end[1] + dy1];
    updateMask(currentStart, currentEnd);
  };
  const handles = {
    "handle-n": { vector: [0, 1, 0, 0], cursor: "ns-resize" },
    "handle-e": { vector: [0, 0, 1, 0], cursor: "ew-resize" },
    "handle-s": { vector: [0, 0, 0, 1], cursor: "ns-resize" },
    "handle-w": { vector: [1, 0, 0, 0], cursor: "ew-resize" },
    "handle-nw": { vector: [1, 1, 0, 0], cursor: "nwse-resize" },
    "handle-ne": { vector: [0, 1, 1, 0], cursor: "nesw-resize" },
    "handle-se": { vector: [0, 0, 1, 1], cursor: "nwse-resize" },
    "handle-sw": { vector: [1, 0, 0, 1], cursor: "nesw-resize" }
  };
  const isMask = (target) => {
    return isSelection(target) || isHandle(target);
  };
  const isHandle = (target) => {
    const { id: id4 } = target;
    if (selectedHandles.indexOf(id4) === -1)
      return false;
    return new Set(Object.keys(handles)).has(id4);
  };
  const isSelection = (target) => {
    return target === mask.getElementById("selection");
  };
  const dragstart = (event) => {
    const { target } = event;
    const [offsetX, offsetY] = brushMousePosition(root2, event);
    if (!mask || !isMask(target)) {
      initMask(offsetX, offsetY, event);
      creating = true;
      return;
    }
    if (isMask(target)) {
      moveStart = [offsetX, offsetY];
    }
  };
  const drag = (event) => {
    const { target } = event;
    const mouse = brushMousePosition(root2, event);
    if (!start)
      return;
    if (!moveStart)
      return updateMask(start, mouse);
    if (isSelection(target))
      return moveMask(mouse);
    const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];
    const { id: id4 } = target;
    if (handles[id4]) {
      const [sx, sy, ex, ey] = handles[id4].vector;
      return updateMask([start[0] + dx * sx, start[1] + dy * sy], [end[0] + dx * ex, end[1] + dy * ey]);
    }
  };
  const dragend = (event) => {
    if (moveStart) {
      moveStart = null;
      const { x: x3, y: y4, width: width2, height: height2 } = mask.style;
      start = [x3, y4];
      end = [x3 + width2, y4 + height2];
      brushupdated(x3, y4, x3 + width2, y4 + height2, event);
      return;
    }
    end = brushMousePosition(root2, event);
    const [fx, fy, fx1, fy1] = updateMask(start, end);
    creating = false;
    brushcreated(fx, fy, fx1, fy1, event);
  };
  const click = (event) => {
    const { target } = event;
    if (mask && !isMask(target))
      removeMask();
  };
  const pointermove = (event) => {
    const { target } = event;
    if (!mask || !isMask(target) || creating)
      setCursor(root2, "crosshair");
    else if (isSelection(target))
      setCursor(root2, "move");
    else if (isHandle(target))
      setCursor(root2, handles[target.id].cursor);
  };
  const pointerleave = () => {
    setCursor(root2, "default");
  };
  root2.addEventListener("dragstart", dragstart);
  root2.addEventListener("drag", drag);
  root2.addEventListener("dragend", dragend);
  root2.addEventListener("click", click);
  root2.addEventListener("pointermove", pointermove);
  root2.addEventListener("pointerleave", pointerleave);
  return {
    mask,
    move(x3, y4, x12, y12, emit = true) {
      if (!mask)
        initMask(x3, y4, {});
      start = [x3, y4];
      end = [x12, y12];
      updateMask([x3, y4], [x12, y12], emit);
    },
    remove(emit = true) {
      if (mask)
        removeMask(emit);
    },
    destroy() {
      if (mask)
        removeMask(false);
      setCursor(root2, "default");
      root2.removeEventListener("dragstart", dragstart);
      root2.removeEventListener("drag", drag);
      root2.removeEventListener("dragend", dragend);
      root2.removeEventListener("click", click);
      root2.removeEventListener("pointermove", pointermove);
      root2.removeEventListener("pointerleave", pointerleave);
    }
  };
}
function selectSiblingViews(target, viewInstances, brushKey) {
  return viewInstances.filter((d4) => {
    if (d4 === target)
      return false;
    const { interaction = {} } = d4.options;
    return Object.values(interaction).find((d5) => d5.brushKey === brushKey);
  });
}
function selectSiblingContainers(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d4) => selectPlotArea(d4.container));
}
function selectSiblingOptions(target, viewInstances, brushKey) {
  return selectSiblingViews(target, viewInstances, brushKey).map((d4) => d4.options);
}
function brushHighlight(root2, _a2) {
  var { elements: elementof, selectedHandles, siblings: siblingsof = (root3) => [], datum, brushRegion, extent: optionalExtent, reverse: reverse2, scale: scale12, coordinate, series = false, key = (d4) => d4, bboxOf: bboxOf3 = (root3) => {
    const { x: x3, y: y4, width, height } = root3.style;
    return { x: x3, y: y4, width, height };
  }, state = {}, emitter } = _a2, rest = __rest81(_a2, ["elements", "selectedHandles", "siblings", "datum", "brushRegion", "extent", "reverse", "scale", "coordinate", "series", "key", "bboxOf", "state", "emitter"]);
  const elements = elementof(root2);
  const siblings = siblingsof(root2);
  const siblingElements = siblings.flatMap(elementof);
  const valueof2 = createValueof(elements, datum);
  const brushStyle = subObject(rest, "mask");
  const { setState, removeState } = useState(state, valueof2);
  const clonedElement = /* @__PURE__ */ new Map();
  const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf3(root2);
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const brushended = () => {
    for (const element of [...elements, ...siblingElements]) {
      removeState(element, "active", "inactive");
    }
  };
  const brushed = (x3, y4, x12, y12) => {
    var _a3;
    for (const sibling of siblings)
      (_a3 = sibling.brush) === null || _a3 === void 0 ? void 0 : _a3.remove();
    const keys2 = /* @__PURE__ */ new Set();
    for (const element of elements) {
      const { min: min10, max: max11 } = element.getLocalBounds();
      const [ex, ey] = min10;
      const [ex1, ey1] = max11;
      if (!intersect3([ex, ey, ex1, ey1], [x3, y4, x12, y12])) {
        setState(element, "inactive");
      } else {
        setState(element, "active");
        keys2.add(key(element));
      }
    }
    for (const element of siblingElements) {
      if (keys2.has(key(element)))
        setState(element, "active");
      else
        setState(element, "inactive");
    }
  };
  const seriesBrushend = () => {
    for (const element of elements)
      removeState(element, "inactive");
    for (const cloned of clonedElement.values())
      cloned.remove();
    clonedElement.clear();
  };
  const seriesBrushed = (x3, y4, x12, y12) => {
    const clone8 = (element) => {
      const cloned = element.cloneNode();
      cloned.__data__ = element.__data__;
      element.parentNode.appendChild(cloned);
      clonedElement.set(element, cloned);
      return cloned;
    };
    const clipPath = new Rect({
      style: {
        x: x3 + ordinalX,
        y: y4 + ordinalY,
        width: x12 - x3,
        height: y12 - y4
      }
    });
    root2.appendChild(clipPath);
    for (const element of elements) {
      const cloned = clonedElement.get(element) || clone8(element);
      cloned.style.clipPath = clipPath;
      setState(element, "inactive");
      setState(cloned, "active");
    }
  };
  const brushHandler = brush(root2, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse2,
    selectedHandles,
    brushended: (emit) => {
      const handler = series ? seriesBrushend : brushended;
      if (emit) {
        emitter.emit("brush:remove", { nativeEvent: true });
      }
      handler();
    },
    brushed: (x3, y4, x12, y12, emit) => {
      const selection = selectionOf(x3, y4, x12, y12, scale12, coordinate);
      if (emit) {
        emitter.emit("brush:highlight", {
          nativeEvent: true,
          data: { selection }
        });
      }
      const handler = series ? seriesBrushed : brushed;
      handler(x3, y4, x12, y12);
    },
    brushcreated: (x3, y4, x12, y12, event) => {
      const selection = selectionOf(x3, y4, x12, y12, scale12, coordinate);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushupdated: (x3, y4, x12, y12, event) => {
      const selection = selectionOf(x3, y4, x12, y12, scale12, coordinate);
      emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
    },
    brushstarted: (e3) => {
      emitter.emit("brush:start", e3);
    }
  }));
  const onHighlight = ({ nativeEvent, data: data2 }) => {
    if (nativeEvent)
      return;
    const { selection } = data2;
    const [x3, y4, x12, y12] = pixelsOf(selection, scale12, coordinate);
    brushHandler.move(x3, y4, x12, y12, false);
  };
  emitter.on("brush:highlight", onHighlight);
  const onRemove = ({ nativeEvent } = {}) => {
    if (nativeEvent)
      return;
    brushHandler.remove(false);
  };
  emitter.on("brush:remove", onRemove);
  const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
  brushHandler.destroy = () => {
    emitter.off("brush:highlight", onHighlight);
    emitter.off("brush:remove", onRemove);
    preBrushDestroy();
  };
  return brushHandler;
}
function BrushHighlight(_a2) {
  var { facet, brushKey } = _a2, rest = __rest81(_a2, ["facet", "brushKey"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      reverse: false
    };
    const defaultStates = ["active", ["inactive", { opacity: 0.5 }]];
    const { scale: scale12, coordinate } = view;
    if (facet) {
      const bbox = plotArea.getBounds();
      const x3 = bbox.min[0];
      const y4 = bbox.min[1];
      const x12 = bbox.max[0];
      const y12 = bbox.max[1];
      return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
        elements: () => selectFacetG2Elements(target, viewInstances),
        datum: createDatumof(selectFacetViews(target, viewInstances).map((d4) => d4.view)),
        brushRegion: (x4, y5, x13, y13) => [x4, y5, x13, y13],
        extent: [x3, y4, x12, y12],
        state: mergeState(selectFacetViews(target, viewInstances).map((d4) => d4.options), defaultStates),
        emitter,
        scale: scale12,
        coordinate,
        selectedHandles: void 0
      }, defaultOptions), rest));
    }
    const brush2 = brushHighlight(plotArea, Object.assign(Object.assign({
      elements: selectG2Elements,
      key: (element) => element.__data__.key,
      siblings: () => selectSiblingContainers(target, viewInstances, brushKey),
      datum: createDatumof([
        view,
        ...selectSiblingViews(target, viewInstances, brushKey).map((d4) => d4.view)
      ]),
      brushRegion: (x3, y4, x12, y12) => [x3, y4, x12, y12],
      extent: void 0,
      state: mergeState([options, ...selectSiblingOptions(target, viewInstances, brushKey)], defaultStates),
      emitter,
      scale: scale12,
      coordinate,
      selectedHandles: void 0
    }, defaultOptions), rest));
    plotArea.brush = brush2;
    return () => brush2.destroy();
  };
}

// node_modules/@antv/g2/esm/interaction/brushXHighlight.js
function brushXRegion(x3, y4, x12, y12, extent2) {
  const [, minY, , maxY2] = extent2;
  return [x3, minY, x12, maxY2];
}
function BrushXHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushXRegion, selectedHandles: ["handle-e", "handle-w"] }));
}

// node_modules/@antv/g2/esm/interaction/brushYHighlight.js
function brushYRegion(x3, y4, x12, y12, extent2) {
  const [minX, , maxX] = extent2;
  return [minX, y4, maxX, y12];
}
function BrushYHighlight(options) {
  return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushYRegion, selectedHandles: ["handle-n", "handle-s"] }));
}

// node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js
var __rest82 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var AXIS_CLASS_NAME = "axis";
var AXIS_LINE_CLASS_NAME = "axis-line";
var AXIS_MAIN_CLASS_NAME = "axis-main-group";
var AXIS_HOT_AREA_CLASS_NAME = "axis-hot-area";
function axesOf(container) {
  return container.getElementsByClassName(AXIS_CLASS_NAME);
}
function lineOf(axis) {
  return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
}
function mainGroupOf(axis) {
  return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
}
function boundsOfAxis(axis) {
  return mainGroupOf(axis).getLocalBounds();
}
function verticalBrush(axis, _a2) {
  var { cross: cross7, offsetX, offsetY } = _a2, style = __rest82(_a2, ["cross", "offsetX", "offsetY"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [lineX] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size3 = (maxX - minX) * 2;
  return {
    brushRegion: brushYRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        width: cross7 ? size3 / 2 : size3,
        transform: `translate(${(cross7 ? minX : lineX - size3 / 2).toFixed(2)}, ${minY})`,
        height: maxY2 - minY
      }, style)
    }),
    extent: cross7 ? (
      // If it is cross, the x range is ignored.
      (x3, y4, x12, y12) => [-Infinity, y4, Infinity, y12]
    ) : (x3, y4, x12, y12) => [
      Math.floor(minX - offsetX),
      y4,
      Math.ceil(maxX - offsetX),
      y12
    ]
  };
}
function horizontalBrush(axis, _a2) {
  var { offsetY, offsetX, cross: cross7 = false } = _a2, style = __rest82(_a2, ["offsetY", "offsetX", "cross"]);
  const bounds = boundsOfAxis(axis);
  const axisLine = lineOf(axis);
  const [, lineY] = axisLine.getLocalBounds().min;
  const [minX, minY] = bounds.min;
  const [maxX, maxY2] = bounds.max;
  const size3 = maxY2 - minY;
  return {
    brushRegion: brushXRegion,
    hotZone: new Rect({
      className: AXIS_HOT_AREA_CLASS_NAME,
      style: Object.assign({
        width: maxX - minX,
        // If it is not cross, draw brush in both side of axisLine,
        // otherwise the draw brush within bounds area.
        height: cross7 ? size3 : size3 * 2,
        transform: `translate(${minX}, ${cross7 ? minY : lineY - size3})`
      }, style)
    }),
    extent: cross7 ? (
      // If it is cross, the y range is ignored.
      (x3, y4, x12, y12) => [x3, -Infinity, x12, Infinity]
    ) : (x3, y4, x12, y12) => [
      x3,
      Math.floor(minY - offsetY),
      x12,
      Math.ceil(maxY2 - offsetY)
    ]
  };
}
function brushAxisHighlight(root2, _a2) {
  var {
    axes: axesOf2,
    // given root, return axes
    elements: elementsOf,
    // given root, return elements
    points: pointsOf,
    // given shape, return control points
    horizontal: isHorizontal3,
    // given axis, return direction
    datum,
    // given shape, return datum
    offsetY,
    // offsetY for shape area
    offsetX,
    // offsetX for shape area
    reverse: reverse2 = false,
    state = {},
    emitter,
    coordinate
  } = _a2, rest = __rest82(_a2, ["axes", "elements", "points", "horizontal", "datum", "offsetY", "offsetX", "reverse", "state", "emitter", "coordinate"]);
  const elements = elementsOf(root2);
  const axes = axesOf2(root2);
  const valueof2 = createValueof(elements, datum);
  const { setState, removeState } = useState(state, valueof2);
  const axisExtent = /* @__PURE__ */ new Map();
  const brushStyle = subObject(rest, "mask");
  const brushed = (points) => Array.from(axisExtent.values()).every(([x3, y4, x12, y12]) => points.some(([x05, y05]) => {
    return x05 >= x3 && x05 <= x12 && y05 >= y4 && y05 <= y12;
  }));
  const scales = axes.map((d4) => d4.attributes.scale);
  const extentOf2 = (D2) => D2.length > 2 ? [D2[0], D2[D2.length - 1]] : D2;
  const indexDomain = /* @__PURE__ */ new Map();
  const initIndexDomain = () => {
    indexDomain.clear();
    for (let i2 = 0; i2 < axes.length; i2++) {
      const scale12 = scales[i2];
      const { domain } = scale12.getOptions();
      indexDomain.set(i2, extentOf2(domain));
    }
  };
  initIndexDomain();
  const updateElement = (i2, emit) => {
    const selectedElements = [];
    for (const element of elements) {
      const points = pointsOf(element);
      if (brushed(points)) {
        setState(element, "active");
        selectedElements.push(element);
      } else
        setState(element, "inactive");
    }
    indexDomain.set(i2, selectionOf2(selectedElements, i2));
    if (!emit)
      return;
    const selection = () => {
      if (!cross7)
        return Array.from(indexDomain.values());
      const S = [];
      for (const [index3, domain] of indexDomain) {
        const scale12 = scales[index3];
        const { name: name2 } = scale12.getOptions();
        if (name2 === "x")
          S[0] = domain;
        else
          S[1] = domain;
      }
      return S;
    };
    emitter.emit("brushAxis:highlight", {
      nativeEvent: true,
      data: {
        selection: selection()
      }
    });
  };
  const clearElement = (emit) => {
    for (const element of elements)
      removeState(element, "active", "inactive");
    initIndexDomain();
    if (!emit)
      return;
    emitter.emit("brushAxis:remove", { nativeEvent: true });
  };
  const selectionOf2 = (selected, i2) => {
    const scale12 = scales[i2];
    const { name: name2 } = scale12.getOptions();
    const domain = selected.map((d4) => {
      const data2 = d4.__data__;
      return scale12.invert(data2[name2]);
    });
    return extentOf2(domainOf3(scale12, domain));
  };
  const cross7 = axes.some(isHorizontal3) && axes.some((d4) => !isHorizontal3(d4));
  const handlers = [];
  for (let i2 = 0; i2 < axes.length; i2++) {
    const axis = axes[i2];
    const createBrush = isHorizontal3(axis) ? horizontalBrush : verticalBrush;
    const { hotZone, brushRegion, extent: extent2 } = createBrush(axis, {
      offsetY,
      offsetX,
      cross: cross7,
      zIndex: 999,
      fill: "transparent"
      // Make it interactive.
    });
    axis.parentNode.appendChild(hotZone);
    const brushHandler = brush(hotZone, Object.assign(Object.assign({}, brushStyle), {
      reverse: reverse2,
      brushRegion,
      brushended(emit) {
        axisExtent.delete(axis);
        if (Array.from(axisExtent.entries()).length === 0)
          clearElement(emit);
        else
          updateElement(i2, emit);
      },
      brushed(x3, y4, x12, y12, emit) {
        axisExtent.set(axis, extent2(x3, y4, x12, y12));
        updateElement(i2, emit);
      }
    }));
    handlers.push(brushHandler);
  }
  const onRemove = (event = {}) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    handlers.forEach((d4) => d4.remove(false));
  };
  const rangeOf5 = (domain, scale12, axis) => {
    const [d0, d1] = domain;
    const maybeStep = (scale13) => scale13.getStep ? scale13.getStep() : 0;
    const x3 = abstractOf2(d0, scale12, axis);
    const x12 = abstractOf2(d1, scale12, axis) + maybeStep(scale12);
    if (isHorizontal3(axis))
      return [x3, -Infinity, x12, Infinity];
    return [-Infinity, x3, Infinity, x12];
  };
  const abstractOf2 = (x3, scale12, axis) => {
    const { height, width } = coordinate.getOptions();
    const scale1 = scale12.clone();
    if (isHorizontal3(axis))
      scale1.update({ range: [0, width] });
    else
      scale1.update({ range: [height, 0] });
    return scale1.map(x3);
  };
  const onHighlight = (event) => {
    const { nativeEvent } = event;
    if (nativeEvent)
      return;
    const { selection } = event.data;
    for (let i2 = 0; i2 < handlers.length; i2++) {
      const domain = selection[i2];
      const handler = handlers[i2];
      const axis = axes[i2];
      if (domain) {
        const scale12 = scales[i2];
        handler.move(...rangeOf5(domain, scale12, axis), false);
      } else {
        handler.remove(false);
      }
    }
  };
  emitter.on("brushAxis:remove", onRemove);
  emitter.on("brushAxis:highlight", onHighlight);
  return () => {
    handlers.forEach((d4) => d4.destroy());
    emitter.off("brushAxis:remove", onRemove);
    emitter.off("brushAxis:highlight", onHighlight);
  };
}
function BrushAxisHighlight(options) {
  return (target, _2, emitter) => {
    const { container, view, options: viewOptions } = target;
    const plotArea = selectPlotArea(container);
    const { x: x05, y: y05 } = plotArea.getBBox();
    const { coordinate } = view;
    return brushAxisHighlight(container, Object.assign({
      elements: selectG2Elements,
      axes: axesOf,
      offsetY: y05,
      offsetX: x05,
      points: (element) => element.__data__.points,
      horizontal: (axis) => {
        const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
        return sx !== ex && sy === ey;
      },
      datum: createDatumof(view),
      state: mergeState(viewOptions, [
        "active",
        ["inactive", { opacity: 0.5 }]
      ]),
      coordinate,
      emitter
    }, options));
  };
}

// node_modules/@antv/g2/esm/interaction/brushFilter.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest83 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function dblclick(interval2 = 300) {
  let preTimeStamp = null;
  return (e3) => {
    const { timeStamp } = e3;
    if (preTimeStamp !== null && timeStamp - preTimeStamp < interval2) {
      preTimeStamp = timeStamp;
      return true;
    }
    preTimeStamp = timeStamp;
    return false;
  };
}
function brushFilter(root2, _a2) {
  var { filter: filter3, reset, brushRegion, extent: optionalExtent, reverse: reverse2, emitter, scale: scale12, coordinate, selection, series = false } = _a2, rest = __rest83(_a2, ["filter", "reset", "brushRegion", "extent", "reverse", "emitter", "scale", "coordinate", "selection", "series"]);
  const brushStyle = subObject(rest, "mask");
  const { width: rootWidth, height: rootHeight } = root2.getBBox();
  const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
  const isDblclick = dblclick();
  const brush2 = brush(root2, Object.assign(Object.assign({}, brushStyle), {
    extent: extent2,
    brushRegion,
    reverse: reverse2,
    brushcreated
  }));
  root2.addEventListener("click", click);
  function brushcreated(x3, y4, x12, y12, event) {
    if (x3 === x12 && y4 === y12)
      return;
    event.nativeEvent = true;
    filter3(selection(x3, y4, x12, y12), event);
    brush2.remove();
  }
  function click(e3) {
    if (isDblclick(e3)) {
      e3.nativeEvent = true;
      reset(e3);
    }
  }
  const onFilter = ({ nativeEvent, data: data2 }) => {
    if (nativeEvent)
      return;
    const { selection: selection2 } = data2;
    filter3(selection2, { nativeEvent: false });
  };
  emitter.on("brush:filter", onFilter);
  return () => {
    brush2.destroy();
    emitter.off("brush:filter", onFilter);
    root2.removeEventListener("click", click);
  };
}
function BrushFilter(_a2) {
  var { hideX = true, hideY = true } = _a2, rest = __rest83(_a2, ["hideX", "hideY"]);
  return (target, viewInstances, emitter) => {
    const { container, view, options: viewOptions, update: update2, setState } = target;
    const plotArea = selectPlotArea(container);
    const defaultOptions = {
      maskFill: "#777",
      maskFillOpacity: "0.3",
      maskStroke: "#fff",
      unhighlightedOpacity: 0.5,
      reverse: false
    };
    let filtered = false;
    let filtering = false;
    let newView = view;
    const { scale: scale12, coordinate } = view;
    return brushFilter(plotArea, Object.assign(Object.assign({
      brushRegion: (x3, y4, x12, y12) => [x3, y4, x12, y12],
      selection: (x3, y4, x12, y12) => {
        const { scale: scale13, coordinate: coordinate2 } = newView;
        return selectionOf(x3, y4, x12, y12, scale13, coordinate2);
      },
      filter: (selection, event) => __awaiter8(this, void 0, void 0, function* () {
        if (filtering)
          return;
        filtering = true;
        const [domainX, domainY] = selection;
        setState("brushFilter", (options) => {
          const { marks } = options;
          const newMarks = marks.map((mark2) => deep_mix_default({
            // Hide label to keep smooth transition.
            axis: Object.assign(Object.assign({}, hideX && { x: { transform: [{ type: "hide" }] } }), hideY && { y: { transform: [{ type: "hide" }] } })
          }, mark2, {
            // Set nice to false to avoid modify domain.
            scale: {
              x: { domain: domainX, nice: false },
              y: { domain: domainY, nice: false }
            }
          }));
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks, clip: true });
        });
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        const newState = yield update2();
        newView = newState.view;
        filtering = false;
        filtered = true;
      }),
      reset: (event) => {
        if (filtering || !filtered)
          return;
        const { scale: scale13 } = view;
        const { x: scaleX2, y: scaleY2 } = scale13;
        const domainX = scaleX2.getOptions().domain;
        const domainY = scaleY2.getOptions().domain;
        emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
        filtered = false;
        newView = view;
        setState("brushFilter");
        update2();
      },
      extent: void 0,
      emitter,
      scale: scale12,
      coordinate
    }, defaultOptions), rest));
  };
}

// node_modules/@antv/g2/esm/interaction/brushXFilter.js
function BrushXFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideX: true }, options), { brushRegion: brushXRegion }));
}

// node_modules/@antv/g2/esm/interaction/brushYFilter.js
function BrushYFilter(options) {
  return BrushFilter(Object.assign(Object.assign({ hideY: true }, options), { brushRegion: brushYRegion }));
}

// node_modules/@antv/g2/esm/interaction/sliderFilter.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SLIDER_CLASS_NAME = "slider";
function filterDataByDomain(options, scaleOptions, prefix, hasState = false, channel0 = "x", channel1 = "y") {
  const { marks } = options;
  const newMarks = marks.map((mark2) => {
    var _a2, _b;
    return deep_mix_default({
      // Hide label to keep smooth transition.
      axis: {
        x: { transform: [{ type: "hide" }] },
        y: { transform: [{ type: "hide" }] }
      }
    }, mark2, {
      scale: scaleOptions,
      // Don't rerender sliders.
      [prefix]: Object.assign(Object.assign({}, ((_a2 = mark2[prefix]) === null || _a2 === void 0 ? void 0 : _a2[channel0]) && {
        [channel0]: Object.assign({ preserve: true }, hasState && { ratio: null })
      }), ((_b = mark2[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
        [channel1]: { preserve: true }
      }),
      animate: false
    });
  });
  return Object.assign(Object.assign({}, options), { marks: newMarks, clip: true, animate: false });
}
function abstractValue(values4, scale12, reverse2) {
  const [x3, x12] = values4;
  const v = reverse2 ? (d4) => 1 - d4 : (d4) => d4;
  const d0 = invert4(scale12, v(x3), true);
  const d1 = invert4(scale12, v(x12), false);
  return domainOf3(scale12, [d0, d1]);
}
function extentOf(domain) {
  return [domain[0], domain[domain.length - 1]];
}
function SliderFilter({ initDomain = {}, className: className2 = SLIDER_CLASS_NAME, prefix = "slider", setValue = (component, values4) => component.setValues(values4), hasState = false, wait = 50, leading = true, trailing = false, getInitValues = (slider) => {
  var _a2;
  const values4 = (_a2 = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a2 === void 0 ? void 0 : _a2.values;
  if (values4[0] !== 0 || values4[1] !== 1)
    return values4;
} }) {
  return (context, _2, emitter) => {
    const { container, view, update: update2, setState } = context;
    const sliders = container.getElementsByClassName(className2);
    if (!sliders.length)
      return () => {
      };
    let filtering = false;
    const { scale: scale12, coordinate, layout } = view;
    const { paddingLeft, paddingTop, paddingBottom, paddingRight } = layout;
    const { x: scaleX2, y: scaleY2 } = scale12;
    const transposed = isTranspose(coordinate);
    const channelOf = (orientation) => {
      const channel0 = orientation === "vertical" ? "y" : "x";
      const channel1 = orientation === "vertical" ? "x" : "y";
      if (transposed)
        return [channel1, channel0];
      return [channel0, channel1];
    };
    const sliderHandler = /* @__PURE__ */ new Map();
    const emitHandlers = /* @__PURE__ */ new Set();
    const channelDomain = {
      x: initDomain.x || scaleX2.getOptions().domain,
      y: initDomain.y || scaleY2.getOptions().domain
    };
    for (const slider of sliders) {
      const { orientation } = slider.attributes;
      const [channel0, channel1] = channelOf(orientation);
      const eventName = `${prefix}${upper_first_default(channel0)}:filter`;
      const isX = channel0 === "x";
      const { ratio: ratioX } = scaleX2.getOptions();
      const { ratio: ratioY } = scaleY2.getOptions();
      const domainsOf = (event) => {
        if (event.data) {
          const { selection } = event.data;
          const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
          return isX ? [domainOf3(scaleX2, X, ratioX), domainOf3(scaleY2, Y, ratioY)] : [domainOf3(scaleY2, Y, ratioY), domainOf3(scaleX2, X, ratioX)];
        }
        const { value: values5 } = event.detail;
        const scale0 = scale12[channel0];
        const domain0 = abstractValue(values5, scale0, transposed && orientation === "horizontal");
        const domain1 = channelDomain[channel1];
        return [domain0, domain1];
      };
      const onValueChange = throttle_default((event) => __awaiter9(this, void 0, void 0, function* () {
        const { initValue = false } = event;
        if (filtering && !initValue)
          return;
        filtering = true;
        const { nativeEvent = true } = event;
        const scaleXOptions = scaleX2.getOptions();
        if (get_default(scaleXOptions, "domain.length") !== get_default(scaleXOptions, "expectedDomain.length")) {
          scaleX2.update({ domain: scaleXOptions.expectedDomain });
        }
        const scaleYOptions = scaleY2.getOptions();
        if (get_default(scaleYOptions, "domain.length") !== get_default(scaleYOptions, "expectedDomain.length")) {
          scaleY2.update({ domain: scaleYOptions.expectedDomain });
        }
        const [domain0, domain1] = domainsOf(event);
        channelDomain[channel0] = domain0;
        channelDomain[channel1] = domain1;
        if (nativeEvent) {
          const X = isX ? domain0 : domain1;
          const Y = isX ? domain1 : domain0;
          emitter.emit(eventName, Object.assign(Object.assign({}, event), { nativeEvent, data: { selection: [extentOf(X), extentOf(Y)] } }));
        }
        setState(slider, (options) => Object.assign(Object.assign({}, filterDataByDomain(
          options,
          // Set nice to false to avoid modify domain.
          // Only update domain of current slider / scrollbar.
          { [channel0]: { domain: domain0, nice: false } },
          prefix,
          hasState,
          channel0,
          channel1
        )), {
          paddingLeft,
          paddingTop,
          paddingBottom,
          paddingRight
        }));
        yield update2();
        filtering = false;
      }), wait, { leading, trailing });
      const emitHandler = (event) => {
        const { nativeEvent } = event;
        if (nativeEvent)
          return;
        const { data: data2 } = event;
        const { selection } = data2;
        const [X, Y] = selection;
        slider.dispatchEvent(new CustomEvent("valuechange", {
          data: data2,
          nativeEvent: false
        }));
        const V = isX ? abstractOf(X, scaleX2) : abstractOf(Y, scaleY2);
        setValue(slider, V);
      };
      emitter.on(eventName, emitHandler);
      slider.addEventListener("valuechange", onValueChange);
      sliderHandler.set(slider, onValueChange);
      emitHandlers.add([eventName, emitHandler]);
      const values4 = getInitValues(slider);
      if (values4) {
        slider.dispatchEvent(new CustomEvent("valuechange", {
          detail: {
            value: values4
          },
          nativeEvent: false,
          initValue: true
        }));
      }
    }
    return () => {
      for (const [slider, handler] of sliderHandler) {
        slider.removeEventListener("valuechange", handler);
      }
      for (const [name2, handler] of emitHandlers) {
        emitter.off(name2, handler);
      }
    };
  };
}

// node_modules/@antv/g2/esm/interaction/scrollbarFilter.js
var SCROLLBAR_CLASS_NAME = "g2-scrollbar";
function ScrollbarFilter(options = {}) {
  return (context, _2, emitter) => {
    const { view, container } = context;
    const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
    if (!scrollbars.length)
      return () => {
      };
    const { scale: scale12 } = view;
    const { x: scaleX2, y: scaleY2 } = scale12;
    const initDomain = {
      x: [...scaleX2.getOptions().domain],
      y: [...scaleY2.getOptions().domain]
    };
    const interaction = SliderFilter(Object.assign({ initDomain, className: SCROLLBAR_CLASS_NAME, prefix: "scrollbar", hasState: true, setValue: (component, values4) => component.setValue(values4[0]), getInitValues: (scrollbar) => {
      const values4 = scrollbar.slider.attributes.values;
      if (values4[0] !== 0)
        return values4;
    } }, options));
    return interaction(context, _2, emitter);
  };
}

// node_modules/@antv/g2/esm/interaction/poptip.js
var __rest84 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function dom(tag, children, style) {
  return `<${tag} style="${Object.entries(style).map(([key, value2]) => `${kebabCase(key)}:${value2}`).join(";")}">${children}</${tag}>`;
}
var defaultTipStyle = {
  backgroundColor: "rgba(0,0,0,0.75)",
  color: "#fff",
  width: "max-content",
  padding: "1px 4px",
  fontSize: "12px",
  borderRadius: "2.5px",
  boxShadow: "0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)"
};
function isTipText(element) {
  if (element.nodeName !== "text")
    return false;
  if (element.isOverflowing())
    return true;
  return false;
}
function Poptip2(_a2) {
  var { offsetX = 8, offsetY = 8 } = _a2, style = __rest84(_a2, ["offsetX", "offsetY"]);
  return (context) => {
    const { container } = context;
    const [x05, y05] = container.getBounds().min;
    const tipStyle = subObject(style, "tip");
    const tips = /* @__PURE__ */ new Set();
    const pointerover = (e3) => {
      const { target } = e3;
      if (!isTipText(target)) {
        e3.stopPropagation();
        return;
      }
      const { offsetX: mouseX, offsetY: mouseY } = e3;
      const x3 = mouseX + offsetX - x05;
      const y4 = mouseY + offsetY - y05;
      if (target.tip) {
        target.tip.style.x = x3;
        target.tip.style.y = y4;
        return;
      }
      const { text } = target.style;
      const tipELement = new HTML({
        className: "poptip",
        style: {
          innerHTML: dom("div", text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
          x: x3,
          y: y4
        }
      });
      container.appendChild(tipELement);
      target.tip = tipELement;
      tips.add(tipELement);
    };
    const pointerout = (e3) => {
      const { target } = e3;
      if (!isTipText(target)) {
        e3.stopPropagation();
        return;
      }
      if (!target.tip)
        return;
      target.tip.remove();
      target.tip = null;
      tips.delete(target.tip);
    };
    container.addEventListener("pointerover", pointerover);
    container.addEventListener("pointerout", pointerout);
    return () => {
      container.removeEventListener("pointerover", pointerover);
      container.removeEventListener("pointerout", pointerout);
      tips.forEach((tip) => tip.remove());
    };
  };
}
Poptip2.props = {
  reapplyWhenUpdate: true
};

// node_modules/@antv/g2/esm/interaction/treemapDrillDown.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest85 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function selectPlotArea2(root2) {
  return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB_STYLE = {
  breadCrumbFill: "rgba(0, 0, 0, 0.85)",
  breadCrumbFontSize: 12,
  breadCrumbY: 12,
  activeFill: "rgba(0, 0, 0, 0.5)"
};
function TreemapDrillDown(drillDownOptions = {}) {
  const { originData = [], layout } = drillDownOptions, style = __rest85(drillDownOptions, ["originData", "layout"]);
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB_STYLE, style);
  const breadCrumbStyle = subObject(breadCrumb, "breadCrumb");
  const breadCrumbActiveStyle = subObject(breadCrumb, "active");
  return (context) => {
    const { update: update2, setState, container, options } = context;
    const plotArea = selectPlotArea2(container);
    const mark2 = options.marks[0];
    const { state } = mark2;
    const textGroup = new Group2();
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter10(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (depth) {
        let name2 = "";
        let y4 = breadCrumbStyle.y;
        let x3 = 0;
        const textPath = [];
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = path2.map((text, index3) => {
          name2 = `${name2}${text}/`;
          textPath.push(text);
          const drillText = new Text({
            name: name2.replace(/\/$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x3,
              // @ts-ignore
              path: [...textPath],
              depth: index3
            }, breadCrumbStyle), { y: y4 })
          });
          textGroup.appendChild(drillText);
          x3 += drillText.getBBox().width;
          const textSeparator = new Text({
            style: Object.assign(Object.assign({ x: x3, text: " / " }, breadCrumbStyle), { y: y4 })
          });
          textGroup.appendChild(textSeparator);
          x3 += textSeparator.getBBox().width;
          if (x3 > maxWidth) {
            y4 = textGroup.getBBox().height + breadCrumbStyle.y;
            x3 = 0;
            drillText.attr({
              x: x3,
              y: y4
            });
            x3 += drillText.getBBox().width;
            textSeparator.attr({
              x: x3,
              y: y4
            });
            x3 += textSeparator.getBBox().width;
          }
          if (index3 === size(path2) - 1) {
            textSeparator.remove();
          }
          return drillText;
        });
        drillTexts.forEach((item, index3) => {
          if (index3 === size(drillTexts) - 1)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumbActiveStyle);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(get_default(item, ["style", "path"]), get_default(item, ["style", "depth"]));
          });
        });
      }
      legendClearSetState(container, setState);
      setState("treemapDrillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const strPath = path2.join("/");
        const newMarks = marks.map((mark3) => {
          if (mark3.type !== "rect")
            return mark3;
          let newData = originData;
          if (depth) {
            const filterData = originData.filter((item) => {
              const id4 = get_default(item, ["id"]);
              return id4 && (id4.match(`${strPath}/`) || strPath.match(id4));
            }).map((item) => ({
              value: item.height === 0 ? get_default(item, ["value"]) : void 0,
              name: get_default(item, ["id"])
            }));
            const { paddingLeft, paddingBottom, paddingRight } = layout;
            const newLayout = Object.assign(Object.assign({}, layout), { paddingTop: (layout.paddingTop || textGroup.getBBox().height + 10) / (depth + 1), paddingLeft: paddingLeft / (depth + 1), paddingBottom: paddingBottom / (depth + 1), paddingRight: paddingRight / (depth + 1), path: (d4) => d4.name, layer: (d4) => d4.depth === depth + 1 });
            newData = treeDataTransform(filterData, newLayout, {
              value: "value"
            })[0];
          } else {
            newData = originData.filter((item) => {
              return item.depth === 1;
            });
          }
          const colorDomain = [];
          newData.forEach(({ path: path3 }) => {
            colorDomain.push(last(path3));
          });
          return deep_mix_default({}, mark3, {
            data: newData,
            scale: {
              color: { domain: colorDomain }
            }
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update2(void 0, ["legendFilter"]);
    });
    const keyofLabel = (d4) => d4.attributes.key.split("-")[0];
    const keyofRect = (d4) => get_default(d4, ["__data__", "key"]);
    const createDrillClick = (e3) => {
      const item = e3.target;
      const { markType, nodeName, attributes } = item || {};
      if (markType !== "rect" && nodeName !== Shape.TEXT)
        return;
      const key = nodeName === Shape.TEXT && get_default(attributes, "isTreemapLabel") === true ? keyofLabel(item) : keyofRect(item);
      const node = find_default(originData, (d4) => d4.id === key);
      if (get_default(node, "height")) {
        drillDownClick(get_default(node, "path"), get_default(node, "depth"));
      }
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElements(plotArea);
      elements.forEach((element) => {
        const cursor = get_default(element, ["style", "cursor"]);
        const node = find_default(originData, (d4) => d4.id === get_default(element, ["__data__", "key"]));
        if (cursor !== "pointer" && (node === null || node === void 0 ? void 0 : node.height)) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    createActive();
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2/esm/interaction/elementPointMove.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest86 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var DEFAULT_STYLE2 = {
  pointR: 6,
  pointStrokeWidth: 1,
  pointStroke: "#888",
  pointActiveStroke: "#f5f5f5",
  pathStroke: "#888",
  pathLineDash: [3, 4],
  labelFontSize: 12,
  labelFill: "#888",
  labelStroke: "#fff",
  labelLineWidth: 1,
  labelY: -6,
  labelX: 2
};
var MOVE_POINT_NAME = "movePoint";
var elementMouseenter = (e3) => {
  const element = e3.target;
  const { markType } = element;
  if (markType === "line") {
    element.attr("_lineWidth", element.attr("lineWidth") || 1);
    element.attr("lineWidth", element.attr("_lineWidth") + 3);
  }
  if (markType === "interval") {
    element.attr("_opacity", element.attr("opacity") || 1);
    element.attr("opacity", 0.7 * element.attr("_opacity"));
  }
};
var elementMouseleave = (e3) => {
  const element = e3.target;
  const { markType } = element;
  if (markType === "line") {
    element.attr("lineWidth", element.attr("_lineWidth"));
  }
  if (markType === "interval") {
    element.attr("opacity", element.attr("_opacity"));
  }
};
var getNewData = (newChangeData, data2, encode) => {
  return data2.map((d4) => {
    const isUpdate = ["x", "color"].reduce((v, key) => {
      const field3 = encode[key];
      if (!field3)
        return v;
      if (d4[field3] !== newChangeData[field3])
        return false;
      return v;
    }, true);
    return isUpdate ? Object.assign(Object.assign({}, d4), newChangeData) : d4;
  });
};
var getIntervalDataRatioTransformFn = (element) => {
  const y4 = get_default(element, ["__data__", "y"]);
  const y12 = get_default(element, ["__data__", "y1"]);
  const v = y12 - y4;
  const { __data__: { data: data2, encode, transform: transform2 }, childNodes } = element.parentNode;
  const isNormalizeY = find_default(transform2, ({ type }) => type === "normalizeY");
  const yField = get_default(encode, ["y", "field"]);
  const value2 = data2[childNodes.indexOf(element)][yField];
  return (newValue, isTheta3 = false) => {
    if (isNormalizeY || isTheta3) {
      return newValue / (1 - newValue) / (v / (1 - v)) * value2;
    }
    return newValue;
  };
};
var getPathDataRatioTransformFn = (element, index3) => {
  const v = get_default(element, ["__data__", "seriesItems", index3, "0", "value"]);
  const i2 = get_default(element, ["__data__", "seriesIndex", index3]);
  const { __data__: { data: data2, encode, transform: transform2 } } = element.parentNode;
  const isNormalizeY = find_default(transform2, ({ type }) => type === "normalizeY");
  const yField = get_default(encode, ["y", "field"]);
  const value2 = data2[i2][yField];
  return (newValue) => {
    if (isNormalizeY) {
      if (v === 1) {
        return newValue;
      }
      return newValue / (1 - newValue) / (v / (1 - v)) * value2;
    }
    return newValue;
  };
};
var selectedPointsStyle = (pointsShape, selection, defaultStyle2) => {
  pointsShape.forEach((shape23, index3) => {
    shape23.attr("stroke", selection[1] === index3 ? defaultStyle2["activeStroke"] : defaultStyle2["stroke"]);
  });
};
var createHelpShape = (group3, circle3, pathStyle, labelStyle) => {
  const pathShape = new Path2({
    style: pathStyle
  });
  const labelShape = new Text({
    style: labelStyle
  });
  circle3.appendChild(labelShape);
  group3.appendChild(pathShape);
  return [pathShape, labelShape];
};
var getColorType = (scaleColor, color3) => {
  const indexOf5 = get_default(scaleColor, ["options", "range", "indexOf"]);
  if (!indexOf5)
    return;
  const i2 = scaleColor.options.range.indexOf(color3);
  return scaleColor.sortedDomain[i2];
};
var getSamePointPosition = (center2, point7, target) => {
  const oldR = getPointsR(center2, point7);
  const newR = getPointsR(center2, target);
  const ratio = newR / oldR;
  const newX = center2[0] + (point7[0] - center2[0]) * ratio;
  const newY = center2[1] + (point7[1] - center2[1]) * ratio;
  return [newX, newY];
};
function ElementPointMove(elementPointMoveOptions = {}) {
  const { selection = [], precision = 2 } = elementPointMoveOptions, style = __rest86(elementPointMoveOptions, ["selection", "precision"]);
  const defaultStyle2 = Object.assign(Object.assign({}, DEFAULT_STYLE2), style || {});
  const pathDefaultStyle = subObject(defaultStyle2, "path");
  const labelDefaultStyle = subObject(defaultStyle2, "label");
  const pointDefaultStyle = subObject(defaultStyle2, "point");
  return (context, _2, emitter) => {
    const { update: update2, setState, container, view, options: { marks, coordinate: coordinateOptions } } = context;
    const plotArea = selectPlotArea(container);
    let elements = getElements(plotArea);
    let newState;
    let newSelection = selection;
    const { transform: transform2 = [], type: coordinateType } = coordinateOptions;
    const isTranspose3 = !!find_default(transform2, ({ type }) => type === "transpose");
    const isPolar3 = coordinateType === "polar";
    const isTheta3 = coordinateType === "theta";
    const isArea = !!find_default(elements, ({ markType }) => markType === "area");
    if (isArea) {
      elements = elements.filter(({ markType }) => markType === "area");
    }
    const pointsGroup = new Group2({
      style: {
        // Tooltip point need down.
        zIndex: 2
      }
    });
    plotArea.appendChild(pointsGroup);
    const selectedChange = () => {
      emitter.emit("element-point:select", {
        nativeEvent: true,
        data: {
          selection: newSelection
        }
      });
    };
    const dataChange = (changeData, data2) => {
      emitter.emit("element-point:moved", {
        nativeEvent: true,
        data: {
          changeData,
          data: data2
        }
      });
    };
    const elementClick = (e3) => {
      const element = e3.target;
      newSelection = [element.parentNode.childNodes.indexOf(element)];
      selectedChange();
      createPoints(element);
    };
    const elementSelect2 = (d4) => {
      const { data: { selection: selection2 }, nativeEvent } = d4;
      if (nativeEvent)
        return;
      newSelection = selection2;
      const element = get_default(elements, [newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]]);
      if (element) {
        createPoints(element);
      }
    };
    const createPoints = (element) => {
      const { attributes, markType, __data__: data2 } = element;
      const { stroke: fill } = attributes;
      const { points, seriesTitle, color: color3, title, seriesX, y1: y12 } = data2;
      if (isTranspose3 && markType !== "interval")
        return;
      const { scale: scale12, coordinate } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;
      const { color: scaleColor, y: scaleY2, x: scaleX2 } = scale12;
      const center2 = coordinate.getCenter();
      pointsGroup.removeChildren();
      let downPoint;
      const updateView = (x3, y4, color4, markTypes) => __awaiter11(this, void 0, void 0, function* () {
        setState("elementPointMove", (viewOptions) => {
          var _a2;
          const newMarks = (((_a2 = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a2 === void 0 ? void 0 : _a2.marks) || marks).map((mark2) => {
            if (!markTypes.includes(mark2.type))
              return mark2;
            const { data: data3, encode } = mark2;
            const encodeKeys = Object.keys(encode);
            const newChangeData = encodeKeys.reduce((value2, key) => {
              const dataKey = encode[key];
              if (key === "x") {
                value2[dataKey] = x3;
              }
              if (key === "y") {
                value2[dataKey] = y4;
              }
              if (key === "color") {
                value2[dataKey] = color4;
              }
              return value2;
            }, {});
            const newData = getNewData(newChangeData, data3, encode);
            dataChange(newChangeData, newData);
            return deep_mix_default({}, mark2, {
              data: newData,
              // No need animate
              animate: false
            });
          });
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
        });
        return yield update2("elementPointMove");
      });
      if (["line", "area"].includes(markType)) {
        points.forEach((p3, index3) => {
          const title2 = scaleX2.invert(seriesX[index3]);
          if (!title2)
            return;
          const circle3 = new Circle({
            name: MOVE_POINT_NAME,
            style: Object.assign({ cx: p3[0], cy: p3[1], fill }, pointDefaultStyle)
          });
          const ratioTransform = getPathDataRatioTransformFn(element, index3);
          circle3.addEventListener("mousedown", (e3) => {
            const oldPoint = coordinate.output([seriesX[index3], 0]);
            const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;
            container.attr("cursor", "move");
            if (newSelection[1] !== index3) {
              newSelection[1] = index3;
              selectedChange();
            }
            selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
            const [pathShape, labelShape] = createHelpShape(pointsGroup, circle3, pathDefaultStyle, labelDefaultStyle);
            const pointMousemove = (e4) => {
              const newCy = p3[1] + e4.clientY - downPoint[1];
              if (isArea) {
                if (isPolar3) {
                  const newCx = p3[0] + e4.clientX - downPoint[0];
                  const [newX, newY] = getSamePointPosition(center2, oldPoint, [
                    newCx,
                    newCy
                  ]);
                  const [, initY] = coordinate.output([1, scaleY2.output(0)]);
                  const [, y4] = coordinate.invert([
                    newX,
                    initY - (points[index3 + pathLength][1] - newY)
                  ]);
                  const nextIndex = (index3 + 1) % pathLength;
                  const lastIndex = (index3 - 1 + pathLength) % pathLength;
                  const newPath = getPointsPath([
                    points[lastIndex],
                    [newX, newY],
                    seriesTitle[nextIndex] && points[nextIndex]
                  ]);
                  labelShape.attr("text", ratioTransform(scaleY2.invert(y4)).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle3.attr("cx", newX);
                  circle3.attr("cy", newY);
                } else {
                  const [, initY] = coordinate.output([1, scaleY2.output(0)]);
                  const [, y4] = coordinate.invert([
                    p3[0],
                    initY - (points[index3 + pathLength][1] - newCy)
                  ]);
                  const newPath = getPointsPath([
                    points[index3 - 1],
                    [p3[0], newCy],
                    seriesTitle[index3 + 1] && points[index3 + 1]
                  ]);
                  labelShape.attr("text", ratioTransform(scaleY2.invert(y4)).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle3.attr("cy", newCy);
                }
              } else {
                const [, y4] = coordinate.invert([p3[0], newCy]);
                const newPath = getPointsPath([
                  points[index3 - 1],
                  [p3[0], newCy],
                  points[index3 + 1]
                ]);
                labelShape.attr("text", scaleY2.invert(y4).toFixed(precision));
                pathShape.attr("d", newPath);
                circle3.attr("cy", newCy);
              }
            };
            downPoint = [e3.clientX, e3.clientY];
            window.addEventListener("mousemove", pointMousemove);
            const mouseupFn = () => __awaiter11(this, void 0, void 0, function* () {
              container.attr("cursor", "default");
              window.removeEventListener("mousemove", pointMousemove);
              container.removeEventListener("mouseup", mouseupFn);
              if (is_undefined_default(labelShape.attr("text")))
                return;
              const y4 = Number(labelShape.attr("text"));
              const colorType = getColorType(scaleColor, color3);
              newState = yield updateView(title2, y4, colorType, [
                "line",
                "area"
              ]);
              labelShape.remove();
              pathShape.remove();
              createPoints(element);
            });
            container.addEventListener("mouseup", mouseupFn);
          });
          pointsGroup.appendChild(circle3);
        });
        selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
      } else if (markType === "interval") {
        let circlePoint = [(points[0][0] + points[1][0]) / 2, points[0][1]];
        if (isTranspose3) {
          circlePoint = [points[0][0], (points[0][1] + points[1][1]) / 2];
        } else if (isTheta3) {
          circlePoint = points[0];
        }
        const ratioTransform = getIntervalDataRatioTransformFn(element);
        const circle3 = new Circle({
          name: MOVE_POINT_NAME,
          style: Object.assign(Object.assign({ cx: circlePoint[0], cy: circlePoint[1], fill }, pointDefaultStyle), { stroke: pointDefaultStyle["activeStroke"] })
        });
        circle3.addEventListener("mousedown", (e3) => {
          container.attr("cursor", "move");
          const colorType = getColorType(scaleColor, color3);
          const [pathShape, labelShape] = createHelpShape(pointsGroup, circle3, pathDefaultStyle, labelDefaultStyle);
          const pointMousemove = (e4) => {
            if (isTranspose3) {
              const newCx = circlePoint[0] + e4.clientX - downPoint[0];
              const [initX] = coordinate.output([
                scaleY2.output(0),
                scaleY2.output(0)
              ]);
              const [, x3] = coordinate.invert([
                initX + (newCx - points[2][0]),
                circlePoint[1]
              ]);
              const newPath = getPointsPath([
                [newCx, points[0][1]],
                [newCx, points[1][1]],
                points[2],
                points[3]
              ], true);
              labelShape.attr("text", ratioTransform(scaleY2.invert(x3)).toFixed(precision));
              pathShape.attr("d", newPath);
              circle3.attr("cx", newCx);
            } else if (isTheta3) {
              const newCy = circlePoint[1] + e4.clientY - downPoint[1];
              const newCx = circlePoint[0] + e4.clientX - downPoint[0];
              const [newXOut, newYOut] = getSamePointPosition(center2, [newCx, newCy], circlePoint);
              const [newXIn, newYIn] = getSamePointPosition(center2, [newCx, newCy], points[1]);
              const lastPercent = coordinate.invert([newXOut, newYOut])[1];
              const percent2 = y12 - lastPercent;
              if (percent2 < 0)
                return;
              const newPath = getThetaPath(center2, [[newXOut, newYOut], [newXIn, newYIn], points[2], points[3]], percent2 > 0.5 ? 1 : 0);
              labelShape.attr("text", ratioTransform(percent2, true).toFixed(precision));
              pathShape.attr("d", newPath);
              circle3.attr("cx", newXOut);
              circle3.attr("cy", newYOut);
            } else {
              const newCy = circlePoint[1] + e4.clientY - downPoint[1];
              const [, initY] = coordinate.output([1, scaleY2.output(0)]);
              const [, y4] = coordinate.invert([
                circlePoint[0],
                initY - (points[2][1] - newCy)
              ]);
              const newPath = getPointsPath([
                [points[0][0], newCy],
                [points[1][0], newCy],
                points[2],
                points[3]
              ], true);
              labelShape.attr("text", ratioTransform(scaleY2.invert(y4)).toFixed(precision));
              pathShape.attr("d", newPath);
              circle3.attr("cy", newCy);
            }
          };
          downPoint = [e3.clientX, e3.clientY];
          window.addEventListener("mousemove", pointMousemove);
          const mouseupFn = () => __awaiter11(this, void 0, void 0, function* () {
            container.attr("cursor", "default");
            container.removeEventListener("mouseup", mouseupFn);
            window.removeEventListener("mousemove", pointMousemove);
            if (is_undefined_default(labelShape.attr("text")))
              return;
            const y4 = Number(labelShape.attr("text"));
            newState = yield updateView(title, y4, colorType, [markType]);
            labelShape.remove();
            pathShape.remove();
            createPoints(element);
          });
          container.addEventListener("mouseup", mouseupFn);
        });
        pointsGroup.appendChild(circle3);
      }
    };
    elements.forEach((element, index3) => {
      if (newSelection[0] === index3) {
        createPoints(element);
      }
      element.addEventListener("click", elementClick);
      element.addEventListener("mouseenter", elementMouseenter);
      element.addEventListener("mouseleave", elementMouseleave);
    });
    const rootClick = (e3) => {
      const element = e3 === null || e3 === void 0 ? void 0 : e3.target;
      if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {
        newSelection = [];
        selectedChange();
        pointsGroup.removeChildren();
      }
    };
    emitter.on("element-point:select", elementSelect2);
    emitter.on("element-point:unselect", rootClick);
    container.addEventListener("mousedown", rootClick);
    return () => {
      pointsGroup.remove();
      emitter.off("element-point:select", elementSelect2);
      emitter.off("element-point:unselect", rootClick);
      container.removeEventListener("mousedown", rootClick);
      elements.forEach((element) => {
        element.removeEventListener("click", elementClick);
        element.removeEventListener("mouseenter", elementMouseenter);
        element.removeEventListener("mouseleave", elementMouseleave);
      });
    };
  };
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i2) {
    return JSON.stringify(name2) + ": d[" + i2 + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f2) {
  var object = objectConverter(columns);
  return function(row2, i2) {
    return f2(object(row2), i2, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row2) {
    for (var column2 in row2) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad2(value2, width) {
  var s4 = value2 + "", length5 = s4.length;
  return length5 < width ? new Array(width - length5 + 1).join(0) + s4 : s4;
}
function formatYear(year2) {
  return year2 < 0 ? "-" + pad2(-year2, 6) : year2 > 9999 ? "+" + pad2(year2, 6) : pad2(year2, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad2(date.getUTCMonth() + 1, 2) + "-" + pad2(date.getUTCDate(), 2) + (milliseconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "." + pad2(milliseconds, 3) + "Z" : seconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "Z" : minutes || hours ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f2) {
    var convert, columns, rows = parseRows(text, function(row2, i2) {
      if (convert) return convert(row2, i2 - 1);
      columns = row2, convert = f2 ? customConverter(row2, f2) : objectConverter(row2);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f2) {
    var rows = [], N = text.length, I = 0, n2 = 0, t, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;
    function token2() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;
      var i2, j = I, c6;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) ;
        if ((i2 = I) >= N) eof = true;
        else if ((c6 = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c6 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i2 - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c6 = text.charCodeAt(i2 = I++)) === NEWLINE) eol = true;
        else if (c6 === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c6 !== DELIMITER) continue;
        return text.slice(j, i2);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t = token2()) !== EOF) {
      var row2 = [];
      while (t !== EOL && t !== EOF) row2.push(t), t = token2();
      if (f2 && (row2 = f2(row2, n2++)) == null) continue;
      rows.push(row2);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row2) {
      return columns.map(function(column2) {
        return formatValue(row2[column2]);
      }).join(delimiter);
    });
  }
  function format3(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row2) {
    return row2.map(formatValue).join(delimiter);
  }
  function formatValue(value2) {
    return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
  }
  return {
    parse,
    parseRows,
    format: format3,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
function autoType(object) {
  for (var key in object) {
    var value2 = object[key].trim(), number3, m3;
    if (!value2) value2 = null;
    else if (value2 === "true") value2 = true;
    else if (value2 === "false") value2 = false;
    else if (value2 === "NaN") value2 = NaN;
    else if (!isNaN(number3 = +value2)) value2 = number3;
    else if (m3 = value2.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m3[4] && !m3[7]) value2 = value2.replace(/-/g, "/").replace(/T/, " ");
      value2 = new Date(value2);
    } else continue;
    object[key] = value2;
  }
  return object;
}
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/@antv/g2/esm/data/fetch.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Fetch = (options) => {
  const { value: value2, format: format3 = value2.split(".").pop(), delimiter = ",", autoType: autoType2 = true } = options;
  return () => __awaiter12(void 0, void 0, void 0, function* () {
    const response = yield fetch(value2);
    if (format3 === "csv") {
      const str7 = yield response.text();
      return dsv_default(delimiter).parse(str7, autoType2 ? autoType : identity6);
    }
    if (format3 === "json") {
      return yield response.json();
    }
    throw new Error(`Unknown format: ${format3}.`);
  });
};
Fetch.props = {};

// node_modules/@antv/g2/esm/data/fold.js
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
var Fold = (options) => {
  const { fields, key = "key", value: value2 = "value" } = options;
  return (data2) => {
    if (isEmpty(fields))
      return data2;
    return data2.flatMap((d4) => fields.map((f2) => Object.assign(Object.assign({}, d4), { [key]: f2, [value2]: d4[f2] })));
  };
};
Fold.props = {};

// node_modules/@antv/g2/esm/data/filter.js
function defined3(d4) {
  return d4 !== void 0 && d4 !== null && !Number.isNaN(d4);
}
var Filter2 = (options) => {
  const { callback = defined3 } = options;
  return (data2) => data2.filter(callback);
};
Filter2.props = {};

// node_modules/@antv/g2/esm/data/sort.js
var Sort2 = (options) => {
  const { callback } = options;
  return (data2) => Array.isArray(data2) ? [...data2].sort(callback) : data2;
};
Sort2.props = {};

// node_modules/@antv/g2/esm/data/pick.js
function pick(v, fields = []) {
  return fields.reduce((datum, field3) => {
    if (field3 in v) {
      datum[field3] = v[field3];
    }
    return datum;
  }, {});
}
var Pick = (options) => {
  const { fields } = options;
  return (data2) => data2.map((d4) => pick(d4, fields));
};
Pick.props = {};

// node_modules/@antv/g2/esm/data/rename.js
function isEmpty2(obj) {
  return Object.keys(obj).length === 0;
}
var Rename = (options) => {
  return (data2) => {
    if (!options || isEmpty2(options))
      return data2;
    const rename = (v) => Object.entries(v).reduce((datum, [key, value2]) => (datum[options[key] || key] = value2, datum), {});
    return data2.map(rename);
  };
};
Rename.props = {};

// node_modules/@antv/g2/esm/data/utils/fields.js
function normalizeFields(fields, defaultValue) {
  return fields.map((d4) => {
    if (Array.isArray(d4)) {
      const [field3, value2 = defaultValue] = d4;
      return [field3, value2];
    }
    return [d4, defaultValue];
  });
}

// node_modules/@antv/g2/esm/data/sortBy.js
var SortBy = (options) => {
  const { fields: F = [] } = options;
  const normalizedF = normalizeFields(F, true);
  return (data2) => {
    const comparator = (a5, b) => normalizedF.reduce((ret, [field3, order = true]) => {
      if (ret !== 0) {
        return ret;
      }
      if (order) {
        return a5[field3] < b[field3] ? -1 : +(a5[field3] !== b[field3]);
      } else {
        return a5[field3] > b[field3] ? -1 : +(a5[field3] !== b[field3]);
      }
    }, 0);
    return [...data2].sort(comparator);
  };
};
SortBy.props = {};

// node_modules/@antv/g2/esm/data/inline.js
var Inline = (options) => {
  const { value: value2 } = options;
  return () => value2;
};
Inline.props = {};

// node_modules/@antv/g2/esm/data/custom.js
var Custom = (options) => {
  const { callback = identity6 } = options;
  return (data2) => callback(data2);
};
Custom.props = {};

// node_modules/@antv/g2/esm/data/map.js
var Map2 = (options) => {
  const { callback = identity6 } = options;
  return (data2) => Array.isArray(data2) ? data2.map(callback) : data2;
};
Map2.props = {};

// node_modules/@antv/g2/esm/data/utils/flow.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function flow2(target, source) {
  return {
    set(key, normalize10, callback) {
      if (source[key] === void 0)
        return this;
      const value2 = normalize10 ? normalize10.call(null, source[key]) : source[key];
      if (callback)
        callback.call(null, value2);
      else if (typeof target[key] === "function")
        target[key](value2);
      else
        target[key] = value2;
      return this;
    },
    setAsync(key, normalize10, callback) {
      return __awaiter13(this, void 0, void 0, function* () {
        if (source[key] === void 0)
          return this;
        const value2 = normalize10 ? yield normalize10.call(null, source[key]) : source[key];
        if (callback)
          callback.call(null, value2);
        else if (typeof target[key] === "function")
          target[key](value2);
        else
          target[key] = value2;
        return this;
      });
    }
  };
}

// node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloudText(d4) {
  return d4.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d4) {
  return d4.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudDispatch() {
  return;
}
function cloudSprite(contextAndRatio, d4, data2, di) {
  if (d4.sprite)
    return;
  const c6 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c6.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  let x3 = 0, y4 = 0, maxh = 0;
  const n2 = data2.length;
  --di;
  while (++di < n2) {
    d4 = data2[di];
    c6.save();
    c6.font = d4.style + " " + d4.weight + " " + ~~((d4.size + 1) / ratio) + "px " + d4.font;
    let w2 = c6.measureText(d4.text + "m").width * ratio, h2 = d4.size << 1;
    if (d4.rotate) {
      const sr = Math.sin(d4.rotate * cloudRadians), cr = Math.cos(d4.rotate * cloudRadians), wcr = w2 * cr, wsr = w2 * sr, hcr = h2 * cr, hsr = h2 * sr;
      w2 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w2 = w2 + 31 >> 5 << 5;
    }
    if (h2 > maxh)
      maxh = h2;
    if (x3 + w2 >= cw << 5) {
      x3 = 0;
      y4 += maxh;
      maxh = 0;
    }
    if (y4 + h2 >= ch)
      break;
    c6.translate((x3 + (w2 >> 1)) / ratio, (y4 + (h2 >> 1)) / ratio);
    if (d4.rotate)
      c6.rotate(d4.rotate * cloudRadians);
    c6.fillText(d4.text, 0, 0);
    if (d4.padding) {
      c6.lineWidth = 2 * d4.padding;
      c6.strokeText(d4.text, 0, 0);
    }
    c6.restore();
    d4.width = w2;
    d4.height = h2;
    d4.xoff = x3;
    d4.yoff = y4;
    d4.x1 = w2 >> 1;
    d4.y1 = h2 >> 1;
    d4.x0 = -d4.x1;
    d4.y0 = -d4.y1;
    d4.hasText = true;
    x3 += w2;
  }
  const pixels = c6.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d4 = data2[di];
    if (!d4.hasText)
      continue;
    const w2 = d4.width, w32 = w2 >> 5;
    let h2 = d4.y1 - d4.y0;
    for (let i2 = 0; i2 < h2 * w32; i2++)
      sprite[i2] = 0;
    x3 = d4.xoff;
    if (x3 == null)
      return;
    y4 = d4.yoff;
    let seen = 0, seenRow = -1;
    for (let j = 0; j < h2; j++) {
      for (let i2 = 0; i2 < w2; i2++) {
        const k2 = w32 * j + (i2 >> 5), m3 = pixels[(y4 + j) * (cw << 5) + (x3 + i2) << 2] ? 1 << 31 - i2 % 32 : 0;
        sprite[k2] |= m3;
        seen |= m3;
      }
      if (seen)
        seenRow = j;
      else {
        d4.y0++;
        h2--;
        j--;
        y4++;
      }
    }
    d4.y1 = d4.y0 + seenRow;
    d4.sprite = sprite.slice(0, (d4.y1 - d4.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  const sprite = tag.sprite, w2 = tag.width >> 5, lx = tag.x - (w2 << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0;
  let x3 = (tag.y + tag.y0) * sw + (lx >> 5), last5;
  for (let j = 0; j < h2; j++) {
    last5 = 0;
    for (let i2 = 0; i2 <= w2; i2++) {
      if ((last5 << msx | (i2 < w2 ? (last5 = sprite[j * w2 + i2]) >>> sx : 0)) & board[x3 + i2])
        return true;
    }
    x3 += sw;
  }
  return false;
}
function cloudBounds(bounds, d4) {
  const b0 = bounds[0], b1 = bounds[1];
  if (d4.x + d4.x0 < b0.x)
    b0.x = d4.x + d4.x0;
  if (d4.y + d4.y0 < b0.y)
    b0.y = d4.y + d4.y0;
  if (d4.x + d4.x1 > b1.x)
    b1.x = d4.x + d4.x1;
  if (d4.y + d4.y1 > b1.y)
    b1.y = d4.y + d4.y1;
}
function collideRects(a5, b) {
  return a5.x + a5.x1 > b[0].x && a5.x + a5.x0 < b[1].x && a5.y + a5.y1 > b[0].y && a5.y + a5.y0 < b[1].y;
}
function archimedeanSpiral(size3) {
  const e3 = size3[0] / size3[1];
  return function(t) {
    return [e3 * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size3) {
  const dy = 4, dx = dy * size3[0] / size3[1];
  let x3 = 0, y4 = 0;
  return function(t) {
    const sign3 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
      case 0:
        x3 += dx;
        break;
      case 1:
        y4 += dy;
        break;
      case 2:
        x3 -= dx;
        break;
      default:
        y4 -= dy;
        break;
    }
    return [x3, y4];
  };
}
function zeroArray(n2) {
  const a5 = [];
  let i2 = -1;
  while (++i2 < n2)
    a5[i2] = 0;
  return a5;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d4) {
  return typeof d4 === "function" ? d4 : function() {
    return d4;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  let size3 = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate7 = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random5 = Math.random, event = cloudDispatch, words = [], timer2 = null, timeInterval = Infinity, canvas = cloudCanvas;
  const fontStyle = cloudFontNormal;
  const cloud = {};
  cloud.start = function() {
    const [width, height] = size3;
    const contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size3[0] >> 5) * size3[1]), n2 = words.length, tags = [], data2 = words.map(function(d4, i3, data3) {
      d4.text = text.call(this, d4, i3, data3);
      d4.font = font.call(this, d4, i3, data3);
      d4.style = fontStyle.call(this, d4, i3, data3);
      d4.weight = fontWeight.call(this, d4, i3, data3);
      d4.rotate = rotate7.call(this, d4, i3, data3);
      d4.size = ~~fontSize.call(this, d4, i3, data3);
      d4.padding = padding.call(this, d4, i3, data3);
      return d4;
    }).sort(function(a5, b) {
      return b.size - a5.size;
    });
    let i2 = -1, bounds = !cloud.board ? void 0 : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    if (timer2)
      clearInterval(timer2);
    timer2 = setInterval(step2, 0);
    step2();
    function step2() {
      const start = Date.now();
      while (Date.now() - start < timeInterval && ++i2 < n2) {
        const d4 = data2[i2];
        d4.x = width * (random5() + 0.5) >> 1;
        d4.y = height * (random5() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d4, data2, i2);
        if (d4.hasText && place2(board, d4, bounds)) {
          event.call(null, "word", { cloud, word: d4 });
          tags.push(d4);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d4);
            }
          } else {
            bounds = [
              { x: d4.x + d4.x0, y: d4.y + d4.y0 },
              { x: d4.x + d4.x1, y: d4.y + d4.y1 }
            ];
          }
          d4.x -= size3[0] >> 1;
          d4.y -= size3[1] >> 1;
        }
      }
      cloud._tags = tags;
      cloud._bounds = bounds;
      if (i2 >= n2) {
        cloud.stop();
        event.call(null, "end", { cloud, words: tags, bounds });
      }
    }
    return cloud;
  };
  cloud.stop = function() {
    if (timer2) {
      clearInterval(timer2);
      timer2 = null;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    const ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    const context = canvas2.getContext("2d");
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    context.textBaseline = "middle";
    return { context, ratio };
  }
  function place2(board, tag, bounds) {
    const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size3[0] * size3[0] + size3[1] * size3[1]), s4 = spiral(size3), dt = random5() < 0.5 ? 1 : -1;
    let dxdy, t = -dt, dx, dy;
    while (dxdy = s4(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size3[0] || tag.y + tag.y1 > size3[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size3[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          const sprite = tag.sprite, w2 = tag.width >> 5, sw = size3[0] >> 5, lx = tag.x - (w2 << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0;
          let last5, x3 = (tag.y + tag.y0) * sw + (lx >> 5);
          for (let j = 0; j < h2; j++) {
            last5 = 0;
            for (let i2 = 0; i2 <= w2; i2++) {
              board[x3 + i2] |= last5 << msx | (i2 < w2 ? (last5 = sprite[j * w2 + i2]) >>> sx : 0);
            }
            x3 += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = (img) => {
    const can = document.createElement("canvas");
    const [width, height] = size3;
    if (!width || !height) {
      return;
    }
    const w32 = width >> 5;
    const board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    const cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    const imageData = cxt.getImageData(0, 0, width, height).data;
    for (let j = 0; j < height; j++) {
      for (let i2 = 0; i2 < width; i2++) {
        const k2 = w32 * j + (i2 >> 5);
        const tmp2 = j * width + i2 << 2;
        const flag = imageData[tmp2] >= 250 && imageData[tmp2 + 1] >= 250 && imageData[tmp2 + 2] >= 250;
        const m3 = flag ? 1 << 31 - i2 % 32 : 0;
        board[k2] |= m3;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_2) {
    timeInterval = _2 == null ? Infinity : _2;
  };
  cloud.words = function(_2) {
    words = _2;
  };
  cloud.size = function(_2 = []) {
    size3 = [+_2[0], +_2[1]];
  };
  cloud.text = function(_2) {
    text = functor(_2);
  };
  cloud.font = function(_2) {
    font = functor(_2);
  };
  cloud.fontWeight = function(_2) {
    fontWeight = functor(_2);
  };
  cloud.rotate = function(_2) {
    rotate7 = functor(_2);
  };
  cloud.canvas = function(_2) {
    canvas = functor(_2);
  };
  cloud.spiral = function(_2) {
    spiral = spirals[_2] || _2;
  };
  cloud.fontSize = function(_2) {
    fontSize = functor(_2);
  };
  cloud.padding = function(_2) {
    padding = functor(_2);
  };
  cloud.random = function(_2) {
    random5 = functor(_2);
  };
  cloud.on = function(_2) {
    event = functor(_2);
  };
  return cloud;
}

// node_modules/@antv/g2/esm/data/wordCloud.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest87 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var DEFAULT_OPTIONS5 = {
  fontSize: [20, 60],
  font: "Impact",
  padding: 2,
  rotate: function() {
    return (~~(Math.random() * 6) - 3) * 30;
  }
};
function processImageMask(img) {
  return new Promise((res, rej) => {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (typeof img === "string") {
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.src = img;
      image.onload = () => res(image);
      image.onerror = () => {
        console.error(`'image ${img} load failed !!!'`);
        rej();
      };
      return;
    }
    rej();
  });
}
function normalizeFontSize(fontSize, range3) {
  if (typeof fontSize === "function")
    return fontSize;
  if (Array.isArray(fontSize)) {
    const [fMin, fMax] = fontSize;
    if (!range3)
      return () => (fMax + fMin) / 2;
    const [min10, max11] = range3;
    if (max11 === min10)
      return () => (fMax + fMin) / 2;
    return ({ value: value2 }) => (fMax - fMin) / (max11 - min10) * (value2 - min10) + fMin;
  }
  return () => fontSize;
}
var WordCloud2 = (options, context) => {
  return (data2) => __awaiter14(void 0, void 0, void 0, function* () {
    const cloudOptions = Object.assign({}, DEFAULT_OPTIONS5, options, {
      canvas: context.createCanvas
    });
    const layout = tagCloud();
    yield flow2(layout, cloudOptions).set("fontSize", (v) => {
      const arr = data2.map((d4) => d4.value);
      return normalizeFontSize(v, [min4(arr), max5(arr)]);
    }).set("font").set("fontStyle").set("fontWeight").set("padding").set("rotate").set("size").set("spiral").set("timeInterval").set("random").set("text").set("on").set("canvas").setAsync("imageMask", processImageMask, layout.createMask);
    layout.words([...data2]);
    const result = layout.start();
    const [cw2, ch2] = cloudOptions.size;
    const defaultBounds = [
      { x: 0, y: 0 },
      { x: cw2, y: ch2 }
    ];
    const { _bounds: bounds = defaultBounds, _tags, hasImage } = result;
    const tags = _tags.map((_a2) => {
      var { x: x3, y: y4, font } = _a2, rest = __rest87(_a2, ["x", "y", "font"]);
      return Object.assign(Object.assign({}, rest), { x: x3 + cw2 / 2, y: y4 + ch2 / 2, fontFamily: font });
    });
    const [{ x: tlx, y: tly }, { x: brx, y: bry }] = bounds;
    const invisibleText = { text: "", value: 0, opacity: 0, fontSize: 0 };
    tags.push(Object.assign(Object.assign({}, invisibleText), { x: hasImage ? 0 : tlx, y: hasImage ? 0 : tly }), Object.assign(Object.assign({}, invisibleText), { x: hasImage ? cw2 : brx, y: hasImage ? ch2 : bry }));
    return tags;
  });
};
WordCloud2.props = {};

// node_modules/@antv/g2/esm/data/join.js
function field2(key) {
  return typeof key === "string" ? (d4) => d4[key] : key;
}
var Join = (options) => {
  const { join, on, select: select3 = [], as = select3, unknown = NaN } = options;
  const [key, fromKey] = on;
  const fk = field2(fromKey);
  const k2 = field2(key);
  const keyData = rollup(
    join,
    ([d4]) => d4,
    // Get the first matched.
    (d4) => fk(d4)
  );
  return (data2) => data2.map((d4) => {
    const source = keyData.get(k2(d4));
    return Object.assign(Object.assign({}, d4), select3.reduce((prev, key2, idx) => (prev[as[idx]] = source ? source[key2] : unknown, prev), {}));
  });
};
Join.props = {};

// node_modules/@antv/g2/esm/data/slice.js
var Slice = (options) => {
  const { start, end } = options;
  return (data2) => data2.slice(start, end);
};
Slice.props = {};

// node_modules/@antv/g2/esm/data/kde.js
var import_pdfast = __toESM(require_src());
var KDE = (options) => {
  const { field: field3, groupBy: groupBy3, as = ["y", "size"], min: min10, max: max11, size: size3 = 10, width } = options;
  const [yField, sizeField] = as;
  return (data2) => {
    const gs = Array.from(group(data2, (d4) => groupBy3.map((gb) => d4[gb]).join("-")).values());
    return gs.map((g) => {
      const pdfResult = import_pdfast.default.create(g.map((i2) => i2[field3]), {
        min: min10,
        max: max11,
        size: size3,
        width
      });
      const _y = pdfResult.map((result) => result.x);
      const _size = pdfResult.map((result) => result.y);
      return Object.assign(Object.assign({}, g[0]), { [yField]: _y, [sizeField]: _size });
    });
  };
};
KDE.props = {};

// node_modules/@antv/g2/esm/data/utils/venn/fmin/bisect.js
function bisect2(f2, a5, b, parameters) {
  parameters = parameters || {};
  const maxIterations = parameters.maxIterations || 100;
  const tolerance2 = parameters.tolerance || 1e-10;
  const fA = f2(a5);
  const fB = f2(b);
  let delta = b - a5;
  if (fA * fB > 0) {
    throw "Initial bisect points must have opposite signs";
  }
  if (fA === 0)
    return a5;
  if (fB === 0)
    return b;
  for (let i2 = 0; i2 < maxIterations; ++i2) {
    delta /= 2;
    const mid2 = a5 + delta;
    const fMid = f2(mid2);
    if (fMid * fA >= 0) {
      a5 = mid2;
    }
    if (Math.abs(delta) < tolerance2 || fMid === 0) {
      return mid2;
    }
  }
  return a5 + delta;
}

// node_modules/@antv/g2/esm/data/utils/venn/fmin/blas1.js
function zeros(x3) {
  const r2 = new Array(x3);
  for (let i2 = 0; i2 < x3; ++i2) {
    r2[i2] = 0;
  }
  return r2;
}
function zerosM(x3, y4) {
  return zeros(x3).map(() => zeros(y4));
}
function dot8(a5, b) {
  let ret = 0;
  for (let i2 = 0; i2 < a5.length; ++i2) {
    ret += a5[i2] * b[i2];
  }
  return ret;
}
function norm2(a5) {
  return Math.sqrt(dot8(a5, a5));
}
function scale10(ret, value2, c6) {
  for (let i2 = 0; i2 < value2.length; ++i2) {
    ret[i2] = value2[i2] * c6;
  }
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (let j = 0; j < ret.length; ++j) {
    ret[j] = w1 * v1[j] + w2 * v2[j];
  }
}

// node_modules/@antv/g2/esm/data/utils/venn/fmin/nelderMead.js
function nelderMead(f2, x05, parameters) {
  parameters = parameters || {};
  const maxIterations = parameters.maxIterations || x05.length * 200;
  const nonZeroDelta = parameters.nonZeroDelta || 1.05;
  const zeroDelta = parameters.zeroDelta || 1e-3;
  const minErrorDelta = parameters.minErrorDelta || 1e-6;
  const minTolerance = parameters.minErrorDelta || 1e-5;
  const rho = parameters.rho !== void 0 ? parameters.rho : 1;
  const chi = parameters.chi !== void 0 ? parameters.chi : 2;
  const psi = parameters.psi !== void 0 ? parameters.psi : -0.5;
  const sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5;
  let maxDiff;
  const N = x05.length;
  const simplex = new Array(N + 1);
  simplex[0] = x05;
  simplex[0].fx = f2(x05);
  simplex[0].id = 0;
  for (let i2 = 0; i2 < N; ++i2) {
    const point7 = x05.slice();
    point7[i2] = point7[i2] ? point7[i2] * nonZeroDelta : zeroDelta;
    simplex[i2 + 1] = point7;
    simplex[i2 + 1].fx = f2(point7);
    simplex[i2 + 1].id = i2 + 1;
  }
  function updateSimplex(value2) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      simplex[N][i2] = value2[i2];
    }
    simplex[N].fx = value2.fx;
  }
  const sortOrder = (a5, b) => a5.fx - b.fx;
  const centroid = x05.slice();
  const reflected = x05.slice();
  const contracted = x05.slice();
  const expanded = x05.slice();
  for (let iteration = 0; iteration < maxIterations; ++iteration) {
    simplex.sort(sortOrder);
    if (parameters.history) {
      const sortedSimplex = simplex.map((x3) => {
        const state = x3.slice();
        state.fx = x3.fx;
        state.id = x3.id;
        return state;
      });
      sortedSimplex.sort((a5, b) => a5.id - b.id);
      parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (let i2 = 0; i2 < N; ++i2) {
      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i2] - simplex[1][i2]));
    }
    if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
      break;
    }
    for (let i2 = 0; i2 < N; ++i2) {
      centroid[i2] = 0;
      for (let j = 0; j < N; ++j) {
        centroid[i2] += simplex[j][i2];
      }
      centroid[i2] /= N;
    }
    const worst = simplex[N];
    weightedSum(reflected, 1 + rho, centroid, -rho, worst);
    reflected.fx = f2(reflected);
    if (reflected.fx < simplex[0].fx) {
      weightedSum(expanded, 1 + chi, centroid, -chi, worst);
      expanded.fx = f2(expanded);
      if (expanded.fx < reflected.fx) {
        updateSimplex(expanded);
      } else {
        updateSimplex(reflected);
      }
    } else if (reflected.fx >= simplex[N - 1].fx) {
      let shouldReduce = false;
      if (reflected.fx > worst.fx) {
        weightedSum(contracted, 1 + psi, centroid, -psi, worst);
        contracted.fx = f2(contracted);
        if (contracted.fx < worst.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      } else {
        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
        contracted.fx = f2(contracted);
        if (contracted.fx < reflected.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      }
      if (shouldReduce) {
        if (sigma >= 1)
          break;
        for (let i2 = 1; i2 < simplex.length; ++i2) {
          weightedSum(simplex[i2], 1 - sigma, simplex[0], sigma, simplex[i2]);
          simplex[i2].fx = f2(simplex[i2]);
        }
      }
    } else {
      updateSimplex(reflected);
    }
  }
  simplex.sort(sortOrder);
  return { fx: simplex[0].fx, x: simplex[0] };
}

// node_modules/@antv/g2/esm/data/utils/venn/fmin/linesearch.js
function wolfeLineSearch(f2, pk, current, next, a5, c1, c22) {
  const phi0 = current.fx;
  const phiPrime0 = dot8(current.fxprime, pk);
  let phi2 = phi0;
  let phi_old = phi0;
  let phiPrime = phiPrime0;
  let a0 = 0;
  a5 = a5 || 1;
  c1 = c1 || 1e-6;
  c22 = c22 || 0.1;
  function zoom(a_lo, a_high, phi_lo) {
    for (let iteration = 0; iteration < 16; ++iteration) {
      a5 = (a_lo + a_high) / 2;
      weightedSum(next.x, 1, current.x, a5, pk);
      phi2 = next.fx = f2(next.x, next.fxprime);
      phiPrime = dot8(next.fxprime, pk);
      if (phi2 > phi0 + c1 * a5 * phiPrime0 || phi2 >= phi_lo) {
        a_high = a5;
      } else {
        if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
          return a5;
        }
        if (phiPrime * (a_high - a_lo) >= 0) {
          a_high = a_lo;
        }
        a_lo = a5;
        phi_lo = phi2;
      }
    }
    return 0;
  }
  for (let iteration = 0; iteration < 10; ++iteration) {
    weightedSum(next.x, 1, current.x, a5, pk);
    phi2 = next.fx = f2(next.x, next.fxprime);
    phiPrime = dot8(next.fxprime, pk);
    if (phi2 > phi0 + c1 * a5 * phiPrime0 || iteration && phi2 >= phi_old) {
      return zoom(a0, a5, phi_old);
    }
    if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
      return a5;
    }
    if (phiPrime >= 0) {
      return zoom(a5, a0, phi2);
    }
    phi_old = phi2;
    a0 = a5;
    a5 *= 2;
  }
  return a5;
}

// node_modules/@antv/g2/esm/data/utils/venn/fmin/conjugateGradient.js
function conjugateGradient(f2, initial, params) {
  let current = { x: initial.slice(), fx: 0, fxprime: initial.slice() };
  let next = { x: initial.slice(), fx: 0, fxprime: initial.slice() };
  const yk = initial.slice();
  let temp;
  let a5 = 1;
  params = params || {};
  const maxIterations = params.maxIterations || initial.length * 20;
  current.fx = f2(current.x, current.fxprime);
  const pk = current.fxprime.slice();
  scale10(pk, current.fxprime, -1);
  for (let i2 = 0; i2 < maxIterations; ++i2) {
    a5 = wolfeLineSearch(f2, pk, current, next, a5);
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a5
      });
    }
    if (!a5) {
      scale10(pk, current.fxprime, -1);
    } else {
      weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
      const delta_k = dot8(current.fxprime, current.fxprime);
      const beta_k = Math.max(0, dot8(yk, next.fxprime) / delta_k);
      weightedSum(pk, beta_k, pk, -1, next.fxprime);
      temp = current;
      current = next;
      next = temp;
    }
    if (norm2(current.fxprime) <= 1e-5) {
      break;
    }
  }
  if (params.history) {
    params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a5
    });
  }
  return current;
}

// node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js
var SMALL = 1e-10;
function intersectionArea(circles, stats) {
  const intersectionPoints = getIntersectionPoints(circles);
  const innerPoints = intersectionPoints.filter(function(p3) {
    return containedInCircles(p3, circles);
  });
  let arcArea = 0, polygonArea = 0, i2;
  const arcs = [];
  if (innerPoints.length > 1) {
    const center2 = getCenter(innerPoints);
    for (i2 = 0; i2 < innerPoints.length; ++i2) {
      const p3 = innerPoints[i2];
      p3.angle = Math.atan2(p3.x - center2.x, p3.y - center2.y);
    }
    innerPoints.sort(function(a5, b) {
      return b.angle - a5.angle;
    });
    let p22 = innerPoints[innerPoints.length - 1];
    for (i2 = 0; i2 < innerPoints.length; ++i2) {
      const p1 = innerPoints[i2];
      polygonArea += (p22.x + p1.x) * (p1.y - p22.y);
      const midPoint2 = { x: (p1.x + p22.x) / 2, y: (p1.y + p22.y) / 2 };
      let arc = null;
      for (let j = 0; j < p1.parentIndex.length; ++j) {
        if (p22.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          const circle3 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle3.x, p1.y - circle3.y), a22 = Math.atan2(p22.x - circle3.x, p22.y - circle3.y);
          let angleDiff = a22 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          const a5 = a22 - angleDiff / 2;
          let width = distance6(midPoint2, {
            x: circle3.x + circle3.radius * Math.sin(a5),
            y: circle3.y + circle3.radius * Math.cos(a5)
          });
          if (width > circle3.radius * 2) {
            width = circle3.radius * 2;
          }
          if (arc === null || arc.width > width) {
            arc = { circle: circle3, width, p1, p2: p22 };
          }
        }
      }
      if (arc !== null) {
        arcs.push(arc);
        arcArea += circleArea(arc.circle.radius, arc.width);
        p22 = p1;
      }
    }
  } else {
    let smallest = circles[0];
    for (i2 = 1; i2 < circles.length; ++i2) {
      if (circles[i2].radius < smallest.radius) {
        smallest = circles[i2];
      }
    }
    let disjoint2 = false;
    for (i2 = 0; i2 < circles.length; ++i2) {
      if (distance6(circles[i2], smallest) > Math.abs(smallest.radius - circles[i2].radius)) {
        disjoint2 = true;
        break;
      }
    }
    if (disjoint2) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point7, circles) {
  for (let i2 = 0; i2 < circles.length; ++i2) {
    if (distance6(point7, circles[i2]) > circles[i2].radius + SMALL) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  const ret = [];
  for (let i2 = 0; i2 < circles.length; ++i2) {
    for (let j = i2 + 1; j < circles.length; ++j) {
      const intersect4 = circleCircleIntersection(circles[i2], circles[j]);
      for (let k2 = 0; k2 < intersect4.length; ++k2) {
        const p3 = intersect4[k2];
        p3.parentIndex = [i2, j];
        ret.push(p3);
      }
    }
  }
  return ret;
}
function circleArea(r2, width) {
  return r2 * r2 * Math.acos(1 - width / r2) - (r2 - width) * Math.sqrt(width * (2 * r2 - width));
}
function distance6(p1, p22) {
  return Math.sqrt((p1.x - p22.x) * (p1.x - p22.x) + (p1.y - p22.y) * (p1.y - p22.y));
}
function circleOverlap(r1, r2, d4) {
  if (d4 >= r1 + r2) {
    return 0;
  }
  if (d4 <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  const w1 = r1 - (d4 * d4 - r2 * r2 + r1 * r1) / (2 * d4), w2 = r2 - (d4 * d4 - r1 * r1 + r2 * r2) / (2 * d4);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p22) {
  const d4 = distance6(p1, p22), r1 = p1.radius, r2 = p22.radius;
  if (d4 >= r1 + r2 || d4 <= Math.abs(r1 - r2)) {
    return [];
  }
  const a5 = (r1 * r1 - r2 * r2 + d4 * d4) / (2 * d4), h2 = Math.sqrt(r1 * r1 - a5 * a5), x05 = p1.x + a5 * (p22.x - p1.x) / d4, y05 = p1.y + a5 * (p22.y - p1.y) / d4, rx = -(p22.y - p1.y) * (h2 / d4), ry = -(p22.x - p1.x) * (h2 / d4);
  return [
    { x: x05 + rx, y: y05 - ry },
    { x: x05 - rx, y: y05 + ry }
  ];
}
function getCenter(points) {
  const center2 = { x: 0, y: 0 };
  for (let i2 = 0; i2 < points.length; ++i2) {
    center2.x += points[i2].x;
    center2.y += points[i2].y;
  }
  center2.x /= points.length;
  center2.y /= points.length;
  return center2;
}

// node_modules/@antv/g2/esm/data/utils/venn/layout.js
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  const initialLayout = parameters.initialLayout || bestInitialLayout;
  const loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  const circles = initialLayout(areas, parameters);
  const initial = [], setids = [];
  let setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial.push(circles[setid].x);
      initial.push(circles[setid].y);
      setids.push(setid);
    }
  }
  const solution = nelderMead(function(values4) {
    const current = {};
    for (let i2 = 0; i2 < setids.length; ++i2) {
      const setid2 = setids[i2];
      current[setid2] = {
        x: values4[2 * i2],
        y: values4[2 * i2 + 1],
        radius: circles[setid2].radius
      };
    }
    return loss(current, areas);
  }, initial, parameters);
  const positions = solution.x;
  for (let i2 = 0; i2 < setids.length; ++i2) {
    setid = setids[i2];
    circles[setid].x = positions[2 * i2];
    circles[setid].y = positions[2 * i2 + 1];
  }
  return circles;
}
var SMALL2 = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL2) {
    return Math.abs(r1 - r2);
  }
  return bisect2(function(distance7) {
    return circleOverlap(r1, r2, distance7) - overlap;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  const ids = [], pairs2 = {};
  let i2, j, a5, b;
  for (i2 = 0; i2 < areas.length; ++i2) {
    const area2 = areas[i2];
    if (area2.sets.length == 1) {
      ids.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a5 = area2.sets[0];
      b = area2.sets[1];
      pairs2[[a5, b]] = true;
      pairs2[[b, a5]] = true;
    }
  }
  ids.sort((a6, b2) => {
    return a6 > b2 ? 1 : -1;
  });
  for (i2 = 0; i2 < ids.length; ++i2) {
    a5 = ids[i2];
    for (j = i2 + 1; j < ids.length; ++j) {
      b = ids[j];
      if (!([a5, b] in pairs2)) {
        areas.push({ sets: [a5, b], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  const distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x3) {
    return x3.sets.length == 2;
  }).map(function(current) {
    const left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance7 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance7;
    let c6 = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c6 = 1;
    } else if (current.size <= 1e-10) {
      c6 = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c6;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x3, fxprime, distances, constraints) {
  let loss = 0, i2;
  for (i2 = 0; i2 < fxprime.length; ++i2) {
    fxprime[i2] = 0;
  }
  for (i2 = 0; i2 < distances.length; ++i2) {
    const xi = x3[2 * i2], yi = x3[2 * i2 + 1];
    for (let j = i2 + 1; j < distances.length; ++j) {
      const xj = x3[2 * j], yj = x3[2 * j + 1], dij = distances[i2][j], constraint = constraints[i2][j];
      const squaredDistance4 = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance7 = Math.sqrt(squaredDistance4), delta = squaredDistance4 - dij * dij;
      if (constraint > 0 && distance7 <= dij || constraint < 0 && distance7 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i2] += 4 * delta * (xi - xj);
      fxprime[2 * i2 + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  let initial = greedyLayout(areas, params);
  const loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    const constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial = constrained;
    }
  }
  return initial;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  const restarts = params.restarts || 10;
  const sets = [], setids = {};
  let i2;
  for (i2 = 0; i2 < areas.length; ++i2) {
    const area2 = areas[i2];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  const matrices = getDistanceMatrices(areas, sets, setids);
  let distances = matrices.distances;
  const constraints = matrices.constraints;
  const norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row2) {
    return row2.map(function(value2) {
      return value2 / norm;
    });
  });
  const obj = function(x3, fxprime) {
    return constrainedMDSGradient(x3, fxprime, distances, constraints);
  };
  let best, current;
  for (i2 = 0; i2 < restarts; ++i2) {
    const initial = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  const positions = best.x;
  const circles = {};
  for (i2 = 0; i2 < sets.length; ++i2) {
    const set10 = sets[i2];
    circles[set10.sets[0]] = {
      x: positions[2 * i2] * norm,
      y: positions[2 * i2 + 1] * norm,
      radius: Math.sqrt(set10.size / Math.PI)
    };
  }
  if (params.history) {
    for (i2 = 0; i2 < params.history.length; ++i2) {
      scale10(params.history[i2].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  const circles = {}, setOverlaps = {};
  let set10;
  for (let i2 = 0; i2 < areas.length; ++i2) {
    const area2 = areas[i2];
    if (area2.sets.length == 1) {
      set10 = area2.sets[0];
      circles[set10] = {
        x: 1e10,
        y: 1e10,
        // rowid: circles.length, // fix to ->
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set10] = [];
    }
  }
  areas = areas.filter(function(a5) {
    return a5.sets.length == 2;
  });
  for (let i2 = 0; i2 < areas.length; ++i2) {
    const current = areas[i2];
    let weight2 = current.hasOwnProperty("weight") ? current.weight : 1;
    const left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL2 >= Math.min(circles[left2].size, circles[right2].size)) {
      weight2 = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight: weight2 });
    setOverlaps[right2].push({ set: left2, size: current.size, weight: weight2 });
  }
  const mostOverlapped = [];
  for (set10 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set10)) {
      let size3 = 0;
      for (let i2 = 0; i2 < setOverlaps[set10].length; ++i2) {
        size3 += setOverlaps[set10][i2].size * setOverlaps[set10][i2].weight;
      }
      mostOverlapped.push({ set: set10, size: size3 });
    }
  }
  function sortOrder(a5, b) {
    return b.size - a5.size;
  }
  mostOverlapped.sort(sortOrder);
  const positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point7, index3) {
    circles[index3].x = point7.x;
    circles[index3].y = point7.y;
    positioned[index3] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (let i2 = 1; i2 < mostOverlapped.length; ++i2) {
    const setIndex = mostOverlapped[i2].set, overlap = setOverlaps[setIndex].filter(isPositioned);
    set10 = circles[setIndex];
    overlap.sort(sortOrder);
    if (overlap.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    const points = [];
    for (let j = 0; j < overlap.length; ++j) {
      const p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set10.radius, p1.radius, overlap[j].size);
      points.push({ x: p1.x + d1, y: p1.y });
      points.push({ x: p1.x - d1, y: p1.y });
      points.push({ y: p1.y + d1, x: p1.x });
      points.push({ y: p1.y - d1, x: p1.x });
      for (let k2 = j + 1; k2 < overlap.length; ++k2) {
        const p22 = circles[overlap[k2].set], d22 = distanceFromIntersectArea(set10.radius, p22.radius, overlap[k2].size);
        const extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p22.x, y: p22.y, radius: d22 });
        for (let l2 = 0; l2 < extraPoints.length; ++l2) {
          points.push(extraPoints[l2]);
        }
      }
    }
    let bestLoss = 1e50, bestPoint = points[0];
    for (let j = 0; j < points.length; ++j) {
      circles[setIndex].x = points[j].x;
      circles[setIndex].y = points[j].y;
      const localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points[j];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  let output = 0;
  function getCircles(indices) {
    return indices.map(function(i2) {
      return sets[i2];
    });
  }
  for (let i2 = 0; i2 < overlaps.length; ++i2) {
    const area2 = overlaps[i2];
    let overlap;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      const left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap = circleOverlap(left2.radius, right2.radius, distance6(left2, right2));
    } else {
      overlap = intersectionArea(getCircles(area2.sets));
    }
    const weight2 = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output += weight2 * (overlap - area2.size) * (overlap - area2.size);
  }
  return output;
}
function getBoundingBox(circles) {
  const minMax = function(d4) {
    const hi = Math.max.apply(null, circles.map(function(c6) {
      return c6[d4] + c6.radius;
    })), lo = Math.min.apply(null, circles.map(function(c6) {
      return c6[d4] - c6.radius;
    }));
    return { max: hi, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding) {
  const circles = [], setids = [];
  for (const setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding;
  height -= 2 * padding;
  const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  const scaled = {};
  for (let i2 = 0; i2 < circles.length; ++i2) {
    const circle3 = circles[i2];
    scaled[setids[i2]] = {
      radius: scaling * circle3.radius,
      x: padding + xOffset + (circle3.x - xRange.min) * scaling,
      y: padding + yOffset + (circle3.y - yRange.min) * scaling
    };
  }
  return scaled;
}

// node_modules/@antv/g2/esm/data/utils/venn/diagram.js
function circlePath(x3, y4, r2) {
  const ret = [];
  const x05 = x3 - r2;
  const y05 = y4;
  ret.push("M", x05, y05);
  ret.push("A", r2, r2, 0, 1, 0, x05 + 2 * r2, y05);
  ret.push("A", r2, r2, 0, 1, 0, x05, y05);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  const stats = {};
  intersectionArea(circles, stats);
  const arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    const circle3 = arcs[0].circle;
    return circlePath(circle3.x, circle3.y, circle3.radius);
  } else {
    const ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (let i2 = 0; i2 < arcs.length; ++i2) {
      const arc = arcs[i2], r2 = arc.circle.radius, wide = arc.width > r2;
      ret.push("\nA", r2, r2, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
    }
    return ret.join(" ");
  }
}

// node_modules/@antv/g2/esm/data/venn.js
var Venn = (options) => {
  const { sets = "sets", size: size3 = "size", as = ["key", "path"], padding = 0 } = options;
  const [key, path2] = as;
  return (data2) => {
    const vennData = data2.map((d4) => Object.assign(Object.assign({}, d4), { sets: d4[sets], size: d4[size3], [key]: d4.sets.join("&") }));
    vennData.sort((a5, b) => a5.sets.length - b.sets.length);
    const solution = venn(vennData);
    let circles;
    return vennData.map((datum) => {
      const setsValue = datum[sets];
      const pathFunc = ({ width, height }) => {
        circles = circles ? circles : scaleSolution(solution, width, height, padding);
        const setCircles = setsValue.map((set10) => circles[set10]);
        let p3 = intersectionAreaPath(setCircles);
        if (!/[zZ]$/.test(p3))
          p3 += " Z";
        return p3;
      };
      return Object.assign(Object.assign({}, datum), { [path2]: pathFunc });
    });
  };
};
Venn.props = {};

// node_modules/@antv/g2/esm/data/log.js
var Log3 = () => {
  return (data2) => {
    console.log("G2 data section:", data2);
    return data2;
  };
};
Log3.props = {};

// node_modules/@antv/g2/esm/data/ema.js
function ema(values4, alpha) {
  if (alpha < 0 || alpha > 1) {
    throw new Error("alpha must be between 0 and 1.");
  }
  if (values4.length === 0) {
    return [];
  }
  let last5 = values4[0];
  const smoothed = [];
  for (const point7 of values4) {
    if (point7 === null || point7 === void 0) {
      smoothed.push(point7);
      console.warn("EMAThe value is null or undefined", values4);
      continue;
    }
    if (last5 === null || last5 === void 0) {
      last5 = point7;
    }
    const smoothedVal = last5 * alpha + (1 - alpha) * point7;
    smoothed.push(smoothedVal);
    last5 = smoothedVal;
  }
  return smoothed;
}
var EMA = (options) => {
  const { field: field3 = "y", alpha = 0.6, as = field3 } = options;
  return (data2) => {
    const values4 = data2.map((d4) => {
      return d4[field3];
    });
    const out = ema(values4, alpha);
    return data2.map((d4, i2) => {
      return Object.assign(Object.assign({}, d4), { [as]: out[i2] });
    });
  };
};
EMA.props = {};

// node_modules/@antv/g2/esm/utils/bounds.js
var EPSILON3 = 0.01;
function parseAABB(min22) {
  const { min: min10, max: max11 } = min22;
  return [
    [min10[0], min10[1]],
    [max11[0], max11[1]]
  ];
}
function isInBounds(point7, bounds, threshold = EPSILON3) {
  const [x3, y4] = point7;
  const [min10, max11] = bounds;
  return x3 >= min10[0] - threshold && x3 <= max11[0] + threshold && y4 >= min10[1] - threshold && y4 <= max11[1] + threshold;
}
function isOverflow(b1, b2, threshold = EPSILON3) {
  const [min10, max11] = b1;
  return !(isInBounds(min10, b2, threshold) && isInBounds(max11, b2, threshold));
}
function isOverlap(b1, b2) {
  const [min1, max1] = b1;
  const [min22, max22] = b2;
  return min1[0] < max22[0] && max1[0] > min22[0] && min1[1] < max22[1] && max1[1] > min22[1];
}

// node_modules/@antv/g2/esm/label-transform/overlapHide.js
var OverlapHide = (options) => {
  const { priority } = options;
  return (labels) => {
    const displayLabels = [];
    if (priority)
      labels.sort(priority);
    labels.forEach((l2) => {
      show2(l2);
      const b1 = l2.getLocalBounds();
      const overlaping = displayLabels.some((dl) => isOverlap(parseAABB(b1), parseAABB(dl.getLocalBounds())));
      if (overlaping)
        hide2(l2);
      else
        displayLabels.push(l2);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overlapDodgeY.js
function isSegmentIntersect([a5, b], [c6, d4]) {
  return d4 > a5 && b > c6;
}
function useMap() {
  const map5 = /* @__PURE__ */ new Map();
  const get4 = (key) => map5.get(key);
  const set10 = (key, value2) => map5.set(key, value2);
  return [get4, set10];
}
function getBoundsWithoutConnector(shape23) {
  const node = shape23.cloneNode(true);
  const connectorShape = node.getElementById("connector");
  connectorShape && node.removeChild(connectorShape);
  const { min: min10, max: max11 } = node.getRenderBounds();
  node.destroy();
  return { min: min10, max: max11 };
}
var OverlapDodgeY = (options) => {
  const { maxIterations = 10, maxError = 0.1, padding = 1 } = options;
  return (labels) => {
    const n2 = labels.length;
    if (n2 <= 1)
      return labels;
    const [y05, setY0] = useMap();
    const [y4, setY] = useMap();
    const [h2, setH] = useMap();
    const [xx, setXX] = useMap();
    for (const label of labels) {
      const { min: min10, max: max11 } = getBoundsWithoutConnector(label);
      const [x05, y06] = min10;
      const [x12, y12] = max11;
      setY0(label, y06);
      setY(label, y06);
      setH(label, y12 - y06);
      setXX(label, [x05, x12]);
    }
    for (let iter = 0; iter < maxIterations; iter++) {
      labels.sort((a5, b) => ascending(y4(a5), y4(b)));
      let error3 = 0;
      for (let i2 = 0; i2 < n2 - 1; i2++) {
        const l0 = labels[i2];
        let j = i2 + 1;
        let l1;
        while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1)))
          j += 1;
        if (l1) {
          const y06 = y4(l0);
          const h0 = h2(l0);
          const y12 = y4(l1);
          const delta = y12 - (y06 + h0);
          if (delta < padding) {
            const newDelta = (padding - delta) / 2;
            error3 = Math.max(error3, newDelta);
            setY(l0, y06 - newDelta);
            setY(l1, y12 + newDelta);
          }
        }
      }
      if (error3 < maxError)
        break;
    }
    for (const label of labels) {
      label.style.y += y4(label) - y05(label);
    }
    return labels;
  };
};

// node_modules/@antv/g2/esm/utils/color.js
function parseToRGB(c6) {
  if (typeof c6 === "object")
    return c6;
  return parseColor(c6);
}

// node_modules/@antv/g2/esm/label-transform/utils.js
function getsRGB(s4) {
  let c6 = s4 / 255;
  c6 = c6 <= 0.03928 ? c6 / 12.92 : Math.pow((c6 + 0.055) / 1.055, 2.4);
  return c6;
}
function getL(r2, g, b) {
  return 0.2126 * getsRGB(r2) + 0.7152 * getsRGB(g) + 0.0722 * getsRGB(b);
}
function contrast(foreground, background) {
  if (!foreground || !background || foreground === background)
    return 1;
  const { r: r2, g, b } = foreground;
  const { r: rb, g: gb, b: bb } = background;
  const L1 = getL(r2, g, b);
  const L2 = getL(rb, gb, bb);
  return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}
function mostContrast(color3, palette) {
  const i2 = maxIndex(palette, (c6) => contrast(color3, parseToRGB(c6)));
  return palette[i2];
}

// node_modules/@antv/g2/esm/label-transform/contrastReverse.js
var ContrastReverse = (options) => {
  const { threshold = 4.5, palette = ["#000", "#fff"] } = options;
  return (labels) => {
    labels.forEach((l2) => {
      const background = l2.attr("dependentElement").parsedStyle.fill;
      const foreground = l2.parsedStyle.fill;
      const c6 = contrast(foreground, background);
      if (c6 < threshold)
        l2.attr("fill", mostContrast(background, palette));
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overflowHide.js
var OverflowHide = () => {
  return (labels) => {
    labels.forEach((l2) => {
      show2(l2);
      const bounds = l2.attr("bounds");
      const b = l2.getLocalBounds();
      const overflow = isOverflow(parseAABB(b), bounds);
      if (overflow)
        hide2(l2);
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/exceedAdjust.js
var adjustPosition = (target, edge) => {
  const [[minEdgeX, minEdgeY], [maxEdgeX, maxEdgeY]] = edge;
  const [[minX, minY], [maxX, maxY2]] = target;
  let changeX = 0, changeY = 0;
  if (minX < minEdgeX) {
    changeX = minEdgeX - minX;
  } else if (maxX > maxEdgeX) {
    changeX = maxEdgeX - maxX;
  }
  if (minY < minEdgeY) {
    changeY = minEdgeY - minY;
  } else if (maxY2 > maxEdgeY) {
    changeY = maxEdgeY - maxY2;
  }
  return [changeX, changeY];
};
var ExceedAdjust = (options = {}) => {
  return (labels, { canvas, layout }) => {
    const { bounds = "view", offsetX = 0, offsetY = 0 } = options;
    const getBoundaryArea = () => {
      if (bounds === "main") {
        const { x: x3 = 0, y: y4 = 0, width = 0, height = 0, marginLeft = 0, marginRight = 0, marginTop = 0, marginBottom = 0, paddingLeft = 0, paddingRight = 0, paddingTop = 0, paddingBottom = 0 } = layout;
        return [
          [
            x3 + marginLeft + paddingLeft + offsetX,
            y4 + marginTop + paddingTop + offsetY
          ],
          [
            x3 + width - marginRight - paddingRight - offsetX,
            y4 + height - marginBottom - paddingBottom - offsetY
          ]
        ];
      } else {
        const { x: x3 = 0, y: y4 = 0, width = 0, height = 0 } = layout;
        return [
          [x3 + offsetX, y4 + offsetY],
          [x3 + width - offsetX, y4 + height - offsetY]
        ];
      }
    };
    const boundaryArea = getBoundaryArea();
    labels.forEach((l2) => {
      show2(l2);
      const { max: max11, min: min10 } = l2.getRenderBounds();
      const [xMax, yMax] = max11, [xMin, yMin] = min10;
      const changeValue = adjustPosition(
        [
          [xMin, yMin],
          [xMax, yMax]
        ],
        // Use the calculated boundary area based on bounds configuration
        boundaryArea
      );
      if (l2.style.connector && l2.style.connectorPoints) {
        l2.style.connectorPoints[0][0] -= changeValue[0];
        l2.style.connectorPoints[0][1] -= changeValue[1];
      }
      l2.style.x += changeValue[0];
      l2.style.y += changeValue[1];
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/label-transform/overflowStroke.js
function getBoundsWithAnimation(element) {
  var _a2;
  const animations = element.getAnimations();
  if (!animations || animations.length === 0) {
    return bboxOf(element);
  }
  const cloneElement = element.cloneNode(true);
  cloneElement.style.visibility = "hidden";
  animations.forEach((animation) => {
    const keyframes = animation.effect.getKeyframes();
    if (keyframes && keyframes.length > 0) {
      cloneElement.attr(keyframes[keyframes.length - 1]);
    }
  });
  (_a2 = element.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(cloneElement);
  const bounds = bboxOf(cloneElement);
  cloneElement.destroy();
  return bounds;
}
var OverflowStroke = (options) => {
  const { palette = ["#000", "#fff"], threshold = 2 } = options;
  return (labels) => {
    labels.forEach((l2) => {
      var _a2, _b;
      const dependentElement = l2.attr("dependentElement");
      const labelFill = (_b = (_a2 = l2.attributes.fill) !== null && _a2 !== void 0 ? _a2 : l2.parsedStyle.fill) !== null && _b !== void 0 ? _b : "#fff";
      const textBounds = parseAABB(getBoundsWithAnimation(l2));
      const elementBounds = parseAABB(getBoundsWithAnimation(dependentElement));
      if (isOverflow(textBounds, elementBounds, threshold)) {
        const strokeColor = mostContrast(parseToRGB(labelFill), palette);
        l2.attr("stroke", strokeColor);
      } else {
        l2.removeAttribute("stroke");
      }
    });
    return labels;
  };
};

// node_modules/@antv/g2/esm/lib/core.js
function corelib() {
  return {
    "data.fetch": Fetch,
    "data.inline": Inline,
    "data.sortBy": SortBy,
    "data.sort": Sort2,
    "data.filter": Filter2,
    "data.pick": Pick,
    "data.rename": Rename,
    "data.fold": Fold,
    "data.slice": Slice,
    "data.custom": Custom,
    "data.map": Map2,
    "data.join": Join,
    "data.kde": KDE,
    "data.log": Log3,
    "data.wordCloud": WordCloud2,
    "data.ema": EMA,
    "transform.stackY": StackY,
    "transform.binX": BinX,
    "transform.bin": Bin,
    "transform.dodgeX": DodgeX,
    "transform.jitter": Jitter,
    "transform.jitterX": JitterX,
    "transform.jitterY": JitterY,
    "transform.symmetryY": SymmetryY,
    "transform.diffY": DiffY,
    "transform.stackEnter": StackEnter,
    "transform.normalizeY": NormalizeY,
    "transform.select": Select,
    "transform.selectX": SelectX,
    "transform.selectY": SelectY,
    "transform.groupX": GroupX,
    "transform.groupY": GroupY,
    "transform.groupColor": GroupColor,
    "transform.group": Group,
    "transform.sortX": SortX,
    "transform.sortY": SortY,
    "transform.sortColor": SortColor,
    "transform.flexX": FlexX,
    "transform.pack": Pack,
    "transform.sample": Sample,
    "transform.filter": Filter,
    "coordinate.cartesian": Cartesian,
    "coordinate.polar": Polar,
    "coordinate.transpose": Transpose,
    "coordinate.theta": Theta,
    "coordinate.parallel": Parallel,
    "coordinate.fisheye": Fisheye,
    "coordinate.radial": Radial,
    "coordinate.radar": Radar,
    "coordinate.helix": Helix,
    "encode.constant": Constant,
    "encode.field": Field,
    "encode.transform": Transform,
    "encode.column": Column,
    "mark.interval": Interval,
    "mark.rect": Rect3,
    "mark.line": Line5,
    "mark.point": Point4,
    "mark.text": Text4,
    "mark.cell": Cell,
    "mark.area": Area2,
    "mark.link": Link2,
    "mark.image": Image4,
    "mark.polygon": Polygon3,
    "mark.box": Box2,
    "mark.vector": Vector2,
    "mark.lineX": LineX,
    "mark.lineY": LineY,
    "mark.connector": Connector2,
    "mark.range": Range2,
    "mark.rangeX": RangeX,
    "mark.rangeY": RangeY,
    "mark.path": Path4,
    "mark.shape": Shape3,
    "mark.density": Density2,
    "mark.heatmap": Heatmap2,
    "mark.wordCloud": WordCloud,
    "palette.category10": Category10,
    "palette.category20": Category20,
    "scale.linear": Linear3,
    "scale.ordinal": Ordinal2,
    "scale.band": Band2,
    "scale.identity": Identity2,
    "scale.point": Point5,
    "scale.time": Time2,
    "scale.log": Log2,
    "scale.pow": Pow2,
    "scale.sqrt": Sqrt2,
    "scale.threshold": Threshold2,
    "scale.quantile": Quantile2,
    "scale.quantize": Quantize2,
    "scale.sequential": Sequential3,
    "scale.constant": Constant3,
    "theme.classic": Classic,
    "theme.classicDark": ClassicDark,
    "theme.academy": Academy,
    "theme.light": Light,
    "theme.dark": Dark,
    "component.axisX": AxisX,
    "component.axisY": AxisY,
    "component.legendCategory": LegendCategory,
    "component.legendContinuous": LegendContinuous,
    "component.legends": Legends,
    "component.title": TitleComponent,
    "component.sliderX": SliderX,
    "component.sliderY": SliderY,
    "component.scrollbarX": ScrollbarX,
    "component.scrollbarY": ScrollbarY,
    "animation.scaleInX": ScaleInX,
    "animation.scaleOutX": ScaleOutX,
    "animation.scaleInY": ScaleInY,
    "animation.scaleOutY": ScaleOutY,
    "animation.waveIn": WaveIn,
    "animation.fadeIn": FadeIn,
    "animation.fadeOut": FadeOut,
    "animation.zoomIn": ZoomIn,
    "animation.zoomOut": ZoomOut,
    "animation.pathIn": PathIn,
    "animation.morphing": Morphing,
    "animation.growInX": GrowInX,
    "animation.growInY": GrowInY,
    "interaction.elementHighlight": ElementHighlight,
    "interaction.elementHighlightByX": ElementHighlightByX,
    "interaction.elementHighlightByColor": ElementHighlightByColor,
    "interaction.elementSelect": ElementSelect,
    "interaction.elementSelectByX": ElementSelectByX,
    "interaction.elementSelectByColor": ElementSelectByColor,
    "interaction.fisheye": Fisheye2,
    "interaction.chartIndex": ChartIndex,
    "interaction.tooltip": Tooltip2,
    "interaction.legendFilter": LegendFilter,
    "interaction.legendHighlight": LegendHighlight,
    "interaction.brushHighlight": BrushHighlight,
    "interaction.brushXHighlight": BrushXHighlight,
    "interaction.brushYHighlight": BrushYHighlight,
    "interaction.brushAxisHighlight": BrushAxisHighlight,
    "interaction.brushFilter": BrushFilter,
    "interaction.brushXFilter": BrushXFilter,
    "interaction.brushYFilter": BrushYFilter,
    "interaction.sliderFilter": SliderFilter,
    "interaction.scrollbarFilter": ScrollbarFilter,
    "interaction.poptip": Poptip2,
    "interaction.treemapDrillDown": TreemapDrillDown,
    "interaction.elementPointMove": ElementPointMove,
    "composition.spaceLayer": SpaceLayer,
    "composition.spaceFlex": SpaceFlex,
    "composition.facetRect": FacetRect,
    "composition.repeatMatrix": RepeatMatrix,
    "composition.facetCircle": FacetCircle,
    "composition.timingKeyframe": TimingKeyframe,
    "labelTransform.overlapHide": OverlapHide,
    "labelTransform.overlapDodgeY": OverlapDodgeY,
    "labelTransform.overflowHide": OverflowHide,
    "labelTransform.contrastReverse": ContrastReverse,
    "labelTransform.overflowStroke": OverflowStroke,
    "labelTransform.exceedAdjust": ExceedAdjust
  };
}

// node_modules/@antv/g2/esm/lib/geo.js
function geolib() {
  return {
    "composition.geoView": GeoView,
    "composition.geoPath": GeoPath
  };
}

// node_modules/@antv/g2/esm/lib/graph.js
function graphlib() {
  return {
    "data.arc": Arc3,
    "data.cluster": Cluster,
    "mark.forceGraph": ForceGraph,
    "mark.tree": Tree2,
    "mark.pack": Pack2,
    "mark.sankey": Sankey3,
    "mark.chord": Chord,
    "mark.treemap": Treemap
  };
}

// node_modules/@antv/g2/esm/lib/plot.js
function plotlib() {
  return {
    "data.venn": Venn,
    "mark.boxplot": Boxplot,
    "mark.gauge": Gauge,
    "mark.wordCloud": WordCloud,
    "mark.liquid": Liquid2
  };
}

// node_modules/@antv/g2/esm/lib/std.js
function stdlib() {
  return Object.assign(Object.assign(Object.assign(Object.assign({}, geolib()), graphlib()), plotlib()), corelib());
}

// node_modules/@antv/g2/esm/lib/lite.js
function litelib() {
  return {
    "data.inline": Inline,
    "coordinate.cartesian": Cartesian,
    "encode.constant": Constant,
    "encode.field": Field,
    "encode.transform": Transform,
    "encode.column": Column,
    "mark.interval": Interval,
    "shape.label.label": Label,
    "palette.category10": Category10,
    "palette.category20": Category20,
    "scale.linear": Linear3,
    "scale.ordinal": Ordinal2,
    "scale.band": Band2,
    "scale.identity": Identity2,
    "scale.point": Point5,
    "scale.time": Time2,
    "scale.log": Log2,
    "scale.pow": Pow2,
    "scale.sqrt": Sqrt2,
    "scale.threshold": Threshold2,
    "scale.quantile": Quantile2,
    "scale.quantize": Quantize2,
    "scale.sequential": Sequential3,
    "scale.constant": Constant3,
    "theme.classic": Classic,
    "component.axisX": AxisX,
    "component.axisY": AxisY,
    "component.axisRadar": AxisRadar,
    "component.axisLinear": LinearAxis,
    "component.axisArc": ArcAxis,
    "component.legendCategory": LegendCategory,
    "component.legendContinuous": LegendContinuous,
    "component.legendContinuousBlock": LegendContinuousBlock,
    "component.legendContinuousBlockSize": LegendContinuousBlockSize,
    "component.legendContinuousSize": LegendContinuousSize,
    "component.legends": Legends,
    "component.title": TitleComponent,
    "component.sliderX": SliderX,
    "component.sliderY": SliderY,
    "component.scrollbarX": ScrollbarX,
    "component.scrollbarY": ScrollbarY,
    "animation.scaleInX": ScaleInX,
    "animation.scaleOutX": ScaleOutX,
    "animation.scaleInY": ScaleInY,
    "animation.scaleOutY": ScaleOutY,
    "animation.waveIn": WaveIn,
    "animation.fadeIn": FadeIn,
    "animation.fadeOut": FadeOut,
    "animation.morphing": Morphing,
    "interaction.tooltip": Tooltip2,
    "interaction.legendFilter": LegendFilter,
    "interaction.legendHighlight": LegendHighlight,
    "interaction.sliderFilter": SliderFilter,
    "interaction.scrollbarFilter": ScrollbarFilter,
    "interaction.poptip": Poptip2,
    "interaction.event": Event2,
    "composition.mark": Mark,
    "composition.view": View
  };
}

// node_modules/@antv/g2/esm/api/extend.js
function extend5(Runtime2, library3) {
  class Chart4 extends Runtime2 {
    constructor(options) {
      super(Object.assign(Object.assign({}, options), { lib: library3 }));
    }
  }
  return Chart4;
}

// node_modules/@antv/g2/esm/api/library.js
var library = {};
function register(key, component) {
  if (key.startsWith("symbol."))
    registerSymbol(key.split(".").pop(), component);
  else
    Object.assign(library, { [key]: component });
}

// node_modules/@antv/g2/esm/utils/size.js
var parseInt10 = (d4) => d4 ? parseInt(d4) : 0;
function getContainerSize(container) {
  const style = getComputedStyle(container);
  const wrapperWidth = container.clientWidth || parseInt10(style.width);
  const wrapperHeight = container.clientHeight || parseInt10(style.height);
  const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
  const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
  return {
    width: wrapperWidth - widthPadding,
    height: wrapperHeight - heightPadding
  };
}

// node_modules/@antv/g2/esm/api/node.js
function bfs(node, callback) {
  const discovered = [node];
  while (discovered.length) {
    const currentNode = discovered.shift();
    callback && callback(currentNode);
    const children = currentNode.children || [];
    for (const child of children) {
      discovered.push(child);
    }
  }
}
var Node4 = class {
  constructor(value2 = {}, type) {
    this.parentNode = null;
    this.children = [];
    this.index = 0;
    this.type = type;
    this.value = value2;
  }
  /**
   * Apply specified transform to current value. Mount the node
   * to replace the original one in the tree and then return it.
   */
  map(transform2 = (x3) => x3) {
    const newValue = transform2(this.value);
    this.value = newValue;
    return this;
  }
  /**
   * Set or get the specified attribute. It the value is specified, update
   * the attribute of current value and return the node. Otherwise
   * return the the attribute of current value.
   */
  attr(key, value2) {
    if (arguments.length === 1)
      return this.value[key];
    return this.map((v) => (v[key] = value2, v));
  }
  /**
   * Create a new node and append to children nodes.
   */
  append(Ctor) {
    const node = new Ctor({});
    node.children = [];
    this.push(node);
    return node;
  }
  push(node) {
    node.parentNode = this;
    node.index = this.children.length;
    this.children.push(node);
    return this;
  }
  /**
   * Remove current node from parentNode.
   */
  remove() {
    const parent = this.parentNode;
    if (parent) {
      const { children } = parent;
      const index3 = children.findIndex((item) => item === this);
      children.splice(index3, 1);
    }
    return this;
  }
  getNodeByKey(key) {
    let targetNode = null;
    const callback = (node) => {
      if (key === node.attr("key")) {
        targetNode = node;
      }
    };
    bfs(this, callback);
    return targetNode;
  }
  getNodesByType(type) {
    const nodes = [];
    const callback = (node) => {
      if (type === node.type) {
        nodes.push(node);
      }
    };
    bfs(this, callback);
    return nodes;
  }
  getNodeByType(type) {
    let node = null;
    bfs(this, (current) => {
      if (node)
        return;
      if (type === current.type)
        node = current;
    });
    return node;
  }
  /**
   * Apply specified callback to the node value.
   */
  call(callback, ...params) {
    callback(this.map(), ...params);
    return this;
  }
  getRoot() {
    let root2 = this;
    while (root2 && root2.parentNode) {
      root2 = root2.parentNode;
    }
    return root2;
  }
};

// node_modules/@antv/g2/esm/api/utils.js
var __rest88 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var VIEW_KEYS = [
  "width",
  "height",
  "depth",
  "padding",
  "paddingLeft",
  "paddingRight",
  "paddingBottom",
  "paddingTop",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "margin",
  "marginLeft",
  "marginRight",
  "marginTop",
  "marginBottom",
  "autoFit",
  "theme",
  "title",
  "interaction"
];
var REMOVE_FLAG = "__remove__";
var CALLBACK_NODE = "__callback__";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
function normalizeContainer2(container) {
  if (container === void 0) {
    const container2 = document.createElement("div");
    container2[REMOVE_FLAG] = true;
    return container2;
  }
  if (typeof container === "string") {
    const node = document.getElementById(container);
    return node;
  }
  return container;
}
function removeContainer(container) {
  const parent = container.parentNode;
  if (parent) {
    parent.removeChild(container);
  }
}
function normalizeRoot(node) {
  if (node.type !== null)
    return node;
  const root2 = node.children[node.children.length - 1];
  for (const key of VIEW_KEYS)
    root2.attr(key, node.attr(key));
  return root2;
}
function valueOf3(node) {
  return Object.assign(Object.assign({}, node.value), { type: node.type });
}
function sizeOf2(options, container) {
  const { width, height, autoFit, depth = 0 } = options;
  let effectiveWidth = 640;
  let effectiveHeight = 480;
  if (autoFit) {
    const { width: containerWidth, height: containerHeight } = getContainerSize(container);
    effectiveWidth = containerWidth || effectiveWidth;
    effectiveHeight = containerHeight || effectiveHeight;
  }
  effectiveWidth = width || effectiveWidth;
  effectiveHeight = height || effectiveHeight;
  return {
    width: Math.max(isNumber(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),
    depth
  };
}
function optionsOf(node) {
  const root2 = normalizeRoot(node);
  const discovered = [root2];
  const nodeValue = /* @__PURE__ */ new Map();
  nodeValue.set(root2, valueOf3(root2));
  while (discovered.length) {
    const node2 = discovered.pop();
    const value2 = nodeValue.get(node2);
    const { children = [] } = node2;
    for (const child of children) {
      if (child.type === CALLBACK_NODE) {
        value2.children = child.value;
      } else {
        const childValue = valueOf3(child);
        const { children: children2 = [] } = value2;
        children2.push(childValue);
        discovered.push(child);
        nodeValue.set(child, childValue);
        value2.children = children2;
      }
    }
  }
  return nodeValue.get(root2);
}
function isMark(type, mark2) {
  if (typeof type === "function")
    return true;
  return new Set(Object.keys(mark2)).has(type);
}
function isComposition(type, composition) {
  return typeof type !== "function" && new Set(Object.keys(composition)).has(type);
}
function normalizeRootOptions(node, options, previousType, marks, composition) {
  const { type: oldType } = node;
  const { type = previousType || oldType } = options;
  if (isComposition(type, composition)) {
    for (const key of VIEW_KEYS) {
      if (node.attr(key) !== void 0 && options[key] === void 0) {
        options[key] = node.attr(key);
      }
    }
    return options;
  }
  if (isMark(type, marks)) {
    const view = { type: "view" };
    const mark2 = Object.assign({}, options);
    for (const key of VIEW_KEYS) {
      if (mark2[key] !== void 0) {
        view[key] = mark2[key];
        delete mark2[key];
      }
    }
    return Object.assign(Object.assign({}, view), { children: [mark2] });
  }
  return options;
}
function typeCtor(type, mark2, composition) {
  if (typeof type === "function")
    return mark2.mark;
  const node = Object.assign(Object.assign({}, mark2), composition);
  const ctor = node[type];
  if (!ctor)
    throw new Error(`Unknown mark: ${type}.`);
  return ctor;
}
function createNode(options, mark2, composition) {
  if (typeof options === "function") {
    const node2 = new Node4();
    node2.value = options;
    node2.type = CALLBACK_NODE;
    return node2;
  }
  const { type, children } = options, value2 = __rest88(options, ["type", "children"]);
  const Ctor = typeCtor(type, mark2, composition);
  const node = new Ctor();
  node.value = value2;
  node.type = type;
  return node;
}
function updateNode(node, newOptions) {
  const { type, children } = newOptions, value2 = __rest88(newOptions, ["type", "children"]);
  if (node.type === type || type === void 0) {
    deepAssign(node.value, value2);
  } else if (typeof type === "string") {
    node.type = type;
    node.value = value2;
  }
}
function appendNode(parent, newOptions, mark2, composition) {
  if (!parent)
    return;
  const discovered = [[parent, newOptions]];
  while (discovered.length) {
    const [parent2, nodeOptions] = discovered.shift();
    const node = createNode(nodeOptions, mark2, composition);
    if (Array.isArray(parent2.children))
      parent2.push(node);
    const { children } = nodeOptions;
    if (Array.isArray(children)) {
      for (const child of children) {
        discovered.push([node, child]);
      }
    } else if (typeof children === "function") {
      discovered.push([node, children]);
    }
  }
}
function updateRoot(node, options, definedType, mark2, composition) {
  const rootOptions = normalizeRootOptions(node, options, definedType, mark2, composition);
  const discovered = [[null, node, rootOptions]];
  while (discovered.length) {
    const [parent, oldNode, newNode] = discovered.shift();
    if (!oldNode) {
      appendNode(parent, newNode, mark2, composition);
    } else if (!newNode) {
      oldNode.remove();
    } else {
      updateNode(oldNode, newNode);
      const { children: newChildren } = newNode;
      const { children: oldChildren } = oldNode;
      if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {
        const n2 = Math.max(newChildren.length, oldChildren.length);
        for (let i2 = 0; i2 < n2; i2++) {
          const newChild = newChildren[i2];
          const oldChild = oldChildren[i2];
          discovered.push([oldNode, oldChild, newChild]);
        }
      } else if (typeof newChildren === "function") {
        discovered.push([oldNode, null, newChildren]);
      }
    }
  }
}
function createEmptyPromise() {
  let reject;
  let resolve;
  const cloned = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return [cloned, resolve, reject];
}

// node_modules/@antv/g2/esm/api/define.js
function defineValueProp(Node5, name2, { key = name2 }) {
  Node5.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    return this.attr(key, value2);
  };
}
function defineArrayProp(Node5, name2, { key = name2 }) {
  Node5.prototype[name2] = function(value2) {
    if (arguments.length === 0)
      return this.attr(key);
    if (Array.isArray(value2))
      return this.attr(key, value2);
    const array2 = [...this.attr(key) || [], value2];
    return this.attr(key, array2);
  };
}
function defineObjectProp(Node5, name2, { key: k2 = name2 }) {
  Node5.prototype[name2] = function(key, value2) {
    if (arguments.length === 0)
      return this.attr(k2);
    if (arguments.length === 1 && typeof key !== "string") {
      return this.attr(k2, key);
    }
    const obj = this.attr(k2) || {};
    obj[key] = arguments.length === 1 ? true : value2;
    return this.attr(k2, obj);
  };
}
function defineMixProp(Node5, name2, descriptor) {
  Node5.prototype[name2] = function(key) {
    if (arguments.length === 0)
      return this.attr(name2);
    if (Array.isArray(key))
      return this.attr(name2, { items: key });
    if (isStrictObject(key) && (key.title !== void 0 || key.items !== void 0)) {
      return this.attr(name2, key);
    }
    if (key === null || key === false)
      return this.attr(name2, key);
    const obj = this.attr(name2) || {};
    const { items = [] } = obj;
    items.push(key);
    obj.items = items;
    return this.attr(name2, obj);
  };
}
function defineNodeProp(Node5, name2, { ctor }) {
  Node5.prototype[name2] = function(hocMark) {
    const node = this.append(ctor);
    if (name2 === "mark") {
      node.type = hocMark;
    }
    return node;
  };
}
function defineContainerProp(Node5, name2, { ctor }) {
  Node5.prototype[name2] = function() {
    this.type = null;
    return this.append(ctor);
  };
}
function defineProps(descriptors) {
  return (Node5) => {
    for (const [name2, descriptor] of Object.entries(descriptors)) {
      const { type } = descriptor;
      if (type === "value")
        defineValueProp(Node5, name2, descriptor);
      else if (type === "array")
        defineArrayProp(Node5, name2, descriptor);
      else if (type === "object")
        defineObjectProp(Node5, name2, descriptor);
      else if (type === "node")
        defineNodeProp(Node5, name2, descriptor);
      else if (type === "container")
        defineContainerProp(Node5, name2, descriptor);
      else if (type === "mix")
        defineMixProp(Node5, name2, descriptor);
    }
    return Node5;
  };
}
function nodeProps(node) {
  return Object.fromEntries(Object.entries(node).map(([name2, ctor]) => [name2, { type: "node", ctor }]));
}

// node_modules/@antv/g2/esm/api/props.js
var commonProps = {
  encode: { type: "object" },
  scale: { type: "object" },
  data: { type: "value" },
  transform: { type: "array" },
  style: { type: "object" },
  animate: { type: "object" },
  coordinate: { type: "object" },
  interaction: { type: "object" },
  label: { type: "array", key: "labels" },
  axis: { type: "object" },
  legend: { type: "object" },
  slider: { type: "object" },
  scrollbar: { type: "object" },
  state: { type: "object" },
  layout: { type: "object" },
  theme: { type: "object" },
  title: { type: "value" }
};
var markProps = Object.assign(Object.assign({}, commonProps), { tooltip: { type: "mix" }, viewStyle: { type: "object" } });
var compositionProps = Object.assign(Object.assign({}, commonProps), { labelTransform: { type: "array" } });

// node_modules/@antv/g2/esm/api/composition.js
var __decorate3 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r2 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d4 = decorators[i2]) r2 = (c6 < 3 ? d4(r2) : c6 > 3 ? d4(target, key, r2) : d4(target, key)) || r2;
  return c6 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var CompositionNode = class CompositionNode2 extends Node4 {
  /**
   * Change current node data and its children data.
   */
  changeData(data2) {
    var _a2;
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data2);
    if ((_a2 = this.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
      this.children.forEach((child) => {
        child.attr("data", data2);
      });
    }
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get view instance by key.
   */
  getView() {
    const chart = this.getRoot();
    const { views } = chart.getContext();
    if (!(views === null || views === void 0 ? void 0 : views.length))
      return void 0;
    return views.find((view) => view.key === this._key);
  }
  getScale() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.scale;
  }
  getScaleByChannel(channel) {
    const scale12 = this.getScale();
    if (scale12)
      return scale12[channel];
    return;
  }
  getCoordinate() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.coordinate;
  }
  getTheme() {
    var _a2;
    return (_a2 = this.getView()) === null || _a2 === void 0 ? void 0 : _a2.theme;
  }
  getGroup() {
    const key = this._key;
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
  /**
   * Show the view.
   */
  show() {
    const group3 = this.getGroup();
    if (!group3)
      return;
    !group3.isVisible() && show2(group3);
  }
  /**
   * Hide the view.
   */
  hide() {
    const group3 = this.getGroup();
    if (!group3)
      return;
    group3.isVisible() && hide2(group3);
  }
};
CompositionNode = __decorate3([
  defineProps(compositionProps)
], CompositionNode);

// node_modules/@antv/g2/esm/api/mark.js
var __decorate4 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r2 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d4 = decorators[i2]) r2 = (c6 < 3 ? d4(r2) : c6 > 3 ? d4(target, key, r2) : d4(target, key)) || r2;
  return c6 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var MarkNode = class MarkNode2 extends Node4 {
  changeData(data2) {
    const chart = this.getRoot();
    if (!chart)
      return;
    this.attr("data", data2);
    return chart === null || chart === void 0 ? void 0 : chart.render();
  }
  /**
   * Get mark from chart views.
   */
  getMark() {
    var _a2;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    const { markState } = chartView;
    const markKey = Array.from(markState.keys()).find((item) => item.key === this.attr("key"));
    return markState.get(markKey);
  }
  /**
   * Get all scales instance.
   */
  getScale() {
    var _a2;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    return chartView === null || chartView === void 0 ? void 0 : chartView.scale;
  }
  /**
   * Get the scale instance by channel.
   */
  getScaleByChannel(channel) {
    var _a2, _b;
    const chartView = (_a2 = this.getRoot()) === null || _a2 === void 0 ? void 0 : _a2.getView();
    if (!chartView)
      return void 0;
    return (_b = chartView === null || chartView === void 0 ? void 0 : chartView.scale) === null || _b === void 0 ? void 0 : _b[channel];
  }
  /**
   * Get canvas group.
   */
  getGroup() {
    const key = this.attr("key");
    if (!key)
      return void 0;
    const chart = this.getRoot();
    const chartGroup = chart.getContext().canvas.getRoot();
    return chartGroup.getElementById(key);
  }
};
MarkNode = __decorate4([
  defineProps(markProps)
], MarkNode);

// node_modules/@antv/g2/esm/api/runtime.js
var __decorate5 = function(decorators, target, key, desc) {
  var c6 = arguments.length, r2 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d4 = decorators[i2]) r2 = (c6 < 3 ? d4(r2) : c6 > 3 ? d4(target, key, r2) : d4(target, key)) || r2;
  return c6 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __rest89 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var G2_CHART_KEY = "G2_CHART_KEY";
var Runtime = class extends CompositionNode {
  constructor(options) {
    const { container, canvas, renderer, plugins, lib, createCanvas } = options, rest = __rest89(options, ["container", "canvas", "renderer", "plugins", "lib", "createCanvas"]);
    super(rest, "view");
    this._hasBindAutoFit = false;
    this._rendering = false;
    this._trailingClear = null;
    this._trailing = false;
    this._trailingResolve = null;
    this._trailingReject = null;
    this._previousDefinedType = null;
    this._onResize = debounce_default(() => {
      this.forceFit();
    }, 300);
    this._renderer = renderer || new Renderer();
    this._plugins = plugins || [];
    this._container = normalizeContainer2(container);
    this._emitter = new esm_default();
    this._context = {
      library: Object.assign(Object.assign({}, lib), library),
      emitter: this._emitter,
      canvas,
      createCanvas
    };
    this._create();
  }
  render() {
    if (this._rendering)
      return this._addToTrailing();
    if (!this._context.canvas)
      this._createCanvas();
    this._bindAutoFit();
    this._rendering = true;
    const finished = new Promise((resolve2, reject2) => render(this._computedOptions(), this._context, this._createResolve(resolve2), this._createReject(reject2)));
    const [finished1, resolve, reject] = createEmptyPromise();
    finished.then(resolve).then(() => {
      if (this._trailingClear) {
        const options = this.options();
        this._trailingClear();
        if (this._trailing)
          this.options(options);
      }
    }).catch(reject).then(() => {
      this._trailingClear = null;
      this._renderTrailing();
    });
    return finished1;
  }
  /**
   * @overload
   * @param {G2ViewTree} [options]
   * @returns {Runtime|Spec}
   */
  options(options) {
    if (arguments.length === 0)
      return optionsOf(this);
    const { type } = options;
    if (type)
      this._previousDefinedType = type;
    updateRoot(this, options, this._previousDefinedType, this._marks, this._compositions);
    return this;
  }
  getContainer() {
    return this._container;
  }
  getContext() {
    return this._context;
  }
  on(event, callback, once) {
    this._emitter.on(event, callback, once);
    return this;
  }
  once(event, callback) {
    this._emitter.once(event, callback);
    return this;
  }
  emit(event, ...args) {
    this._emitter.emit(event, ...args);
    return this;
  }
  off(event, callback) {
    this._emitter.off(event, callback);
    return this;
  }
  clear(isClearEvents = true) {
    if (this._rendering) {
      this._trailingClear = () => {
        this.clear(isClearEvents);
      };
      this._reset();
      return;
    }
    const options = this.options();
    this.emit(ChartEvent.BEFORE_CLEAR);
    this._reset();
    destroy(options, this._context, false, isClearEvents);
    this.emit(ChartEvent.AFTER_CLEAR);
  }
  destroy() {
    const options = this.options();
    this.emit(ChartEvent.BEFORE_DESTROY);
    this._unbindAutoFit();
    this._reset();
    destroy(options, this._context, true);
    if (this._container[REMOVE_FLAG])
      removeContainer(this._container);
    this.emit(ChartEvent.AFTER_DESTROY);
  }
  forceFit() {
    this.options["autoFit"] = true;
    const { width, height } = sizeOf2(this.options(), this._container);
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  changeSize(width, height) {
    if (width === this._width && height === this._height) {
      return Promise.resolve(this);
    }
    this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
    this.attr("width", width);
    this.attr("height", height);
    const finished = this.render();
    finished.then(() => {
      this.emit(ChartEvent.AFTER_CHANGE_SIZE);
    });
    return finished;
  }
  getDataByXY(point7, options = {}) {
    const { shared = false, series, facet = false, startX = 0, startY = 0 } = options;
    const { canvas, views } = this._context;
    const { document: document2 } = canvas;
    const { x: x3, y: y4 } = point7;
    const { coordinate, scale: scale12, markState, data: dataMap, key } = views[0];
    const elements = document2.getElementsByClassName(ELEMENT_CLASS_NAME);
    const groupKey = shared ? (element) => element.__data__.x : (d4) => d4;
    const keyGroup = group(elements, groupKey);
    const container = document2.getElementsByClassName(VIEW_CLASS_NAME)[0];
    const root2 = selectPlotArea(container);
    const hasSeriesInteraction = (markState2) => {
      return Array.from(markState2.values()).some((d4) => {
        var _a2, _b;
        return ((_a2 = d4.interaction) === null || _a2 === void 0 ? void 0 : _a2["seriesTooltip"]) || ((_b = d4.channels) === null || _b === void 0 ? void 0 : _b.some((c6) => c6.name === "series" && c6.values !== void 0));
      });
    };
    const isSeries = maybeValue(series, hasSeriesInteraction(markState));
    const getElementData = (el) => get_default(el, "__data__.data", null);
    const getElementsData = (els) => els.map(getElementData);
    try {
      if (isSeries && hasSeriesInteraction(markState) && !facet) {
        const { selectedData } = findSeriesElement({
          root: root2,
          event: { offsetX: x3, offsetY: y4 },
          elements,
          coordinate,
          scale: scale12,
          startX,
          startY
        });
        const viewData = dataMap.get(`${key}-0`);
        return selectedData.map(({ index: index3 }) => viewData[index3]);
      }
      const element = findSingleElement({
        root: root2,
        event: { offsetX: x3, offsetY: y4 },
        elements,
        coordinate,
        scale: scale12,
        shared
      });
      if (isHeatmap(element))
        return dataOf(element, dataMap.get(key));
      const k2 = groupKey(element);
      const groupElements = keyGroup.get(k2);
      return groupElements ? getElementsData(groupElements) : [];
    } catch (e3) {
      const topMostElement = canvas.document.elementFromPointSync(x3, y4);
      return topMostElement ? getElementData(topMostElement) : [];
    }
  }
  _create() {
    const { library: library3 } = this._context;
    const isMark2 = (key) => key.startsWith("mark.") || key === "component.axisX" || key === "component.axisY" || key === "component.legends";
    const marks = [
      "mark.mark",
      ...Object.keys(library3).filter(isMark2)
    ];
    this._marks = {};
    for (const key of marks) {
      const name2 = key.split(".").pop();
      class Mark2 extends MarkNode {
        constructor() {
          super({}, name2);
        }
      }
      this._marks[name2] = Mark2;
      this[name2] = function(composite) {
        const node = this.append(Mark2);
        if (name2 === "mark")
          node.type = composite;
        return node;
      };
    }
    const compositions = [
      "composition.view",
      ...Object.keys(library3).filter((key) => key.startsWith("composition.") && key !== "composition.mark")
    ];
    this._compositions = Object.fromEntries(compositions.map((key) => {
      const name2 = key.split(".").pop();
      let Composition = class Composition extends CompositionNode {
        constructor() {
          super({}, name2);
        }
      };
      Composition = __decorate5([
        defineProps(nodeProps(this._marks))
      ], Composition);
      return [name2, Composition];
    }));
    for (const Ctor of Object.values(this._compositions)) {
      defineProps(nodeProps(this._compositions))(Ctor);
    }
    for (const key of compositions) {
      const name2 = key.split(".").pop();
      this[name2] = function() {
        const Composition = this._compositions[name2];
        this.type = null;
        return this.append(Composition);
      };
    }
  }
  _reset() {
    const KEYS = ["theme", "type", "width", "height", "autoFit"];
    this.type = "view";
    this.value = Object.fromEntries(Object.entries(this.value).filter(([key]) => key.startsWith("margin") || key.startsWith("padding") || key.startsWith("inset") || KEYS.includes(key)));
    this.children = [];
  }
  _renderTrailing() {
    if (!this._trailing)
      return;
    this._trailing = false;
    this.render().then(() => {
      const trailingResolve = this._trailingResolve.bind(this);
      this._trailingResolve = null;
      trailingResolve(this);
    }).catch((error3) => {
      const trailingReject = this._trailingReject.bind(this);
      this._trailingReject = null;
      trailingReject(error3);
    });
  }
  _createResolve(resolve) {
    return () => {
      this._rendering = false;
      resolve(this);
    };
  }
  _createReject(reject) {
    return (error3) => {
      this._rendering = false;
      reject(error3);
    };
  }
  // Update actual size and key.
  _computedOptions() {
    const options = this.options();
    const { key = G2_CHART_KEY } = options;
    const { width, height, depth } = sizeOf2(options, this._container);
    this._width = width;
    this._height = height;
    this._key = key;
    return Object.assign(Object.assign({ key: this._key }, options), { width, height, depth });
  }
  // Create canvas if it does not exist.
  // DragAndDropPlugin is for interaction.
  // It is OK to register more than one time, G will handle this.
  _createCanvas() {
    const { width, height } = sizeOf2(this.options(), this._container);
    this._plugins.push(new Plugin7());
    this._plugins.forEach((d4) => this._renderer.registerPlugin(d4));
    this._context.canvas = new Canvas({
      container: this._container,
      width,
      height,
      renderer: this._renderer
    });
  }
  _addToTrailing() {
    var _a2;
    (_a2 = this._trailingResolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
    this._trailing = true;
    const promise = new Promise((resolve, reject) => {
      this._trailingResolve = resolve;
      this._trailingReject = reject;
    });
    return promise;
  }
  _bindAutoFit() {
    const options = this.options();
    const { autoFit } = options;
    if (this._hasBindAutoFit) {
      if (!autoFit)
        this._unbindAutoFit();
      return;
    }
    if (autoFit) {
      this._hasBindAutoFit = true;
      window.addEventListener("resize", this._onResize);
    }
  }
  _unbindAutoFit() {
    if (this._hasBindAutoFit) {
      this._hasBindAutoFit = false;
      window.removeEventListener("resize", this._onResize);
    }
  }
};

// node_modules/@antv/g2/esm/api/chart.js
var Chart = extend5(Runtime, library);

// node_modules/@antv/g2/esm/index.js
var library2 = Object.assign({}, stdlib());
var Chart2 = extend5(Runtime, library2);

// node_modules/@ant-design/charts-util/es/react/render.js
var React = __toESM(require_react());
var version2 = React.version || "";
var createRoot;
var legacyRender;
var legacyUnmount;
var MARK = "__rc_react_root__";
try {
  mainVersion = parseInt(version2.split(".")[0], 10);
  if (mainVersion >= 18) {
    client = require_client();
    createRoot = client.createRoot;
  } else {
    legacyReactDOM = require_react_dom();
    legacyRender = legacyReactDOM.render;
    legacyUnmount = legacyReactDOM.unmountComponentAtNode;
  }
} catch (e3) {
}
var mainVersion;
var client;
var legacyReactDOM;
function modernRender(node, container) {
  if (!container[MARK]) {
    container[MARK] = createRoot(container);
  }
  container[MARK].render(node);
}
function fallbackLegacyRender(node, container) {
  if (legacyRender) {
    legacyRender(node, container);
  } else {
    throw new Error("ReactDOM.render is not available in this React version");
  }
}
function render2(node, container) {
  if (createRoot) {
    modernRender(node, container);
  } else {
    fallbackLegacyRender(node, container);
  }
}

// node_modules/@ant-design/charts-util/es/rc/create-node.js
var mountMapping = /* @__PURE__ */ new Map();
if (typeof document !== "undefined") {
  mountMapping.set("tooltip", document.createElement("div"));
}
var createNode2 = function(children, isTooltip) {
  if (isTooltip === void 0) {
    isTooltip = false;
  }
  var mount = null;
  if (isTooltip) {
    mount = mountMapping.get("tooltip");
  } else {
    mount = document.createElement("div");
    if (children === null || children === void 0 ? void 0 : children.key) {
      var exist = mountMapping.get(children.key);
      if (exist) {
        mount = exist;
      } else {
        mountMapping.set(children.key, mount);
      }
    }
  }
  render2(children, mount);
  return mount;
};

// node_modules/@ant-design/charts-util/es/rc/chart-loading.js
var import_react = __toESM(require_react());
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var shadowLoading = function(ele, style) {
  if (style === void 0) {
    style = {};
  }
  if (typeof document === "undefined") {
    return "loading";
  }
  var overStyle = "";
  if (style) {
    Object.keys(style).forEach(function(key) {
      overStyle += "".concat(key, ": ").concat(style[key], ";\n");
    });
  }
  var shadowRoot = ele.attachShadow({ mode: "open" });
  var shadowDiv = document.createElement("div");
  var shadowStyle = document.createElement("style");
  shadowStyle.innerHTML = ".loading {\n    display: inline-block;\n    position: relative;\n    width: 80px;\n    height: 80px;\n  }\n  .loading div {\n    position: absolute;\n    top: 33px;\n    width: 13px;\n    height: 13px;\n    border-radius: 50%;\n    background: #ccc;\n    animation-timing-function: cubic-bezier(0, 1, 1, 0);\n    ".concat(overStyle, "\n  }\n  .loading div:nth-child(1) {\n    left: 8px;\n    animation: loading1 0.6s infinite;\n  }\n  .loading div:nth-child(2) {\n    left: 8px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(3) {\n    left: 32px;\n    animation: loading2 0.6s infinite;\n  }\n  .loading div:nth-child(4) {\n    left: 56px;\n    animation: loading3 0.6s infinite;\n  }\n  @keyframes loading1 {\n    0% {\n      transform: scale(0);\n    }\n    100% {\n      transform: scale(1);\n    }\n  }\n  @keyframes loading3 {\n    0% {\n      transform: scale(1);\n    }\n    100% {\n      transform: scale(0);\n    }\n  }\n  @keyframes loading2 {\n    0% {\n      transform: translate(0, 0);\n    }\n    100% {\n      transform: translate(24px, 0);\n    }\n  }\n  ");
  shadowDiv.classList.add("loading");
  shadowDiv.innerHTML = "<div></div><div></div><div></div><div></div>";
  shadowRoot.appendChild(shadowStyle);
  shadowRoot.appendChild(shadowDiv);
};
var ChartLoading = function(_a2) {
  var loadingTemplate = _a2.loadingTemplate, _b = _a2.theme, theme = _b === void 0 ? "light" : _b, loading = _a2.loading;
  var shadow = import_react.default.useRef(null);
  var _c = typeof loading === "object" ? loading : {}, _d = _c.container, container = _d === void 0 ? {} : _d, _e = _c.icon, icon = _e === void 0 ? {} : _e;
  import_react.default.useEffect(function() {
    if (!loadingTemplate && shadow.current) {
      shadowLoading(shadow.current, icon);
    }
  }, []);
  var renderLoading = function() {
    if (loadingTemplate)
      return loadingTemplate;
    return import_react.default.createElement("div", { ref: shadow });
  };
  return import_react.default.createElement("div", { className: "charts-loading-container", style: __assign2({ position: "absolute", width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", left: 0, top: 0, zIndex: 99, background: theme === "dark" ? "rgb(20, 20, 20)" : "rgb(255, 255, 255)" }, container) }, renderLoading());
};

// node_modules/@ant-design/charts-util/es/rc/error-boundary.js
var import_react2 = __toESM(require_react());
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ErrorBoundary = (
  /** @class */
  function(_super) {
    __extends2(ErrorBoundary2, _super);
    function ErrorBoundary2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.state = {
        hasError: false
      };
      _this2.renderError = function(e3) {
        var errorTemplate = _this2.props.errorTemplate;
        switch (e3) {
          default:
            if (typeof errorTemplate === "function")
              return errorTemplate(e3);
            return errorTemplate ? errorTemplate : import_react2.default.createElement(
              "h5",
              null,
              " ",
              e3.message
            );
        }
      };
      return _this2;
    }
    ErrorBoundary2.getDerivedStateFromError = function(error3) {
      return { hasError: true, error: error3 };
    };
    ErrorBoundary2.getDerivedStateFromProps = function(nextProps, state) {
      if (state.children !== nextProps.children) {
        return {
          children: nextProps.children,
          hasError: false,
          error: void 0
        };
      }
      return null;
    };
    ErrorBoundary2.prototype.render = function() {
      if (this.state.hasError) {
        return this.renderError(this.state.error);
      }
      return import_react2.default.createElement(import_react2.Fragment, null, this.props.children);
    };
    return ErrorBoundary2;
  }(import_react2.default.Component)
);

// node_modules/@ant-design/charts-util/es/utils/measure-text.js
var import_lodash2 = __toESM(require_lodash());

// node_modules/@ant-design/charts-util/es/utils/context.js
var ctx3;
var getCanvasContext = function() {
  if (!ctx3) {
    ctx3 = document.createElement("canvas").getContext("2d");
  }
  return ctx3;
};

// node_modules/@ant-design/charts-util/es/utils/measure-text.js
var __spreadArray6 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var measureText = (0, import_lodash2.memoize)(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, _a2 = font.fontFamily, fontFamily = _a2 === void 0 ? "sans-serif" : _a2, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx4 = getCanvasContext();
  ctx4.font = [fontStyle, fontWeight, fontVariant, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx4.measureText((0, import_lodash2.isString)(text) ? text : "");
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray6([text], (0, import_lodash2.values)(font), true).join("");
});
var measureTextWidth2 = function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return measureText(text, font).width;
};

// node_modules/@ant-design/plots/es/components/base/index.js
var import_react4 = __toESM(require_react());

// node_modules/@ant-design/plots/es/hooks/useChart.js
var import_react3 = __toESM(require_react());

// node_modules/@ant-design/plots/es/util/index.js
var import_lodash3 = __toESM(require_lodash());

// node_modules/@ant-design/plots/es/util/is-valid-element.js
var isValidElement = function(jsxCode) {
  var basicReactPatterns = [/\breact\b/i, /\.jsx/, /children:\s*\[/, /\*#__PURE__\*/];
  var createElementPattern = /(\w+)?\.createElement\(\s*(['"`])([^'"`]+)\2/g;
  var GElements = /* @__PURE__ */ new Set([
    "g",
    "circle",
    "ellipse",
    "image",
    "rect",
    "line",
    "polyline",
    "polygon",
    "text",
    "path",
    "html",
    "mesh"
  ]);
  if (basicReactPatterns.some(function(pattern) {
    return pattern.test(jsxCode);
  })) {
    return true;
  }
  var matches = jsxCode.match(createElementPattern);
  if (!matches) {
    return false;
  }
  return matches.some(function(match) {
    var elementMatch = match.match(/\.createElement\(\s*(['"`])([^'"`]+)\1/);
    return elementMatch && !GElements.has(elementMatch[2].toLowerCase());
  });
};

// node_modules/@ant-design/plots/es/hooks/useChart.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
function useChart(ChartClass, config) {
  var chart = (0, import_react3.useRef)(null);
  var chartOptions = (0, import_react3.useRef)(null);
  var container = (0, import_react3.useRef)(null);
  var onReady = config.onReady, onEvent = config.onEvent;
  var toDataURL = function(type, encoderOptions) {
    var _a2;
    if (type === void 0) {
      type = "image/png";
    }
    var canvas = (_a2 = container.current) === null || _a2 === void 0 ? void 0 : _a2.getElementsByTagName("canvas")[0];
    return canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(type, encoderOptions);
  };
  var downloadImage = function(name2, type, encoderOptions) {
    if (name2 === void 0) {
      name2 = "download";
    }
    if (type === void 0) {
      type = "image/png";
    }
    var imageName = name2;
    if (name2.indexOf(".") === -1) {
      imageName = "".concat(name2, ".").concat(type.split("/")[1]);
    }
    var base64 = toDataURL(type, encoderOptions);
    var a5 = document.createElement("a");
    a5.href = base64;
    a5.download = imageName;
    document.body.appendChild(a5);
    a5.click();
    document.body.removeChild(a5);
    a5 = null;
    return imageName;
  };
  var processConfig = function(cfg, flag) {
    if (flag === void 0) {
      flag = false;
    }
    var keys2 = Object.keys(cfg);
    var isTooltip = flag;
    keys2.forEach(function(key) {
      var current = cfg[key];
      if (key === "tooltip") {
        isTooltip = true;
      }
      if ((0, import_lodash3.isFunction)(current) && isValidElement("".concat(current))) {
        cfg[key] = function() {
          var arg = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arg[_i] = arguments[_i];
          }
          return createNode2(current.apply(void 0, arg), isTooltip);
        };
      } else {
        if ((0, import_lodash3.isArray)(current)) {
          current.forEach(function(item) {
            processConfig(item, isTooltip);
          });
        } else if ((0, import_lodash3.isObject)(current)) {
          processConfig(current, isTooltip);
        } else {
          isTooltip = flag;
        }
      }
    });
  };
  (0, import_react3.useEffect)(function() {
    if (chart.current && !(0, import_lodash3.isEqual)(chartOptions.current, config)) {
      chartOptions.current = (0, import_lodash3.cloneDeep)(config);
      processConfig(config);
      chart.current.update(config);
      chart.current.render();
    }
  }, [config]);
  (0, import_react3.useEffect)(function() {
    if (!container.current) {
      return function() {
        return null;
      };
    }
    if (!chartOptions.current) {
      chartOptions.current = (0, import_lodash3.cloneDeep)(config);
    }
    processConfig(config);
    var chartInstance = new ChartClass(container.current, __assign3({}, config));
    chartInstance.toDataURL = toDataURL;
    chartInstance.downloadImage = downloadImage;
    chartInstance.render();
    chart.current = chartInstance;
    if (onReady) {
      onReady(chartInstance);
    }
    var handler = function(event) {
      if (onEvent) {
        onEvent(chartInstance, event);
      }
    };
    chartInstance.on("*", handler);
    return function() {
      if (chart.current) {
        chart.current.destroy();
        chart.current.off("*", handler);
        chart.current = void 0;
      }
    };
  }, []);
  return {
    chart,
    container
  };
}

// node_modules/@antv/g2-extension-plot/esm/utils/hierarchy/partition.js
var DEFAULT_OPTIONS6 = {
  field: "value",
  size: [1, 1],
  // width, height
  round: false,
  padding: 0,
  // Default desc.
  sort: (a5, b) => b.value - a5.value,
  as: ["x", "y"],
  // Whether to ignore parentValue. When set to true, the weight of the parent node is determined by the child element.
  ignoreParentValue: true
};
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  const { field: field3, fields } = options;
  if (isString(field3)) {
    return field3;
  }
  if (isArray(field3)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field3[0];
  }
  console.warn(`${INVALID_FIELD_ERR_MSG} will try to get fields instead.`);
  if (isString(fields)) {
    return fields;
  }
  if (isArray(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root2) {
  const nodes = [];
  if (root2 && root2.each) {
    let parent;
    let index3;
    root2.each((node) => {
      var _a2, _b;
      if (node.parent !== parent) {
        parent = node.parent;
        index3 = 0;
      } else {
        index3 += 1;
      }
      const ancestors = filter_default((((_a2 = node.ancestors) === null || _a2 === void 0 ? void 0 : _a2.call(node)) || []).map((d4) => nodes.find((n2) => n2.name === d4.name) || d4), ({ depth }) => depth > 0 && depth < node.depth);
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index3;
      nodes.push(node);
    });
  } else if (root2 && root2.eachNode) {
    root2.eachNode((node) => {
      nodes.push(node);
    });
  }
  return nodes;
}
function partition(data2, options) {
  options = mix({}, DEFAULT_OPTIONS6, options);
  const as = options.as;
  if (!isArray(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  let field3;
  try {
    field3 = getField(options);
  } catch (e3) {
    console.warn(e3);
  }
  const partition2 = (data3) => partition_default().size(options.size).round(options.round).padding(options.padding)(
    /**
     * The sum function must be specified in the d3Hierarchy layout to compute node values by calling the specified value function
     * from the current node in post-order traversal order for the current node and for each descendant node and returning the current node.
     * for example:
     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}.
     * The computed value obtained by the parent is sum(node(parent)) + sum(node(child1)) + sum(node(child2)).
     * In the sum function, d is the data passed in by the user and children is the reserved field.
     */
    hierarchy(data3).sum((d4) => size(d4.children) ? options.ignoreParentValue ? 0 : d4[field3] - reduce_default(d4.children, (a5, b) => a5 + b[field3], 0) : d4[field3]).sort(options.sort)
  );
  const root2 = partition2(data2);
  const x3 = as[0];
  const y4 = as[1];
  root2.each((node) => {
    var _a2, _b;
    node[x3] = [node.x0, node.x1, node.x1, node.x0];
    node[y4] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a2 = node.data) === null || _a2 === void 0 ? void 0 : _a2.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach((prop) => {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root2);
}

// node_modules/@antv/g2-extension-plot/esm/mark/sunburst.js
var __rest90 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var SUNBURST_TYPE = "sunburst";
var SUNBURST_TYPE_FIELD = "markType";
var SUNBURST_PATH_FIELD = "path";
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
function transformData(options) {
  const { data: data2, encode } = options;
  const { color: color3, value: value2 } = encode;
  const type = "partition";
  const nodes = partition(data2, {
    field: value2,
    // @ts-ignore
    type: `hierarchy.${type}`,
    as: ["x", "y"]
  });
  const result = [];
  nodes.forEach((node) => {
    var _a2, _b, _c, _d;
    if (node.depth === 0) {
      return null;
    }
    let path2 = node.data.name;
    const pathList = [path2];
    let ancestorNode = Object.assign({}, node);
    while (ancestorNode.depth > 1) {
      path2 = `${(_a2 = ancestorNode.parent.data) === null || _a2 === void 0 ? void 0 : _a2.name} / ${path2}`;
      pathList.unshift((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name);
      ancestorNode = ancestorNode.parent;
    }
    const nodeInfo = Object.assign(Object.assign(Object.assign({}, pick_default(node.data, [value2])), { [SUNBURST_PATH_FIELD]: path2, [SUNBURST_ANCESTOR_FIELD]: ancestorNode.data.name }), node);
    if (color3 && color3 !== SUNBURST_ANCESTOR_FIELD) {
      nodeInfo[color3] = node.data[color3] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[color3]);
    }
    result.push(nodeInfo);
  });
  return result.map((d4) => {
    const x3 = d4.x.slice(0, 2);
    const y4 = [d4.y[2], d4.y[0]];
    if (x3[0] === x3[1]) {
      y4[0] = y4[1] = (d4.y[2] + d4.y[0]) / 2;
    }
    return Object.assign(Object.assign({}, d4), {
      x: x3,
      y: y4,
      fillOpacity: Math.pow(0.85, d4.depth)
    });
  });
}
var DEFAULT_OPTIONS7 = {
  id: SUNBURST_TYPE,
  encode: {
    x: "x",
    y: "y",
    key: SUNBURST_PATH_FIELD,
    color: SUNBURST_ANCESTOR_FIELD,
    value: "value"
  },
  axis: { x: false, y: false },
  style: {
    [SUNBURST_TYPE_FIELD]: SUNBURST_TYPE,
    stroke: "#fff",
    lineWidth: 0.5,
    fillOpacity: "fillOpacity",
    [CHILD_NODE_COUNT]: CHILD_NODE_COUNT,
    depth: "depth"
  },
  state: {
    active: { zIndex: 2, stroke: "#000" },
    inactive: { zIndex: 1, stroke: "#fff" }
  },
  legend: false,
  interaction: { drillDown: true },
  coordinate: {
    type: "polar",
    innerRadius: 0.2
  }
};
var Sunburst = (options) => {
  const { encode: encodeOption, data: data2 = [] } = options, resOptions = __rest90(options, ["encode", "data"]);
  const coordinate = Object.assign(Object.assign({}, resOptions.coordinate), {
    // Reac Bug InnerRadius = 0.
    innerRadius: Math.max(get_default(resOptions, ["coordinate", "innerRadius"], 0.2), 1e-5)
  });
  const encode = Object.assign(Object.assign({}, DEFAULT_OPTIONS7.encode), encodeOption);
  const { value: value2 } = encode;
  const rectData = transformData({ encode, data: data2 });
  return [
    deep_mix_default({}, DEFAULT_OPTIONS7, Object.assign(Object.assign({ type: "rect", data: rectData, encode, tooltip: {
      title: "path",
      items: [
        (d4) => {
          return {
            name: value2,
            value: d4[value2]
          };
        }
      ]
    } }, resOptions), { coordinate }))
  ];
};
Sunburst.props = {};

// node_modules/@antv/g2-extension-plot/esm/interaction/drillDown.js
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step2(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step2(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getElementsSunburst = (plot2) => {
  return plot2.querySelectorAll(".element").filter((item) => get_default(item, ["style", SUNBURST_TYPE_FIELD]) === SUNBURST_TYPE);
};
function selectPlotArea3(root2) {
  return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
}
var DEFAULT_BREADCRUMB = {
  rootText: "root",
  style: {
    fill: "rgba(0, 0, 0, 0.85)",
    fontSize: 12,
    y: 1
  },
  active: {
    fill: "rgba(0, 0, 0, 0.5)"
  }
};
function DrillDown(drillDownOptions = {}) {
  const { breadCrumb: textConfig = {}, isFixedColor = false } = drillDownOptions;
  const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB, textConfig);
  return (context) => {
    const { update: update2, setState, container, view, options } = context;
    const document2 = container.ownerDocument;
    const plotArea = selectPlotArea3(container);
    const sunburstMark = options.marks.find(({ id: id4 }) => id4 === SUNBURST_TYPE);
    const { state } = sunburstMark;
    const textGroup = document2.createElement("g");
    plotArea.appendChild(textGroup);
    const drillDownClick = (path2, depth) => __awaiter15(this, void 0, void 0, function* () {
      textGroup.removeChildren();
      if (path2) {
        const rootText = document2.createElement("text", {
          style: Object.assign({
            x: 0,
            text: breadCrumb.rootText,
            // @ts-ignore
            depth: 0
          }, breadCrumb.style)
        });
        textGroup.appendChild(rootText);
        let name2 = "";
        const pathArray = path2 === null || path2 === void 0 ? void 0 : path2.split(" / ");
        let y4 = breadCrumb.style.y;
        let x3 = textGroup.getBBox().width;
        const maxWidth = plotArea.getBBox().width;
        const drillTexts = pathArray.map((text, index3) => {
          const textSeparator = document2.createElement("text", {
            style: Object.assign(Object.assign({ x: x3, text: " / " }, breadCrumb.style), { y: y4 })
          });
          textGroup.appendChild(textSeparator);
          x3 += textSeparator.getBBox().width;
          name2 = `${name2}${text} / `;
          const drillText = document2.createElement("text", {
            name: name2.replace(/\s\/\s$/, ""),
            style: Object.assign(Object.assign({
              text,
              x: x3,
              // @ts-ignore
              depth: index3 + 1
            }, breadCrumb.style), { y: y4 })
          });
          textGroup.appendChild(drillText);
          x3 += drillText.getBBox().width;
          if (x3 > maxWidth) {
            y4 = textGroup.getBBox().height;
            x3 = 0;
            textSeparator.attr({
              x: x3,
              y: y4
            });
            x3 += textSeparator.getBBox().width;
            drillText.attr({
              x: x3,
              y: y4
            });
            x3 += drillText.getBBox().width;
          }
          return drillText;
        });
        [rootText, ...drillTexts].forEach((item, index3) => {
          if (index3 === drillTexts.length)
            return;
          const originalAttrs = Object.assign({}, item.attributes);
          item.attr("cursor", "pointer");
          item.addEventListener("mouseenter", () => {
            item.attr(breadCrumb.active);
          });
          item.addEventListener("mouseleave", () => {
            item.attr(originalAttrs);
          });
          item.addEventListener("click", () => {
            drillDownClick(item.name, get_default(item, ["style", "depth"]));
          });
        });
      }
      setState("drillDown", (viewOptions) => {
        const { marks } = viewOptions;
        const newMarks = marks.map((mark2) => {
          if (mark2.id !== SUNBURST_TYPE && mark2.type !== "rect")
            return mark2;
          const { data: data2 } = mark2;
          const newScale = Object.fromEntries(["color"].map((channel) => [channel, { domain: view.scale[channel].getOptions().domain }]));
          const newData = data2.filter((item) => {
            const key = item.path;
            if (!isFixedColor) {
              item[SUNBURST_ANCESTOR_FIELD] = key.split(" / ")[depth];
            }
            if (!path2)
              return true;
            const reg = new RegExp(`^${path2}.+`);
            return reg.test(key);
          });
          return deep_mix_default({}, mark2, isFixedColor ? {
            data: newData,
            scale: newScale
          } : {
            data: newData
          });
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update2();
    });
    const createDrillClick = (e3) => {
      const item = e3.target;
      if (get_default(item, ["style", SUNBURST_TYPE_FIELD]) !== SUNBURST_TYPE || get_default(item, ["markType"]) !== "rect" || !get_default(item, ["style", CHILD_NODE_COUNT]))
        return;
      const path2 = get_default(item, ["__data__", "key"]);
      const depth = get_default(item, ["style", "depth"]);
      item.style.cursor = "pointer";
      drillDownClick(path2, depth);
    };
    plotArea.addEventListener("click", createDrillClick);
    const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
    const createActive = () => {
      const elements = getElementsSunburst(plotArea);
      elements.forEach((element) => {
        const childNodeCount = get_default(element, ["style", CHILD_NODE_COUNT]);
        const cursor = get_default(element, ["style", "cursor"]);
        if (cursor !== "pointer" && childNodeCount) {
          element.style.cursor = "pointer";
          const originalAttrs = pick_default(element.attributes, changeStyleKey);
          element.addEventListener("mouseenter", () => {
            element.attr(state.active);
          });
          element.addEventListener("mouseleave", () => {
            element.attr(deep_mix_default(originalAttrs, state.inactive));
          });
        }
      });
    };
    plotArea.addEventListener("mousemove", createActive);
    return () => {
      textGroup.remove();
      plotArea.removeEventListener("click", createDrillClick);
      plotArea.removeEventListener("mousemove", createActive);
    };
  };
}

// node_modules/@antv/g2-extension-plot/esm/lib.js
function plotlib2() {
  return {
    "interaction.drillDown": DrillDown,
    "mark.sunburst": Sunburst
  };
}

// node_modules/@ant-design/plots/es/core/base/chart.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var Chart3 = extend5(Runtime, __assign4(__assign4({}, stdlib()), plotlib2()));

// node_modules/@ant-design/plots/es/core/utils/index.js
var import_lodash4 = __toESM(require_lodash());

// node_modules/@ant-design/plots/es/core/utils/transform.js
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var transformOptions = function(params) {
  var options = filterTransformed(params);
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  var rest = (0, import_lodash4.omit)(options, [].concat(VIEW_OPTIONS, CONFIG_SHAPE.map(function(item) {
    return item.key;
  })));
  var getCustomTransform = function(key) {
    var _a3;
    return (_a3 = SPECIAL_OPTIONS.find(function(option) {
      return option.key === key;
    })) === null || _a3 === void 0 ? void 0 : _a3.callback;
  };
  var updateOptions = function(origin, key, value2) {
    var callback = getCustomTransform(key);
    if (callback) {
      callback(origin, key, value2);
    } else {
      origin[key] = mergeWithArrayCoverage({}, origin[key], value2);
    }
  };
  var transformShape = function(config) {
    Object.keys(config).forEach(function(key) {
      if (!config[key])
        return;
      var exist = CONFIG_SHAPE.find(function(item) {
        return item.key === key;
      });
      if (exist) {
        var type = exist.type, extendedProperties = exist.extendedProperties, _a3 = exist.defaultShapeConfig, defaultShapeConfig = _a3 === void 0 ? {} : _a3;
        if (type) {
          var tooltip2 = config[key].tooltip;
          children.push(transformConfig(mergeWithArrayCoverage({}, (0, import_lodash4.pick)(config, extendedProperties), defaultShapeConfig, { type }, config[key], {
            tooltip: tooltip2 ? tooltip2 : false
          })));
        } else {
          if ((0, import_lodash4.isArray)(config[key])) {
            var isText_1 = config[key].some(function(item) {
              return item.type === "text";
            });
            config[key].forEach(function(annotation) {
              children.push(transformConfig(__assign5(__assign5(__assign5({}, isText_1 ? { data: [] } : {}), { tooltip: false }), annotation)));
            });
          }
        }
      }
    });
  };
  var transformConfig = function(config) {
    transformShape(config);
    Object.keys(TRANSFORM_OPTION_KEY).forEach(function(key) {
      var transformTarget = TRANSFORM_OPTION_KEY[key];
      if (!(0, import_lodash4.isUndefined)(config[key])) {
        if ((0, import_lodash4.isObject)(transformTarget)) {
          var value2 = transformTarget.value, target = transformTarget.target;
          var transformValue = value2(config[key]);
          updateOptions(config, target, transformValue);
        } else {
          (0, import_lodash4.set)(config, transformTarget, config[key]);
        }
      }
    });
    return config;
  };
  children.forEach(function(child) {
    var config = mergeWithArrayCoverage({}, rest, child);
    transformConfig(mergeWithArrayCoverage(child, config));
  });
  transformShape(options);
  deleteExcessKeys(options);
  return params;
};

// node_modules/@ant-design/plots/es/core/utils/delete-excess-keys.js
var __spreadArray7 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var deleteExcessKeys = function(options) {
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  var deleteKeys = Object.keys(TRANSFORM_OPTION_KEY).concat(CONFIG_SHAPE.map(function(item) {
    return item.key;
  }));
  deleteKeys.forEach(function(key) {
    delete options[key];
  });
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if (deleteKeys.includes(key)) {
        delete child[key];
      }
    });
  });
  Object.keys(options).forEach(function(key) {
    if (!__spreadArray7(__spreadArray7([], VIEW_OPTIONS, true), ANNOTATION_LIST.map(function(item) {
      return item.key;
    }), true).includes(key)) {
      delete options[key];
    }
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/filter-transformed.js
var filterTransformed = function(params) {
  var options = params.options;
  var _a2 = options.children, children = _a2 === void 0 ? [] : _a2;
  children.forEach(function(child) {
    Object.keys(child).forEach(function(key) {
      if ((0, import_lodash4.isArray)(child[key]) && key !== "data") {
        child[key] = child[key].filter(function(item) {
          return !item[TRANSFORM_SIGN];
        });
      }
    });
  });
  return options;
};

// node_modules/@ant-design/plots/es/core/utils/merge-with-array-coverage.js
var __spreadArray8 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var arrayCoverage = function(objValue, srcValue) {
  if ((0, import_lodash4.isArray)(srcValue)) {
    return srcValue;
  }
};
var mergeWithArrayCoverage = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return import_lodash4.mergeWith.apply(void 0, __spreadArray8(__spreadArray8([], args, false), [arrayCoverage], false));
};

// node_modules/@ant-design/plots/es/core/utils/field-adapter.js
function fieldAdapter(field3) {
  switch (typeof field3) {
    case "function":
      return field3;
    case "string":
      return function(d4) {
        return (0, import_lodash4.get)(d4, [field3]);
      };
    default:
      return function() {
        return field3;
      };
  }
}

// node_modules/@ant-design/plots/es/core/utils/data-transform.js
var dataTransform4 = function(params) {
  var options = params.options;
  var data2 = options.data;
  if ((0, import_lodash4.get)(data2, "value"))
    return params;
  if ((0, import_lodash4.get)(data2, "type") !== "fetch" && (0, import_lodash4.isPlainObject)(data2)) {
    (0, import_lodash4.set)(options, "data.value", data2);
  }
  return params;
};

// node_modules/@ant-design/plots/es/core/constants/index.js
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var __rest91 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var CHART_OPTIONS = ["renderer"];
var VIEW_OPTIONS = [
  "width",
  "height",
  "autoFit",
  "theme",
  "inset",
  "insetLeft",
  "insetRight",
  "insetTop",
  "insetBottom",
  "padding",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "margin",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  "depth",
  "title",
  "clip",
  "children",
  "type",
  "data",
  "direction"
];
var TRANSFORM_SIGN = "__transform__";
var SKIP_DEL_CUSTOM_SIGN = "__skipDelCustomKeys__";
var commonCallback = function(type, value2) {
  if ((0, import_lodash4.isBoolean)(value2)) {
    return {
      type,
      available: value2
    };
  }
  return __assign6({ type }, value2);
};
var TRANSFORM_OPTION_KEY = {
  /** encode */
  xField: "encode.x",
  yField: "encode.y",
  colorField: "encode.color",
  angleField: "encode.y",
  keyField: "encode.key",
  y1Field: "encode.y1",
  sizeField: "encode.size",
  setsField: "encode.sets",
  shapeField: "encode.shape",
  seriesField: "encode.series",
  positionField: "encode.position",
  textField: "encode.text",
  valueField: "encode.value",
  binField: "encode.x",
  srcField: "encode.src",
  linkColorField: "encode.linkColor",
  fontSizeField: "encode.fontSize",
  coordinateType: "coordinate.type",
  radius: "coordinate.outerRadius",
  innerRadius: "coordinate.innerRadius",
  startAngle: "coordinate.startAngle",
  endAngle: "coordinate.endAngle",
  focusX: "coordinate.focusX",
  focusY: "coordinate.focusY",
  distortionX: "coordinate.distortionX",
  distortionY: "coordinate.distortionY",
  visual: "coordinate.visual",
  /**
   * @title 
   * @example
   *  1. stack: true -> transform: [{type: 'stackY'}]
   */
  stack: {
    target: "transform",
    value: function(value2) {
      return commonCallback("stackY", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. normalize: true -> transform: [{type: 'normalizeY'}]
   */
  normalize: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 
   * @description  normalize
   * @example
   *  1. percent: true -> transform: [{type: 'normalizeY'}]
   */
  percent: {
    target: "transform",
    value: function(value2) {
      return commonCallback("normalizeY", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. group: true -> transform: [{type: 'dodgeX'}]
   */
  group: {
    target: "transform",
    value: function(value2) {
      return commonCallback("dodgeX", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. sort: true -> transform: [{type: 'sortX'}]
   */
  sort: {
    target: "transform",
    value: function(value2) {
      return commonCallback("sortX", value2);
    }
  },
  /**
   * @title 
   * @example
   *  1. symmetry: true -> transform: [{type: 'symmetryY'}]
   */
  symmetry: {
    target: "transform",
    value: function(value2) {
      return commonCallback("symmetryY", value2);
    }
  },
  /**
   * @title  y  y1 
   * @example
   *  1. diff: true -> transform: [{type: 'diffY'}]
   */
  diff: {
    target: "transform",
    value: function(value2) {
      return commonCallback("diffY", value2);
    }
  },
  meta: {
    target: "scale",
    value: function(value2) {
      return value2;
    }
  },
  label: {
    target: "labels",
    value: function(value2) {
      return value2;
    }
  },
  /**
   * @title 
   * @example
   *  1. shape: 'smooth' -> style: {shape: 'smooth'}
   */
  shape: "style.shape",
  /**
   * @title 
   * @description  boolean  
   */
  connectNulls: {
    target: "style",
    value: function(value2) {
      if ((0, import_lodash4.isBoolean)(value2)) {
        return {
          connect: value2
        };
      }
      return value2;
    }
  },
  /**
   * @title 
   * @example
   *  1. transpose: true -> coordinate: { transform: [{ type: 'transpose' }]}
   *  2. transpose: false -> coordinate: { }
   */
  transpose: {
    target: "transpose",
    value: function(value2) {
      return commonCallback("transpose", value2);
    }
  }
};
var EXTENDED_PROPERTIES = [
  "xField",
  "yField",
  "seriesField",
  "colorField",
  "shapeField",
  "keyField",
  "positionField",
  "meta",
  "tooltip",
  "animate",
  "stack",
  "normalize",
  "percent",
  "group",
  "sort",
  "symmetry",
  "diff"
];
var CONFIG_SHAPE = [
  {
    key: "annotations",
    extendedProperties: []
  },
  {
    key: "line",
    type: "line",
    extendedProperties: EXTENDED_PROPERTIES
  },
  {
    key: "connector",
    type: "connector",
    extendedProperties: []
  },
  {
    key: "point",
    type: "point",
    extendedProperties: EXTENDED_PROPERTIES,
    defaultShapeConfig: {
      shapeField: "circle"
    }
  },
  {
    key: "area",
    type: "area",
    extendedProperties: EXTENDED_PROPERTIES
  }
];
var SPECIAL_OPTIONS = [
  {
    key: "transform",
    callback: function(origin, key, value2) {
      var _a2;
      origin[key] = origin[key] || [];
      var _b = value2.available, available = _b === void 0 ? true : _b, rest = __rest91(value2, ["available"]);
      if (available) {
        origin[key].push(__assign6((_a2 = {}, _a2[TRANSFORM_SIGN] = true, _a2), rest));
      } else {
        var index3 = origin[key].indexOf(function(item) {
          return item.type === value2.type;
        });
        if (index3 !== -1) {
          origin[key].splice(index3, 1);
        }
      }
    }
  },
  {
    key: "labels",
    callback: function(origin, key, value2) {
      var _a2;
      if (!value2 || (0, import_lodash4.isArray)(value2)) {
        origin[key] = value2 ? value2 : [];
        return;
      }
      if (!value2.text) {
        value2["text"] = origin["yField"];
      }
      origin[key] = origin[key] || [];
      origin[key].push(__assign6((_a2 = {}, _a2[TRANSFORM_SIGN] = true, _a2), value2));
    }
  },
  {
    key: "transpose",
    callback: function(origin, key, value2) {
      var _a2;
      if (value2.available) {
        origin["coordinate"] = {
          transform: [__assign6((_a2 = {}, _a2[TRANSFORM_SIGN] = true, _a2), value2)]
        };
      } else {
        origin["coordinate"] = {};
      }
    }
  }
];
var ANNOTATION_LIST = [
  {
    key: "conversionTag",
    shape: "ConversionTag"
  },
  {
    key: "axisText",
    shape: "BidirectionalBarAxisText"
  }
];

// node_modules/@ant-design/plots/es/core/annotation/shapes/Text.js
var __extends3 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var __rest92 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Text5 = (
  /** @class */
  function(_super) {
    __extends3(Text6, _super);
    function Text6(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest92(_a2, ["style"]);
      return _super.call(this, __assign7({ style: __assign7({ text: "", fontSize: 12, textBaseline: "middle", textAlign: "center", fill: "#000", fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1 }, style) }, restOptions)) || this;
    }
    return Text6;
  }(Text)
);

// node_modules/@ant-design/plots/es/core/annotation/shapes/Polygon.js
var __extends4 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var __rest93 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var Polygon4 = (
  /** @class */
  function(_super) {
    __extends4(Polygon5, _super);
    function Polygon5(_a2) {
      if (_a2 === void 0) {
        _a2 = {};
      }
      var style = _a2.style, restOptions = __rest93(_a2, ["style"]);
      return _super.call(this, __assign8({ style: __assign8({ fill: "#eee" }, style) }, restOptions)) || this;
    }
    return Polygon5;
  }(Polygon)
);

// node_modules/@ant-design/plots/es/core/annotation/core.js
var __extends5 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Annotaion = (
  /** @class */
  function(_super) {
    __extends5(Annotaion3, _super);
    function Annotaion3(chart, config, defaultOptions) {
      var _this2 = _super.call(this, { style: mergeWithArrayCoverage(defaultOptions, config) }) || this;
      _this2.chart = chart;
      return _this2;
    }
    Annotaion3.prototype.connectedCallback = function() {
      this.render(this.attributes, this);
      this.bindEvents(this.attributes, this);
    };
    Annotaion3.prototype.disconnectedCallback = function() {
    };
    Annotaion3.prototype.attributeChangedCallback = function(name2) {
    };
    Annotaion3.prototype.update = function(attr2, animate2) {
      var _a2;
      this.attr(mergeWithArrayCoverage({}, this.attributes, attr2 || {}));
      return (_a2 = this.render) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.attributes, this, animate2);
    };
    Annotaion3.prototype.clear = function() {
      this.removeChildren();
    };
    Annotaion3.prototype.getElementsLayout = function() {
      var canvas = this.chart.getContext().canvas;
      var elements = canvas.document.getElementsByClassName("element");
      var elementsLayout = [];
      elements.forEach(function(element) {
        var bbox = element.getBBox();
        var x3 = bbox.x, y4 = bbox.y, width = bbox.width, height = bbox.height;
        var data2 = element["__data__"];
        elementsLayout.push({
          bbox,
          x: x3,
          y: y4,
          width,
          height,
          key: data2.key,
          data: data2
        });
      });
      return elementsLayout;
    };
    Annotaion3.prototype.bindEvents = function(attributes, container) {
    };
    return Annotaion3;
  }(CustomElement)
);

// node_modules/@ant-design/plots/es/core/annotation/conversion-tag.js
var __extends6 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var ConversionTag = (
  /** @class */
  function(_super) {
    __extends6(ConversionTag2, _super);
    function ConversionTag2(chart, options) {
      return _super.call(this, chart, options, { type: ConversionTag2.tag }) || this;
    }
    ConversionTag2.prototype.getConversionTagLayout = function() {
      var isVertical2 = this.direction === "vertical";
      var elementsLayout = this.getElementsLayout();
      var _a2 = elementsLayout[0], firstX = _a2.x, firstY = _a2.y, firstHeigt = _a2.height, firstWidth = _a2.width, firstData = _a2.data;
      var valuePath = ["items", 0, "value"];
      var preValue = (0, import_lodash4.get)(firstData, valuePath);
      var elementDistance = isVertical2 ? elementsLayout[1].y - firstY - firstHeigt : elementsLayout[1].x - firstX - firstWidth;
      var tagLayout = [];
      var _b = this.attributes, _c = _b.size, size3 = _c === void 0 ? 40 : _c, _d = _b.arrowSize, arrowSize = _d === void 0 ? 20 : _d, _e = _b.spacing, spacing = _e === void 0 ? 4 : _e;
      elementsLayout.forEach(function(element, index3) {
        if (index3 > 0) {
          var x3 = element.x, y4 = element.y, height = element.height, width = element.width, data2 = element.data, key = element.key;
          var currentValue = (0, import_lodash4.get)(data2, valuePath);
          var halfSize = size3 / 2;
          if (isVertical2) {
            var arrowVertexX = x3 + width / 2;
            var arrowVertexY = y4;
            tagLayout.push({
              points: [
                [arrowVertexX + halfSize, arrowVertexY - elementDistance + spacing],
                [arrowVertexX + halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX, arrowVertexY - spacing],
                [arrowVertexX - halfSize, arrowVertexY - arrowSize - spacing],
                [arrowVertexX - halfSize, arrowVertexY - elementDistance + spacing]
              ],
              center: [arrowVertexX, arrowVertexY - elementDistance / 2 - spacing],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          } else {
            var arrowVertexX = x3;
            var arrowVertexY = y4 + height / 2;
            tagLayout.push({
              points: [
                [x3 - elementDistance + spacing, arrowVertexY - halfSize],
                [x3 - arrowSize - spacing, arrowVertexY - halfSize],
                [arrowVertexX - spacing, arrowVertexY],
                [x3 - arrowSize - spacing, arrowVertexY + halfSize],
                [x3 - elementDistance + spacing, arrowVertexY + halfSize]
              ],
              center: [arrowVertexX - elementDistance / 2 - spacing, arrowVertexY],
              width: elementDistance,
              value: [preValue, currentValue],
              key
            });
          }
          preValue = currentValue;
        }
      });
      return tagLayout;
    };
    ConversionTag2.prototype.render = function() {
      this.setDirection();
      this.drawConversionTag();
    };
    ConversionTag2.prototype.setDirection = function() {
      var coordinate = this.chart.getCoordinate();
      var transformations = (0, import_lodash4.get)(coordinate, "options.transformations");
      var direction3 = "horizontal";
      transformations.forEach(function(transformation) {
        if (transformation.includes("transpose")) {
          direction3 = "vertical";
        }
      });
      this.direction = direction3;
    };
    ConversionTag2.prototype.drawConversionTag = function() {
      var _this2 = this;
      var conversionLayout = this.getConversionTagLayout();
      var _a2 = this.attributes, style = _a2.style, _b = _a2.text, textStyle = _b.style, formatter2 = _b.formatter;
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, value2 = layout.value, key = layout.key;
        var prev = value2[0], next = value2[1];
        var x3 = center2[0], y4 = center2[1];
        var polygon = new Polygon4({
          style: __assign9({ points, fill: "#eee" }, style),
          id: "polygon-".concat(key)
        });
        var text = new Text5({
          style: __assign9({ x: x3, y: y4, text: (0, import_lodash4.isFunction)(formatter2) ? formatter2(prev, next) : (next / prev * 100).toFixed(2) + "%" }, textStyle),
          id: "text-".concat(key)
        });
        _this2.appendChild(polygon);
        _this2.appendChild(text);
      });
    };
    ConversionTag2.prototype.update = function() {
      var _this2 = this;
      var conversionLayout = this.getConversionTagLayout();
      conversionLayout.forEach(function(layout) {
        var points = layout.points, center2 = layout.center, key = layout.key;
        var x3 = center2[0], y4 = center2[1];
        var polygon = _this2.getElementById("polygon-".concat(key));
        var text = _this2.getElementById("text-".concat(key));
        polygon.setAttribute("points", points);
        text.setAttribute("x", x3);
        text.setAttribute("y", y4);
      });
    };
    ConversionTag2.prototype.destroy = function() {
      this.clear();
    };
    ConversionTag2.tag = "ConversionTag";
    return ConversionTag2;
  }(Annotaion)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/constants.js
var VERTICAL_MARGIN = 32;
var HORIZONTAL_MARGIN = 16;
var AXIS_LABEL_PADDING = 48;

// node_modules/@ant-design/plots/es/core/annotation/bidirectional-bar-axis-text.js
var __extends7 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var __rest94 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var BidirectionalBarAxisText = (
  /** @class */
  function(_super) {
    __extends7(BidirectionalBarAxisText2, _super);
    function BidirectionalBarAxisText2(chart, options) {
      return _super.call(this, chart, options, { type: BidirectionalBarAxisText2.tag }) || this;
    }
    BidirectionalBarAxisText2.prototype.render = function() {
      this.drawText();
    };
    BidirectionalBarAxisText2.prototype.getBidirectionalBarAxisTextLayout = function() {
      var layout = this.attributes.layout;
      var isVertical2 = layout === "vertical";
      var allElementsLayout = this.getElementsLayout();
      var elementsLayout = isVertical2 ? (0, import_lodash4.uniqBy)(allElementsLayout, "x") : (0, import_lodash4.uniqBy)(allElementsLayout, "y");
      var textPath = ["title"];
      var textLayout = [];
      var views = this.chart.getContext().views;
      var _a2 = (0, import_lodash4.get)(views, [0, "layout"]), viewWidth = _a2.width, viewHeight = _a2.height;
      elementsLayout.forEach(function(element) {
        var x3 = element.x, y4 = element.y, height = element.height, width = element.width, data2 = element.data, key = element.key;
        var text = (0, import_lodash4.get)(data2, textPath);
        if (isVertical2) {
          textLayout.push({
            x: x3 + width / 2,
            y: viewHeight,
            text,
            key
          });
        } else {
          textLayout.push({
            x: viewWidth,
            y: y4 + height / 2,
            text,
            key
          });
        }
      });
      if ((0, import_lodash4.uniqBy)(textLayout, "text").length !== textLayout.length) {
        textLayout = Object.values((0, import_lodash4.groupBy)(textLayout, "text")).map(function(items) {
          var _a3;
          var sum4 = items.reduce(function(pre, cur) {
            return pre + (isVertical2 ? cur.x : cur.y);
          }, 0);
          return __assign10(__assign10({}, items[0]), (_a3 = {}, _a3[isVertical2 ? "x" : "y"] = sum4 / items.length, _a3));
        });
      }
      return textLayout;
    };
    BidirectionalBarAxisText2.prototype.transformLabelStyle = function(style) {
      var removeLabel = {};
      var reg = /^label[A-Z]/;
      Object.keys(style).forEach(function(key) {
        if (reg.test(key)) {
          removeLabel[key.replace("label", "").replace(/^[A-Z]/, function(match) {
            return match.toLowerCase();
          })] = style[key];
        }
      });
      return removeLabel;
    };
    BidirectionalBarAxisText2.prototype.drawText = function() {
      var _this2 = this;
      var axisLayout = this.getBidirectionalBarAxisTextLayout();
      var _a2 = this.attributes, viewLayout = _a2.layout, labelFormatter2 = _a2.labelFormatter, textStyle = __rest94(_a2, ["layout", "labelFormatter"]);
      axisLayout.forEach(function(layout) {
        var x3 = layout.x, y4 = layout.y, text = layout.text, key = layout.key;
        var textNode = new Text5({
          style: __assign10({ x: x3, y: y4, text: (0, import_lodash4.isFunction)(labelFormatter2) ? labelFormatter2(text) : text, wordWrap: true, wordWrapWidth: viewLayout === "horizontal" ? VERTICAL_MARGIN * 2 : 120, maxLines: 2, textOverflow: "ellipsis" }, _this2.transformLabelStyle(textStyle)),
          id: "text-".concat(key)
        });
        _this2.appendChild(textNode);
      });
    };
    BidirectionalBarAxisText2.prototype.destroy = function() {
      this.clear();
    };
    BidirectionalBarAxisText2.prototype.update = function() {
      this.destroy();
      this.drawText();
    };
    BidirectionalBarAxisText2.tag = "BidirectionalBarAxisText";
    return BidirectionalBarAxisText2;
  }(Annotaion)
);

// node_modules/@ant-design/plots/es/core/annotation/index.js
var Annotaion2 = { ConversionTag, BidirectionalBarAxisText };
var Controller2 = (
  /** @class */
  function() {
    function Controller3(chart, config) {
      this.container = /* @__PURE__ */ new Map();
      this.chart = chart;
      this.config = config;
      this.init();
    }
    Controller3.prototype.init = function() {
      var _this2 = this;
      ANNOTATION_LIST.forEach(function(annotation) {
        var _a2;
        var key = annotation.key, shape23 = annotation.shape;
        var annotationOptions = _this2.config[key];
        if (annotationOptions) {
          var annotationInstance = new Annotaion2[shape23](_this2.chart, annotationOptions);
          var canvas = _this2.chart.getContext().canvas;
          canvas.appendChild(annotationInstance);
          _this2.container.set(key, annotationInstance);
        } else {
          (_a2 = _this2.container.get(key)) === null || _a2 === void 0 ? void 0 : _a2.clear();
        }
      });
    };
    Controller3.prototype.update = function() {
      var _this2 = this;
      if (!this.container.size)
        return;
      ANNOTATION_LIST.forEach(function(annotation) {
        var key = annotation.key;
        var annotationInstance = _this2.container.get(key);
        annotationInstance === null || annotationInstance === void 0 ? void 0 : annotationInstance.update();
      });
    };
    Controller3.prototype.destroy = function() {
      this.container.forEach(function(annotationInstance) {
        annotationInstance.destroy();
      });
      this.container.clear();
    };
    return Controller3;
  }()
);

// node_modules/@ant-design/plots/es/core/base/index.js
var __extends8 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var Plot = (
  /** @class */
  function(_super) {
    __extends8(Plot2, _super);
    function Plot2(container, options) {
      var _this2 = _super.call(this) || this;
      _this2.eventListeners = [];
      _this2.bindedEvents = false;
      _this2.container = typeof container === "string" ? document.getElementById(container) : container;
      _this2.options = _this2.mergeOption(options);
      _this2.createG2();
      _this2.bindEvents();
      return _this2;
    }
    Plot2.prototype.getChartOptions = function() {
      return __assign11(__assign11({}, (0, import_lodash4.pick)(this.options, CHART_OPTIONS)), { container: this.container });
    };
    Plot2.prototype.getSpecOptions = function() {
      if (this.type === "base" || this[SKIP_DEL_CUSTOM_SIGN]) {
        return __assign11(__assign11({}, this.options), this.getChartOptions());
      }
      return this.options;
    };
    Plot2.prototype.createG2 = function() {
      if (!this.container) {
        throw Error("The container is not initialized!");
      }
      this.chart = new Chart3(this.getChartOptions());
      this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "Ant Design Charts");
    };
    Plot2.prototype.bindEvents = function() {
      var _this2 = this;
      if (this.chart) {
        var eventHandler_1 = function(e3) {
          if (e3 === null || e3 === void 0 ? void 0 : e3.type) {
            _this2.emit(e3.type, e3);
          }
        };
        this.chart.on("*", eventHandler_1);
        this.eventListeners.push(function() {
          var _a2;
          (_a2 = _this2.chart) === null || _a2 === void 0 ? void 0 : _a2.off("*", eventHandler_1);
        });
      }
    };
    Plot2.prototype.getBaseOptions = function() {
      return { type: "view", autoFit: true };
    };
    Plot2.prototype.getDefaultOptions = function() {
    };
    Plot2.prototype.render = function() {
      var _this2 = this;
      if (this.type !== "base") {
        this.execAdaptor();
      }
      this.chart.options(this.getSpecOptions());
      this.chart.render().then(function() {
        _this2.annotation = new Controller2(_this2.chart, _this2.options);
        _this2.bindSizeSensor();
      });
    };
    Plot2.prototype.update = function(options) {
      this.options = this.mergeOption(options);
    };
    Plot2.prototype.mergeOption = function(options) {
      return mergeWithArrayCoverage({}, this.getBaseOptions(), this.getDefaultOptions(), options);
    };
    Plot2.prototype.changeData = function(data2) {
      this.chart.changeData(data2);
    };
    Plot2.prototype.changeSize = function(width, height) {
      this.chart.changeSize(width, height);
    };
    Plot2.prototype.destroy = function() {
      this.eventListeners.forEach(function(cleanup) {
        return cleanup();
      });
      this.eventListeners = [];
      if (this.annotation && typeof this.annotation.destroy === "function") {
        this.annotation.destroy();
      }
      this.annotation = null;
      this.chart.destroy();
      this.off();
      this.bindedEvents = false;
      this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
    };
    Plot2.prototype.execAdaptor = function() {
      var adaptor33 = this.getSchemaAdaptor();
      adaptor33({
        chart: this.chart,
        options: this.options
      });
    };
    Plot2.prototype.triggerResize = function() {
      this.chart.forceFit();
    };
    Plot2.prototype.bindSizeSensor = function() {
      var _this2 = this;
      if (this.bindedEvents)
        return;
      var _a2 = this.options.autoFit, autoFit = _a2 === void 0 ? true : _a2;
      if (autoFit) {
        var resizeHandler_1 = function() {
          if (_this2.annotation) {
            _this2.annotation.update();
          }
        };
        this.chart.on(ChartEvent.AFTER_CHANGE_SIZE, resizeHandler_1);
        this.eventListeners.push(function() {
          var _a3;
          (_a3 = _this2.chart) === null || _a3 === void 0 ? void 0 : _a3.off(ChartEvent.AFTER_CHANGE_SIZE, resizeHandler_1);
        });
        this.bindedEvents = true;
      }
    };
    return Plot2;
  }(esm_default)
);

// node_modules/@ant-design/plots/es/core/plots/base/index.js
var __extends9 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Base2 = (
  /** @class */
  function(_super) {
    __extends9(Base3, _super);
    function Base3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "base";
      return _this2;
    }
    Base3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line" }]
      };
    };
    Base3.prototype.getDefaultOptions = function() {
      return Base3.getDefaultOptions();
    };
    Base3.prototype.getSchemaAdaptor = function() {
      return function(params) {
        return params;
      };
    };
    return Base3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/adaptor/shape-stack.js
var __assign12 = function() {
  __assign12 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign12.apply(this, arguments);
};
function shapeStack(params) {
  var options = params.options;
  var stack = options.stack, tooltip2 = options.tooltip, xField = options.xField;
  if (!stack)
    return params;
  var shapes = CONFIG_SHAPE.map(function(item) {
    return item.type;
  }).filter(function(item) {
    return !!item;
  });
  var hasStack = false;
  shapes.forEach(function(shape23) {
    if (options[shape23]) {
      hasStack = true;
      (0, import_lodash4.set)(options, [shape23, "stack"], __assign12({ y1: "y" }, typeof stack === "object" ? stack : {}));
    }
  });
  if (hasStack && !(0, import_lodash4.isBoolean)(tooltip2) && !tooltip2) {
    (0, import_lodash4.set)(options, "tooltip", {
      title: xField,
      items: [
        {
          channel: "y"
        }
      ]
    });
  }
  return params;
}

// node_modules/@ant-design/plots/es/core/adaptor/mark.js
function mark(params) {
  return (0, import_lodash4.flow)(shapeStack)(params);
}

// node_modules/@ant-design/plots/es/core/adaptor/coordinate-layout.js
function coordinateLayout(params) {
  var _a2 = params.options.layout, layout = _a2 === void 0 ? "horizontal" : _a2;
  params.options.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
  return params;
}
function allCoordinateLayout(params) {
  coordinateLayout(params);
  var _a2 = params.options.layout, layout = _a2 === void 0 ? "horizontal" : _a2;
  params.options.children.forEach(function(item) {
    var _a3;
    if ((_a3 = item === null || item === void 0 ? void 0 : item.coordinate) === null || _a3 === void 0 ? void 0 : _a3.transform) {
      item.coordinate.transform = layout !== "horizontal" ? void 0 : [{ type: "transpose" }];
    }
  });
  return params;
}

// node_modules/@ant-design/plots/es/core/plots/area/adaptor.js
function adaptor2(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/area/index.js
var __extends10 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Area3 = (
  /** @class */
  function(_super) {
    __extends10(Area4, _super);
    function Area4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "area";
      return _this2;
    }
    Area4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "area" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        }
      };
    };
    Area4.prototype.getDefaultOptions = function() {
      return Area4.getDefaultOptions();
    };
    Area4.prototype.getSchemaAdaptor = function() {
      return adaptor2;
    };
    return Area4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bar/adaptor.js
var __assign13 = function() {
  __assign13 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign13.apply(this, arguments);
};
function adaptor3(params) {
  var background = function(params2) {
    var options = params2.options;
    if ((0, import_lodash4.get)(options, "children.length") > 1) {
      (0, import_lodash4.set)(options, "children", [{ type: "interval" }]);
    }
    var scale12 = options.scale, markBackground = options.markBackground, data2 = options.data, children = options.children, yField = options.yField;
    var domain = (0, import_lodash4.get)(scale12, "y.domain", []);
    if (markBackground && domain.length && (0, import_lodash4.isArray)(data2)) {
      var domainMax_1 = "domainMax";
      var backgroundData = data2.map(function(item) {
        var _a2;
        return __assign13(__assign13({ originData: __assign13({}, item) }, (0, import_lodash4.omit)(item, yField)), (_a2 = {}, _a2[domainMax_1] = domain[domain.length - 1], _a2));
      });
      children.unshift(__assign13({ type: "interval", data: backgroundData, yField: domainMax_1, tooltip: false, style: {
        fill: "#eee"
      }, label: false }, markBackground));
    }
    return params2;
  };
  return (0, import_lodash4.flow)(background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bar/shape.js
var reisterShape = function() {
  var draw25DBar = function(style, context) {
    return function(points) {
      var _a2 = style.fill, fill = _a2 === void 0 ? "#2888FF" : _a2, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var p1 = points[0], p22 = points[1], p3 = points[2], p4 = points[3];
      var height = (p22[1] - p1[1]) / 2;
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var top = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], [p3[0] - pitch, p1[1] + height], p4],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var bottom = document2.createElement("polygon", {
        style: {
          points: [[p1[0] - pitch, p1[1] + height], p22, p3, [p3[0] - pitch, p1[1] + height]],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [p1, [p1[0] - pitch, p1[1] + height], p22, [p1[0] + pitch, p1[1] + height]],
          fill,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(top);
      g.appendChild(bottom);
      g.appendChild(right2);
      return g;
    };
  };
  register("shape.interval.bar25D", draw25DBar);
};

// node_modules/@ant-design/plots/es/core/plots/bar/index.js
var __extends11 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape();
var Bar = (
  /** @class */
  function(_super) {
    __extends11(Bar2, _super);
    function Bar2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Bar";
      return _this2;
    }
    Bar2.getDefaultOptions = function() {
      return {
        type: "view",
        coordinate: { transform: [{ type: "transpose" }] },
        children: [{ type: "interval" }],
        scale: {
          y: { nice: true }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlight: {
            background: true
          }
        }
      };
    };
    Bar2.prototype.getDefaultOptions = function() {
      return Bar2.getDefaultOptions();
    };
    Bar2.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Bar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/column/shape.js
var reisterShape2 = function() {
  var draw25DColumn = function(style, context) {
    return function(points) {
      var _a2 = style.fill, fill = _a2 === void 0 ? "#2888FF" : _a2, stroke2 = style.stroke, _b = style.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, _c = style.strokeOpacity, strokeOpacity = _c === void 0 ? 0.2 : _c, _d = style.pitch, pitch = _d === void 0 ? 8 : _d;
      var x3 = points[1][0] - points[0][0];
      var x4 = x3 / 2 + points[0][0];
      var document2 = context.document;
      var g = document2.createElement("g", {});
      var left2 = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] + pitch],
            [x4, points[3][1] + pitch],
            [points[3][0], points[3][1]]
          ],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity,
          inset: 30
        }
      });
      var right2 = document2.createElement("polygon", {
        style: {
          points: [
            [x4, points[1][1] + pitch],
            [points[1][0], points[1][1]],
            [points[2][0], points[2][1]],
            [x4, points[2][1] + pitch]
          ],
          fill,
          fillOpacity,
          stroke: stroke2,
          strokeOpacity
        }
      });
      var top = document2.createElement("polygon", {
        style: {
          points: [
            [points[0][0], points[0][1]],
            [x4, points[1][1] - pitch],
            [points[1][0], points[1][1]],
            [x4, points[1][1] + pitch]
          ],
          fill,
          fillOpacity: fillOpacity - 0.2
        }
      });
      g.appendChild(right2);
      g.appendChild(left2);
      g.appendChild(top);
      return g;
    };
  };
  register("shape.interval.column25D", draw25DColumn);
};

// node_modules/@ant-design/plots/es/core/plots/column/index.js
var __extends12 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
reisterShape2();
var Column2 = (
  /** @class */
  function(_super) {
    __extends12(Column3, _super);
    function Column3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "column";
      return _this2;
    }
    Column3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          },
          elementHighlight: {
            background: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Column3.prototype.getDefaultOptions = function() {
      return Column3.getDefaultOptions();
    };
    Column3.prototype.getSchemaAdaptor = function() {
      return adaptor3;
    };
    return Column3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/dual-axes/adaptor.js
function adaptor4(params) {
  var colorField = function(params2) {
    var options = params2.options;
    var _a2 = options.children, children = _a2 === void 0 ? [] : _a2, legend = options.legend;
    if (!legend)
      return params2;
    children.forEach(function(option) {
      if (!(0, import_lodash4.get)(option, "colorField")) {
        var yField_1 = (0, import_lodash4.get)(option, "yField");
        (0, import_lodash4.set)(option, "colorField", function() {
          return yField_1;
        });
      }
    });
    return params2;
  };
  var annotations = function(params2) {
    var options = params2.options;
    var _a2 = options.annotations, annotations2 = _a2 === void 0 ? [] : _a2, _b = options.children, children = _b === void 0 ? [] : _b, scale12 = options.scale;
    var sharedScale = false;
    if ((0, import_lodash4.get)(scale12, "y.key")) {
      return params2;
    }
    children.forEach(function(child, index3) {
      if (!(0, import_lodash4.get)(child, "scale.y.key")) {
        var scaleKey_1 = "child".concat(index3, "Scale");
        (0, import_lodash4.set)(child, "scale.y.key", scaleKey_1);
        var _a3 = child.annotations, childAnnotations = _a3 === void 0 ? [] : _a3;
        if (childAnnotations.length > 0) {
          (0, import_lodash4.set)(child, "scale.y.independent", false);
          childAnnotations.forEach(function(annotation) {
            (0, import_lodash4.set)(annotation, "scale.y.key", scaleKey_1);
          });
        }
        if (!sharedScale && annotations2.length > 0 && (0, import_lodash4.get)(child, "scale.y.independent") === void 0) {
          sharedScale = true;
          (0, import_lodash4.set)(child, "scale.y.independent", false);
          annotations2.forEach(function(annotation) {
            (0, import_lodash4.set)(annotation, "scale.y.key", scaleKey_1);
          });
        }
      }
    });
    return params2;
  };
  return (0, import_lodash4.flow)(colorField, annotations, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/dual-axes/index.js
var __extends13 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DualAxes = (
  /** @class */
  function(_super) {
    __extends13(DualAxes2, _super);
    function DualAxes2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "DualAxes";
      return _this2;
    }
    DualAxes2.getDefaultOptions = function() {
      return {
        type: "view",
        axis: {
          y: { title: false, tick: false },
          x: { title: false }
        },
        scale: {
          y: {
            independent: true,
            nice: true
          }
        }
      };
    };
    DualAxes2.prototype.getDefaultOptions = function() {
      return DualAxes2.getDefaultOptions();
    };
    DualAxes2.prototype.getSchemaAdaptor = function() {
      return adaptor4;
    };
    return DualAxes2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/funnel/adaptor.js
function adaptor5(params) {
  var init = function(params2) {
    var options = params2.options;
    var xField = options.xField, colorField = options.colorField;
    if (!colorField) {
      (0, import_lodash4.set)(options, "colorField", xField);
    }
    return params2;
  };
  var transform2 = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, transform3 = options.transform, _a2 = options.isTransposed, isTransposed = _a2 === void 0 ? true : _a2, coordinate = options.coordinate;
    if (!transform3) {
      if (compareField) {
        (0, import_lodash4.set)(options, "transform", []);
      } else {
        (0, import_lodash4.set)(options, "transform", [{ type: "symmetryY" }]);
      }
    }
    if (!coordinate && isTransposed) {
      (0, import_lodash4.set)(options, "coordinate", { transform: [{ type: "transpose" }] });
    }
    return params2;
  };
  var compare = function(params2) {
    var options = params2.options;
    var compareField = options.compareField, seriesField = options.seriesField, data2 = options.data, children = options.children, yField = options.yField, _a2 = options.isTransposed, isTransposed = _a2 === void 0 ? true : _a2;
    if (compareField || seriesField) {
      var groupedData = Object.values((0, import_lodash4.groupBy)(data2, function(item) {
        return item[compareField || seriesField];
      }));
      children[0].data = groupedData[0];
      children.push({
        type: "interval",
        data: groupedData[1],
        // @ts-ignore
        yField: function(item) {
          return -item[yField];
        }
      });
      delete options["compareField"];
      delete options.data;
    }
    if (seriesField) {
      (0, import_lodash4.set)(options, "type", "spaceFlex");
      (0, import_lodash4.set)(options, "ratio", [1, 1]);
      (0, import_lodash4.set)(options, "direction", isTransposed ? "row" : "col");
      delete options["seriesField"];
    }
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        title: false,
        items: [
          function(d4) {
            return { name: d4[xField], value: d4[yField] };
          }
        ]
      });
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, transform2, compare, tooltip2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/funnel/index.js
var __extends14 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Funnel2 = (
  /** @class */
  function(_super) {
    __extends14(Funnel3, _super);
    function Funnel3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "column";
      return _this2;
    }
    Funnel3.getDefaultOptions = function() {
      return {
        type: "view",
        scale: { x: { padding: 0 } },
        animate: { enter: { type: "fadeIn" } },
        axis: false,
        shapeField: "funnel",
        label: {
          position: "inside",
          transform: [{ type: "contrastReverse" }]
        },
        children: [
          {
            type: "interval"
          }
        ]
      };
    };
    Funnel3.prototype.getDefaultOptions = function() {
      return Funnel3.getDefaultOptions();
    };
    Funnel3.prototype.getSchemaAdaptor = function() {
      return adaptor5;
    };
    return Funnel3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/line/adaptor.js
function adaptor6(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/line/index.js
var __extends15 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Line6 = (
  /** @class */
  function(_super) {
    __extends15(Line7, _super);
    function Line7() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "line";
      return _this2;
    }
    Line7.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          y: { nice: true }
        },
        interaction: {
          tooltip: {
            shared: true
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        // - 
        // animate: {
        //   enter: { type: 'growInX' },
        // },
        children: [{ type: "line" }]
      };
    };
    Line7.prototype.getDefaultOptions = function() {
      return Line7.getDefaultOptions();
    };
    Line7.prototype.getSchemaAdaptor = function() {
      return adaptor6;
    };
    return Line7;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/pie/adaptor.js
var __assign14 = function() {
  __assign14 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign14.apply(this, arguments);
};
function adaptor7(params) {
  var emptyData = function(params2) {
    var options = params2.options;
    var angleField = options.angleField, data2 = options.data, label = options.label, tooltip2 = options.tooltip, colorField = options.colorField;
    var getColorValue = fieldAdapter(colorField);
    if ((0, import_lodash4.isArray)(data2) && data2.length > 0) {
      var sum4 = data2.reduce(function(a5, b) {
        return a5 + b[angleField];
      }, 0);
      if (sum4 === 0) {
        var normalization = data2.map(function(item) {
          var _a2;
          return __assign14(__assign14({}, item), (_a2 = {}, _a2[angleField] = 1, _a2));
        });
        (0, import_lodash4.set)(options, "data", normalization);
        if (label) {
          var isColorField = colorField === (0, import_lodash4.get)(label, "text");
          (0, import_lodash4.set)(options, "label", __assign14(__assign14({}, label), isColorField ? {} : { formatter: function() {
            return 0;
          } }));
        }
        if (tooltip2 !== false) {
          if ((0, import_lodash4.isFunction)(tooltip2)) {
            (0, import_lodash4.set)(options, "tooltip", function(arg, index3, items) {
              var _a2;
              return tooltip2(__assign14(__assign14({}, arg), (_a2 = {}, _a2[angleField] = 0, _a2)), index3, items.map(function(item) {
                var _a3;
                return __assign14(__assign14({}, item), (_a3 = {}, _a3[angleField] = 0, _a3));
              }));
            });
          } else {
            (0, import_lodash4.set)(options, "tooltip", __assign14(__assign14({}, tooltip2), { items: [
              function(arg, i2, d4) {
                return {
                  name: getColorValue(arg, i2, d4),
                  value: 0
                };
              }
            ] }));
          }
        }
      }
    }
    return params2;
  };
  return (0, import_lodash4.flow)(emptyData, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/pie/index.js
var __extends16 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Pie = (
  /** @class */
  function(_super) {
    __extends16(Pie2, _super);
    function Pie2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "pie";
      return _this2;
    }
    Pie2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "theta" },
        transform: [{ type: "stackY", reverse: true }],
        animate: { enter: { type: "waveIn" } }
      };
    };
    Pie2.prototype.getDefaultOptions = function() {
      return Pie2.getDefaultOptions();
    };
    Pie2.prototype.getSchemaAdaptor = function() {
      return adaptor7;
    };
    return Pie2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/scatter/adaptor.js
function adaptor8(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/scatter/index.js
var __extends17 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Scatter = (
  /** @class */
  function(_super) {
    __extends17(Scatter2, _super);
    function Scatter2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "scatter";
      return _this2;
    }
    Scatter2.getDefaultOptions = function() {
      return {
        axis: {
          y: { title: false },
          x: { title: false }
        },
        legend: {
          size: false
        },
        children: [{ type: "point" }]
      };
    };
    Scatter2.prototype.getDefaultOptions = function() {
      return Scatter2.getDefaultOptions();
    };
    Scatter2.prototype.getSchemaAdaptor = function() {
      return adaptor8;
    };
    return Scatter2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radar/adaptor.js
function adaptor9(params) {
  var init = function(params2) {
    (0, import_lodash4.set)(params2, "options.coordinate", { type: (0, import_lodash4.get)(params2, "options.coordinateType", "polar") });
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radar/index.js
var __extends18 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Radar2 = (
  /** @class */
  function(_super) {
    __extends18(Radar3, _super);
    function Radar3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "radar";
      return _this2;
    }
    Radar3.getDefaultOptions = function() {
      return {
        axis: {
          x: { grid: true, line: true },
          y: { zIndex: 1, title: false, line: true, nice: true }
        },
        meta: { x: { padding: 0.5, align: 0 } },
        interaction: { tooltip: { style: { crosshairsLineDash: [4, 4] } } },
        children: [{ type: "line" }],
        //   polar  radar 
        coordinateType: "polar"
      };
    };
    Radar3.prototype.getDefaultOptions = function() {
      return Radar3.getDefaultOptions();
    };
    Radar3.prototype.getSchemaAdaptor = function() {
      return adaptor9;
    };
    return Radar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/stock/adaptor.js
function adaptor10(params) {
  var init = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children, _a2 = options.style, style = _a2 === void 0 ? {} : _a2, _b = options.lineStyle, lineStyle = _b === void 0 ? {} : _b;
    var open = yField[0], close = yField[1], high = yField[2], low = yField[3];
    (0, import_lodash4.set)(children, [0, "yField"], [high, low]);
    (0, import_lodash4.set)(children, [0, "style"], lineStyle);
    (0, import_lodash4.set)(children, [1, "yField"], [open, close]);
    (0, import_lodash4.set)(children, [1, "style"], style);
    delete options.yField;
    delete options.lineStyle;
    delete options.style;
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/stock/index.js
var __extends19 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DEFAULT_COLORS = ["#26a69a", "#999999", "#ef5350"];
var Stock = (
  /** @class */
  function(_super) {
    __extends19(Stock2, _super);
    function Stock2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "stock";
      return _this2;
    }
    Stock2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            domain: [-1, 0, 1],
            range: DEFAULT_COLORS
          },
          y: { nice: true }
        },
        children: [
          // line shadow
          {
            type: "link"
          },
          {
            type: "interval"
          }
        ],
        axis: {
          x: { title: false, grid: false },
          y: { title: false, grid: true, gridLineDash: null }
        },
        animate: { enter: { type: "scaleInY" } },
        interaction: {
          tooltip: {
            shared: true,
            marker: false,
            groupName: false,
            crosshairs: true
          }
        }
      };
    };
    Stock2.prototype.getDefaultOptions = function() {
      return Stock2.getDefaultOptions();
    };
    Stock2.prototype.getSchemaAdaptor = function() {
      return adaptor10;
    };
    return Stock2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-line/adaptor.js
function adaptor11(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-line/index.js
var __extends20 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyLine = (
  /** @class */
  function(_super) {
    __extends20(TinyLine2, _super);
    function TinyLine2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyLine";
      return _this2;
    }
    TinyLine2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "line", axis: false }],
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyLine2.prototype.getDefaultOptions = function() {
      return TinyLine2.getDefaultOptions();
    };
    TinyLine2.prototype.getSchemaAdaptor = function() {
      return adaptor11;
    };
    return TinyLine2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-area/adaptor.js
function adaptor12(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-area/index.js
var __extends21 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyArea = (
  /** @class */
  function(_super) {
    __extends21(TinyArea2, _super);
    function TinyArea2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyArea";
      return _this2;
    }
    TinyArea2.getDefaultOptions = function() {
      return {
        type: "view",
        animate: {
          enter: { type: "growInX", duration: 500 }
        },
        children: [{ type: "area", axis: false }],
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyArea2.prototype.getDefaultOptions = function() {
      return TinyArea2.getDefaultOptions();
    };
    TinyArea2.prototype.getSchemaAdaptor = function() {
      return adaptor12;
    };
    return TinyArea2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-column/adaptor.js
function adaptor13(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-column/index.js
var __extends22 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyColumn = (
  /** @class */
  function(_super) {
    __extends22(TinyColumn2, _super);
    function TinyColumn2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyColumn";
      return _this2;
    }
    TinyColumn2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval", axis: false }],
        padding: 0,
        margin: 0,
        tooltip: false
      };
    };
    TinyColumn2.prototype.getDefaultOptions = function() {
      return TinyColumn2.getDefaultOptions();
    };
    TinyColumn2.prototype.getSchemaAdaptor = function() {
      return adaptor13;
    };
    return TinyColumn2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/adaptor.js
var __assign15 = function() {
  __assign15 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign15.apply(this, arguments);
};
function adaptor14(params) {
  var transformData2 = function(params2) {
    var options = params2.options;
    var percent2 = options.percent, _a2 = options.color, color3 = _a2 === void 0 ? [] : _a2;
    if (!percent2)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color3.length ? color3 : [] }
      },
      data: [1, percent2]
    };
    Object.assign(options, __assign15({}, transformOption));
    return params2;
  };
  return (0, import_lodash4.flow)(transformData2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-progress/index.js
var __extends23 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyProgress = (
  /** @class */
  function(_super) {
    __extends23(TinyProgress2, _super);
    function TinyProgress2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyProgress";
      return _this2;
    }
    TinyProgress2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        margin: 0,
        padding: 0,
        tooltip: false,
        children: [
          {
            interaction: { tooltip: false },
            coordinate: { transform: [{ type: "transpose" }] },
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d4) {
              return d4;
            }, color: function(d4, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyProgress2.prototype.getDefaultOptions = function() {
      return TinyProgress2.getDefaultOptions();
    };
    TinyProgress2.prototype.getSchemaAdaptor = function() {
      return adaptor14;
    };
    return TinyProgress2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/adaptor.js
var __assign16 = function() {
  __assign16 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign16.apply(this, arguments);
};
function adaptor15(params) {
  var radius = function(params2) {
    var options = params2.options;
    var _a2 = options.radius, radius2 = _a2 === void 0 ? 0.8 : _a2;
    (0, import_lodash4.set)(params2, "options.coordinate.innerRadius", radius2);
    return params2;
  };
  var transformData2 = function(params2) {
    var options = params2.options;
    var percent2 = options.percent, _a2 = options.color, color3 = _a2 === void 0 ? [] : _a2;
    if (!percent2)
      return params2;
    var transformOption = {
      scale: {
        color: { range: color3.length ? color3 : [] }
      },
      data: [1, percent2]
    };
    Object.assign(options, __assign16({}, transformOption));
    return params2;
  };
  return (0, import_lodash4.flow)(radius, transformData2, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/tiny-ring/index.js
var __extends24 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TinyRing = (
  /** @class */
  function(_super) {
    __extends24(TinyRing2, _super);
    function TinyRing2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "TinyRing";
      return _this2;
    }
    TinyRing2.getDefaultOptions = function() {
      return {
        type: "view",
        data: [],
        margin: 0,
        padding: 0,
        coordinate: { type: "theta" },
        animate: { enter: { type: "waveIn" } },
        interaction: { tooltip: false },
        tooltip: false,
        children: [
          {
            type: "interval",
            axis: false,
            legend: false,
            encode: { y: function(d4) {
              return d4;
            }, color: function(d4, idx) {
              return idx;
            } }
          }
        ]
      };
    };
    TinyRing2.prototype.getDefaultOptions = function() {
      return TinyRing2.getDefaultOptions();
    };
    TinyRing2.prototype.getSchemaAdaptor = function() {
      return adaptor15;
    };
    return TinyRing2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/rose/adaptor.js
function adaptor16(params) {
  return (0, import_lodash4.flow)(transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/rose/index.js
var __extends25 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Rose = (
  /** @class */
  function(_super) {
    __extends25(Rose2, _super);
    function Rose2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "rose";
      return _this2;
    }
    Rose2.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "polar" },
        animate: { enter: { type: "waveIn" } }
      };
    };
    Rose2.prototype.getDefaultOptions = function() {
      return Rose2.getDefaultOptions();
    };
    Rose2.prototype.getSchemaAdaptor = function() {
      return adaptor16;
    };
    return Rose2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/waterfall/constants.js
var START_KEY = "__start__";
var END_KEY = "__end__";
var WATERFALL_VALUE = "__waterfall_value__";

// node_modules/@ant-design/plots/es/core/plots/waterfall/adaptor.js
var __assign17 = function() {
  __assign17 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign17.apply(this, arguments);
};
var __spreadArray9 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor17(params) {
  var transformData2 = function(params2) {
    var options = params2.options;
    var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField;
    if (!data2.length)
      return params2;
    data2.reduce(function(prev, cur, index3) {
      var _a3;
      var getFieldData = fieldAdapter(yField);
      var newCur = getFieldData(cur, index3, data2);
      if (index3 === 0 || cur.isTotal) {
        cur[START_KEY] = 0;
        cur[END_KEY] = newCur;
        cur[WATERFALL_VALUE] = newCur;
      } else {
        var start = (_a3 = prev[END_KEY]) !== null && _a3 !== void 0 ? _a3 : getFieldData(prev, index3, data2);
        cur[START_KEY] = start;
        cur[END_KEY] = start + newCur;
        cur[WATERFALL_VALUE] = prev[END_KEY];
      }
      return cur;
    }, []);
    Object.assign(options, { yField: [START_KEY, END_KEY] });
    return params2;
  };
  var link3 = function(params2) {
    var options = params2.options;
    var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, xField = options.xField, children = options.children, linkStyle = options.linkStyle;
    var linkData = __spreadArray9([], data2, true);
    linkData.reduce(function(prev, cur, index3) {
      if (index3 > 0) {
        cur.x1 = prev[xField];
        cur.x2 = cur[xField];
        cur.y1 = prev[END_KEY];
      }
      return cur;
    }, []);
    linkData.shift();
    children.push({
      type: "link",
      xField: ["x1", "x2"],
      yField: "y1",
      //  scrollbar  link  interval
      zIndex: -1,
      data: linkData,
      style: __assign17({ stroke: "#697474" }, linkStyle),
      label: false,
      tooltip: false
    });
    return params2;
  };
  var connectorTransform = function(params2) {
    var options = params2.options;
    var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, connector = options.connector;
    if (!connector)
      return params2;
    (0, import_lodash4.set)(options, "connector", __assign17({ xField: connector.reverse ? ["x2", "x1"] : ["x1", "x2"], yField: connector.reverse ? ["y2", "y1"] : ["y1", "y2"], data: [
      {
        x1: data2[0].x,
        y1: data2[0][END_KEY],
        x2: data2[data2.length - 1].x,
        y2: data2[data2.length - 1][END_KEY]
      }
    ] }, (0, import_lodash4.isObject)(connector) ? connector : {}));
    return params2;
  };
  return (0, import_lodash4.flow)(transformData2, link3, mark, connectorTransform, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/waterfall/index.js
var __extends26 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Waterfall = (
  /** @class */
  function(_super) {
    __extends26(Waterfall2, _super);
    function Waterfall2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "waterfall";
      return _this2;
    }
    Waterfall2.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          field: WATERFALL_VALUE,
          valueFormatter: "~s",
          name: "value"
        },
        axis: {
          y: {
            title: null,
            labelFormatter: "~s"
          },
          x: {
            title: null
          }
        },
        children: [
          {
            type: "interval",
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Waterfall2.prototype.getDefaultOptions = function() {
      return Waterfall2.getDefaultOptions();
    };
    Waterfall2.prototype.getSchemaAdaptor = function() {
      return adaptor17;
    };
    return Waterfall2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/histogram/adaptor.js
function adaptor18(params) {
  var transformHistogramConfig = function(params2) {
    var options = params2.options;
    var data2 = options.data, binNumber = options.binNumber, binWidth = options.binWidth, children = options.children, _a2 = options.channel, channel = _a2 === void 0 ? "count" : _a2;
    var targetTransform = (0, import_lodash4.get)(children, "[0].transform[0]", {});
    if ((0, import_lodash4.isNumber)(binWidth)) {
      (0, import_lodash4.assign)(targetTransform, { thresholds: (0, import_lodash4.ceil)((0, import_lodash4.divide)(data2.length, binWidth)), y: channel });
      return params2;
    }
    if ((0, import_lodash4.isNumber)(binNumber)) {
      (0, import_lodash4.assign)(targetTransform, { thresholds: binNumber, y: channel });
      return params2;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(transformHistogramConfig, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/histogram/index.js
var __extends27 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Histogram = (
  /** @class */
  function(_super) {
    __extends27(Histogram2, _super);
    function Histogram2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Histogram";
      return _this2;
    }
    Histogram2.getDefaultOptions = function() {
      return {
        type: "view",
        autoFit: true,
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "rect",
            transform: [{ type: "binX", y: "count" }],
            interaction: {
              elementHighlight: {
                background: true
              }
            }
          }
        ]
      };
    };
    Histogram2.prototype.getDefaultOptions = function() {
      return Histogram2.getDefaultOptions();
    };
    Histogram2.prototype.getSchemaAdaptor = function() {
      return adaptor18;
    };
    return Histogram2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/heatmap/adaptor.js
function adaptor19(params) {
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a2 = options.tooltip, tooltip3 = _a2 === void 0 ? {} : _a2, colorField = options.colorField, sizeField = options.sizeField;
    if (tooltip3 && !tooltip3.field) {
      tooltip3.field = colorField || sizeField;
    }
    return params2;
  };
  var transformMark = function(params2) {
    var options = params2.options;
    var mark2 = options.mark, children = options.children;
    if (mark2) {
      children[0].type = mark2;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(tooltip2, transformMark, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/heatmap/index.js
var __extends28 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Heatmap3 = (
  /** @class */
  function(_super) {
    __extends28(Heatmap4, _super);
    function Heatmap4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "heatmap";
      return _this2;
    }
    Heatmap4.getDefaultOptions = function() {
      return {
        type: "view",
        legend: null,
        tooltip: {
          valueFormatter: "~s"
        },
        axis: {
          y: {
            title: null,
            grid: true
          },
          x: {
            title: null,
            grid: true
          }
        },
        children: [
          {
            type: "point"
          }
        ]
      };
    };
    Heatmap4.prototype.getDefaultOptions = function() {
      return Heatmap4.getDefaultOptions();
    };
    Heatmap4.prototype.getSchemaAdaptor = function() {
      return adaptor19;
    };
    return Heatmap4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/box/adaptor.js
function adaptor20(params) {
  var init = function(params2) {
    var _a2 = params2.options.boxType, boxType = _a2 === void 0 ? "box" : _a2;
    params2.options.children[0].type = boxType;
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/box/index.js
var __extends29 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Box3 = (
  /** @class */
  function(_super) {
    __extends29(Box4, _super);
    function Box4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "box";
      return _this2;
    }
    Box4.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "box" }],
        axis: {
          y: { title: false },
          x: { title: false }
        },
        //  tooltip
        tooltip: {
          items: [
            { name: "min", channel: "y" },
            { name: "q1", channel: "y1" },
            { name: "q2", channel: "y2" },
            { name: "q3", channel: "y3" },
            { name: "max", channel: "y4" }
          ]
        }
      };
    };
    Box4.prototype.getDefaultOptions = function() {
      return Box4.getDefaultOptions();
    };
    Box4.prototype.getSchemaAdaptor = function() {
      return adaptor20;
    };
    return Box4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sankey/adaptor.js
var defaultTransform = function(params) {
  var options = params.options;
  var data2 = options.data;
  var transformLinks = [
    {
      type: "custom",
      callback: function(datum) {
        return { links: datum };
      }
    }
  ];
  if ((0, import_lodash4.isArray)(data2)) {
    if (data2.length > 0) {
      (0, import_lodash4.set)(options, "data", {
        value: data2,
        transform: transformLinks
      });
    } else {
      delete options.children;
    }
  } else if ((0, import_lodash4.get)(data2, "type") === "fetch" && (0, import_lodash4.get)(data2, "value")) {
    var transform2 = (0, import_lodash4.get)(data2, "transform");
    if (!(0, import_lodash4.isArray)(transform2)) {
      (0, import_lodash4.set)(data2, "transform", transformLinks);
    }
  }
  return params;
};
function adaptor21(params) {
  return (0, import_lodash4.flow)(dataTransform4, defaultTransform, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sankey/index.js
var __extends30 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sankey4 = (
  /** @class */
  function(_super) {
    __extends30(Sankey5, _super);
    function Sankey5() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "sankey";
      return _this2;
    }
    Sankey5.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sankey" }] };
    };
    Sankey5.prototype.getDefaultOptions = function() {
      return Sankey5.getDefaultOptions();
    };
    Sankey5.prototype.getSchemaAdaptor = function() {
      return adaptor21;
    };
    return Sankey5;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bullet/adaptor.js
var __assign18 = function() {
  __assign18 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign18.apply(this, arguments);
};
var DEFAULT_COLORS2 = ["#f0efff", "#5B8FF9", "#3D76DD"];
function getTransformData(data2, field3, xField, isSort) {
  if (isSort === void 0) {
    isSort = true;
  }
  var maxSize = 0;
  var isArrayData = false;
  var transformData2 = (0, import_lodash4.map)(data2, function(d4) {
    var _a2, _b;
    var fieldData = (0, import_lodash4.get)(d4, [field3]);
    if ((0, import_lodash4.isNil)(fieldData))
      return [];
    if ((0, import_lodash4.isString)(fieldData)) {
      var numberData = Number(fieldData);
      if (isNaN(numberData))
        return [];
      return _a2 = {}, _a2[xField] = d4[xField], _a2[field3] = numberData, _a2;
    }
    if ((0, import_lodash4.isArray)(fieldData)) {
      isArrayData = true;
      maxSize = Math.max(maxSize, fieldData.length);
      return (0, import_lodash4.map)(isSort ? fieldData.sort(function(a5, b) {
        return b - a5;
      }) : fieldData, function(value2, index3) {
        var _a3;
        return _a3 = {}, _a3[xField] = d4[xField], _a3[field3] = value2, _a3.index = index3, _a3;
      });
    }
    maxSize = Math.max(1, maxSize);
    return _b = {}, _b[xField] = d4[xField], _b[field3] = fieldData, _b;
  }).flat();
  if (isArrayData) {
    return [
      transformData2.map(function(item) {
        return __assign18({ index: 0 }, item);
      }),
      maxSize
    ];
  }
  return [transformData2, maxSize];
}
function getFieldColor(maxSize, color3) {
  return new Array(maxSize).fill("").map(function(d4, i2) {
    return (0, import_lodash4.isArray)(color3) ? color3[i2 % color3.length] : color3;
  });
}
function adaptor22(params) {
  var init = function(params2) {
    var options = params2.options;
    var color3 = options.color, _a2 = options.rangeField, rangeField = _a2 === void 0 ? "ranges" : _a2, _b = options.measureField, measureField = _b === void 0 ? "measures" : _b, _c = options.targetField, targetField = _c === void 0 ? "targets" : _c, _d = options.xField, xField = _d === void 0 ? "title" : _d, mapField = options.mapField, data2 = options.data;
    var _e = getTransformData(data2, rangeField, xField), rangesData = _e[0], rangesMaxSize = _e[1];
    var _f = getTransformData(data2, measureField, xField, false), measuresData = _f[0], measuresMaxSize = _f[1];
    var _g = getTransformData(data2, targetField, xField, false), targetsData = _g[0], targetsMaxSize = _g[1];
    var rangesColor = (0, import_lodash4.get)(color3, [rangeField], DEFAULT_COLORS2[0]);
    var measuresColor = (0, import_lodash4.get)(color3, [measureField], DEFAULT_COLORS2[1]);
    var targetsColor = (0, import_lodash4.get)(color3, [targetField], DEFAULT_COLORS2[2]);
    var colors = [
      getFieldColor(rangesMaxSize, rangesColor),
      getFieldColor(measuresMaxSize, measuresColor),
      getFieldColor(targetsMaxSize, targetsColor)
    ].flat();
    options.children = (0, import_lodash4.map)(options.children, function(c6, i2) {
      var datas = [rangesData, measuresData, targetsData][i2];
      var yField = [rangeField, measureField, targetField][i2];
      return __assign18(__assign18({}, c6), { data: datas, encode: __assign18(__assign18({}, c6.encode || {}), { x: xField, y: yField, color: function(d4) {
        var index3 = d4.index;
        var mapString = (0, import_lodash4.isNumber)(index3) ? "".concat(yField, "_").concat(index3) : yField;
        return mapField ? (0, import_lodash4.get)(mapField, [yField, index3], mapString) : mapString;
      } }) });
    });
    (0, import_lodash4.set)(options, "scale.color.range", colors);
    options.legend.color.itemMarker = function(d4) {
      if (mapField && (0, import_lodash4.includes)(mapField === null || mapField === void 0 ? void 0 : mapField[targetField], d4)) {
        return "line";
      }
      return (d4 === null || d4 === void 0 ? void 0 : d4.replace(/\_\d$/, "")) === targetField ? "line" : "square";
    };
    return params2;
  };
  var layoutAdaptor = function(params2) {
    var _a2 = params2.options.transpose, transpose6 = _a2 === void 0 ? true : _a2;
    if (!transpose6) {
      (0, import_lodash4.set)(params2, "options.children[2].shapeField", "hyphen");
    }
    return params2;
  };
  var cfgAdaptor = function(params2) {
    var options = params2.options;
    var _a2 = options.range, range3 = _a2 === void 0 ? {} : _a2, _b = options.measure, measure = _b === void 0 ? {} : _b, _c = options.target, target = _c === void 0 ? {} : _c, children = options.children;
    options.children = [range3, measure, target].map(function(c6, i2) {
      return mergeWithArrayCoverage(children[i2], c6);
    });
    return params2;
  };
  return (0, import_lodash4.flow)(init, layoutAdaptor, cfgAdaptor, allCoordinateLayout, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bullet/index.js
var __extends31 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bullet = (
  /** @class */
  function(_super) {
    __extends31(Bullet2, _super);
    function Bullet2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "bullet";
      return _this2;
    }
    Bullet2.getDefaultOptions = function() {
      return {
        type: "view",
        scale: {
          color: {
            range: DEFAULT_COLORS2
          }
        },
        legend: {
          color: {
            itemMarker: function(d4) {
              return d4 === "targets" ? "line" : "square";
            }
          }
        },
        axis: {
          y: { title: false },
          x: { title: false }
        },
        children: [
          {
            type: "interval",
            style: { maxWidth: 30, zIndex: -2 },
            axis: { y: { grid: true, gridLineWidth: 2 } }
          },
          {
            type: "interval",
            style: { maxWidth: 20, zIndex: -1 },
            transform: [{ type: "stackY" }]
          },
          {
            type: "point",
            encode: { size: 8, shape: "line" }
          }
        ],
        interaction: { tooltip: { shared: true } },
        coordinate: { transform: [{ type: "transpose" }] }
      };
    };
    Bullet2.prototype.getDefaultOptions = function() {
      return Bullet2.getDefaultOptions();
    };
    Bullet2.prototype.getSchemaAdaptor = function() {
      return adaptor22;
    };
    return Bullet2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/gauge/adaptor.js
function adaptor23(params) {
  var init = function(params2) {
    var data2 = params2.options.data;
    params2.options.data = {
      value: data2
    };
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/gauge/index.js
var __extends32 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Gauge2 = (
  /** @class */
  function(_super) {
    __extends32(Gauge3, _super);
    function Gauge3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Gauge";
      return _this2;
    }
    Gauge3.getDefaultOptions = function() {
      return {
        type: "view",
        legend: false,
        children: [{ type: "gauge" }]
      };
    };
    Gauge3.prototype.getDefaultOptions = function() {
      return Gauge3.getDefaultOptions();
    };
    Gauge3.prototype.getSchemaAdaptor = function() {
      return adaptor23;
    };
    return Gauge3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/liquid/adaptor.js
function adaptor24(params) {
  var init = function(params2) {
    var percent2 = params2.options.percent;
    if ((0, import_lodash4.isNumber)(percent2)) {
      (0, import_lodash4.set)(params2, "options.data", percent2);
      delete params2.options.percent;
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/liquid/index.js
var __extends33 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Liquid3 = (
  /** @class */
  function(_super) {
    __extends33(Liquid4, _super);
    function Liquid4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Liquid";
      return _this2;
    }
    Liquid4.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "liquid" }] };
    };
    Liquid4.prototype.getDefaultOptions = function() {
      return Liquid4.getDefaultOptions();
    };
    Liquid4.prototype.getSchemaAdaptor = function() {
      return adaptor24;
    };
    return Liquid4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/wordCloud/adaptor.js
function adaptor25(params) {
  return (0, import_lodash4.flow)(mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/wordCloud/index.js
var __extends34 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WordCloud3 = (
  /** @class */
  function(_super) {
    __extends34(WordCloud4, _super);
    function WordCloud4() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "WordCloud";
      return _this2;
    }
    WordCloud4.getDefaultOptions = function() {
      return { type: "view", legend: false, children: [{ type: "wordCloud" }] };
    };
    WordCloud4.prototype.getDefaultOptions = function() {
      return WordCloud4.getDefaultOptions();
    };
    WordCloud4.prototype.getSchemaAdaptor = function() {
      return adaptor25;
    };
    return WordCloud4;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/treemap/adaptor.js
function adaptor26(params) {
  return (0, import_lodash4.flow)(dataTransform4, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/treemap/index.js
var __extends35 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Treemap2 = (
  /** @class */
  function(_super) {
    __extends35(Treemap3, _super);
    function Treemap3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "treemap";
      return _this2;
    }
    Treemap3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "treemap"
          }
        ]
      };
    };
    Treemap3.prototype.getDefaultOptions = function() {
      return Treemap3.getDefaultOptions();
    };
    Treemap3.prototype.getSchemaAdaptor = function() {
      return adaptor26;
    };
    return Treemap3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/radial-bar/adaptor.js
var __assign19 = function() {
  __assign19 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign19.apply(this, arguments);
};
var __rest95 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function adaptor27(params) {
  var coordinate = function(params2) {
    var options = params2.options;
    var startAngle = options.startAngle, maxAngle = options.maxAngle, coordinate2 = options.coordinate;
    var start = (0, import_lodash4.isNumber)(startAngle) ? startAngle / (2 * Math.PI) * 360 : -90;
    var end = (0, import_lodash4.isNumber)(maxAngle) ? (Number(maxAngle) + start) / 180 * Math.PI : Math.PI;
    (0, import_lodash4.set)(params2, ["options", "coordinate"], __assign19(__assign19({}, coordinate2), { endAngle: end, startAngle: startAngle !== null && startAngle !== void 0 ? startAngle : -Math.PI / 2 }));
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var tooltip3 = options.tooltip, xField = options.xField, yField = options.yField;
    var getXFieldData = fieldAdapter(xField);
    var getYFieldData = fieldAdapter(yField);
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        title: false,
        items: [function(d4, i2, data2) {
          return { name: getXFieldData(d4, i2, data2), value: getYFieldData(d4, i2, data2) };
        }]
      });
    }
    return params2;
  };
  var background = function(params2) {
    var options = params2.options;
    var markBackground = options.markBackground, children = options.children, scale12 = options.scale, coordinate2 = options.coordinate, xField = options.xField;
    var domain = (0, import_lodash4.get)(scale12, "y.domain", []);
    if (markBackground) {
      var style = markBackground.style, rest = __rest95(markBackground, ["style"]);
      children.unshift(__assign19({
        type: "interval",
        xField,
        yField: domain[domain.length - 1],
        style: __assign19({ fillOpacity: 0.4, fill: "#e0e4ee" }, style),
        // 
        coordinate: __assign19(__assign19({}, coordinate2), { startAngle: -Math.PI / 2, endAngle: 3 / 2 * Math.PI }),
        animate: false
      }, rest));
    }
    return params2;
  };
  return (0, import_lodash4.flow)(coordinate, tooltip2, background, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/radial-bar/index.js
var __extends36 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RadialBar = (
  /** @class */
  function(_super) {
    __extends36(RadialBar3, _super);
    function RadialBar3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "radial";
      return _this2;
    }
    RadialBar3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "interval" }],
        coordinate: { type: "radial", innerRadius: 0.1, outerRadius: 1, endAngle: Math.PI },
        animate: { enter: { type: "waveIn", duration: 800 } },
        axis: {
          y: {
            nice: true,
            labelAutoHide: true,
            labelAutoRotate: false
          },
          x: {
            title: false,
            nice: true,
            labelAutoRotate: false,
            labelAutoHide: { type: "equidistance", cfg: { minGap: 6 } }
          }
        }
      };
    };
    RadialBar3.prototype.getDefaultOptions = function() {
      return RadialBar3.getDefaultOptions();
    };
    RadialBar3.prototype.getSchemaAdaptor = function() {
      return adaptor27;
    };
    return RadialBar3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/circle-packing/adaptor.js
function adaptor28(params) {
  return (0, import_lodash4.flow)(dataTransform4, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/circle-packing/index.js
var __extends37 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CirclePacking = (
  /** @class */
  function(_super) {
    __extends37(CirclePacking2, _super);
    function CirclePacking2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "CirclePacking";
      return _this2;
    }
    CirclePacking2.getDefaultOptions = function() {
      return {
        legend: false,
        type: "view",
        children: [
          {
            type: "pack",
            encode: {
              color: "depth"
            }
          }
        ]
      };
    };
    CirclePacking2.prototype.getDefaultOptions = function() {
      return CirclePacking2.getDefaultOptions();
    };
    CirclePacking2.prototype.getSchemaAdaptor = function() {
      return adaptor28;
    };
    return CirclePacking2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/violin/adaptor.js
var __assign20 = function() {
  __assign20 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign20.apply(this, arguments);
};
function withField(field1, field22) {
  if (field1)
    return field1;
  return field22;
}
function adaptor29(params) {
  var customTransform = function(params2) {
    var options = params2.options;
    var xField = options.xField, yField = options.yField, colorField = options.colorField, seriesField = options.seriesField, children = options.children;
    var newChildren = children === null || children === void 0 ? void 0 : children.map(function(item) {
      return __assign20(__assign20({}, item), { xField, yField, seriesField: withField(seriesField, colorField), colorField: withField(colorField, seriesField), data: item.type === "density" ? {
        transform: [
          {
            type: "kde",
            field: yField,
            groupBy: [xField, withField(seriesField, colorField)]
          }
        ]
      } : item.data });
    }).filter(function(item) {
      return options.box || item.type === "density";
    });
    (0, import_lodash4.set)(options, "children", newChildren);
    delete options.box;
    return params2;
  };
  return (0, import_lodash4.flow)(customTransform, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/violin/index.js
var __extends38 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Violin2 = (
  /** @class */
  function(_super) {
    __extends38(Violin3, _super);
    function Violin3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "violin";
      return _this2;
    }
    Violin3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [
          {
            type: "density",
            sizeField: "size",
            tooltip: false
          },
          {
            type: "boxplot",
            shapeField: "violin",
            style: {
              opacity: 0.5,
              point: false
            }
          }
        ],
        animate: { enter: { type: "fadeIn" } }
      };
    };
    Violin3.prototype.getDefaultOptions = function() {
      return Violin3.getDefaultOptions();
    };
    Violin3.prototype.getSchemaAdaptor = function() {
      return adaptor29;
    };
    return Violin3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/adaptor.js
var __assign21 = function() {
  __assign21 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign21.apply(this, arguments);
};
var __spreadArray10 = function(to, from, pack3) {
  if (pack3 || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function adaptor30(params) {
  var field3 = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children;
    children.forEach(function(child, index3) {
      (0, import_lodash4.set)(child, "yField", yField[index3]);
    });
    return params2;
  };
  var data2 = function(params2) {
    var options = params2.options;
    var yField = options.yField, children = options.children, data3 = options.data;
    if ((0, import_lodash4.isPlainObject)(data3))
      return params2;
    var transformData2 = (0, import_lodash4.isArray)((0, import_lodash4.get)(data3, [0])) ? data3 : [data3, data3];
    children.forEach(function(child, index3) {
      (0, import_lodash4.set)(child, "data", __spreadArray10([], transformData2[index3].map(function(item) {
        return __assign21({ groupKey: yField[index3] }, item);
      }), true));
    });
    return params2;
  };
  var tooltip2 = function(params2) {
    var options = params2.options;
    var _a2 = options.yField, y12 = _a2[0], y22 = _a2[1], tooltip3 = options.tooltip;
    if (!tooltip3) {
      (0, import_lodash4.set)(options, "tooltip", {
        items: [
          {
            field: y12,
            value: y12
          },
          {
            field: y22,
            value: y22
          }
        ]
      });
    }
    return params2;
  };
  var layout = function(params2) {
    var options = params2.options;
    var children = options.children, layout2 = options.layout, transform2 = options.coordinate.transform, _a2 = options.paddingBottom, paddingBottom = _a2 === void 0 ? AXIS_LABEL_PADDING : _a2, _b = options.paddingLeft, paddingLeft = _b === void 0 ? AXIS_LABEL_PADDING : _b, axis = options.axis;
    (0, import_lodash4.set)(options, "axisText", __assign21(__assign21({}, (axis === null || axis === void 0 ? void 0 : axis.x) || {}), { layout: layout2 }));
    var child1 = children[0], child2 = children[1];
    if (layout2 === "vertical") {
      (0, import_lodash4.set)(options, "direction", "col");
      (0, import_lodash4.set)(options, "paddingLeft", paddingLeft);
      (0, import_lodash4.set)(options, "coordinate.transform", transform2.filter(function(item) {
        return item.type !== "transpose";
      }));
      (0, import_lodash4.set)(child1, "paddingBottom", HORIZONTAL_MARGIN);
      (0, import_lodash4.set)(child2, "paddingTop", HORIZONTAL_MARGIN);
      (0, import_lodash4.set)(child2, "axis.x.position", "top");
      (0, import_lodash4.set)(child2, "scale.y.range", [0, 1]);
    } else {
      (0, import_lodash4.set)(options, "paddingBottom", paddingBottom);
      (0, import_lodash4.set)(child1, "scale.y.range", [0, 1]);
      var _c = child1.paddingRight, paddingRight = _c === void 0 ? VERTICAL_MARGIN : _c;
      var _d = child2.paddingLeft, paddingLeft_1 = _d === void 0 ? VERTICAL_MARGIN : _d;
      (0, import_lodash4.set)(child1, "paddingRight", paddingRight);
      (0, import_lodash4.set)(child1, "axis.x.position", "right");
      (0, import_lodash4.set)(child2, "paddingLeft", paddingLeft_1);
    }
    return params2;
  };
  return (0, import_lodash4.flow)(field3, data2, tooltip2, layout, mark, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/bidirectional-bar/index.js
var __extends39 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BidirectionalBar = (
  /** @class */
  function(_super) {
    __extends39(BidirectionalBar2, _super);
    function BidirectionalBar2() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "BidirectionalBar";
      return _this2;
    }
    BidirectionalBar2.getDefaultOptions = function() {
      return {
        type: "spaceFlex",
        coordinate: { transform: [{ type: "transpose" }] },
        scale: {
          y: { nice: true }
        },
        direction: "row",
        layout: "horizontal",
        legend: false,
        axis: {
          y: {
            title: false
          },
          x: { title: false, label: false }
        },
        children: [{ type: "interval" }, { type: "interval" }]
      };
    };
    BidirectionalBar2.prototype.getDefaultOptions = function() {
      return BidirectionalBar2.getDefaultOptions();
    };
    BidirectionalBar2.prototype.getSchemaAdaptor = function() {
      return adaptor30;
    };
    return BidirectionalBar2;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/venn/type.js
var DefaultTransformKey;
(function(DefaultTransformKey2) {
  DefaultTransformKey2["color"] = "key";
  DefaultTransformKey2["d"] = "path";
})(DefaultTransformKey || (DefaultTransformKey = {}));

// node_modules/@ant-design/plots/es/core/plots/venn/adaptor.js
function adaptor31(params) {
  var init = function(params2) {
    var options = params2.options;
    var data2 = options.data, setsField = options.setsField, sizeField = options.sizeField;
    if ((0, import_lodash4.isArray)(data2)) {
      (0, import_lodash4.set)(options, "data", {
        type: "inline",
        value: data2,
        transform: [
          {
            type: "venn",
            sets: setsField,
            size: sizeField,
            as: [DefaultTransformKey.color, DefaultTransformKey.d]
          }
        ]
      });
      (0, import_lodash4.set)(options, "colorField", DefaultTransformKey.color);
      (0, import_lodash4.set)(options, ["children", "0", "encode", "d"], DefaultTransformKey.d);
    }
    return params2;
  };
  return (0, import_lodash4.flow)(init, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/venn/index.js
var __extends40 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Venn2 = (
  /** @class */
  function(_super) {
    __extends40(Venn3, _super);
    function Venn3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "venn";
      return _this2;
    }
    Venn3.getDefaultOptions = function() {
      return {
        type: "view",
        children: [{ type: "path" }],
        legend: {
          color: { itemMarker: "circle" }
        },
        encode: { color: DefaultTransformKey.color, d: DefaultTransformKey.d }
      };
    };
    Venn3.prototype.getDefaultOptions = function() {
      return Venn3.getDefaultOptions();
    };
    Venn3.prototype.getSchemaAdaptor = function() {
      return adaptor31;
    };
    return Venn3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/plots/sunburst/adaptor.js
function adaptor32(params) {
  return (0, import_lodash4.flow)(dataTransform4, transformOptions)(params);
}

// node_modules/@ant-design/plots/es/core/plots/sunburst/index.js
var __extends41 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d4, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b2) {
      d5.__proto__ = b2;
    } || function(d5, b2) {
      for (var p3 in b2) if (Object.prototype.hasOwnProperty.call(b2, p3)) d5[p3] = b2[p3];
    };
    return extendStatics2(d4, b);
  };
  return function(d4, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics2(d4, b);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Sunburst2 = (
  /** @class */
  function(_super) {
    __extends41(Sunburst3, _super);
    function Sunburst3() {
      var _this2 = _super !== null && _super.apply(this, arguments) || this;
      _this2.type = "Sunburst";
      return _this2;
    }
    Sunburst3.getDefaultOptions = function() {
      return { type: "view", children: [{ type: "sunburst" }] };
    };
    Sunburst3.prototype.getDefaultOptions = function() {
      return Sunburst3.getDefaultOptions();
    };
    Sunburst3.prototype.getSchemaAdaptor = function() {
      return adaptor32;
    };
    return Sunburst3;
  }(Plot)
);

// node_modules/@ant-design/plots/es/core/index.js
var Plots = {
  Base: Base2,
  Line: Line6,
  Column: Column2,
  Pie,
  Area: Area3,
  Bar,
  DualAxes,
  Funnel: Funnel2,
  Scatter,
  Radar: Radar2,
  Rose,
  Stock,
  TinyLine,
  TinyArea,
  TinyColumn,
  TinyProgress,
  TinyRing,
  Waterfall,
  Histogram,
  Heatmap: Heatmap3,
  Box: Box3,
  Sankey: Sankey4,
  Bullet,
  Gauge: Gauge2,
  Liquid: Liquid3,
  WordCloud: WordCloud3,
  Treemap: Treemap2,
  RadialBar,
  CirclePacking,
  Violin: Violin2,
  BidirectionalBar,
  Venn: Venn2,
  Mix: DualAxes,
  Sunburst: Sunburst2
};

// node_modules/@ant-design/plots/es/components/base/index.js
var __assign22 = function() {
  __assign22 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign22.apply(this, arguments);
};
var __rest96 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
var BaseChart = (0, import_react4.forwardRef)(function(_a2, ref) {
  var _b = _a2.chartType, chartType = _b === void 0 ? "Base" : _b, config = __rest96(_a2, ["chartType"]);
  var _c = config.containerStyle, containerStyle = _c === void 0 ? {
    height: "inherit",
    flex: 1
  } : _c, _d = config.containerAttributes, containerAttributes = _d === void 0 ? {} : _d, className2 = config.className, loading = config.loading, loadingTemplate = config.loadingTemplate, errorTemplate = config.errorTemplate, onReady = config.onReady, rest = __rest96(config, ["containerStyle", "containerAttributes", "className", "loading", "loadingTemplate", "errorTemplate", "onReady"]);
  var _e = useChart(Plots[chartType], __assign22(__assign22({}, rest), { onReady: function(chartInstance) {
    if (ref) {
      if (typeof ref === "function") {
        ref(chartInstance);
      } else {
        ref.current = chartInstance;
      }
    }
    onReady === null || onReady === void 0 ? void 0 : onReady(chartInstance);
  } })), chart = _e.chart, container = _e.container;
  return import_react4.default.createElement(
    ErrorBoundary,
    { errorTemplate },
    loading && import_react4.default.createElement(ChartLoading, { loadingTemplate, theme: config.theme, loading }),
    import_react4.default.createElement("div", __assign22({ className: className2, style: containerStyle, ref: container }, containerAttributes))
  );
});

// node_modules/@ant-design/plots/es/util/makeChartComp.js
var import_react7 = __toESM(require_react());

// node_modules/@ant-design/plots/es/hooks/useConfig.js
var import_react6 = __toESM(require_react());

// node_modules/@ant-design/plots/es/context.js
var import_react5 = __toESM(require_react());
var ConfigContext = (0, import_react5.createContext)({});

// node_modules/@ant-design/plots/es/hooks/useConfig.js
function useConfig() {
  return (0, import_react6.useContext)(ConfigContext);
}

// node_modules/@ant-design/plots/es/util/scale.js
var __assign23 = function() {
  __assign23 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign23.apply(this, arguments);
};
function scale11(props) {
  var yField = props.yField, data2 = props.data;
  var noDomainMax = (0, import_lodash3.isArray)(data2) && data2.length > 0 && (0, import_lodash3.isString)(yField) && !(0, import_lodash3.get)(props, "scale.y.domainMax");
  var newProps = Object.isFrozen(props) ? __assign23({}, props) : props;
  if (noDomainMax && data2.reduce(function(acc, item) {
    return acc + item[yField];
  }, 0) === 0) {
    (0, import_lodash3.set)(newProps, "scale.y.domainMax", 1);
  } else if (noDomainMax && data2.reduce(function(acc, item) {
    return acc + item[yField];
  }, 0) !== 0) {
    (0, import_lodash3.set)(newProps, "scale.y.domainMax", void 0);
  }
  return newProps;
}

// node_modules/@ant-design/plots/es/util/makeChartComp.js
var __assign24 = function() {
  __assign24 = Object.assign || function(t) {
    for (var s4, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s4 = arguments[i2];
      for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3))
        t[p3] = s4[p3];
    }
    return t;
  };
  return __assign24.apply(this, arguments);
};
function makeChartComp(chartType) {
  var configKey = chartType.charAt(0).toLowerCase() + chartType.slice(1);
  return (0, import_react7.forwardRef)(function(props, ref) {
    var config = useConfig();
    var flowProps = (0, import_lodash3.flow)([scale11])(props);
    if (!config || !config[configKey]) {
      return import_react7.default.createElement(BaseChart, __assign24({}, flowProps, { chartType, ref }));
    }
    return import_react7.default.createElement(BaseChart, __assign24({}, config.common, config[configKey], flowProps, { chartType, ref }));
  });
}

// node_modules/@ant-design/plots/es/components/area/index.js
var AreaChart = makeChartComp("Area");
var area_default4 = AreaChart;

// node_modules/@ant-design/plots/es/components/bar/index.js
var BarChart2 = makeChartComp("Bar");
var bar_default = BarChart2;

// node_modules/@ant-design/plots/es/components/column/index.js
var ColumnChart = makeChartComp("Column");
var column_default = ColumnChart;

// node_modules/@ant-design/plots/es/components/config-provider/index.js
var import_react8 = __toESM(require_react());
var __rest97 = function(s4, e3) {
  var t = {};
  for (var p3 in s4) if (Object.prototype.hasOwnProperty.call(s4, p3) && e3.indexOf(p3) < 0)
    t[p3] = s4[p3];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s4); i2 < p3.length; i2++) {
      if (e3.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p3[i2]))
        t[p3[i2]] = s4[p3[i2]];
    }
  return t;
};
function ConfigProvider(_a2) {
  var children = _a2.children, value2 = __rest97(_a2, ["children"]);
  return import_react8.default.createElement(ConfigContext.Provider, { value: value2 }, children);
}

// node_modules/@ant-design/plots/es/components/dual-axes/index.js
var DualAxesChart = makeChartComp("DualAxes");
var dual_axes_default = DualAxesChart;

// node_modules/@ant-design/plots/es/components/funnel/index.js
var FunnelChart = makeChartComp("Funnel");
var funnel_default = FunnelChart;

// node_modules/@ant-design/plots/es/components/line/index.js
var LineChart2 = makeChartComp("Line");
var line_default3 = LineChart2;

// node_modules/@ant-design/plots/es/components/pie/index.js
var PieChart = makeChartComp("Pie");
var pie_default2 = PieChart;

// node_modules/@ant-design/plots/es/components/scatter/index.js
var ScatterChart = makeChartComp("Scatter");
var scatter_default = ScatterChart;

// node_modules/@ant-design/plots/es/components/radar/index.js
var RadarChart = makeChartComp("Radar");
var radar_default = RadarChart;

// node_modules/@ant-design/plots/es/components/tiny/line/index.js
var TinyLineChart = makeChartComp("TinyLine");
var line_default4 = TinyLineChart;

// node_modules/@ant-design/plots/es/components/tiny/area/index.js
var TinyAreaChart = makeChartComp("TinyArea");
var area_default5 = TinyAreaChart;

// node_modules/@ant-design/plots/es/components/tiny/column/index.js
var TinyLineChart2 = makeChartComp("TinyColumn");
var column_default2 = TinyLineChart2;

// node_modules/@ant-design/plots/es/components/tiny/progress/index.js
var TinyProgressChart = makeChartComp("TinyProgress");
var progress_default = TinyProgressChart;

// node_modules/@ant-design/plots/es/components/tiny/ring/index.js
var TinyRingChart = makeChartComp("TinyRing");
var ring_default = TinyRingChart;

// node_modules/@ant-design/plots/es/components/tiny/index.js
var Tiny = { Line: line_default4, Area: area_default5, Column: column_default2, Progress: progress_default, Ring: ring_default };

// node_modules/@ant-design/plots/es/components/rose/index.js
var RoseChart = makeChartComp("Rose");
var rose_default = RoseChart;

// node_modules/@ant-design/plots/es/components/waterfall/index.js
var WaterfallChart = makeChartComp("Waterfall");
var waterfall_default = WaterfallChart;

// node_modules/@ant-design/plots/es/components/histogram/index.js
var HistogramChart = makeChartComp("Histogram");
var histogram_default = HistogramChart;

// node_modules/@ant-design/plots/es/components/heatmap/index.js
var HeatmapChart = makeChartComp("Heatmap");
var heatmap_default = HeatmapChart;

// node_modules/@ant-design/plots/es/components/box/index.js
var BoxChart = makeChartComp("Box");
var box_default = BoxChart;

// node_modules/@ant-design/plots/es/components/sankey/index.js
var SankeyChart = makeChartComp("Sankey");
var sankey_default = SankeyChart;

// node_modules/@ant-design/plots/es/components/stock/index.js
var StockChart = makeChartComp("Stock");
var stock_default = StockChart;

// node_modules/@ant-design/plots/es/components/bullet/index.js
var BulletChart = makeChartComp("Bullet");
var bullet_default = BulletChart;

// node_modules/@ant-design/plots/es/components/gauge/index.js
var GaugeChart = makeChartComp("Gauge");
var gauge_default = GaugeChart;

// node_modules/@ant-design/plots/es/components/liquid/index.js
var LiquidChart = makeChartComp("Liquid");
var liquid_default = LiquidChart;

// node_modules/@ant-design/plots/es/components/wordCloud/index.js
var WordCloudChart = makeChartComp("WordCloud");
var wordCloud_default = WordCloudChart;

// node_modules/@ant-design/plots/es/components/treemap/index.js
var TreemapChart = makeChartComp("Treemap");
var treemap_default2 = TreemapChart;

// node_modules/@ant-design/plots/es/components/radial-bar/index.js
var RadialBar2 = makeChartComp("RadialBar");
var radial_bar_default = RadialBar2;

// node_modules/@ant-design/plots/es/components/circlePacking/index.js
var CirclePackingChart = makeChartComp("CirclePacking");
var circlePacking_default = CirclePackingChart;

// node_modules/@ant-design/plots/es/components/violin/index.js
var ViolinChart = makeChartComp("Violin");
var violin_default = ViolinChart;

// node_modules/@ant-design/plots/es/components/bidirectional-bar/index.js
var BidirectionalBarChart = makeChartComp("BidirectionalBar");
var bidirectional_bar_default = BidirectionalBarChart;

// node_modules/@ant-design/plots/es/components/venn/index.js
var VennChart = makeChartComp("Venn");
var venn_default = VennChart;

// node_modules/@ant-design/plots/es/components/mix/index.js
var MixChart = makeChartComp("Mix");
var mix_default = MixChart;

// node_modules/@ant-design/plots/es/components/sunburst/index.js
var SunburstChart = makeChartComp("Sunburst");
var sunburst_default = SunburstChart;
export {
  area_default4 as Area,
  bar_default as Bar,
  BaseChart as Base,
  bidirectional_bar_default as BidirectionalBar,
  box_default as Box,
  bullet_default as Bullet,
  ChartEvent,
  circlePacking_default as CirclePacking,
  column_default as Column,
  ConfigProvider,
  dual_axes_default as DualAxes,
  funnel_default as Funnel,
  esm_exports as G2,
  gauge_default as Gauge,
  heatmap_default as Heatmap,
  histogram_default as Histogram,
  line_default3 as Line,
  liquid_default as Liquid,
  mix_default as Mix,
  pie_default2 as Pie,
  radar_default as Radar,
  radial_bar_default as RadialBar,
  rose_default as Rose,
  sankey_default as Sankey,
  scatter_default as Scatter,
  stock_default as Stock,
  sunburst_default as Sunburst,
  Tiny,
  treemap_default2 as Treemap,
  venn_default as Venn,
  violin_default as Violin,
  waterfall_default as Waterfall,
  wordCloud_default as WordCloud,
  measureTextWidth2 as measureTextWidth,
  register
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@antv/g-math/dist/index.esm.js:
  (*!
   * @antv/g-math
   * @description Geometry util
   * @version 3.0.1
   * @date 5/9/2025, 8:18:51 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-lite/dist/index.esm.js:
  (*!
   * @antv/g-lite
   * @description A core module for rendering engine implements DOM API.
   * @version 2.3.2
   * @date 7/30/2025, 1:34:19 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-camera-api/dist/index.esm.js:
  (*!
   * @antv/g-camera-api
   * @description A simple implementation of Camera API.
   * @version 2.0.41
   * @date 7/30/2025, 1:34:37 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-dom-mutation-observer-api/dist/index.esm.js:
  (*!
   * @antv/g-dom-mutation-observer-api
   * @description A simple implementation of DOM MutationObserver API.
   * @version 2.0.38
   * @date 7/30/2025, 1:34:51 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-web-animations-api/dist/index.esm.js:
  (*!
   * @antv/g-web-animations-api
   * @description A simple implementation of Web Animations API.
   * @version 2.1.28
   * @date 7/30/2025, 1:36:24 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g/dist/index.esm.js:
  (*!
   * @antv/g
   * @description A core module for rendering engine implements DOM API.
   * @version 6.1.28
   * @date 7/30/2025, 1:36:29 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-path-generator/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-path-generator
   * @description A G plugin of path generator with Canvas2D API
   * @version 2.1.22
   * @date 7/30/2025, 1:35:25 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-picker/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-picker
   * @description A G plugin for picking in canvas
   * @version 2.1.27
   * @date 7/30/2025, 1:37:32 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-image-loader/dist/index.esm.js:
  (*!
   * @antv/g-plugin-image-loader
   * @description A G plugin for loading image
   * @version 2.1.26
   * @date 7/30/2025, 1:35:52 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-renderer
   * @description A G plugin of renderer implementation with Canvas2D API
   * @version 2.3.3
   * @date 7/30/2025, 1:36:40 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dom-interaction/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dom-interaction
   * @description A G plugin
   * @version 2.1.27
   * @date 7/30/2025, 1:35:38 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-html-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-html-renderer
   * @description A G plugin for rendering HTML
   * @version 2.1.27
   * @date 7/30/2025, 1:35:48 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-canvas/dist/index.esm.js:
  (*!
   * @antv/g-canvas
   * @description A renderer implemented by Canvas 2D API
   * @version 2.0.48
   * @date 7/30/2025, 1:38:18 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dragndrop/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dragndrop
   * @description A G plugin for Drag n Drop implemented with PointerEvents
   * @version 2.0.38
   * @date 7/30/2025, 1:35:41 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)
*/
//# sourceMappingURL=@ant-design_plots.js.map
